
zephyr.elf:     file format elf32-i386


Disassembly of section text:

00100000 <__start>:
        mov  %eax, %esi			/* low  value */
        mov  %edx, %edi			/* high value */
#endif

	/* Enable write-back caching by clearing the NW and CD bits */
	movl	%cr0, %eax
  100000:	0f 20 c0             	mov    %cr0,%eax
	andl	$0x9fffffff, %eax
  100003:	25 ff ff ff 9f       	and    $0x9fffffff,%eax
	movl	%eax, %cr0
  100008:	0f 22 c0             	mov    %eax,%cr0
	/*
	 * Ensure interrupts are disabled.  Interrupts are enabled when
	 * the first context switch occurs.
	 */

	cli
  10000b:	fa                   	cli    
	 * Although the bootloader sets up an Interrupt Descriptor Table (IDT)
	 * and a Global Descriptor Table (GDT), the specification encourages
	 * booted operating systems to setup their own IDT and GDT.
	 */
#if CONFIG_SET_GDT
	lgdt	_gdt_rom		/* load 32-bit operand size GDT */
  10000c:	0f 01 15 70 00 10 00 	lgdtl  0x100070
#endif
	lidt	_Idt		/* load 32-bit operand size IDT */
  100013:	0f 01 1d 57 00 10 00 	lidtl  0x100057
	 *
	 * This is a special case for the ia32 platform, which must work for
	 * multiple platforms (QEMU, generic PC board, etc.). With other
	 * platforms the bootloader is well known so assumptions can be made.
	 */
	movw	$0x10, %ax	/* data segment selector (entry = 3) */
  10001a:	66 b8 10 00          	mov    $0x10,%ax
	movw	%ax, %ds	/* set DS */
  10001e:	8e d8                	mov    %eax,%ds
	movw	%ax, %es	/* set ES */
  100020:	8e c0                	mov    %eax,%es
	movw	%ax, %fs	/* set FS */
  100022:	8e e0                	mov    %eax,%fs
	movw	%ax, %gs	/* set GS */
  100024:	8e e8                	mov    %eax,%gs
	movw	%ax, %ss	/* set SS */
  100026:	8e d0                	mov    %eax,%ss

	ljmp	$0x08, $__csSet	/* set CS = 0x08 */
  100028:	ea 2f 00 10 00 08 00 	ljmp   $0x8,$0x10002f

0010002f <__csSet>:
	/*
	 * Force an #NM exception for floating point instructions
	 * since FP support hasn't been configured
	 */

	movl	%cr0, %eax		/* move CR0 to EAX */
  10002f:	0f 20 c0             	mov    %cr0,%eax
	orl	$0x2e, %eax		/* CR0[NE+TS+EM+MP]=1 */
  100032:	83 c8 2e             	or     $0x2e,%eax
	movl	%eax, %cr0		/* move EAX to CR0 */
  100035:	0f 22 c0             	mov    %eax,%cr0
	stack_size_dwords = (CONFIG_ISR_STACK_SIZE / 4)
	movl $stack_size_dwords, %ecx
	rep  stosl
#endif

	movl	$_interrupt_stack, %esp
  100038:	bc 38 7f 10 00       	mov    $0x107f38,%esp
	addl	$CONFIG_ISR_STACK_SIZE, %esp
  10003d:	81 c4 00 08 00 00    	add    $0x800,%esp

#else /* !CONFIG_SSE */

	/* clear out BSS double words (32-bits at a time) */

	xorl	%eax, %eax		/* fill memory with 0 */
  100043:	31 c0                	xor    %eax,%eax
	movl	$__bss_start, %edi	/* load BSS start address */
  100045:	bf 40 72 10 00       	mov    $0x107240,%edi
	movl	$__bss_num_words, %ecx	/* number of quad bytes */
  10004a:	b9 38 03 00 00       	mov    $0x338,%ecx
	cld
  10004f:	fc                   	cld    
	rep
  100050:	f3 ab                	rep stos %eax,%es:(%edi)
	lgdt	%ds:_gdt
#endif

	/* Jump to C portion of kernel initialization and never return */

	jmp	_Cstart
  100052:	e9 24 37 00 00       	jmp    10377b <_Cstart>

00100057 <_Idt>:
  100057:	ff 07 a8 65 10 00 8d 76 00 02 b0 ad 1b 00 00 00     ...e...v........
  100067:	00 fe 4f 52 e4 8d 74 26 00                          ..OR..t&.

00100070 <_gdt>:
  100070:	17 00 70 00 10 00 00 00 ff ff 00 00 00 9b cf 00     ..p.............
  100080:	ff ff 00 00 00 93 cf 00                             ........

00100088 <_gdt_rom_end>:
  100088:	66 90                	xchg   %ax,%ax
  10008a:	66 90                	xchg   %ax,%ax
  10008c:	66 90                	xchg   %ax,%ax
  10008e:	66 90                	xchg   %ax,%ax

00100090 <__divdi3>:
  100090:	55                   	push   %ebp
  100091:	57                   	push   %edi
  100092:	56                   	push   %esi
  100093:	53                   	push   %ebx
  100094:	83 ec 2c             	sub    $0x2c,%esp
  100097:	8b 5c 24 44          	mov    0x44(%esp),%ebx
  10009b:	8b 54 24 4c          	mov    0x4c(%esp),%edx
  10009f:	8b 4c 24 40          	mov    0x40(%esp),%ecx
  1000a3:	8b 6c 24 48          	mov    0x48(%esp),%ebp
  1000a7:	89 d0                	mov    %edx,%eax
  1000a9:	85 db                	test   %ebx,%ebx
  1000ab:	0f 88 ff 00 00 00    	js     1001b0 <__divdi3+0x120>
  1000b1:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  1000b5:	89 5c 24 14          	mov    %ebx,0x14(%esp)
  1000b9:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  1000c0:	00 
  1000c1:	89 6c 24 08          	mov    %ebp,0x8(%esp)
  1000c5:	89 54 24 0c          	mov    %edx,0xc(%esp)
  1000c9:	85 c0                	test   %eax,%eax
  1000cb:	0f 88 bf 00 00 00    	js     100190 <__divdi3+0x100>
  1000d1:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  1000d5:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  1000d9:	8b 74 24 14          	mov    0x14(%esp),%esi
  1000dd:	8b 54 24 08          	mov    0x8(%esp),%edx
  1000e1:	89 cf                	mov    %ecx,%edi
  1000e3:	89 d8                	mov    %ebx,%eax
  1000e5:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
  1000e9:	89 d5                	mov    %edx,%ebp
  1000eb:	89 f3                	mov    %esi,%ebx
  1000ed:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  1000f1:	89 d6                	mov    %edx,%esi
  1000f3:	85 ff                	test   %edi,%edi
  1000f5:	75 19                	jne    100110 <__divdi3+0x80>
  1000f7:	39 da                	cmp    %ebx,%edx
  1000f9:	76 65                	jbe    100160 <__divdi3+0xd0>
  1000fb:	89 da                	mov    %ebx,%edx
  1000fd:	31 f6                	xor    %esi,%esi
  1000ff:	f7 f5                	div    %ebp
  100101:	89 c1                	mov    %eax,%ecx
  100103:	eb 13                	jmp    100118 <__divdi3+0x88>
  100105:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  100109:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  100110:	39 df                	cmp    %ebx,%edi
  100112:	76 2c                	jbe    100140 <__divdi3+0xb0>
  100114:	31 f6                	xor    %esi,%esi
  100116:	31 c9                	xor    %ecx,%ecx
  100118:	89 c8                	mov    %ecx,%eax
  10011a:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  10011e:	89 f2                	mov    %esi,%edx
  100120:	85 c9                	test   %ecx,%ecx
  100122:	74 07                	je     10012b <__divdi3+0x9b>
  100124:	f7 d8                	neg    %eax
  100126:	83 d2 00             	adc    $0x0,%edx
  100129:	f7 da                	neg    %edx
  10012b:	83 c4 2c             	add    $0x2c,%esp
  10012e:	5b                   	pop    %ebx
  10012f:	5e                   	pop    %esi
  100130:	5f                   	pop    %edi
  100131:	5d                   	pop    %ebp
  100132:	c3                   	ret    
  100133:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  100139:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  100140:	0f bd f7             	bsr    %edi,%esi
  100143:	83 f6 1f             	xor    $0x1f,%esi
  100146:	0f 85 84 00 00 00    	jne    1001d0 <__divdi3+0x140>
  10014c:	39 df                	cmp    %ebx,%edi
  10014e:	72 08                	jb     100158 <__divdi3+0xc8>
  100150:	31 c9                	xor    %ecx,%ecx
  100152:	3b 54 24 1c          	cmp    0x1c(%esp),%edx
  100156:	77 c0                	ja     100118 <__divdi3+0x88>
  100158:	b9 01 00 00 00       	mov    $0x1,%ecx
  10015d:	eb b9                	jmp    100118 <__divdi3+0x88>
  10015f:	90                   	nop
  100160:	85 d2                	test   %edx,%edx
  100162:	75 0b                	jne    10016f <__divdi3+0xdf>
  100164:	b8 01 00 00 00       	mov    $0x1,%eax
  100169:	31 d2                	xor    %edx,%edx
  10016b:	f7 f5                	div    %ebp
  10016d:	89 c6                	mov    %eax,%esi
  10016f:	31 d2                	xor    %edx,%edx
  100171:	89 d8                	mov    %ebx,%eax
  100173:	f7 f6                	div    %esi
  100175:	89 c7                	mov    %eax,%edi
  100177:	89 c8                	mov    %ecx,%eax
  100179:	f7 f6                	div    %esi
  10017b:	89 fe                	mov    %edi,%esi
  10017d:	89 c1                	mov    %eax,%ecx
  10017f:	eb 97                	jmp    100118 <__divdi3+0x88>
  100181:	eb 0d                	jmp    100190 <__divdi3+0x100>
  100183:	90                   	nop
  100184:	90                   	nop
  100185:	90                   	nop
  100186:	90                   	nop
  100187:	90                   	nop
  100188:	90                   	nop
  100189:	90                   	nop
  10018a:	90                   	nop
  10018b:	90                   	nop
  10018c:	90                   	nop
  10018d:	90                   	nop
  10018e:	90                   	nop
  10018f:	90                   	nop
  100190:	f7 5c 24 08          	negl   0x8(%esp)
  100194:	83 54 24 0c 00       	adcl   $0x0,0xc(%esp)
  100199:	f7 54 24 18          	notl   0x18(%esp)
  10019d:	f7 5c 24 0c          	negl   0xc(%esp)
  1001a1:	e9 2b ff ff ff       	jmp    1000d1 <__divdi3+0x41>
  1001a6:	8d 76 00             	lea    0x0(%esi),%esi
  1001a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  1001b0:	f7 d9                	neg    %ecx
  1001b2:	83 d3 00             	adc    $0x0,%ebx
  1001b5:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  1001b9:	f7 db                	neg    %ebx
  1001bb:	89 5c 24 14          	mov    %ebx,0x14(%esp)
  1001bf:	c7 44 24 18 ff ff ff 	movl   $0xffffffff,0x18(%esp)
  1001c6:	ff 
  1001c7:	e9 f5 fe ff ff       	jmp    1000c1 <__divdi3+0x31>
  1001cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  1001d0:	b8 20 00 00 00       	mov    $0x20,%eax
  1001d5:	89 f1                	mov    %esi,%ecx
  1001d7:	29 f0                	sub    %esi,%eax
  1001d9:	d3 e7                	shl    %cl,%edi
  1001db:	88 c1                	mov    %al,%cl
  1001dd:	d3 ea                	shr    %cl,%edx
  1001df:	89 f1                	mov    %esi,%ecx
  1001e1:	09 fa                	or     %edi,%edx
  1001e3:	d3 e5                	shl    %cl,%ebp
  1001e5:	89 df                	mov    %ebx,%edi
  1001e7:	88 c1                	mov    %al,%cl
  1001e9:	d3 ef                	shr    %cl,%edi
  1001eb:	89 f1                	mov    %esi,%ecx
  1001ed:	89 54 24 08          	mov    %edx,0x8(%esp)
  1001f1:	d3 e3                	shl    %cl,%ebx
  1001f3:	8b 54 24 1c          	mov    0x1c(%esp),%edx
  1001f7:	88 c1                	mov    %al,%cl
  1001f9:	d3 ea                	shr    %cl,%edx
  1001fb:	09 d3                	or     %edx,%ebx
  1001fd:	89 fa                	mov    %edi,%edx
  1001ff:	89 d8                	mov    %ebx,%eax
  100201:	f7 74 24 08          	divl   0x8(%esp)
  100205:	89 d7                	mov    %edx,%edi
  100207:	89 c3                	mov    %eax,%ebx
  100209:	f7 e5                	mul    %ebp
  10020b:	39 d7                	cmp    %edx,%edi
  10020d:	72 21                	jb     100230 <__divdi3+0x1a0>
  10020f:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
  100213:	89 f1                	mov    %esi,%ecx
  100215:	d3 e5                	shl    %cl,%ebp
  100217:	39 c5                	cmp    %eax,%ebp
  100219:	73 04                	jae    10021f <__divdi3+0x18f>
  10021b:	39 d7                	cmp    %edx,%edi
  10021d:	74 11                	je     100230 <__divdi3+0x1a0>
  10021f:	89 d9                	mov    %ebx,%ecx
  100221:	31 f6                	xor    %esi,%esi
  100223:	e9 f0 fe ff ff       	jmp    100118 <__divdi3+0x88>
  100228:	90                   	nop
  100229:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  100230:	8d 4b ff             	lea    -0x1(%ebx),%ecx
  100233:	31 f6                	xor    %esi,%esi
  100235:	e9 de fe ff ff       	jmp    100118 <__divdi3+0x88>
  10023a:	66 90                	xchg   %ax,%ax
  10023c:	66 90                	xchg   %ax,%ax
  10023e:	66 90                	xchg   %ax,%ax

00100240 <__udivdi3>:
  100240:	55                   	push   %ebp
  100241:	57                   	push   %edi
  100242:	56                   	push   %esi
  100243:	53                   	push   %ebx
  100244:	83 ec 1c             	sub    $0x1c,%esp
  100247:	8b 5c 24 30          	mov    0x30(%esp),%ebx
  10024b:	8b 4c 24 34          	mov    0x34(%esp),%ecx
  10024f:	8b 7c 24 38          	mov    0x38(%esp),%edi
  100253:	8b 74 24 3c          	mov    0x3c(%esp),%esi
  100257:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  10025b:	89 ca                	mov    %ecx,%edx
  10025d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  100261:	85 f6                	test   %esi,%esi
  100263:	75 3b                	jne    1002a0 <__udivdi3+0x60>
  100265:	39 cf                	cmp    %ecx,%edi
  100267:	0f 87 c3 00 00 00    	ja     100330 <__udivdi3+0xf0>
  10026d:	89 fd                	mov    %edi,%ebp
  10026f:	85 ff                	test   %edi,%edi
  100271:	75 0b                	jne    10027e <__udivdi3+0x3e>
  100273:	b8 01 00 00 00       	mov    $0x1,%eax
  100278:	31 d2                	xor    %edx,%edx
  10027a:	f7 f7                	div    %edi
  10027c:	89 c5                	mov    %eax,%ebp
  10027e:	89 c8                	mov    %ecx,%eax
  100280:	31 d2                	xor    %edx,%edx
  100282:	f7 f5                	div    %ebp
  100284:	89 c1                	mov    %eax,%ecx
  100286:	89 d8                	mov    %ebx,%eax
  100288:	89 cf                	mov    %ecx,%edi
  10028a:	f7 f5                	div    %ebp
  10028c:	89 fa                	mov    %edi,%edx
  10028e:	83 c4 1c             	add    $0x1c,%esp
  100291:	5b                   	pop    %ebx
  100292:	5e                   	pop    %esi
  100293:	5f                   	pop    %edi
  100294:	5d                   	pop    %ebp
  100295:	c3                   	ret    
  100296:	8d 76 00             	lea    0x0(%esi),%esi
  100299:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  1002a0:	39 ce                	cmp    %ecx,%esi
  1002a2:	77 7c                	ja     100320 <__udivdi3+0xe0>
  1002a4:	0f bd fe             	bsr    %esi,%edi
  1002a7:	83 f7 1f             	xor    $0x1f,%edi
  1002aa:	0f 84 90 00 00 00    	je     100340 <__udivdi3+0x100>
  1002b0:	bd 20 00 00 00       	mov    $0x20,%ebp
  1002b5:	89 f9                	mov    %edi,%ecx
  1002b7:	89 eb                	mov    %ebp,%ebx
  1002b9:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
  1002bd:	29 fb                	sub    %edi,%ebx
  1002bf:	89 e8                	mov    %ebp,%eax
  1002c1:	d3 e6                	shl    %cl,%esi
  1002c3:	88 d9                	mov    %bl,%cl
  1002c5:	d3 e8                	shr    %cl,%eax
  1002c7:	89 f9                	mov    %edi,%ecx
  1002c9:	09 f0                	or     %esi,%eax
  1002cb:	d3 e5                	shl    %cl,%ebp
  1002cd:	89 d6                	mov    %edx,%esi
  1002cf:	88 d9                	mov    %bl,%cl
  1002d1:	d3 ee                	shr    %cl,%esi
  1002d3:	89 f9                	mov    %edi,%ecx
  1002d5:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1002d9:	d3 e2                	shl    %cl,%edx
  1002db:	8b 44 24 08          	mov    0x8(%esp),%eax
  1002df:	88 d9                	mov    %bl,%cl
  1002e1:	d3 e8                	shr    %cl,%eax
  1002e3:	09 c2                	or     %eax,%edx
  1002e5:	89 d0                	mov    %edx,%eax
  1002e7:	89 f2                	mov    %esi,%edx
  1002e9:	f7 74 24 0c          	divl   0xc(%esp)
  1002ed:	89 d6                	mov    %edx,%esi
  1002ef:	89 c3                	mov    %eax,%ebx
  1002f1:	f7 e5                	mul    %ebp
  1002f3:	39 d6                	cmp    %edx,%esi
  1002f5:	72 10                	jb     100307 <__udivdi3+0xc7>
  1002f7:	8b 6c 24 08          	mov    0x8(%esp),%ebp
  1002fb:	89 f9                	mov    %edi,%ecx
  1002fd:	d3 e5                	shl    %cl,%ebp
  1002ff:	39 c5                	cmp    %eax,%ebp
  100301:	73 5d                	jae    100360 <__udivdi3+0x120>
  100303:	39 d6                	cmp    %edx,%esi
  100305:	75 59                	jne    100360 <__udivdi3+0x120>
  100307:	8d 43 ff             	lea    -0x1(%ebx),%eax
  10030a:	31 ff                	xor    %edi,%edi
  10030c:	89 fa                	mov    %edi,%edx
  10030e:	83 c4 1c             	add    $0x1c,%esp
  100311:	5b                   	pop    %ebx
  100312:	5e                   	pop    %esi
  100313:	5f                   	pop    %edi
  100314:	5d                   	pop    %ebp
  100315:	c3                   	ret    
  100316:	8d 76 00             	lea    0x0(%esi),%esi
  100319:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  100320:	31 ff                	xor    %edi,%edi
  100322:	31 c0                	xor    %eax,%eax
  100324:	89 fa                	mov    %edi,%edx
  100326:	83 c4 1c             	add    $0x1c,%esp
  100329:	5b                   	pop    %ebx
  10032a:	5e                   	pop    %esi
  10032b:	5f                   	pop    %edi
  10032c:	5d                   	pop    %ebp
  10032d:	c3                   	ret    
  10032e:	66 90                	xchg   %ax,%ax
  100330:	89 d8                	mov    %ebx,%eax
  100332:	f7 f7                	div    %edi
  100334:	31 ff                	xor    %edi,%edi
  100336:	89 fa                	mov    %edi,%edx
  100338:	83 c4 1c             	add    $0x1c,%esp
  10033b:	5b                   	pop    %ebx
  10033c:	5e                   	pop    %esi
  10033d:	5f                   	pop    %edi
  10033e:	5d                   	pop    %ebp
  10033f:	c3                   	ret    
  100340:	39 ce                	cmp    %ecx,%esi
  100342:	72 10                	jb     100354 <__udivdi3+0x114>
  100344:	8b 74 24 08          	mov    0x8(%esp),%esi
  100348:	31 c0                	xor    %eax,%eax
  10034a:	39 74 24 0c          	cmp    %esi,0xc(%esp)
  10034e:	0f 87 38 ff ff ff    	ja     10028c <__udivdi3+0x4c>
  100354:	b8 01 00 00 00       	mov    $0x1,%eax
  100359:	e9 2e ff ff ff       	jmp    10028c <__udivdi3+0x4c>
  10035e:	66 90                	xchg   %ax,%ax
  100360:	89 d8                	mov    %ebx,%eax
  100362:	31 ff                	xor    %edi,%edi
  100364:	e9 23 ff ff ff       	jmp    10028c <__udivdi3+0x4c>

00100369 <main>:
	{"start", start, "start (p) where p<=512 "},
	{"dump", dump, "dump (p1) (p2) where p1<p2. It will print out values stored between pages p1 and p2"},
	{NULL,NULL}
};

int main(void) {
  100369:	55                   	push   %ebp
  10036a:	89 e5                	mov    %esp,%ebp
	no_of_sensors = 0;
	is_rom_init = false;
	current_addr_loc = 0;
	SHELL_REGISTER(SHELL_MODULE_NAME, commands);
	//shell_register_default_module(SHELL_MODULE_NAME);
	hcsr0_dev = device_get_binding("HCSR0");
  10036c:	68 40 47 10 00       	push   $0x104740
  100371:	e8 71 33 00 00       	call   1036e7 <device_get_binding>
	hcsr1_dev = device_get_binding("HCSR1");
  100376:	c7 04 24 46 47 10 00 	movl   $0x104746,(%esp)
	no_of_sensors = 0;
	is_rom_init = false;
	current_addr_loc = 0;
	SHELL_REGISTER(SHELL_MODULE_NAME, commands);
	//shell_register_default_module(SHELL_MODULE_NAME);
	hcsr0_dev = device_get_binding("HCSR0");
  10037d:	a3 40 72 10 00       	mov    %eax,0x107240
	hcsr1_dev = device_get_binding("HCSR1");
  100382:	e8 60 33 00 00       	call   1036e7 <device_get_binding>
  100387:	5a                   	pop    %edx

	api0 = hcsr0_dev->driver_api;
  100388:	8b 15 40 72 10 00    	mov    0x107240,%edx
	api1 = hcsr1_dev->driver_api;
  10038e:	8b 40 04             	mov    0x4(%eax),%eax
	SHELL_REGISTER(SHELL_MODULE_NAME, commands);
	//shell_register_default_module(SHELL_MODULE_NAME);
	hcsr0_dev = device_get_binding("HCSR0");
	hcsr1_dev = device_get_binding("HCSR1");

	api0 = hcsr0_dev->driver_api;
  100391:	8b 52 04             	mov    0x4(%edx),%edx
	api1 = hcsr1_dev->driver_api;
  100394:	a3 a4 7e 10 00       	mov    %eax,0x107ea4
	SHELL_REGISTER(SHELL_MODULE_NAME, commands);
	//shell_register_default_module(SHELL_MODULE_NAME);
	hcsr0_dev = device_get_binding("HCSR0");
	hcsr1_dev = device_get_binding("HCSR1");

	api0 = hcsr0_dev->driver_api;
  100399:	89 15 a8 7e 10 00    	mov    %edx,0x107ea8
	api1 = hcsr1_dev->driver_api;
  10039f:	c9                   	leave  
  1003a0:	c3                   	ret    

001003a1 <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
  1003a1:	55                   	push   %ebp
  1003a2:	89 e5                	mov    %esp,%ebp
  1003a4:	53                   	push   %ebx
  1003a5:	8b 5d 08             	mov    0x8(%ebp),%ebx
		return c;
	}

#endif /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
  1003a8:	83 fb 0a             	cmp    $0xa,%ebx
  1003ab:	75 10                	jne    1003bd <console_out+0x1c>
		uart_poll_out(uart_console_dev, '\r');
  1003ad:	a1 44 72 10 00       	mov    0x107244,%eax
static inline unsigned char uart_poll_out(struct device *dev,
					  unsigned char out_char)
{
	const struct uart_driver_api *api = dev->driver_api;

	return api->poll_out(dev, out_char);
  1003b2:	8b 50 04             	mov    0x4(%eax),%edx
  1003b5:	6a 0d                	push   $0xd
  1003b7:	50                   	push   %eax
  1003b8:	ff 52 04             	call   *0x4(%edx)
  1003bb:	59                   	pop    %ecx
  1003bc:	58                   	pop    %eax
	}
	uart_poll_out(uart_console_dev, c);
  1003bd:	a1 44 72 10 00       	mov    0x107244,%eax
  1003c2:	0f b6 cb             	movzbl %bl,%ecx
  1003c5:	8b 50 04             	mov    0x4(%eax),%edx
  1003c8:	51                   	push   %ecx
  1003c9:	50                   	push   %eax
  1003ca:	ff 52 04             	call   *0x4(%edx)
  1003cd:	58                   	pop    %eax

	return c;
}
  1003ce:	89 d8                	mov    %ebx,%eax
  1003d0:	5a                   	pop    %edx
  1003d1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1003d4:	c9                   	leave  
  1003d5:	c3                   	ret    

001003d6 <uart_console_hook_install>:
 *
 * @return N/A
 */

void uart_console_hook_install(void)
{
  1003d6:	55                   	push   %ebp
  1003d7:	89 e5                	mov    %esp,%ebp
	__stdout_hook_install(console_out);
	__printk_hook_install(console_out);
  1003d9:	68 a1 03 10 00       	push   $0x1003a1
  1003de:	e8 d8 29 00 00       	call   102dbb <__printk_hook_install>
  1003e3:	58                   	pop    %eax
}
  1003e4:	c9                   	leave  
  1003e5:	c3                   	ret    

001003e6 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
  1003e6:	55                   	push   %ebp
  1003e7:	89 e5                	mov    %esp,%ebp

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
  1003e9:	68 4c 47 10 00       	push   $0x10474c
  1003ee:	e8 f4 32 00 00       	call   1036e7 <device_get_binding>
  1003f3:	5a                   	pop    %edx
  1003f4:	a3 44 72 10 00       	mov    %eax,0x107244
		}
	}
	sys_thread_busy_wait(1000000);
#endif

	uart_console_hook_install();
  1003f9:	e8 d8 ff ff ff       	call   1003d6 <uart_console_hook_install>

	return 0;
}
  1003fe:	31 c0                	xor    %eax,%eax
  100400:	c9                   	leave  
  100401:	c3                   	ret    

00100402 <uart_ns16550_poll_in>:
 * @param c Pointer to character
 *
 * @return 0 if a character arrived, -1 if the input buffer if empty.
 */
static int uart_ns16550_poll_in(struct device *dev, unsigned char *c)
{
  100402:	55                   	push   %ebp
  100403:	89 e5                	mov    %esp,%ebp
  100405:	8b 55 08             	mov    0x8(%ebp),%edx
	if ((INBYTE(LSR(dev)) & LSR_RXRDY) == 0x00)
  100408:	8b 42 08             	mov    0x8(%edx),%eax
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
			 : "=q"(ret)
			 : "m" (*(volatile uint8_t *) addr)
  10040b:	8b 00                	mov    (%eax),%eax
static ALWAYS_INLINE
	uint8_t sys_read8(mm_reg_t addr)
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
  10040d:	8a 48 14             	mov    0x14(%eax),%cl
  100410:	80 e1 01             	and    $0x1,%cl
  100413:	74 10                	je     100425 <uart_ns16550_poll_in+0x23>
		return (-1);

	/* got a character */
	*c = INBYTE(RDR(dev));
  100415:	8b 42 08             	mov    0x8(%edx),%eax
			 : "=q"(ret)
			 : "m" (*(volatile uint8_t *) addr)
  100418:	8b 00                	mov    (%eax),%eax
static ALWAYS_INLINE
	uint8_t sys_read8(mm_reg_t addr)
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
  10041a:	8a 10                	mov    (%eax),%dl
  10041c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10041f:	88 10                	mov    %dl,(%eax)

	return 0;
  100421:	31 c0                	xor    %eax,%eax
  100423:	eb 03                	jmp    100428 <uart_ns16550_poll_in+0x26>
  100425:	83 c8 ff             	or     $0xffffffff,%eax
}
  100428:	5d                   	pop    %ebp
  100429:	c3                   	ret    

0010042a <uart_ns16550_poll_out>:
 *
 * @return Sent character
 */
static unsigned char uart_ns16550_poll_out(struct device *dev,
					   unsigned char c)
{
  10042a:	55                   	push   %ebp
  10042b:	89 e5                	mov    %esp,%ebp
  10042d:	8b 55 08             	mov    0x8(%ebp),%edx
  100430:	8b 45 0c             	mov    0xc(%ebp),%eax
	/* wait for transmitter to ready to accept a character */
	while ((INBYTE(LSR(dev)) & LSR_TEMT) == 0)
  100433:	8b 4a 08             	mov    0x8(%edx),%ecx
			 : "=q"(ret)
			 : "m" (*(volatile uint8_t *) addr)
  100436:	8b 09                	mov    (%ecx),%ecx
static ALWAYS_INLINE
	uint8_t sys_read8(mm_reg_t addr)
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
  100438:	8a 49 14             	mov    0x14(%ecx),%cl
  10043b:	80 e1 40             	and    $0x40,%cl
  10043e:	74 f3                	je     100433 <uart_ns16550_poll_out+0x9>
		;

	OUTBYTE(THR(dev), c);
  100440:	8b 52 08             	mov    0x8(%edx),%edx
static ALWAYS_INLINE
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
  100443:	8b 12                	mov    (%edx),%edx
}

static ALWAYS_INLINE
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
  100445:	88 02                	mov    %al,(%edx)

	return c;
}
  100447:	5d                   	pop    %ebp
  100448:	c3                   	ret    

00100449 <uart_ns16550_err_check>:
 *
 * @return one of UART_ERROR_OVERRUN, UART_ERROR_PARITY, UART_ERROR_FRAMING,
 * UART_ERROR_BREAK if an error was detected, 0 otherwise.
 */
static int uart_ns16550_err_check(struct device *dev)
{
  100449:	55                   	push   %ebp
  10044a:	89 e5                	mov    %esp,%ebp
	return (INBYTE(LSR(dev)) & LSR_EOB_MASK) >> 1;
  10044c:	8b 45 08             	mov    0x8(%ebp),%eax
  10044f:	8b 40 08             	mov    0x8(%eax),%eax
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
			 : "=q"(ret)
			 : "m" (*(volatile uint8_t *) addr)
  100452:	8b 00                	mov    (%eax),%eax
static ALWAYS_INLINE
	uint8_t sys_read8(mm_reg_t addr)
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
  100454:	8a 40 14             	mov    0x14(%eax),%al
  100457:	83 e0 1e             	and    $0x1e,%eax
}
  10045a:	5d                   	pop    %ebp
 * @return one of UART_ERROR_OVERRUN, UART_ERROR_PARITY, UART_ERROR_FRAMING,
 * UART_ERROR_BREAK if an error was detected, 0 otherwise.
 */
static int uart_ns16550_err_check(struct device *dev)
{
	return (INBYTE(LSR(dev)) & LSR_EOB_MASK) >> 1;
  10045b:	d1 f8                	sar    %eax
}
  10045d:	c3                   	ret    

0010045e <uart_ns16550_init>:
 * @param dev UART device struct
 *
 * @return 0 if successful, failed othersie
 */
static int uart_ns16550_init(struct device *dev)
{
  10045e:	55                   	push   %ebp
  10045f:	89 e5                	mov    %esp,%ebp
  100461:	57                   	push   %edi
  100462:	56                   	push   %esi
  100463:	53                   	push   %ebx
  100464:	83 ec 10             	sub    $0x10,%esp
  100467:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
  10046a:	8b 73 08             	mov    0x8(%ebx),%esi
#if defined(CONFIG_UART_NS16550_PCI)
static inline int ns16550_pci_uart_scan(struct device *dev)
{
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);

	if (dev_data->pci_dev.vendor_id == 0x0000) {
  10046d:	66 83 7e 1c 00       	cmpw   $0x0,0x1c(%esi)
  100472:	74 23                	je     100497 <uart_ns16550_init+0x39>
		return -EINVAL;
	}

	pci_bus_scan_init();

	if (!pci_bus_scan(&dev_data->pci_dev)) {
  100474:	8d 7e 0c             	lea    0xc(%esi),%edi

	if (dev_data->pci_dev.vendor_id == 0x0000) {
		return -EINVAL;
	}

	pci_bus_scan_init();
  100477:	e8 24 05 00 00       	call   1009a0 <pci_bus_scan_init>

	if (!pci_bus_scan(&dev_data->pci_dev)) {
  10047c:	57                   	push   %edi
  10047d:	e8 8c 05 00 00       	call   100a0e <pci_bus_scan>
  100482:	5a                   	pop    %edx
  100483:	85 c0                	test   %eax,%eax
  100485:	0f 84 b6 00 00 00    	je     100541 <uart_ns16550_init+0xe3>
		return 0;
	}

#ifdef CONFIG_PCI_ENUMERATION
	dev_data->port = dev_data->pci_dev.addr;
  10048b:	8b 46 0c             	mov    0xc(%esi),%eax
  10048e:	89 06                	mov    %eax,(%esi)
#endif

	pci_enable_regs(&dev_data->pci_dev);
  100490:	57                   	push   %edi
  100491:	e8 49 0b 00 00       	call   100fdf <pci_enable_regs>
  100496:	58                   	pop    %eax

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  100497:	9c                   	pushf  
  100498:	fa                   	cli    
  100499:	8f 45 e4             	popl   -0x1c(%ebp)
	dev_data->iir_cache = 0;
#endif

	old_level = irq_lock();

	set_baud_rate(dev, dev_data->baud_rate);
  10049c:	8b 4e 04             	mov    0x4(%esi),%ecx
	const struct uart_ns16550_device_config * const dev_cfg = DEV_CFG(dev);
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
	uint32_t divisor; /* baud rate divisor */
	uint8_t lcr_cache;

	if ((baud_rate != 0) && (dev_cfg->sys_clk_freq != 0)) {
  10049f:	85 c9                	test   %ecx,%ecx
  1004a1:	74 53                	je     1004f6 <uart_ns16550_init+0x98>
}
#endif

static void set_baud_rate(struct device *dev, uint32_t baud_rate)
{
	const struct uart_ns16550_device_config * const dev_cfg = DEV_CFG(dev);
  1004a3:	8b 03                	mov    (%ebx),%eax
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
	uint32_t divisor; /* baud rate divisor */
	uint8_t lcr_cache;

	if ((baud_rate != 0) && (dev_cfg->sys_clk_freq != 0)) {
  1004a5:	8b 40 08             	mov    0x8(%eax),%eax
  1004a8:	8b 00                	mov    (%eax),%eax
  1004aa:	85 c0                	test   %eax,%eax
  1004ac:	74 48                	je     1004f6 <uart_ns16550_init+0x98>
		/* calculate baud rate divisor */
		divisor = (dev_cfg->sys_clk_freq / baud_rate) >> 4;
  1004ae:	31 d2                	xor    %edx,%edx
#endif

static void set_baud_rate(struct device *dev, uint32_t baud_rate)
{
	const struct uart_ns16550_device_config * const dev_cfg = DEV_CFG(dev);
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
  1004b0:	8b 7b 08             	mov    0x8(%ebx),%edi
	uint32_t divisor; /* baud rate divisor */
	uint8_t lcr_cache;

	if ((baud_rate != 0) && (dev_cfg->sys_clk_freq != 0)) {
		/* calculate baud rate divisor */
		divisor = (dev_cfg->sys_clk_freq / baud_rate) >> 4;
  1004b3:	f7 f1                	div    %ecx
  1004b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1004b8:	c1 e8 04             	shr    $0x4,%eax
  1004bb:	89 45 ec             	mov    %eax,-0x14(%ebp)
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
			 : "=q"(ret)
			 : "m" (*(volatile uint8_t *) addr)
  1004be:	8b 07                	mov    (%edi),%eax
static ALWAYS_INLINE
	uint8_t sys_read8(mm_reg_t addr)
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
  1004c0:	8a 40 0c             	mov    0xc(%eax),%al
  1004c3:	88 45 eb             	mov    %al,-0x15(%ebp)

		/* set the DLAB to access the baud rate divisor registers */
		lcr_cache = INBYTE(LCR(dev));
		OUTBYTE(LCR(dev), LCR_DLAB);
  1004c6:	8b 43 08             	mov    0x8(%ebx),%eax
static ALWAYS_INLINE
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
  1004c9:	8b 10                	mov    (%eax),%edx
}

static ALWAYS_INLINE
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
  1004cb:	b0 80                	mov    $0x80,%al
  1004cd:	88 42 0c             	mov    %al,0xc(%edx)
		OUTBYTE(BRDL(dev), (unsigned char)(divisor & 0xff));
  1004d0:	8b 43 08             	mov    0x8(%ebx),%eax
  1004d3:	8a 55 ec             	mov    -0x14(%ebp),%dl
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
  1004d6:	8b 00                	mov    (%eax),%eax
}

static ALWAYS_INLINE
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
  1004d8:	88 10                	mov    %dl,(%eax)
		OUTBYTE(BRDH(dev), (unsigned char)((divisor >> 8) & 0xff));
  1004da:	8b 53 08             	mov    0x8(%ebx),%edx
  1004dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1004e0:	c1 e8 0c             	shr    $0xc,%eax
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
  1004e3:	8b 12                	mov    (%edx),%edx
}

static ALWAYS_INLINE
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
  1004e5:	88 42 04             	mov    %al,0x4(%edx)

		/* restore the DLAB to access the baud rate divisor registers */
		OUTBYTE(LCR(dev), lcr_cache);
  1004e8:	8b 43 08             	mov    0x8(%ebx),%eax
  1004eb:	8a 55 eb             	mov    -0x15(%ebp),%dl
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
  1004ee:	8b 00                	mov    (%eax),%eax
}

static ALWAYS_INLINE
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
  1004f0:	88 50 0c             	mov    %dl,0xc(%eax)

		dev_data->baud_rate = baud_rate;
  1004f3:	89 4f 04             	mov    %ecx,0x4(%edi)
#ifdef CONFIG_UART_NS16550_DLF
	set_dlf(dev, dev_data->dlf);
#endif

	/* 8 data bits, 1 stop bit, no parity, clear DLAB */
	OUTBYTE(LCR(dev), LCR_CS8 | LCR_1_STB | LCR_PDIS);
  1004f6:	8b 43 08             	mov    0x8(%ebx),%eax
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
  1004f9:	8b 10                	mov    (%eax),%edx
}

static ALWAYS_INLINE
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
  1004fb:	b0 03                	mov    $0x3,%al
  1004fd:	88 42 0c             	mov    %al,0xc(%edx)

	mdc = MCR_OUT2 | MCR_RTS | MCR_DTR;
	if ((dev_data->options & UART_OPTION_AFCE) == UART_OPTION_AFCE)
  100500:	8a 46 08             	mov    0x8(%esi),%al
		mdc |= MCR_AFCE;

	OUTBYTE(MDC(dev), mdc);
  100503:	8b 53 08             	mov    0x8(%ebx),%edx

	/* 8 data bits, 1 stop bit, no parity, clear DLAB */
	OUTBYTE(LCR(dev), LCR_CS8 | LCR_1_STB | LCR_PDIS);

	mdc = MCR_OUT2 | MCR_RTS | MCR_DTR;
	if ((dev_data->options & UART_OPTION_AFCE) == UART_OPTION_AFCE)
  100506:	83 e0 01             	and    $0x1,%eax
		mdc |= MCR_AFCE;
  100509:	3c 01                	cmp    $0x1,%al
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
  10050b:	8b 12                	mov    (%edx),%edx
  10050d:	19 c0                	sbb    %eax,%eax
  10050f:	83 e0 e0             	and    $0xffffffe0,%eax
  100512:	83 c0 2b             	add    $0x2b,%eax
}

static ALWAYS_INLINE
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
  100515:	88 42 10             	mov    %al,0x10(%edx)
	/*
	 * Program FIFO: enabled, mode 0 (set for compatibility with quark),
	 * generate the interrupt at 8th byte
	 * Clear TX and RX FIFO
	 */
	OUTBYTE(FCR(dev),
  100518:	8b 43 08             	mov    0x8(%ebx),%eax
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
  10051b:	8b 10                	mov    (%eax),%edx
}

static ALWAYS_INLINE
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
  10051d:	b0 87                	mov    $0x87,%al
  10051f:	88 42 08             	mov    %al,0x8(%edx)
		FCR_FIFO | FCR_MODE0 | FCR_FIFO_8 | FCR_RCVRCLR | FCR_XMITCLR);

	/* clear the port */
	INBYTE(RDR(dev));
  100522:	8b 43 08             	mov    0x8(%ebx),%eax
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
			 : "=q"(ret)
			 : "m" (*(volatile uint8_t *) addr)
  100525:	8b 00                	mov    (%eax),%eax
static ALWAYS_INLINE
	uint8_t sys_read8(mm_reg_t addr)
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
  100527:	8a 00                	mov    (%eax),%al

	/* disable interrupts  */
	OUTBYTE(IER(dev), 0x00);
  100529:	8b 43 08             	mov    0x8(%ebx),%eax
static ALWAYS_INLINE
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
  10052c:	8b 10                	mov    (%eax),%edx
}

static ALWAYS_INLINE
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
  10052e:	31 c0                	xor    %eax,%eax
  100530:	88 42 04             	mov    %al,0x4(%edx)

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	DEV_CFG(dev)->irq_config_func(dev);
#endif

	return 0;
  100533:	31 c0                	xor    %eax,%eax
 *
 */

static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	if (!(key & 0x200)) {
  100535:	f7 45 e4 00 02 00 00 	testl  $0x200,-0x1c(%ebp)
  10053c:	74 0f                	je     10054d <uart_ns16550_init+0xef>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  10053e:	fb                   	sti    
  10053f:	eb 0c                	jmp    10054d <uart_ns16550_init+0xef>

	int old_level;     /* old interrupt lock level */
	uint8_t mdc = 0;

	if (!ns16550_pci_uart_scan(dev)) {
		dev->driver_api = NULL;
  100541:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
		return -ENOTSUP;
  100548:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	DEV_CFG(dev)->irq_config_func(dev);
#endif

	return 0;
}
  10054d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  100550:	5b                   	pop    %ebx
  100551:	5e                   	pop    %esi
  100552:	5f                   	pop    %edi
  100553:	5d                   	pop    %ebp
  100554:	c3                   	ret    

00100555 <_timer_int_handler>:
 * is pushed onto the microkernel stack.
 *
 * @return N/A
 */
void _timer_int_handler(void *unused)
{
  100555:	55                   	push   %ebp
	ARG_UNUSED(unused);

#if defined(CONFIG_HPET_TIMER_LEVEL_LOW) || defined(CONFIG_HPET_TIMER_LEVEL_HIGH)
	/* Acknowledge interrupt */
	*_HPET_GENERAL_INT_STATUS = 1;
  100556:	c7 05 20 00 d0 fe 01 	movl   $0x1,0xfed00020
  10055d:	00 00 00 
 * is pushed onto the microkernel stack.
 *
 * @return N/A
 */
void _timer_int_handler(void *unused)
{
  100560:	89 e5                	mov    %esp,%ebp
	/*
	 * one more tick has occurred -- don't need to do anything special since
	 * timer is already configured to interrupt on the following tick
	 */

	_sys_clock_tick_announce();
  100562:	a1 40 71 10 00       	mov    0x107140,%eax
  100567:	89 45 08             	mov    %eax,0x8(%ebp)
	programmed_ticks = 1;

	_sys_clock_final_tick_announce();
#endif /* !CONFIG_TICKLESS_IDLE */

}
  10056a:	5d                   	pop    %ebp
	/*
	 * one more tick has occurred -- don't need to do anything special since
	 * timer is already configured to interrupt on the following tick
	 */

	_sys_clock_tick_announce();
  10056b:	e9 95 38 00 00       	jmp    103e05 <_nano_sys_clock_tick_announce>

00100570 <_sys_clock_driver_init>:
 *
 * @return 0
 */

int _sys_clock_driver_init(struct device *device)
{
  100570:	55                   	push   %ebp
  100571:	89 e5                	mov    %esp,%ebp
  100573:	57                   	push   %edi
  100574:	56                   	push   %esi
  100575:	53                   	push   %ebx
	/*
	 * Initial state of HPET is unknown, so put it back in a reset-like
	 * state (i.e. set main counter to 0 and disable interrupts)
	 */

	*_HPET_GENERAL_CONFIG &= ~HPET_ENABLE_CNF;
  100576:	a1 10 00 d0 fe       	mov    0xfed00010,%eax
  10057b:	83 e0 fe             	and    $0xfffffffe,%eax
  10057e:	a3 10 00 d0 fe       	mov    %eax,0xfed00010
	*_HPET_MAIN_COUNTER_VALUE = 0;
  100583:	c7 05 f0 00 d0 fe 00 	movl   $0x0,0xfed000f0
  10058a:	00 00 00 
	/*
	 * compute value for the comparator register to achieve
	 * 'sys_clock_us_per_tick' period
	 */

	counter_load_value = (uint32_t)(tickFempto / hpetClockPeriod);
  10058d:	b8 00 ca 9a 3b       	mov    $0x3b9aca00,%eax
	 * Initial state of HPET is unknown, so put it back in a reset-like
	 * state (i.e. set main counter to 0 and disable interrupts)
	 */

	*_HPET_GENERAL_CONFIG &= ~HPET_ENABLE_CNF;
	*_HPET_MAIN_COUNTER_VALUE = 0;
  100592:	c7 05 f4 00 d0 fe 00 	movl   $0x0,0xfed000f4
  100599:	00 00 00 
	/*
	 * compute value for the comparator register to achieve
	 * 'sys_clock_us_per_tick' period
	 */

	counter_load_value = (uint32_t)(tickFempto / hpetClockPeriod);
  10059c:	f7 2d 4c 71 10 00    	imull  0x10714c
	 * to determine the frequency of clock applied to the HPET device.
	 */

	/* read the clock period: units are fempto (10^-15) seconds */

	hpetClockPeriod = HPET_COUNTER_CLK_PERIOD(*_HPET_GENERAL_CAPS);
  1005a2:	8b 0d 00 00 d0 fe    	mov    0xfed00000,%ecx
  1005a8:	8b 1d 04 00 d0 fe    	mov    0xfed00004,%ebx
	/*
	 * compute value for the comparator register to achieve
	 * 'sys_clock_us_per_tick' period
	 */

	counter_load_value = (uint32_t)(tickFempto / hpetClockPeriod);
  1005ae:	89 d9                	mov    %ebx,%ecx
  1005b0:	31 db                	xor    %ebx,%ebx
  1005b2:	53                   	push   %ebx
  1005b3:	51                   	push   %ecx
  1005b4:	52                   	push   %edx
  1005b5:	50                   	push   %eax
  1005b6:	e8 85 fc ff ff       	call   100240 <__udivdi3>
  1005bb:	31 db                	xor    %ebx,%ebx
	       (uint32_t)(*_HPET_TIMER0_CONFIG_CAPS >> 32));

	/* Initialize sys_clock_hw_cycles_per_tick/sec */

	sys_clock_hw_cycles_per_tick = counter_load_value;
	sys_clock_hw_cycles_per_sec = sys_clock_hw_cycles_per_tick *
  1005bd:	6b d0 64             	imul   $0x64,%eax,%edx
	PRINTK("HPET: timer0: available interrupts mask 0x%x\n",
	       (uint32_t)(*_HPET_TIMER0_CONFIG_CAPS >> 32));

	/* Initialize sys_clock_hw_cycles_per_tick/sec */

	sys_clock_hw_cycles_per_tick = counter_load_value;
  1005c0:	a3 48 71 10 00       	mov    %eax,0x107148
	sys_clock_hw_cycles_per_sec = sys_clock_hw_cycles_per_tick *
  1005c5:	89 15 44 71 10 00    	mov    %edx,0x107144
	 * Setting 32-bit mode during the first load of the comparator
	 * value is required to work around some hardware that otherwise
	 * does not work properly.
	 */

	*_HPET_TIMER0_CONFIG_CAPS |= HPET_Tn_TYPE_CNF | HPET_Tn_32MODE_CNF;
  1005cb:	8b 35 00 01 d0 fe    	mov    0xfed00100,%esi
  1005d1:	8b 3d 04 01 d0 fe    	mov    0xfed00104,%edi
  1005d7:	89 f2                	mov    %esi,%edx
	/*
	 * compute value for the comparator register to achieve
	 * 'sys_clock_us_per_tick' period
	 */

	counter_load_value = (uint32_t)(tickFempto / hpetClockPeriod);
  1005d9:	83 c4 10             	add    $0x10,%esp
	 * Setting 32-bit mode during the first load of the comparator
	 * value is required to work around some hardware that otherwise
	 * does not work properly.
	 */

	*_HPET_TIMER0_CONFIG_CAPS |= HPET_Tn_TYPE_CNF | HPET_Tn_32MODE_CNF;
  1005dc:	81 ca 08 01 00 00    	or     $0x108,%edx
  1005e2:	89 15 00 01 d0 fe    	mov    %edx,0xfed00100
  1005e8:	89 3d 04 01 d0 fe    	mov    %edi,0xfed00104

	/*
	 * Set the comparator register for timer0.  The write to the comparator
	 * register is allowed due to setting the HPET_Tn_VAL_SET_CNF bit.
	 */
	*_HPET_TIMER0_CONFIG_CAPS |= HPET_Tn_VAL_SET_CNF;
  1005ee:	8b 35 00 01 d0 fe    	mov    0xfed00100,%esi
  1005f4:	8b 3d 04 01 d0 fe    	mov    0xfed00104,%edi
  1005fa:	89 f2                	mov    %esi,%edx
  1005fc:	83 ca 40             	or     $0x40,%edx
  1005ff:	89 15 00 01 d0 fe    	mov    %edx,0xfed00100
  100605:	89 3d 04 01 d0 fe    	mov    %edi,0xfed00104
	*_HPET_TIMER0_COMPARATOR = counter_load_value;
  10060b:	a3 08 01 d0 fe       	mov    %eax,0xfed00108
  100610:	89 1d 0c 01 d0 fe    	mov    %ebx,0xfed0010c
	/*
	 * After the comparator is loaded, 32-bit mode can be safely
	 * switched off
	 */
	*_HPET_TIMER0_CONFIG_CAPS &= ~HPET_Tn_32MODE_CNF;
  100616:	8b 0d 00 01 d0 fe    	mov    0xfed00100,%ecx
  10061c:	8b 1d 04 01 d0 fe    	mov    0xfed00104,%ebx
  100622:	89 cf                	mov    %ecx,%edi
  100624:	81 e7 ff fe ff ff    	and    $0xfffffeff,%edi
  10062a:	89 3d 00 01 d0 fe    	mov    %edi,0xfed00100
  100630:	89 1d 04 01 d0 fe    	mov    %ebx,0xfed00104
	 * this case program leaves the IRQ fields blank.
	 */

	*_HPET_TIMER0_CONFIG_CAPS =
#if CONFIG_HPET_TIMER_IRQ < 32
		(*_HPET_TIMER0_CONFIG_CAPS & ~HPET_Tn_INT_ROUTE_CNF_MASK) |
  100636:	a1 00 01 d0 fe       	mov    0xfed00100,%eax
  10063b:	8b 15 04 01 d0 fe    	mov    0xfed00104,%edx
#else
		(*_HPET_TIMER0_CONFIG_CAPS & ~HPET_Tn_INT_ROUTE_CNF_MASK)
#endif

#if defined(CONFIG_HPET_TIMER_LEVEL_LOW) || defined(CONFIG_HPET_TIMER_LEVEL_HIGH)
		| HPET_Tn_INT_TYPE_CNF;
  100641:	89 c3                	mov    %eax,%ebx
  100643:	81 e3 fd c1 ff ff    	and    $0xffffc1fd,%ebx
  100649:	81 cb 02 28 00 00    	or     $0x2802,%ebx
	 * HPET timers IRQ field is 5 bits wide, and hence, can support only
	 * IRQ's up to 31. Some platforms, however, use IRQs greater than 31. In
	 * this case program leaves the IRQ fields blank.
	 */

	*_HPET_TIMER0_CONFIG_CAPS =
  10064f:	89 1d 00 01 d0 fe    	mov    %ebx,0xfed00100
  100655:	89 15 04 01 d0 fe    	mov    %edx,0xfed00104
 * @returns: N/A
 */
static inline void _irq_controller_irq_config(unsigned int vector,
					      unsigned int irq, uint32_t flags)
{
	__irq_controller_irq_config(vector, irq, flags);
  10065b:	0f b6 05 bc 6d 10 00 	movzbl 0x106dbc,%eax
  100662:	68 00 a0 00 00       	push   $0xa000
  100667:	6a 14                	push   $0x14
  100669:	50                   	push   %eax
  10066a:	e8 af 01 00 00       	call   10081e <__irq_controller_irq_config>
  10066f:	83 c4 0c             	add    $0xc,%esp
	IRQ_CONNECT(CONFIG_HPET_TIMER_IRQ, CONFIG_HPET_TIMER_IRQ_PRIORITY,
		   _timer_int_handler, 0, HPET_IOAPIC_FLAGS);

	/* enable the IRQ in the interrupt controller */

	irq_enable(CONFIG_HPET_TIMER_IRQ);
  100672:	6a 14                	push   $0x14
  100674:	e8 cb 01 00 00       	call   100844 <_arch_irq_enable>
  100679:	58                   	pop    %eax

	/* enable the HPET generally, and timer0 specifically */

	*_HPET_GENERAL_CONFIG |= HPET_ENABLE_CNF;
  10067a:	a1 10 00 d0 fe       	mov    0xfed00010,%eax
  10067f:	83 c8 01             	or     $0x1,%eax
  100682:	a3 10 00 d0 fe       	mov    %eax,0xfed00010
	*_HPET_TIMER0_CONFIG_CAPS |= HPET_Tn_INT_ENB_CNF;

	return 0;
}
  100687:	31 c0                	xor    %eax,%eax
	irq_enable(CONFIG_HPET_TIMER_IRQ);

	/* enable the HPET generally, and timer0 specifically */

	*_HPET_GENERAL_CONFIG |= HPET_ENABLE_CNF;
	*_HPET_TIMER0_CONFIG_CAPS |= HPET_Tn_INT_ENB_CNF;
  100689:	8b 0d 00 01 d0 fe    	mov    0xfed00100,%ecx
  10068f:	8b 1d 04 01 d0 fe    	mov    0xfed00104,%ebx
  100695:	89 cf                	mov    %ecx,%edi
  100697:	83 cf 04             	or     $0x4,%edi
  10069a:	89 3d 00 01 d0 fe    	mov    %edi,0xfed00100
  1006a0:	89 1d 04 01 d0 fe    	mov    %ebx,0xfed00104

	return 0;
}
  1006a6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1006a9:	5b                   	pop    %ebx
  1006aa:	5e                   	pop    %esi
  1006ab:	5f                   	pop    %edi
  1006ac:	5d                   	pop    %ebp
  1006ad:	c3                   	ret    

001006ae <_timer_int_handler_irq20_stub>:

	/*
	 * Although the stub has already been "connected", the vector number
	 * still has to be programmed into the interrupt controller.
	 */
	IRQ_CONNECT(CONFIG_HPET_TIMER_IRQ, CONFIG_HPET_TIMER_IRQ_PRIORITY,
  1006ae:	6a 00                	push   $0x0
  1006b0:	68 55 05 10 00       	push   $0x100555
  1006b5:	e9 d8 2c 00 00       	jmp    103392 <_interrupt_enter>

001006ba <shared_irq_isr_irq18_stub>:
  1006ba:	68 98 71 10 00       	push   $0x107198
  1006bf:	68 d3 12 10 00       	push   $0x1012d3
  1006c4:	e9 c9 2c 00 00       	jmp    103392 <_interrupt_enter>

001006c9 <spi_intel_isr_irq16_stub>:
  1006c9:	68 28 72 10 00       	push   $0x107228
  1006ce:	68 95 15 10 00       	push   $0x101595
  1006d3:	e9 ba 2c 00 00       	jmp    103392 <_interrupt_enter>

001006d8 <_loapic_init>:
 * @return N/A
 *
 */

static int _loapic_init(struct device *unused)
{
  1006d8:	55                   	push   %ebp
  1006d9:	89 e5                	mov    %esp,%ebp
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  1006db:	a1 f0 00 e0 fe       	mov    0xfee000f0,%eax
	ARG_UNUSED(unused);
	int32_t loApicMaxLvt; /* local APIC Max LVT */

	/* enable the Local APIC */
	sys_write32(sys_read32(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_SVR)
  1006e0:	80 cc 01             	or     $0x1,%ah
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  1006e3:	a3 f0 00 e0 fe       	mov    %eax,0xfee000f0
		    | LOAPIC_ENABLE, CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_SVR);

	loApicMaxLvt = (*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_VER) &
  1006e8:	a1 30 00 e0 fe       	mov    0xfee00030,%eax
			LOAPIC_MAXLVT_MASK) >> 16;

	/* reset the DFR, TPR, TIMER_CONFIG, and TIMER_ICR */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_DFR) =
  1006ed:	c7 05 e0 00 e0 fe ff 	movl   $0xffffffff,0xfee000e0
  1006f4:	ff ff ff 
		(int)0xffffffff;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TPR) = (int)0x0;
  1006f7:	c7 05 80 00 e0 fe 00 	movl   $0x0,0xfee00080
  1006fe:	00 00 00 
	*(volatile int *) (CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER_CONFIG) =
  100701:	c7 05 e0 03 e0 fe 00 	movl   $0x0,0xfee003e0
  100708:	00 00 00 
		(int)0x0;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER_ICR) = (int)0x0;
  10070b:	c7 05 80 03 e0 fe 00 	movl   $0x0,0xfee00380
  100712:	00 00 00 

	/* enable the Local APIC */
	sys_write32(sys_read32(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_SVR)
		    | LOAPIC_ENABLE, CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_SVR);

	loApicMaxLvt = (*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_VER) &
  100715:	25 00 00 ff 00       	and    $0xff0000,%eax
  10071a:	c1 f8 10             	sar    $0x10,%eax
	/* program Local Vector Table for the Virtual Wire Mode */

	/* set LINT0: extInt, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) =
		(*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) &
  10071d:	8b 15 50 03 e0 fe    	mov    0xfee00350,%edx
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
  100723:	81 e2 ff 58 fe ff    	and    $0xfffe58ff,%edx
  100729:	80 ce 07             	or     $0x7,%dh

	/* program Local Vector Table for the Virtual Wire Mode */

	/* set LINT0: extInt, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) =
  10072c:	89 15 50 03 e0 fe    	mov    %edx,0xfee00350
		(LOAPIC_EXT | LOAPIC_HIGH | LOAPIC_EDGE);

	/* set LINT1: NMI, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) =
		(*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) &
  100732:	8b 15 60 03 e0 fe    	mov    0xfee00360,%edx
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
  100738:	81 e2 ff 58 fe ff    	and    $0xfffe58ff,%edx
  10073e:	80 ce 04             	or     $0x4,%dh
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER) =
		LOAPIC_LVT_MASKED;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ERROR) =
		LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_P6)
  100741:	83 f8 03             	cmp    $0x3,%eax
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
		(LOAPIC_EXT | LOAPIC_HIGH | LOAPIC_EDGE);

	/* set LINT1: NMI, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) =
  100744:	89 15 60 03 e0 fe    	mov    %edx,0xfee00360
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
		(LOAPIC_NMI | LOAPIC_HIGH | LOAPIC_EDGE);

	/* lock the Local APIC interrupts */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER) =
  10074a:	c7 05 20 03 e0 fe 00 	movl   $0x10000,0xfee00320
  100751:	00 01 00 
		LOAPIC_LVT_MASKED;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ERROR) =
  100754:	c7 05 70 03 e0 fe 00 	movl   $0x10000,0xfee00370
  10075b:	00 01 00 
		LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_P6)
  10075e:	7e 19                	jle    100779 <_loapic_init+0xa1>
		*(volatile int *) (CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_PMC) =
  100760:	c7 05 40 03 e0 fe 00 	movl   $0x10000,0xfee00340
  100767:	00 01 00 
			LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_PENTIUM4)
  10076a:	83 f8 04             	cmp    $0x4,%eax
  10076d:	74 0a                	je     100779 <_loapic_init+0xa1>
		*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_THERMAL) =
  10076f:	c7 05 30 03 e0 fe 00 	movl   $0x10000,0xfee00330
  100776:	00 01 00 

	/* discard a pending interrupt if any */
#if CONFIG_EOI_FORWARDING_BUG
	_lakemont_eoi();
#else
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_EOI) = 0;
  100779:	c7 05 b0 00 e0 fe 00 	movl   $0x0,0xfee000b0
  100780:	00 00 00 
#endif

	return 0;
}
  100783:	31 c0                	xor    %eax,%eax
  100785:	5d                   	pop    %ebp
  100786:	c3                   	ret    

00100787 <_loapic_int_vec_set>:
 */

void _loapic_int_vec_set(unsigned int irq, /* IRQ number of the interrupt */
				  unsigned int vector /* vector to copy into the LVT */
				  )
{
  100787:	55                   	push   %ebp
  100788:	89 e5                	mov    %esp,%ebp
	 *   IRQ5 -> LOAPIC_ERROR
	 *
	 * It's assumed that LVTs are spaced by 0x10 bytes
	 */

	pLvt = (volatile int *)
  10078a:	8b 45 08             	mov    0x8(%ebp),%eax
  10078d:	05 32 00 ee 0f       	add    $0xfee0032,%eax
  100792:	c1 e0 04             	shl    $0x4,%eax

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  100795:	9c                   	pushf  
  100796:	fa                   	cli    
  100797:	59                   	pop    %ecx
			(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER + (irq * 0x10));

	/* update the 'vector' bits in the LVT */

	oldLevel = irq_lock();
	*pLvt = (*pLvt & ~LOAPIC_VECTOR) | vector;
  100798:	8b 10                	mov    (%eax),%edx
  10079a:	30 d2                	xor    %dl,%dl
  10079c:	0b 55 0c             	or     0xc(%ebp),%edx
  10079f:	80 e5 02             	and    $0x2,%ch
  1007a2:	89 10                	mov    %edx,(%eax)
  1007a4:	74 01                	je     1007a7 <_loapic_int_vec_set+0x20>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1007a6:	fb                   	sti    
	irq_unlock(oldLevel);
}
  1007a7:	5d                   	pop    %ebp
  1007a8:	c3                   	ret    

001007a9 <_loapic_irq_enable>:
 *
 * @return N/A
 */

void _loapic_irq_enable(unsigned int irq)
{
  1007a9:	55                   	push   %ebp
  1007aa:	89 e5                	mov    %esp,%ebp
	/*
	 * See the comments in _LoApicLvtVecSet() regarding IRQ to LVT mappings
	 * and ths assumption concerning LVT spacing.
	 */

	pLvt = (volatile int *)
  1007ac:	8b 45 08             	mov    0x8(%ebp),%eax
  1007af:	05 32 00 ee 0f       	add    $0xfee0032,%eax
  1007b4:	c1 e0 04             	shl    $0x4,%eax

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1007b7:	9c                   	pushf  
  1007b8:	fa                   	cli    
  1007b9:	59                   	pop    %ecx
		(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER + (irq * 0x10));

	/* clear the mask bit in the LVT */

	oldLevel = irq_lock();
	*pLvt = *pLvt & ~LOAPIC_LVT_MASKED;
  1007ba:	8b 10                	mov    (%eax),%edx
  1007bc:	81 e2 ff ff fe ff    	and    $0xfffeffff,%edx
  1007c2:	80 e5 02             	and    $0x2,%ch
  1007c5:	89 10                	mov    %edx,(%eax)
  1007c7:	74 01                	je     1007ca <_loapic_irq_enable+0x21>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1007c9:	fb                   	sti    
	irq_unlock(oldLevel);
}
  1007ca:	5d                   	pop    %ebp
  1007cb:	c3                   	ret    

001007cc <_loapic_irq_disable>:
 *
 * @return N/A
 */

void _loapic_irq_disable(unsigned int irq)
{
  1007cc:	55                   	push   %ebp
  1007cd:	89 e5                	mov    %esp,%ebp
	/*
	 * See the comments in _LoApicLvtVecSet() regarding IRQ to LVT mappings
	 * and ths assumption concerning LVT spacing.
	 */

	pLvt = (volatile int *)
  1007cf:	8b 45 08             	mov    0x8(%ebp),%eax
  1007d2:	05 32 00 ee 0f       	add    $0xfee0032,%eax
  1007d7:	c1 e0 04             	shl    $0x4,%eax

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1007da:	9c                   	pushf  
  1007db:	fa                   	cli    
  1007dc:	59                   	pop    %ecx
		(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER + (irq * 0x10));

	/* set the mask bit in the LVT */

	oldLevel = irq_lock();
	*pLvt = *pLvt | LOAPIC_LVT_MASKED;
  1007dd:	8b 10                	mov    (%eax),%edx
  1007df:	81 ca 00 00 01 00    	or     $0x10000,%edx
  1007e5:	80 e5 02             	and    $0x2,%ch
  1007e8:	89 10                	mov    %edx,(%eax)
  1007ea:	74 01                	je     1007ed <_loapic_irq_disable+0x21>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1007ec:	fb                   	sti    
	irq_unlock(oldLevel);
}
  1007ed:	5d                   	pop    %ebp
  1007ee:	c3                   	ret    

001007ef <__irq_controller_isr_vector_get>:
 *
 * @return The vector of the interrupt that is currently being processed, or -1
 * if no IRQ is being serviced.
 */
int __irq_controller_isr_vector_get(void)
{
  1007ef:	55                   	push   %ebp
  1007f0:	b9 70 01 e0 fe       	mov    $0xfee00170,%ecx
  1007f5:	89 e5                	mov    %esp,%ebp
	int pReg, block;

	/* Block 0 bits never lit up as these are all exception or reserved
	 * vectors
	 */
	for (block = 7; likely(block > 0); block--) {
  1007f7:	b8 07 00 00 00       	mov    $0x7,%eax
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  1007fc:	8b 11                	mov    (%ecx),%edx
		pReg = sys_read32(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ISR +
				  (block * 0x10));
		if (pReg) {
  1007fe:	85 d2                	test   %edx,%edx
  100800:	74 11                	je     100813 <__irq_controller_isr_vector_get+0x24>

static ALWAYS_INLINE unsigned int find_msb_set(uint32_t op)
{
	unsigned int bitpos;

	__asm__ volatile (
  100802:	0f bd d2             	bsr    %edx,%edx
  100805:	75 05                	jne    10080c <__irq_controller_isr_vector_get+0x1d>
  100807:	ba ff ff ff ff       	mov    $0xffffffff,%edx
			return (block * 32) + (find_msb_set(pReg) - 1);
  10080c:	c1 e0 05             	shl    $0x5,%eax
  10080f:	01 d0                	add    %edx,%eax
  100811:	eb 09                	jmp    10081c <__irq_controller_isr_vector_get+0x2d>
  100813:	83 e9 10             	sub    $0x10,%ecx
	int pReg, block;

	/* Block 0 bits never lit up as these are all exception or reserved
	 * vectors
	 */
	for (block = 7; likely(block > 0); block--) {
  100816:	48                   	dec    %eax
  100817:	75 e3                	jne    1007fc <__irq_controller_isr_vector_get+0xd>
		if (pReg) {
			return (block * 32) + (find_msb_set(pReg) - 1);
		}

	}
	return -1;
  100819:	83 c8 ff             	or     $0xffffffff,%eax
}
  10081c:	5d                   	pop    %ebp
  10081d:	c3                   	ret    

0010081e <__irq_controller_irq_config>:
 * @param flags interrupt flags
 *
 */
void __irq_controller_irq_config(unsigned int vector, unsigned int irq,
				 uint32_t flags)
{
  10081e:	55                   	push   %ebp
  10081f:	89 e5                	mov    %esp,%ebp
  100821:	8b 45 0c             	mov    0xc(%ebp),%eax
  100824:	8b 55 08             	mov    0x8(%ebp),%edx
	__ASSERT(irq >= 0 && irq <= HARDWARE_IRQ_LIMIT, "invalid irq line");

	if (IS_IOAPIC_IRQ(irq)) {
		_ioapic_irq_set(irq, vector, flags);
  100827:	89 55 0c             	mov    %edx,0xc(%ebp)
void __irq_controller_irq_config(unsigned int vector, unsigned int irq,
				 uint32_t flags)
{
	__ASSERT(irq >= 0 && irq <= HARDWARE_IRQ_LIMIT, "invalid irq line");

	if (IS_IOAPIC_IRQ(irq)) {
  10082a:	83 f8 17             	cmp    $0x17,%eax
  10082d:	77 09                	ja     100838 <__irq_controller_irq_config+0x1a>
		_ioapic_irq_set(irq, vector, flags);
  10082f:	89 45 08             	mov    %eax,0x8(%ebp)
	} else {
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
	}
}
  100832:	5d                   	pop    %ebp
				 uint32_t flags)
{
	__ASSERT(irq >= 0 && irq <= HARDWARE_IRQ_LIMIT, "invalid irq line");

	if (IS_IOAPIC_IRQ(irq)) {
		_ioapic_irq_set(irq, vector, flags);
  100833:	e9 e3 00 00 00       	jmp    10091b <_ioapic_irq_set>
	} else {
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
  100838:	83 e8 18             	sub    $0x18,%eax
  10083b:	89 45 08             	mov    %eax,0x8(%ebp)
	}
}
  10083e:	5d                   	pop    %ebp
	__ASSERT(irq >= 0 && irq <= HARDWARE_IRQ_LIMIT, "invalid irq line");

	if (IS_IOAPIC_IRQ(irq)) {
		_ioapic_irq_set(irq, vector, flags);
	} else {
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
  10083f:	e9 43 ff ff ff       	jmp    100787 <_loapic_int_vec_set>

00100844 <_arch_irq_enable>:
 * virtualization.
 *
 * @return N/A
 */
void _arch_irq_enable(unsigned int irq)
{
  100844:	55                   	push   %ebp
  100845:	89 e5                	mov    %esp,%ebp
  100847:	8b 45 08             	mov    0x8(%ebp),%eax
	if (IS_IOAPIC_IRQ(irq)) {
  10084a:	83 f8 17             	cmp    $0x17,%eax
  10084d:	77 06                	ja     100855 <_arch_irq_enable+0x11>
		_ioapic_irq_enable(irq);
	} else {
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
	}
}
  10084f:	5d                   	pop    %ebp
 * @return N/A
 */
void _arch_irq_enable(unsigned int irq)
{
	if (IS_IOAPIC_IRQ(irq)) {
		_ioapic_irq_enable(irq);
  100850:	e9 9d 00 00 00       	jmp    1008f2 <_ioapic_irq_enable>
	} else {
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
  100855:	83 e8 18             	sub    $0x18,%eax
  100858:	89 45 08             	mov    %eax,0x8(%ebp)
	}
}
  10085b:	5d                   	pop    %ebp
void _arch_irq_enable(unsigned int irq)
{
	if (IS_IOAPIC_IRQ(irq)) {
		_ioapic_irq_enable(irq);
	} else {
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
  10085c:	e9 48 ff ff ff       	jmp    1007a9 <_loapic_irq_enable>

00100861 <_arch_irq_disable>:
 * virtualization.
 *
 * @return N/A
 */
void _arch_irq_disable(unsigned int irq)
{
  100861:	55                   	push   %ebp
  100862:	89 e5                	mov    %esp,%ebp
  100864:	8b 45 08             	mov    0x8(%ebp),%eax
	if (IS_IOAPIC_IRQ(irq)) {
  100867:	83 f8 17             	cmp    $0x17,%eax
  10086a:	77 06                	ja     100872 <_arch_irq_disable+0x11>
		_ioapic_irq_disable(irq);
	} else {
		_loapic_irq_disable(irq - LOAPIC_IRQ_BASE);
	}
}
  10086c:	5d                   	pop    %ebp
 * @return N/A
 */
void _arch_irq_disable(unsigned int irq)
{
	if (IS_IOAPIC_IRQ(irq)) {
		_ioapic_irq_disable(irq);
  10086d:	e9 93 00 00 00       	jmp    100905 <_ioapic_irq_disable>
	} else {
		_loapic_irq_disable(irq - LOAPIC_IRQ_BASE);
  100872:	83 e8 18             	sub    $0x18,%eax
  100875:	89 45 08             	mov    %eax,0x8(%ebp)
	}
}
  100878:	5d                   	pop    %ebp
void _arch_irq_disable(unsigned int irq)
{
	if (IS_IOAPIC_IRQ(irq)) {
		_ioapic_irq_disable(irq);
	} else {
		_loapic_irq_disable(irq - LOAPIC_IRQ_BASE);
  100879:	e9 4e ff ff ff       	jmp    1007cc <_loapic_irq_disable>

0010087e <__IoApicSet>:
 * @param offset Register offset (8 bits)
 * @param value Value to set the register
 * @return N/A
 */
static void __IoApicSet(int32_t offset, uint32_t value)
{
  10087e:	55                   	push   %ebp
  10087f:	89 e5                	mov    %esp,%ebp

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  100881:	9c                   	pushf  
  100882:	fa                   	cli    
  100883:	59                   	pop    %ecx
  100884:	80 e5 02             	and    $0x2,%ch

	/* lock interrupts to ensure indirect addressing works "atomically" */

	key = irq_lock();

	*(volatile char *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_IND) = (char)offset;
  100887:	a2 00 00 c0 fe       	mov    %al,0xfec00000
	*((volatile uint32_t *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_DATA)) = value;
  10088c:	89 15 10 00 c0 fe    	mov    %edx,0xfec00010
  100892:	74 01                	je     100895 <__IoApicSet+0x17>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  100894:	fb                   	sti    

	irq_unlock(key);
}
  100895:	5d                   	pop    %ebp
  100896:	c3                   	ret    

00100897 <_IoApicRedUpdateLo>:
 * @return N/A
 */
static void _IoApicRedUpdateLo(unsigned int irq,
				uint32_t value,
				uint32_t mask)
{
  100897:	55                   	push   %ebp
 * @param irq INTIN number
 * @return 32 low-order bits
 */
static uint32_t ioApicRedGetLo(unsigned int irq)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
  100898:	8d 44 00 10          	lea    0x10(%eax,%eax,1),%eax
 * @return N/A
 */
static void _IoApicRedUpdateLo(unsigned int irq,
				uint32_t value,
				uint32_t mask)
{
  10089c:	89 e5                	mov    %esp,%ebp
  10089e:	56                   	push   %esi
  10089f:	53                   	push   %ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1008a0:	9c                   	pushf  
  1008a1:	fa                   	cli    
  1008a2:	5e                   	pop    %esi
	/* lock interrupts to ensure indirect addressing works "atomically" */

	key = irq_lock();

	*((volatile char *)
		(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_IND)) = (char)offset;
  1008a3:	a2 00 00 c0 fe       	mov    %al,0xfec00000
  1008a8:	81 e6 00 02 00 00    	and    $0x200,%esi
	value = *((volatile uint32_t *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_DATA));
  1008ae:	8b 1d 10 00 c0 fe    	mov    0xfec00010,%ebx
  1008b4:	74 01                	je     1008b7 <_IoApicRedUpdateLo+0x20>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1008b6:	fb                   	sti    
 */
static void ioApicRedSetLo(unsigned int irq, uint32_t lower32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */

	__IoApicSet(offset, lower32);
  1008b7:	31 da                	xor    %ebx,%edx
  1008b9:	21 ca                	and    %ecx,%edx
  1008bb:	31 da                	xor    %ebx,%edx
static void _IoApicRedUpdateLo(unsigned int irq,
				uint32_t value,
				uint32_t mask)
{
	ioApicRedSetLo(irq, (ioApicRedGetLo(irq) & ~mask) | (value & mask));
}
  1008bd:	5b                   	pop    %ebx
  1008be:	5e                   	pop    %esi
  1008bf:	5d                   	pop    %ebp
 */
static void ioApicRedSetLo(unsigned int irq, uint32_t lower32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */

	__IoApicSet(offset, lower32);
  1008c0:	e9 b9 ff ff ff       	jmp    10087e <__IoApicSet>

001008c5 <_ioapic_init>:
 * This routine initializes the IO APIC or xAPIC.
 *
 * @return N/A
 */
int _ioapic_init(struct device *unused)
{
  1008c5:	55                   	push   %ebp
  1008c6:	89 e5                	mov    %esp,%ebp
  1008c8:	56                   	push   %esi
  1008c9:	53                   	push   %ebx
	 * ((__IoApicGet(IOAPIC_VERS) & IOAPIC_MRE_MASK) >> 16) + 1
	 */
	rteValue = IOAPIC_EDGE | IOAPIC_HIGH | IOAPIC_FIXED | IOAPIC_INT_MASK |
		   IOAPIC_PHYSICAL | 0 /* dummy vector */;

	for (ix = 0; ix < CONFIG_IOAPIC_NUM_RTES; ix++) {
  1008ca:	31 db                	xor    %ebx,%ebx
 * @param upper32 Value to be written
 * @return N/A
 */
static void ioApicRedSetHi(unsigned int irq, uint32_t upper32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
  1008cc:	8d 34 1b             	lea    (%ebx,%ebx,1),%esi

	__IoApicSet(offset, upper32);
  1008cf:	31 d2                	xor    %edx,%edx
	 * ((__IoApicGet(IOAPIC_VERS) & IOAPIC_MRE_MASK) >> 16) + 1
	 */
	rteValue = IOAPIC_EDGE | IOAPIC_HIGH | IOAPIC_FIXED | IOAPIC_INT_MASK |
		   IOAPIC_PHYSICAL | 0 /* dummy vector */;

	for (ix = 0; ix < CONFIG_IOAPIC_NUM_RTES; ix++) {
  1008d1:	43                   	inc    %ebx
 */
static void ioApicRedSetHi(unsigned int irq, uint32_t upper32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */

	__IoApicSet(offset, upper32);
  1008d2:	8d 46 11             	lea    0x11(%esi),%eax
  1008d5:	e8 a4 ff ff ff       	call   10087e <__IoApicSet>
 */
static void ioApicRedSetLo(unsigned int irq, uint32_t lower32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */

	__IoApicSet(offset, lower32);
  1008da:	8d 46 10             	lea    0x10(%esi),%eax
  1008dd:	ba 00 00 01 00       	mov    $0x10000,%edx
  1008e2:	e8 97 ff ff ff       	call   10087e <__IoApicSet>
	 * ((__IoApicGet(IOAPIC_VERS) & IOAPIC_MRE_MASK) >> 16) + 1
	 */
	rteValue = IOAPIC_EDGE | IOAPIC_HIGH | IOAPIC_FIXED | IOAPIC_INT_MASK |
		   IOAPIC_PHYSICAL | 0 /* dummy vector */;

	for (ix = 0; ix < CONFIG_IOAPIC_NUM_RTES; ix++) {
  1008e7:	83 fb 18             	cmp    $0x18,%ebx
  1008ea:	75 e0                	jne    1008cc <_ioapic_init+0x7>
		ioApicRedSetHi(ix, 0);
		ioApicRedSetLo(ix, rteValue);
	}
#endif
	return 0;
}
  1008ec:	5b                   	pop    %ebx
  1008ed:	31 c0                	xor    %eax,%eax
  1008ef:	5e                   	pop    %esi
  1008f0:	5d                   	pop    %ebp
  1008f1:	c3                   	ret    

001008f2 <_ioapic_irq_enable>:
 * @param irq IRQ number to enable
 *
 * @return N/A
 */
void _ioapic_irq_enable(unsigned int irq)
{
  1008f2:	55                   	push   %ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
  1008f3:	b9 00 00 01 00       	mov    $0x10000,%ecx
 * @param irq IRQ number to enable
 *
 * @return N/A
 */
void _ioapic_irq_enable(unsigned int irq)
{
  1008f8:	89 e5                	mov    %esp,%ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
  1008fa:	31 d2                	xor    %edx,%edx
  1008fc:	8b 45 08             	mov    0x8(%ebp),%eax
}
  1008ff:	5d                   	pop    %ebp
 *
 * @return N/A
 */
void _ioapic_irq_enable(unsigned int irq)
{
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
  100900:	e9 92 ff ff ff       	jmp    100897 <_IoApicRedUpdateLo>

00100905 <_ioapic_irq_disable>:
 * @param irq IRQ number to disable
 *
 * @return N/A
 */
void _ioapic_irq_disable(unsigned int irq)
{
  100905:	55                   	push   %ebp
	_IoApicRedUpdateLo(irq, IOAPIC_INT_MASK, IOAPIC_INT_MASK);
  100906:	b9 00 00 01 00       	mov    $0x10000,%ecx
 * @param irq IRQ number to disable
 *
 * @return N/A
 */
void _ioapic_irq_disable(unsigned int irq)
{
  10090b:	89 e5                	mov    %esp,%ebp
	_IoApicRedUpdateLo(irq, IOAPIC_INT_MASK, IOAPIC_INT_MASK);
  10090d:	ba 00 00 01 00       	mov    $0x10000,%edx
  100912:	8b 45 08             	mov    0x8(%ebp),%eax
}
  100915:	5d                   	pop    %ebp
 *
 * @return N/A
 */
void _ioapic_irq_disable(unsigned int irq)
{
	_IoApicRedUpdateLo(irq, IOAPIC_INT_MASK, IOAPIC_INT_MASK);
  100916:	e9 7c ff ff ff       	jmp    100897 <_IoApicRedUpdateLo>

0010091b <_ioapic_irq_set>:
 * @param flags Interrupt flags
 *
 * @return N/A
 */
void _ioapic_irq_set(unsigned int irq, unsigned int vector, uint32_t flags)
{
  10091b:	55                   	push   %ebp
 */
static void ioApicRedSetHi(unsigned int irq, uint32_t upper32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */

	__IoApicSet(offset, upper32);
  10091c:	31 d2                	xor    %edx,%edx
 * @param flags Interrupt flags
 *
 * @return N/A
 */
void _ioapic_irq_set(unsigned int irq, unsigned int vector, uint32_t flags)
{
  10091e:	89 e5                	mov    %esp,%ebp
  100920:	56                   	push   %esi
  100921:	53                   	push   %ebx
  100922:	8b 5d 08             	mov    0x8(%ebp),%ebx
 * @param upper32 Value to be written
 * @return N/A
 */
static void ioApicRedSetHi(unsigned int irq, uint32_t upper32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
  100925:	01 db                	add    %ebx,%ebx
 */
void _ioapic_irq_set(unsigned int irq, unsigned int vector, uint32_t flags)
{
	uint32_t rteValue;   /* value to copy into redirection table entry */

	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
  100927:	0f b6 75 0c          	movzbl 0xc(%ebp),%esi
 */
static void ioApicRedSetHi(unsigned int irq, uint32_t upper32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */

	__IoApicSet(offset, upper32);
  10092b:	8d 43 11             	lea    0x11(%ebx),%eax
 */
void _ioapic_irq_set(unsigned int irq, unsigned int vector, uint32_t flags)
{
	uint32_t rteValue;   /* value to copy into redirection table entry */

	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
  10092e:	0b 75 10             	or     0x10(%ebp),%esi
 */
static void ioApicRedSetHi(unsigned int irq, uint32_t upper32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */

	__IoApicSet(offset, upper32);
  100931:	e8 48 ff ff ff       	call   10087e <__IoApicSet>
 */
void _ioapic_irq_set(unsigned int irq, unsigned int vector, uint32_t flags)
{
	uint32_t rteValue;   /* value to copy into redirection table entry */

	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
  100936:	81 ce 00 00 01 00    	or     $0x10000,%esi
 */
static void ioApicRedSetLo(unsigned int irq, uint32_t lower32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */

	__IoApicSet(offset, lower32);
  10093c:	8d 43 10             	lea    0x10(%ebx),%eax
  10093f:	89 f2                	mov    %esi,%edx

	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
		   (vector & IOAPIC_VEC_MASK) | flags;
	ioApicRedSetHi(irq, 0);
	ioApicRedSetLo(irq, rteValue);
}
  100941:	5b                   	pop    %ebx
  100942:	5e                   	pop    %esi
  100943:	5d                   	pop    %ebp
 */
static void ioApicRedSetLo(unsigned int irq, uint32_t lower32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */

	__IoApicSet(offset, lower32);
  100944:	e9 35 ff ff ff       	jmp    10087e <__IoApicSet>

00100949 <pci_set_command_bits>:
	return 0;
}
#endif /* CONFIG_PCI_ENUMERATION */

static void pci_set_command_bits(struct pci_dev_info *dev_info, uint32_t bits)
{
  100949:	55                   	push   %ebp
  10094a:	89 e5                	mov    %esp,%ebp
  10094c:	56                   	push   %esi
  10094d:	53                   	push   %ebx
  10094e:	51                   	push   %ecx
	union pci_addr_reg pci_ctrl_addr;
	uint32_t pci_data;

	pci_ctrl_addr.value = 0;
	pci_ctrl_addr.field.func = dev_info->function;
	pci_ctrl_addr.field.bus = dev_info->bus;
  10094f:	0f b6 58 0c          	movzbl 0xc(%eax),%ebx
  100953:	c1 e3 10             	shl    $0x10,%ebx
	return 0;
}
#endif /* CONFIG_PCI_ENUMERATION */

static void pci_set_command_bits(struct pci_dev_info *dev_info, uint32_t bits)
{
  100956:	89 d6                	mov    %edx,%esi
	union pci_addr_reg pci_ctrl_addr;
	uint32_t pci_data;

	pci_ctrl_addr.value = 0;
	pci_ctrl_addr.field.func = dev_info->function;
  100958:	8b 50 0c             	mov    0xc(%eax),%edx
	pci_ctrl_addr.field.bus = dev_info->bus;
	pci_ctrl_addr.field.device = dev_info->dev;
  10095b:	8a 40 0d             	mov    0xd(%eax),%al
{
	union pci_addr_reg pci_ctrl_addr;
	uint32_t pci_data;

	pci_ctrl_addr.value = 0;
	pci_ctrl_addr.field.func = dev_info->function;
  10095e:	c1 ea 05             	shr    $0x5,%edx
	pci_ctrl_addr.field.bus = dev_info->bus;
	pci_ctrl_addr.field.device = dev_info->dev;
  100961:	83 e0 1f             	and    $0x1f,%eax
  100964:	c1 e0 0b             	shl    $0xb,%eax
	union pci_addr_reg pci_ctrl_addr;
	uint32_t pci_data;

	pci_ctrl_addr.value = 0;
	pci_ctrl_addr.field.func = dev_info->function;
	pci_ctrl_addr.field.bus = dev_info->bus;
  100967:	81 e2 00 07 00 00    	and    $0x700,%edx
	pci_ctrl_addr.field.device = dev_info->dev;
  10096d:	09 d3                	or     %edx,%ebx
	pci_ctrl_addr.field.reg = 1;
  10096f:	09 c3                	or     %eax,%ebx

#ifdef CONFIG_PCI_DEBUG
	printk("pci_set_command_bits 0x%x\n", pci_ctrl_addr.value);
#endif

	pci_read(DEFAULT_PCI_CONTROLLER,
  100971:	8d 45 f4             	lea    -0xc(%ebp),%eax

	pci_ctrl_addr.value = 0;
	pci_ctrl_addr.field.func = dev_info->function;
	pci_ctrl_addr.field.bus = dev_info->bus;
	pci_ctrl_addr.field.device = dev_info->dev;
	pci_ctrl_addr.field.reg = 1;
  100974:	83 cb 04             	or     $0x4,%ebx

#ifdef CONFIG_PCI_DEBUG
	printk("pci_set_command_bits 0x%x\n", pci_ctrl_addr.value);
#endif

	pci_read(DEFAULT_PCI_CONTROLLER,
  100977:	50                   	push   %eax
  100978:	6a 02                	push   $0x2
  10097a:	53                   	push   %ebx
  10097b:	6a 00                	push   $0x0
  10097d:	e8 6e 06 00 00       	call   100ff0 <pci_read>
  100982:	83 c4 10             	add    $0x10,%esp
			pci_ctrl_addr,
			sizeof(uint16_t),
			&pci_data);

	pci_data = pci_data | bits;
  100985:	0b 75 f4             	or     -0xc(%ebp),%esi

	pci_write(DEFAULT_PCI_CONTROLLER,
  100988:	56                   	push   %esi
  100989:	6a 02                	push   $0x2
  10098b:	53                   	push   %ebx
  10098c:	6a 00                	push   $0x0
	pci_read(DEFAULT_PCI_CONTROLLER,
			pci_ctrl_addr,
			sizeof(uint16_t),
			&pci_data);

	pci_data = pci_data | bits;
  10098e:	89 75 f4             	mov    %esi,-0xc(%ebp)

	pci_write(DEFAULT_PCI_CONTROLLER,
  100991:	e8 ca 06 00 00       	call   101060 <pci_write>
  100996:	83 c4 10             	add    $0x10,%esp
			pci_ctrl_addr,
			sizeof(uint16_t),
			pci_data);
}
  100999:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10099c:	5b                   	pop    %ebx
  10099d:	5e                   	pop    %esi
  10099e:	5d                   	pop    %ebp
  10099f:	c3                   	ret    

001009a0 <pci_bus_scan_init>:
	lookup.info.class_type = 0;
	lookup.info.vendor_id = 0;
	lookup.info.device_id = 0;
	lookup.info.function = PCI_FUNCTION_ANY;
	lookup.info.bar = PCI_BAR_ANY;
	lookup.bus = 0;
  1009a0:	66 81 25 34 7f 10 00 	andw   $0xfe00,0x107f34
  1009a7:	00 fe 
	return 0;
}

void pci_bus_scan_init(void)
{
	lookup.info.class_type = 0;
  1009a9:	66 81 25 2e 7f 10 00 	andw   $0xfc03,0x107f2e
  1009b0:	03 fc 
	lookup.info.vendor_id = 0;
	lookup.info.device_id = 0;
	lookup.info.function = PCI_FUNCTION_ANY;
	lookup.info.bar = PCI_BAR_ANY;
	lookup.bus = 0;
	lookup.dev = 0;
  1009b2:	80 25 35 7f 10 00 81 	andb   $0x81,0x107f35
void pci_bus_scan_init(void)
{
	lookup.info.class_type = 0;
	lookup.info.vendor_id = 0;
	lookup.info.device_id = 0;
	lookup.info.function = PCI_FUNCTION_ANY;
  1009b9:	a1 2c 7f 10 00       	mov    0x107f2c,%eax

	return 0;
}

void pci_bus_scan_init(void)
{
  1009be:	55                   	push   %ebp
	lookup.info.device_id = 0;
	lookup.info.function = PCI_FUNCTION_ANY;
	lookup.info.bar = PCI_BAR_ANY;
	lookup.bus = 0;
	lookup.dev = 0;
	lookup.func = 0;
  1009bf:	81 25 34 7f 10 00 ff 	andl   $0xfff87fff,0x107f34
  1009c6:	7f f8 ff 
void pci_bus_scan_init(void)
{
	lookup.info.class_type = 0;
	lookup.info.vendor_id = 0;
	lookup.info.device_id = 0;
	lookup.info.function = PCI_FUNCTION_ANY;
  1009c9:	25 ff 1f fe ff       	and    $0xfffe1fff,%eax

	return 0;
}

void pci_bus_scan_init(void)
{
  1009ce:	89 e5                	mov    %esp,%ebp
	lookup.info.class_type = 0;
	lookup.info.vendor_id = 0;
	lookup.info.device_id = 0;
	lookup.info.function = PCI_FUNCTION_ANY;
  1009d0:	0d 00 00 01 00       	or     $0x10000,%eax
}

void pci_bus_scan_init(void)
{
	lookup.info.class_type = 0;
	lookup.info.vendor_id = 0;
  1009d5:	66 c7 05 30 7f 10 00 	movw   $0x0,0x107f30
  1009dc:	00 00 
	lookup.info.device_id = 0;
	lookup.info.function = PCI_FUNCTION_ANY;
  1009de:	a3 2c 7f 10 00       	mov    %eax,0x107f2c

void pci_bus_scan_init(void)
{
	lookup.info.class_type = 0;
	lookup.info.vendor_id = 0;
	lookup.info.device_id = 0;
  1009e3:	66 c7 05 32 7f 10 00 	movw   $0x0,0x107f32
  1009ea:	00 00 
	lookup.info.function = PCI_FUNCTION_ANY;
	lookup.info.bar = PCI_BAR_ANY;
  1009ec:	a0 2f 7f 10 00       	mov    0x107f2f,%al
	lookup.bus = 0;
	lookup.dev = 0;
	lookup.func = 0;
	lookup.baridx = 0;
	lookup.barofs = 0;
}
  1009f1:	5d                   	pop    %ebp
	lookup.info.function = PCI_FUNCTION_ANY;
	lookup.info.bar = PCI_BAR_ANY;
	lookup.bus = 0;
	lookup.dev = 0;
	lookup.func = 0;
	lookup.baridx = 0;
  1009f2:	80 25 36 7f 10 00 c7 	andb   $0xc7,0x107f36
{
	lookup.info.class_type = 0;
	lookup.info.vendor_id = 0;
	lookup.info.device_id = 0;
	lookup.info.function = PCI_FUNCTION_ANY;
	lookup.info.bar = PCI_BAR_ANY;
  1009f9:	83 e0 e3             	and    $0xffffffe3,%eax
  1009fc:	83 c8 18             	or     $0x18,%eax
  1009ff:	a2 2f 7f 10 00       	mov    %al,0x107f2f
	lookup.bus = 0;
	lookup.dev = 0;
	lookup.func = 0;
	lookup.baridx = 0;
	lookup.barofs = 0;
  100a04:	66 81 25 36 7f 10 00 	andw   $0xfe3f,0x107f36
  100a0b:	3f fe 
}
  100a0d:	c3                   	ret    

00100a0e <pci_bus_scan>:
 *
 * @return 1 on success, 0 otherwise. On success, dev_info is filled in with
 * currently found device information
 */
int pci_bus_scan(struct pci_dev_info *dev_info)
{
  100a0e:	55                   	push   %ebp
  100a0f:	89 e5                	mov    %esp,%ebp
  100a11:	57                   	push   %edi
  100a12:	56                   	push   %esi
  100a13:	53                   	push   %ebx
  100a14:	83 ec 2c             	sub    $0x2c,%esp

	int init_from_dev_info =
		!lookup.info.class_type &&
		!lookup.info.vendor_id &&
		!lookup.info.device_id &&
		lookup.info.bar == PCI_BAR_ANY &&
  100a17:	66 a1 2e 7f 10 00    	mov    0x107f2e,%ax
 *
 * @return 1 on success, 0 otherwise. On success, dev_info is filled in with
 * currently found device information
 */
int pci_bus_scan(struct pci_dev_info *dev_info)
{
  100a1d:	8b 5d 08             	mov    0x8(%ebp),%ebx

	int init_from_dev_info =
		!lookup.info.class_type &&
		!lookup.info.vendor_id &&
		!lookup.info.device_id &&
		lookup.info.bar == PCI_BAR_ANY &&
  100a20:	66 a9 fc 03          	test   $0x3fc,%ax
  100a24:	75 21                	jne    100a47 <pci_bus_scan+0x39>
{
	union pci_addr_reg pci_ctrl_addr;

	int init_from_dev_info =
		!lookup.info.class_type &&
		!lookup.info.vendor_id &&
  100a26:	83 3d 30 7f 10 00 00 	cmpl   $0x0,0x107f30
  100a2d:	75 18                	jne    100a47 <pci_bus_scan+0x39>
		!lookup.info.device_id &&
		lookup.info.bar == PCI_BAR_ANY &&
  100a2f:	8b 15 2c 7f 10 00    	mov    0x107f2c,%edx
  100a35:	81 e2 00 e0 01 1c    	and    $0x1c01e000,%edx
  100a3b:	81 fa 00 00 01 18    	cmp    $0x18010000,%edx
  100a41:	0f 84 32 05 00 00    	je     100f79 <pci_bus_scan+0x56b>
	}

	/* initialise the PCI controller address register value */
	pci_ctrl_addr.value = 0;

	if (lookup.info.function != PCI_FUNCTION_ANY) {
  100a47:	a1 2c 7f 10 00       	mov    0x107f2c,%eax
		lookup.info.function = dev_info->function;
		lookup.info.bar = dev_info->bar;
	}

	/* initialise the PCI controller address register value */
	pci_ctrl_addr.value = 0;
  100a4c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

	if (lookup.info.function != PCI_FUNCTION_ANY) {
  100a53:	89 c2                	mov    %eax,%edx
  100a55:	81 e2 00 e0 01 00    	and    $0x1e000,%edx
  100a5b:	81 fa 00 00 01 00    	cmp    $0x10000,%edx
  100a61:	0f 84 ec 00 00 00    	je     100b53 <pci_bus_scan+0x145>
		lookup.func = lookup.info.function;
  100a67:	c1 e0 02             	shl    $0x2,%eax
  100a6a:	8b 15 34 7f 10 00    	mov    0x107f34,%edx
  100a70:	25 00 80 07 00       	and    $0x78000,%eax
  100a75:	81 e2 ff 7f f8 ff    	and    $0xfff87fff,%edx
  100a7b:	09 d0                	or     %edx,%eax
  100a7d:	a3 34 7f 10 00       	mov    %eax,0x107f34
  100a82:	e9 cc 00 00 00       	jmp    100b53 <pci_bus_scan+0x145>
	}

	/* run through the buses and devices */
	for (; lookup.bus < LSPCI_MAX_BUS; lookup.bus++) {
		for (; (lookup.dev < LSPCI_MAX_DEV); lookup.dev++) {
			pci_ctrl_addr.field.bus = lookup.bus;
  100a87:	0f b6 15 34 7f 10 00 	movzbl 0x107f34,%edx
  100a8e:	8b 4d dc             	mov    -0x24(%ebp),%ecx
			pci_ctrl_addr.field.device = lookup.dev;
  100a91:	83 e0 1f             	and    $0x1f,%eax
	}

	/* run through the buses and devices */
	for (; lookup.bus < LSPCI_MAX_BUS; lookup.bus++) {
		for (; (lookup.dev < LSPCI_MAX_DEV); lookup.dev++) {
			pci_ctrl_addr.field.bus = lookup.bus;
  100a94:	c1 e2 10             	shl    $0x10,%edx
  100a97:	81 e1 ff 07 00 ff    	and    $0xff0007ff,%ecx
			pci_ctrl_addr.field.device = lookup.dev;
  100a9d:	c1 e0 0b             	shl    $0xb,%eax
  100aa0:	09 ca                	or     %ecx,%edx
  100aa2:	09 c2                	or     %eax,%edx
	int max_bars;

	/* verify first if there is a valid device at this point */
	pci_ctrl_addr.field.func = 0;

	pci_read(DEFAULT_PCI_CONTROLLER,
  100aa4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  100aa7:	89 d7                	mov    %edx,%edi
  100aa9:	50                   	push   %eax
  100aaa:	81 e7 ff f8 ff ff    	and    $0xfffff8ff,%edi
  100ab0:	6a 04                	push   $0x4
  100ab2:	57                   	push   %edi
  100ab3:	6a 00                	push   $0x0

	/* run through the buses and devices */
	for (; lookup.bus < LSPCI_MAX_BUS; lookup.bus++) {
		for (; (lookup.dev < LSPCI_MAX_DEV); lookup.dev++) {
			pci_ctrl_addr.field.bus = lookup.bus;
			pci_ctrl_addr.field.device = lookup.dev;
  100ab5:	89 55 dc             	mov    %edx,-0x24(%ebp)
	int max_bars;

	/* verify first if there is a valid device at this point */
	pci_ctrl_addr.field.func = 0;

	pci_read(DEFAULT_PCI_CONTROLLER,
  100ab8:	e8 33 05 00 00       	call   100ff0 <pci_read>
  100abd:	83 c4 10             	add    $0x10,%esp
			pci_ctrl_addr,
			sizeof(pci_data),
			&pci_data);

	if (pci_data == 0xffffffff) {
  100ac0:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%ebp)
  100ac4:	0f 85 1d 01 00 00    	jne    100be7 <pci_bus_scan+0x1d9>

			if (pci_dev_scan(pci_ctrl_addr, dev_info)) {
				return 1;
			}

			if (lookup.info.function != PCI_FUNCTION_ANY) {
  100aca:	8b 15 2c 7f 10 00    	mov    0x107f2c,%edx
  100ad0:	89 d0                	mov    %edx,%eax
  100ad2:	25 00 e0 01 00       	and    $0x1e000,%eax
  100ad7:	3d 00 00 01 00       	cmp    $0x10000,%eax
  100adc:	a1 34 7f 10 00       	mov    0x107f34,%eax
  100ae1:	0f 84 7d 04 00 00    	je     100f64 <pci_bus_scan+0x556>
				lookup.func = lookup.info.function;
  100ae7:	c1 e2 02             	shl    $0x2,%edx
  100aea:	25 ff 7f f8 ff       	and    $0xfff87fff,%eax
  100aef:	81 e2 00 80 07 00    	and    $0x78000,%edx
  100af5:	09 d0                	or     %edx,%eax
			} else {
				lookup.func = 0;
  100af7:	a3 34 7f 10 00       	mov    %eax,0x107f34
		lookup.func = lookup.info.function;
	}

	/* run through the buses and devices */
	for (; lookup.bus < LSPCI_MAX_BUS; lookup.bus++) {
		for (; (lookup.dev < LSPCI_MAX_DEV); lookup.dev++) {
  100afc:	a0 35 7f 10 00       	mov    0x107f35,%al
  100b01:	88 c2                	mov    %al,%dl
  100b03:	83 e0 81             	and    $0xffffff81,%eax
  100b06:	d0 ea                	shr    %dl
  100b08:	8d 54 12 02          	lea    0x2(%edx,%edx,1),%edx
  100b0c:	83 e2 7e             	and    $0x7e,%edx
  100b0f:	09 d0                	or     %edx,%eax
  100b11:	a2 35 7f 10 00       	mov    %al,0x107f35
  100b16:	8a 15 35 7f 10 00    	mov    0x107f35,%dl
  100b1c:	88 d0                	mov    %dl,%al
  100b1e:	d0 e8                	shr    %al
  100b20:	83 e0 3f             	and    $0x3f,%eax
  100b23:	83 f8 1f             	cmp    $0x1f,%eax
  100b26:	0f 8e 5b ff ff ff    	jle    100a87 <pci_bus_scan+0x79>
				lookup.func = lookup.info.function;
			} else {
				lookup.func = 0;
			}
		}
		lookup.dev = 0;
  100b2c:	88 d0                	mov    %dl,%al
  100b2e:	83 e0 81             	and    $0xffffff81,%eax
  100b31:	a2 35 7f 10 00       	mov    %al,0x107f35
	if (lookup.info.function != PCI_FUNCTION_ANY) {
		lookup.func = lookup.info.function;
	}

	/* run through the buses and devices */
	for (; lookup.bus < LSPCI_MAX_BUS; lookup.bus++) {
  100b36:	8b 0d 34 7f 10 00    	mov    0x107f34,%ecx
  100b3c:	8d 41 01             	lea    0x1(%ecx),%eax
  100b3f:	66 25 ff 01          	and    $0x1ff,%ax
  100b43:	89 c2                	mov    %eax,%edx
  100b45:	89 c8                	mov    %ecx,%eax
  100b47:	66 25 00 fe          	and    $0xfe00,%ax
  100b4b:	09 d0                	or     %edx,%eax
  100b4d:	66 a3 34 7f 10 00    	mov    %ax,0x107f34
  100b53:	a1 34 7f 10 00       	mov    0x107f34,%eax
  100b58:	25 ff 01 00 00       	and    $0x1ff,%eax
  100b5d:	48                   	dec    %eax
  100b5e:	7e b6                	jle    100b16 <pci_bus_scan+0x108>
  100b60:	e9 09 04 00 00       	jmp    100f6e <pci_bus_scan+0x560>
	}

	/* scan all the possible functions for this device */
	for (; lookup.func < LSPCI_MAX_FUNC;
	     lookup.baridx = 0, lookup.barofs = 0, lookup.func++) {
		if (lookup.info.function != PCI_FUNCTION_ANY &&
  100b65:	8b 15 2c 7f 10 00    	mov    0x107f2c,%edx
  100b6b:	89 d6                	mov    %edx,%esi
  100b6d:	81 e6 00 e0 01 00    	and    $0x1e000,%esi
  100b73:	81 fe 00 00 01 00    	cmp    $0x10000,%esi
  100b79:	0f 85 89 00 00 00    	jne    100c08 <pci_bus_scan+0x1fa>
		    lookup.func != lookup.info.function) {
			return 0;
		}

		pci_ctrl_addr.field.func = lookup.func;
  100b7f:	83 e0 07             	and    $0x7,%eax

		if (lookup.func != 0) {
  100b82:	81 e1 00 80 07 00    	and    $0x78000,%ecx
		if (lookup.info.function != PCI_FUNCTION_ANY &&
		    lookup.func != lookup.info.function) {
			return 0;
		}

		pci_ctrl_addr.field.func = lookup.func;
  100b88:	89 c6                	mov    %eax,%esi

		if (lookup.func != 0) {
  100b8a:	0f 84 8b 00 00 00    	je     100c1b <pci_bus_scan+0x20d>
			pci_read(DEFAULT_PCI_CONTROLLER,
  100b90:	89 f0                	mov    %esi,%eax
  100b92:	81 e7 ff f8 ff ff    	and    $0xfffff8ff,%edi
  100b98:	83 e0 07             	and    $0x7,%eax
  100b9b:	c1 e0 08             	shl    $0x8,%eax
  100b9e:	09 c7                	or     %eax,%edi
  100ba0:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  100ba3:	50                   	push   %eax
  100ba4:	6a 04                	push   $0x4
  100ba6:	57                   	push   %edi
  100ba7:	6a 00                	push   $0x0
  100ba9:	e8 42 04 00 00       	call   100ff0 <pci_read>
  100bae:	83 c4 10             	add    $0x10,%esp
					pci_ctrl_addr,
					sizeof(pci_data),
					&pci_data);

			if (pci_data == 0xffffffff) {
  100bb1:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%ebp)
  100bb5:	75 64                	jne    100c1b <pci_bus_scan+0x20d>
		return 0;
	}

	/* scan all the possible functions for this device */
	for (; lookup.func < LSPCI_MAX_FUNC;
	     lookup.baridx = 0, lookup.barofs = 0, lookup.func++) {
  100bb7:	80 25 36 7f 10 00 c7 	andb   $0xc7,0x107f36
  100bbe:	66 81 25 36 7f 10 00 	andw   $0xfe3f,0x107f36
  100bc5:	3f fe 
  100bc7:	8b 15 34 7f 10 00    	mov    0x107f34,%edx
  100bcd:	89 d0                	mov    %edx,%eax
  100bcf:	81 e2 ff 7f f8 ff    	and    $0xfff87fff,%edx
  100bd5:	c1 e8 0f             	shr    $0xf,%eax
  100bd8:	40                   	inc    %eax
  100bd9:	83 e0 0f             	and    $0xf,%eax
  100bdc:	c1 e0 0f             	shl    $0xf,%eax
  100bdf:	09 c2                	or     %eax,%edx
  100be1:	89 15 34 7f 10 00    	mov    %edx,0x107f34
	if (pci_data == 0xffffffff) {
		return 0;
	}

	/* scan all the possible functions for this device */
	for (; lookup.func < LSPCI_MAX_FUNC;
  100be7:	8b 0d 34 7f 10 00    	mov    0x107f34,%ecx
  100bed:	89 ce                	mov    %ecx,%esi
  100bef:	c1 ee 0f             	shr    $0xf,%esi
  100bf2:	89 f0                	mov    %esi,%eax
  100bf4:	83 e0 0f             	and    $0xf,%eax
  100bf7:	0f b6 d0             	movzbl %al,%edx
  100bfa:	83 fa 07             	cmp    $0x7,%edx
  100bfd:	0f 8e 62 ff ff ff    	jle    100b65 <pci_bus_scan+0x157>
  100c03:	e9 c2 fe ff ff       	jmp    100aca <pci_bus_scan+0xbc>
	     lookup.baridx = 0, lookup.barofs = 0, lookup.func++) {
		if (lookup.info.function != PCI_FUNCTION_ANY &&
		    lookup.func != lookup.info.function) {
  100c08:	c1 ea 0d             	shr    $0xd,%edx
  100c0b:	83 e2 0f             	and    $0xf,%edx
	}

	/* scan all the possible functions for this device */
	for (; lookup.func < LSPCI_MAX_FUNC;
	     lookup.baridx = 0, lookup.barofs = 0, lookup.func++) {
		if (lookup.info.function != PCI_FUNCTION_ANY &&
  100c0e:	38 c2                	cmp    %al,%dl
  100c10:	0f 84 69 ff ff ff    	je     100b7f <pci_bus_scan+0x171>
  100c16:	e9 af fe ff ff       	jmp    100aca <pci_bus_scan+0xbc>
				continue;
			}
		}

		/* get the PCI header from the device */
		pci_header_get(DEFAULT_PCI_CONTROLLER,
  100c1b:	89 f0                	mov    %esi,%eax
  100c1d:	81 e7 ff f8 ff ff    	and    $0xfffff8ff,%edi
  100c23:	83 e0 07             	and    $0x7,%eax
  100c26:	68 60 72 10 00       	push   $0x107260
  100c2b:	c1 e0 08             	shl    $0x8,%eax
  100c2e:	09 c7                	or     %eax,%edi
  100c30:	57                   	push   %edi
  100c31:	6a 00                	push   $0x0
  100c33:	e8 92 04 00 00       	call   1010ca <pci_header_get>

		/*
		 * Skip a device if its class is specified by the
		 * caller and does not match
		 */
		if (lookup.info.class_type &&
  100c38:	66 a1 2e 7f 10 00    	mov    0x107f2e,%ax
				continue;
			}
		}

		/* get the PCI header from the device */
		pci_header_get(DEFAULT_PCI_CONTROLLER,
  100c3e:	83 c4 0c             	add    $0xc,%esp

		/*
		 * Skip a device if its class is specified by the
		 * caller and does not match
		 */
		if (lookup.info.class_type &&
  100c41:	66 a9 fc 03          	test   $0x3fc,%ax
  100c45:	74 10                	je     100c57 <pci_bus_scan+0x249>
		    pci_dev_header.field.class != lookup.info.class_type) {
  100c47:	66 c1 e8 02          	shr    $0x2,%ax

		/*
		 * Skip a device if its class is specified by the
		 * caller and does not match
		 */
		if (lookup.info.class_type &&
  100c4b:	38 05 6b 72 10 00    	cmp    %al,0x10726b
  100c51:	0f 85 60 ff ff ff    	jne    100bb7 <pci_bus_scan+0x1a9>
		    pci_dev_header.field.class != lookup.info.class_type) {
			continue;
		}

		if (lookup.info.vendor_id && lookup.info.device_id &&
  100c57:	66 83 3d 30 7f 10 00 	cmpw   $0x0,0x107f30
  100c5e:	00 
  100c5f:	74 1b                	je     100c7c <pci_bus_scan+0x26e>
  100c61:	66 83 3d 32 7f 10 00 	cmpw   $0x0,0x107f32
  100c68:	00 
  100c69:	74 11                	je     100c7c <pci_bus_scan+0x26e>
  100c6b:	a1 60 72 10 00       	mov    0x107260,%eax
  100c70:	39 05 30 7f 10 00    	cmp    %eax,0x107f30
  100c76:	0f 85 3b ff ff ff    	jne    100bb7 <pci_bus_scan+0x1a9>
		    lookup.info.device_id != pci_dev_header.field.device_id)) {
			continue;
		}

		/* Get memory and interrupt information */
		if ((pci_dev_header.field.hdr_type & 0x7f) == 1) {
  100c7c:	a0 6e 72 10 00       	mov    0x10726e,%al
  100c81:	83 e0 7f             	and    $0x7f,%eax
			max_bars = 2;
		} else {
			max_bars = PCI_MAX_BARS;
  100c84:	fe c8                	dec    %al
  100c86:	0f 95 c0             	setne  %al
  100c89:	0f b6 c0             	movzbl %al,%eax
  100c8c:	8d 04 85 02 00 00 00 	lea    0x2(,%eax,4),%eax
  100c93:	89 45 e0             	mov    %eax,-0x20(%ebp)
  100c96:	89 f0                	mov    %esi,%eax
  100c98:	83 e0 07             	and    $0x7,%eax
  100c9b:	89 45 c8             	mov    %eax,-0x38(%ebp)
		}

		for (; lookup.barofs < max_bars;
  100c9e:	66 a1 36 7f 10 00    	mov    0x107f36,%ax
  100ca4:	66 c1 e8 06          	shr    $0x6,%ax
  100ca8:	83 e0 07             	and    $0x7,%eax
  100cab:	0f b6 d0             	movzbl %al,%edx
  100cae:	3b 55 e0             	cmp    -0x20(%ebp),%edx
  100cb1:	0f 8d 00 ff ff ff    	jge    100bb7 <pci_bus_scan+0x1a9>
	uint32_t bar_config;
	uint32_t bar_hival;
	uint32_t addr;
	uint32_t mask;

	pci_ctrl_addr.field.reg = 4 + lookup.barofs;
  100cb7:	83 c0 04             	add    $0x4,%eax
  100cba:	8b 55 c8             	mov    -0x38(%ebp),%edx
  100cbd:	c1 e2 08             	shl    $0x8,%edx
  100cc0:	81 e7 ff f8 ff ff    	and    $0xfffff8ff,%edi
  100cc6:	88 45 cc             	mov    %al,-0x34(%ebp)
  100cc9:	09 d7                	or     %edx,%edi

	pci_read(DEFAULT_PCI_CONTROLLER,
  100ccb:	8b 45 cc             	mov    -0x34(%ebp),%eax
  100cce:	89 fe                	mov    %edi,%esi
  100cd0:	83 e0 0f             	and    $0xf,%eax
  100cd3:	81 e6 03 f8 ff ff    	and    $0xfffff803,%esi
  100cd9:	c1 e0 02             	shl    $0x2,%eax
  100cdc:	09 c6                	or     %eax,%esi
  100cde:	8d 45 e8             	lea    -0x18(%ebp),%eax
  100ce1:	09 d6                	or     %edx,%esi
  100ce3:	50                   	push   %eax
  100ce4:	6a 04                	push   $0x4
  100ce6:	56                   	push   %esi
  100ce7:	6a 00                	push   $0x0
  100ce9:	e8 02 03 00 00       	call   100ff0 <pci_read>
  100cee:	83 c4 10             	add    $0x10,%esp
							uint32_t *config)
{
	uint32_t old_value;

	/* save the current setting */
	pci_read(DEFAULT_PCI_CONTROLLER,
  100cf1:	8d 45 f0             	lea    -0x10(%ebp),%eax
  100cf4:	50                   	push   %eax
  100cf5:	6a 04                	push   $0x4
  100cf7:	56                   	push   %esi
  100cf8:	6a 00                	push   $0x0
  100cfa:	e8 f1 02 00 00       	call   100ff0 <pci_read>
  100cff:	83 c4 10             	add    $0x10,%esp
			pci_ctrl_addr,
			sizeof(old_value),
			&old_value);

	/* write to the BAR to see how large it is */
	pci_write(DEFAULT_PCI_CONTROLLER,
  100d02:	6a ff                	push   $0xffffffff
  100d04:	6a 04                	push   $0x4
  100d06:	56                   	push   %esi
  100d07:	6a 00                	push   $0x0
  100d09:	e8 52 03 00 00       	call   101060 <pci_write>
  100d0e:	83 c4 10             	add    $0x10,%esp
			pci_ctrl_addr,
			sizeof(uint32_t),
			0xffffffff);

	pci_read(DEFAULT_PCI_CONTROLLER,
  100d11:	8d 45 ec             	lea    -0x14(%ebp),%eax
  100d14:	50                   	push   %eax
  100d15:	6a 04                	push   $0x4
  100d17:	56                   	push   %esi
  100d18:	6a 00                	push   $0x0
  100d1a:	e8 d1 02 00 00       	call   100ff0 <pci_read>
  100d1f:	83 c4 10             	add    $0x10,%esp
			pci_ctrl_addr,
			sizeof(*config),
			config);

	/* put back the old configuration */
	pci_write(DEFAULT_PCI_CONTROLLER,
  100d22:	ff 75 f0             	pushl  -0x10(%ebp)
  100d25:	6a 04                	push   $0x4
  100d27:	56                   	push   %esi
  100d28:	6a 00                	push   $0x0
  100d2a:	e8 31 03 00 00       	call   101060 <pci_write>
			pci_ctrl_addr,
			sizeof(old_value),
			old_value);

	/* check if this BAR is implemented */
	if (*config != 0xffffffff && *config != 0) {
  100d2f:	8b 55 ec             	mov    -0x14(%ebp),%edx
			pci_ctrl_addr,
			sizeof(*config),
			config);

	/* put back the old configuration */
	pci_write(DEFAULT_PCI_CONTROLLER,
  100d32:	83 c4 10             	add    $0x10,%esp

	pci_read(DEFAULT_PCI_CONTROLLER,
			pci_ctrl_addr,
			sizeof(bar_value),
			&bar_value);
	if (pci_bar_config_get(pci_ctrl_addr, &bar_config) != 0) {
  100d35:	8d 42 ff             	lea    -0x1(%edx),%eax
  100d38:	83 f8 fd             	cmp    $0xfffffffd,%eax
  100d3b:	0f 87 de 01 00 00    	ja     100f1f <pci_bus_scan+0x511>
		return -1;
	}

	if (BAR_SPACE(bar_config) == BAR_SPACE_MEM) {
  100d41:	f6 c2 01             	test   $0x1,%dl
  100d44:	8a 43 0e             	mov    0xe(%ebx),%al
  100d47:	75 76                	jne    100dbf <pci_bus_scan+0x3b1>
		dev_info->mem_type = BAR_SPACE_MEM;
  100d49:	83 e0 fd             	and    $0xfffffffd,%eax
		mask = ~0xf;
		if (BAR_TYPE(bar_config) == BAR_TYPE_64BIT) {
  100d4c:	83 e2 06             	and    $0x6,%edx
	if (pci_bar_config_get(pci_ctrl_addr, &bar_config) != 0) {
		return -1;
	}

	if (BAR_SPACE(bar_config) == BAR_SPACE_MEM) {
		dev_info->mem_type = BAR_SPACE_MEM;
  100d4f:	88 43 0e             	mov    %al,0xe(%ebx)
		mask = ~0xf;
		if (BAR_TYPE(bar_config) == BAR_TYPE_64BIT) {
  100d52:	83 fa 04             	cmp    $0x4,%edx
  100d55:	74 07                	je     100d5e <pci_bus_scan+0x350>
		return -1;
	}

	if (BAR_SPACE(bar_config) == BAR_SPACE_MEM) {
		dev_info->mem_type = BAR_SPACE_MEM;
		mask = ~0xf;
  100d57:	b9 f0 ff ff ff       	mov    $0xfffffff0,%ecx
  100d5c:	eb 6c                	jmp    100dca <pci_bus_scan+0x3bc>
		if (BAR_TYPE(bar_config) == BAR_TYPE_64BIT) {
			/* Last BAR register cannot be 64-bit */
			if (++lookup.barofs >= max_bars)
  100d5e:	66 8b 0d 36 7f 10 00 	mov    0x107f36,%cx
  100d65:	89 c8                	mov    %ecx,%eax
  100d67:	66 c1 e8 06          	shr    $0x6,%ax
  100d6b:	66 81 e1 3f fe       	and    $0xfe3f,%cx
  100d70:	40                   	inc    %eax
  100d71:	83 e0 07             	and    $0x7,%eax
  100d74:	89 c2                	mov    %eax,%edx
  100d76:	83 e2 07             	and    $0x7,%edx
  100d79:	c1 e2 06             	shl    $0x6,%edx
  100d7c:	09 ca                	or     %ecx,%edx
  100d7e:	0f b6 c0             	movzbl %al,%eax
  100d81:	66 89 15 36 7f 10 00 	mov    %dx,0x107f36
  100d88:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  100d8b:	0f 8e 8e 01 00 00    	jle    100f1f <pci_bus_scan+0x511>
				return 1;

			/* Make sure the address is accessible */
			pci_ctrl_addr.field.reg++;
			pci_read(DEFAULT_PCI_CONTROLLER,
  100d91:	8a 45 cc             	mov    -0x34(%ebp),%al
  100d94:	81 e6 03 ff ff ff    	and    $0xffffff03,%esi
  100d9a:	40                   	inc    %eax
  100d9b:	83 e0 1f             	and    $0x1f,%eax
  100d9e:	c1 e0 02             	shl    $0x2,%eax
  100da1:	09 c6                	or     %eax,%esi
  100da3:	8d 45 f0             	lea    -0x10(%ebp),%eax
  100da6:	50                   	push   %eax
  100da7:	6a 04                	push   $0x4
  100da9:	56                   	push   %esi
  100daa:	6a 00                	push   $0x0
  100dac:	e8 3f 02 00 00       	call   100ff0 <pci_read>
  100db1:	83 c4 10             	add    $0x10,%esp
				 pci_ctrl_addr,
				 sizeof(bar_hival),
				 &bar_hival);
			if (bar_hival)
  100db4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  100db8:	74 9d                	je     100d57 <pci_bus_scan+0x349>
  100dba:	e9 60 01 00 00       	jmp    100f1f <pci_bus_scan+0x511>
				return 1; /* Inaccessible memory */
		}
	} else {
		dev_info->mem_type = BAR_SPACE_IO;
  100dbf:	83 c8 02             	or     $0x2,%eax
		mask = ~0x3;
  100dc2:	b9 fc ff ff ff       	mov    $0xfffffffc,%ecx
				 &bar_hival);
			if (bar_hival)
				return 1; /* Inaccessible memory */
		}
	} else {
		dev_info->mem_type = BAR_SPACE_IO;
  100dc7:	88 43 0e             	mov    %al,0xe(%ebx)
		mask = ~0x3;
	}

	dev_info->addr = bar_value & mask;
  100dca:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100dcd:	21 c8                	and    %ecx,%eax

	addr = bar_config & mask;
	if (addr != 0) {
  100dcf:	23 4d ec             	and    -0x14(%ebp),%ecx
	} else {
		dev_info->mem_type = BAR_SPACE_IO;
		mask = ~0x3;
	}

	dev_info->addr = bar_value & mask;
  100dd2:	89 03                	mov    %eax,(%ebx)

	addr = bar_config & mask;
	if (addr != 0) {
  100dd4:	74 14                	je     100dea <pci_bus_scan+0x3dc>

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
	unsigned int bitpos;

	__asm__ volatile (
  100dd6:	0f bc c9             	bsf    %ecx,%ecx
  100dd9:	75 05                	jne    100de0 <pci_bus_scan+0x3d2>
  100ddb:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
		/* calculate the size of the BAR memory required */
		dev_info->size = 1 << (find_lsb_set(addr) - 1);
  100de0:	b8 01 00 00 00       	mov    $0x1,%eax
  100de5:	d3 e0                	shl    %cl,%eax
  100de7:	89 43 04             	mov    %eax,0x4(%ebx)
		     lookup.baridx++, lookup.barofs++) {
			/* Ignore BARs with errors */
			if (pci_bar_params_get(pci_ctrl_addr, dev_info,
					       max_bars) != 0) {
				continue;
			} else if (lookup.info.bar != PCI_BAR_ANY &&
  100dea:	a0 2f 7f 10 00       	mov    0x107f2f,%al
  100def:	88 c2                	mov    %al,%dl
  100df1:	83 e2 1c             	and    $0x1c,%edx
  100df4:	80 fa 18             	cmp    $0x18,%dl
  100df7:	75 63                	jne    100e5c <pci_bus_scan+0x44e>
				   lookup.baridx != lookup.info.bar) {
				continue;
			} else {
				dev_info->bus = lookup.bus;
  100df9:	a1 34 7f 10 00       	mov    0x107f34,%eax
				dev_info->dev = lookup.dev;
  100dfe:	8a 4b 0d             	mov    0xd(%ebx),%cl
				continue;
			} else if (lookup.info.bar != PCI_BAR_ANY &&
				   lookup.baridx != lookup.info.bar) {
				continue;
			} else {
				dev_info->bus = lookup.bus;
  100e01:	66 25 ff 01          	and    $0x1ff,%ax
				dev_info->dev = lookup.dev;
  100e05:	83 e1 e0             	and    $0xffffffe0,%ecx
				continue;
			} else if (lookup.info.bar != PCI_BAR_ANY &&
				   lookup.baridx != lookup.info.bar) {
				continue;
			} else {
				dev_info->bus = lookup.bus;
  100e08:	88 c2                	mov    %al,%dl
  100e0a:	88 43 0c             	mov    %al,0xc(%ebx)
				dev_info->dev = lookup.dev;
  100e0d:	a0 35 7f 10 00       	mov    0x107f35,%al
 */

static inline int pci_pin2irq(int bus, int dev, int pin)
{
	if (bus < 0 || bus > 1) {
		return -1;
  100e12:	83 ce ff             	or     $0xffffffff,%esi
  100e15:	d0 e8                	shr    %al
  100e17:	83 e0 1f             	and    $0x1f,%eax
  100e1a:	09 c8                	or     %ecx,%eax
				dev_info->vendor_id =
					pci_dev_header.field.vendor_id;
				dev_info->device_id =
					pci_dev_header.field.device_id;
				dev_info->class_type =
  100e1c:	66 8b 4b 0e          	mov    0xe(%ebx),%cx
  100e20:	66 81 e1 03 fc       	and    $0xfc03,%cx
			} else if (lookup.info.bar != PCI_BAR_ANY &&
				   lookup.baridx != lookup.info.bar) {
				continue;
			} else {
				dev_info->bus = lookup.bus;
				dev_info->dev = lookup.dev;
  100e25:	88 43 0d             	mov    %al,0xd(%ebx)
				dev_info->vendor_id =
  100e28:	a1 60 72 10 00       	mov    0x107260,%eax
  100e2d:	66 89 43 10          	mov    %ax,0x10(%ebx)
					pci_dev_header.field.vendor_id;
				dev_info->device_id =
  100e31:	66 a1 62 72 10 00    	mov    0x107262,%ax
  100e37:	66 89 43 12          	mov    %ax,0x12(%ebx)
					pci_dev_header.field.device_id;
				dev_info->class_type =
  100e3b:	0f b6 05 6b 72 10 00 	movzbl 0x10726b,%eax
  100e42:	c1 e0 02             	shl    $0x2,%eax
  100e45:	09 c8                	or     %ecx,%eax
 *
 */

static inline int pci_pin2irq(int bus, int dev, int pin)
{
	if (bus < 0 || bus > 1) {
  100e47:	80 fa 01             	cmp    $0x1,%dl
  100e4a:	66 89 43 0e          	mov    %ax,0xe(%ebx)
					pci_dev_header.field.class;
				dev_info->irq = pci_pin2irq(dev_info->bus,
  100e4e:	0f b6 05 9d 72 10 00 	movzbl 0x10729d,%eax
  100e55:	0f b6 ca             	movzbl %dl,%ecx
  100e58:	76 1e                	jbe    100e78 <pci_bus_scan+0x46a>
  100e5a:	eb 2d                	jmp    100e89 <pci_bus_scan+0x47b>
			/* Ignore BARs with errors */
			if (pci_bar_params_get(pci_ctrl_addr, dev_info,
					       max_bars) != 0) {
				continue;
			} else if (lookup.info.bar != PCI_BAR_ANY &&
				   lookup.baridx != lookup.info.bar) {
  100e5c:	c0 e8 02             	shr    $0x2,%al
  100e5f:	8a 15 36 7f 10 00    	mov    0x107f36,%dl
  100e65:	c0 ea 03             	shr    $0x3,%dl
  100e68:	83 e0 07             	and    $0x7,%eax
  100e6b:	83 e2 07             	and    $0x7,%edx
		     lookup.baridx++, lookup.barofs++) {
			/* Ignore BARs with errors */
			if (pci_bar_params_get(pci_ctrl_addr, dev_info,
					       max_bars) != 0) {
				continue;
			} else if (lookup.info.bar != PCI_BAR_ANY &&
  100e6e:	38 c2                	cmp    %al,%dl
  100e70:	0f 85 a9 00 00 00    	jne    100f1f <pci_bus_scan+0x511>
  100e76:	eb 81                	jmp    100df9 <pci_bus_scan+0x3eb>
		return -1;
	}
	if ((pin < PCI_INTA) || (pin > PCI_INTD)) {
  100e78:	48                   	dec    %eax
 */

static inline int pci_pin2irq(int bus, int dev, int pin)
{
	if (bus < 0 || bus > 1) {
		return -1;
  100e79:	83 ce ff             	or     $0xffffffff,%esi
	}
	if ((pin < PCI_INTA) || (pin > PCI_INTD)) {
  100e7c:	83 f8 03             	cmp    $0x3,%eax
  100e7f:	77 08                	ja     100e89 <pci_bus_scan+0x47b>
		return -1;
	}
	return NUM_STD_IRQS + ((pin - 1 + bus) & 3);
  100e81:	01 c8                	add    %ecx,%eax
  100e83:	83 e0 03             	and    $0x3,%eax
  100e86:	8d 70 10             	lea    0x10(%eax),%esi
				dev_info->class_type =
					pci_dev_header.field.class;
				dev_info->irq = pci_pin2irq(dev_info->bus,
					dev_info->dev,
					pci_dev_header.field.interrupt_pin);
				dev_info->function = lookup.func;
  100e89:	a1 34 7f 10 00       	mov    0x107f34,%eax
  100e8e:	8b 53 0c             	mov    0xc(%ebx),%edx
  100e91:	c1 e8 02             	shr    $0x2,%eax
  100e94:	81 e2 ff 1f fe ff    	and    $0xfffe1fff,%edx
  100e9a:	25 00 e0 01 00       	and    $0x1e000,%eax
					pci_dev_header.field.vendor_id;
				dev_info->device_id =
					pci_dev_header.field.device_id;
				dev_info->class_type =
					pci_dev_header.field.class;
				dev_info->irq = pci_pin2irq(dev_info->bus,
  100e9f:	89 73 08             	mov    %esi,0x8(%ebx)
					dev_info->dev,
					pci_dev_header.field.interrupt_pin);
				dev_info->function = lookup.func;
  100ea2:	09 d0                	or     %edx,%eax
  100ea4:	89 43 0c             	mov    %eax,0xc(%ebx)
				dev_info->bar = lookup.baridx;
  100ea7:	a0 36 7f 10 00       	mov    0x107f36,%al
  100eac:	8a 4b 0f             	mov    0xf(%ebx),%cl
  100eaf:	c0 e8 03             	shr    $0x3,%al
  100eb2:	83 e1 e3             	and    $0xffffffe3,%ecx
  100eb5:	83 e0 07             	and    $0x7,%eax
  100eb8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx

				lookup.baridx++;
  100ebf:	8d 04 c5 08 00 00 00 	lea    0x8(,%eax,8),%eax
					pci_dev_header.field.class;
				dev_info->irq = pci_pin2irq(dev_info->bus,
					dev_info->dev,
					pci_dev_header.field.interrupt_pin);
				dev_info->function = lookup.func;
				dev_info->bar = lookup.baridx;
  100ec6:	09 ca                	or     %ecx,%edx

				lookup.baridx++;
  100ec8:	83 e0 38             	and    $0x38,%eax
					pci_dev_header.field.class;
				dev_info->irq = pci_pin2irq(dev_info->bus,
					dev_info->dev,
					pci_dev_header.field.interrupt_pin);
				dev_info->function = lookup.func;
				dev_info->bar = lookup.baridx;
  100ecb:	88 53 0f             	mov    %dl,0xf(%ebx)

				lookup.baridx++;
  100ece:	8a 15 36 7f 10 00    	mov    0x107f36,%dl
  100ed4:	83 e2 c7             	and    $0xffffffc7,%edx
  100ed7:	09 d0                	or     %edx,%eax
  100ed9:	a2 36 7f 10 00       	mov    %al,0x107f36
				lookup.barofs++;
  100ede:	66 8b 15 36 7f 10 00 	mov    0x107f36,%dx
  100ee5:	89 d0                	mov    %edx,%eax
  100ee7:	66 c1 e8 06          	shr    $0x6,%ax
  100eeb:	66 81 e2 3f fe       	and    $0xfe3f,%dx
  100ef0:	40                   	inc    %eax
  100ef1:	83 e0 07             	and    $0x7,%eax
  100ef4:	89 c1                	mov    %eax,%ecx
  100ef6:	83 e1 07             	and    $0x7,%ecx
  100ef9:	c1 e1 06             	shl    $0x6,%ecx
  100efc:	09 ca                	or     %ecx,%edx
				if (lookup.barofs >= max_bars) {
  100efe:	0f b6 c0             	movzbl %al,%eax
					pci_dev_header.field.interrupt_pin);
				dev_info->function = lookup.func;
				dev_info->bar = lookup.baridx;

				lookup.baridx++;
				lookup.barofs++;
  100f01:	66 89 15 36 7f 10 00 	mov    %dx,0x107f36
				if (lookup.barofs >= max_bars) {
  100f08:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  100f0b:	7c 65                	jl     100f72 <pci_bus_scan+0x564>
					lookup.baridx = 0;
  100f0d:	80 25 36 7f 10 00 c7 	andb   $0xc7,0x107f36
					lookup.barofs = 0;
  100f14:	66 81 25 36 7f 10 00 	andw   $0xfe3f,0x107f36
  100f1b:	3f fe 
  100f1d:	eb 53                	jmp    100f72 <pci_bus_scan+0x564>
		} else {
			max_bars = PCI_MAX_BARS;
		}

		for (; lookup.barofs < max_bars;
		     lookup.baridx++, lookup.barofs++) {
  100f1f:	8a 15 36 7f 10 00    	mov    0x107f36,%dl
  100f25:	88 d0                	mov    %dl,%al
  100f27:	83 e2 c7             	and    $0xffffffc7,%edx
  100f2a:	c0 e8 03             	shr    $0x3,%al
  100f2d:	8d 04 c5 08 00 00 00 	lea    0x8(,%eax,8),%eax
  100f34:	83 e0 38             	and    $0x38,%eax
  100f37:	09 d0                	or     %edx,%eax
  100f39:	a2 36 7f 10 00       	mov    %al,0x107f36
  100f3e:	66 8b 15 36 7f 10 00 	mov    0x107f36,%dx
  100f45:	89 d0                	mov    %edx,%eax
  100f47:	66 c1 e8 06          	shr    $0x6,%ax
  100f4b:	66 81 e2 3f fe       	and    $0xfe3f,%dx
  100f50:	40                   	inc    %eax
  100f51:	83 e0 07             	and    $0x7,%eax
  100f54:	c1 e0 06             	shl    $0x6,%eax
  100f57:	09 d0                	or     %edx,%eax
  100f59:	66 a3 36 7f 10 00    	mov    %ax,0x107f36
  100f5f:	e9 3a fd ff ff       	jmp    100c9e <pci_bus_scan+0x290>
			}

			if (lookup.info.function != PCI_FUNCTION_ANY) {
				lookup.func = lookup.info.function;
			} else {
				lookup.func = 0;
  100f64:	25 ff 7f f8 ff       	and    $0xfff87fff,%eax
  100f69:	e9 89 fb ff ff       	jmp    100af7 <pci_bus_scan+0xe9>
			}
		}
		lookup.dev = 0;
	}

	return 0;
  100f6e:	31 c0                	xor    %eax,%eax
  100f70:	eb 65                	jmp    100fd7 <pci_bus_scan+0x5c9>
		for (; (lookup.dev < LSPCI_MAX_DEV); lookup.dev++) {
			pci_ctrl_addr.field.bus = lookup.bus;
			pci_ctrl_addr.field.device = lookup.dev;

			if (pci_dev_scan(pci_ctrl_addr, dev_info)) {
				return 1;
  100f72:	b8 01 00 00 00       	mov    $0x1,%eax
  100f77:	eb 5e                	jmp    100fd7 <pci_bus_scan+0x5c9>
		!lookup.info.device_id &&
		lookup.info.bar == PCI_BAR_ANY &&
		lookup.info.function == PCI_FUNCTION_ANY;

	if (init_from_dev_info) {
		lookup.info.class_type = dev_info->class_type;
  100f79:	66 25 03 fc          	and    $0xfc03,%ax
  100f7d:	66 8b 53 0e          	mov    0xe(%ebx),%dx
  100f81:	66 81 e2 fc 03       	and    $0x3fc,%dx
  100f86:	09 d0                	or     %edx,%eax
  100f88:	66 a3 2e 7f 10 00    	mov    %ax,0x107f2e
		lookup.info.vendor_id = dev_info->vendor_id;
  100f8e:	8b 43 10             	mov    0x10(%ebx),%eax
		lookup.info.device_id = dev_info->device_id;
		lookup.info.function = dev_info->function;
  100f91:	8b 15 2c 7f 10 00    	mov    0x107f2c,%edx
		lookup.info.bar == PCI_BAR_ANY &&
		lookup.info.function == PCI_FUNCTION_ANY;

	if (init_from_dev_info) {
		lookup.info.class_type = dev_info->class_type;
		lookup.info.vendor_id = dev_info->vendor_id;
  100f97:	66 a3 30 7f 10 00    	mov    %ax,0x107f30
		lookup.info.device_id = dev_info->device_id;
  100f9d:	66 8b 43 12          	mov    0x12(%ebx),%ax
  100fa1:	66 a3 32 7f 10 00    	mov    %ax,0x107f32
		lookup.info.function = dev_info->function;
  100fa7:	8b 43 0c             	mov    0xc(%ebx),%eax
  100faa:	81 e2 ff 1f fe ff    	and    $0xfffe1fff,%edx
  100fb0:	25 00 e0 01 00       	and    $0x1e000,%eax
  100fb5:	09 d0                	or     %edx,%eax
  100fb7:	a3 2c 7f 10 00       	mov    %eax,0x107f2c
		lookup.info.bar = dev_info->bar;
  100fbc:	8a 43 0f             	mov    0xf(%ebx),%al
  100fbf:	8a 15 2f 7f 10 00    	mov    0x107f2f,%dl
  100fc5:	83 e0 1c             	and    $0x1c,%eax
  100fc8:	83 e2 e3             	and    $0xffffffe3,%edx
  100fcb:	09 d0                	or     %edx,%eax
  100fcd:	a2 2f 7f 10 00       	mov    %al,0x107f2f
  100fd2:	e9 70 fa ff ff       	jmp    100a47 <pci_bus_scan+0x39>
		}
		lookup.dev = 0;
	}

	return 0;
}
  100fd7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  100fda:	5b                   	pop    %ebx
  100fdb:	5e                   	pop    %esi
  100fdc:	5f                   	pop    %edi
  100fdd:	5d                   	pop    %ebp
  100fde:	c3                   	ret    

00100fdf <pci_enable_regs>:
			sizeof(uint16_t),
			pci_data);
}

void pci_enable_regs(struct pci_dev_info *dev_info)
{
  100fdf:	55                   	push   %ebp
	pci_set_command_bits(dev_info, PCI_CMD_MEM_ENABLE);
  100fe0:	ba 02 00 00 00       	mov    $0x2,%edx
			sizeof(uint16_t),
			pci_data);
}

void pci_enable_regs(struct pci_dev_info *dev_info)
{
  100fe5:	89 e5                	mov    %esp,%ebp
	pci_set_command_bits(dev_info, PCI_CMD_MEM_ENABLE);
  100fe7:	8b 45 08             	mov    0x8(%ebp),%eax
}
  100fea:	5d                   	pop    %ebp
			pci_data);
}

void pci_enable_regs(struct pci_dev_info *dev_info)
{
	pci_set_command_bits(dev_info, PCI_CMD_MEM_ENABLE);
  100feb:	e9 59 f9 ff ff       	jmp    100949 <pci_set_command_bits>

00100ff0 <pci_read>:
 *
 */

void pci_read(uint32_t controller, union pci_addr_reg addr,
	      uint32_t size, uint32_t *data)
{
  100ff0:	55                   	push   %ebp
  100ff1:	89 e5                	mov    %esp,%ebp
  100ff3:	56                   	push   %esi
  100ff4:	53                   	push   %ebx
  100ff5:	8b 55 10             	mov    0x10(%ebp),%edx
  100ff8:	8b 45 0c             	mov    0xc(%ebp),%eax
  100ffb:	8b 5d 14             	mov    0x14(%ebp),%ebx
	uint32_t access_size;
	uint32_t access_offset;

	/* validate the access size */

	switch (size) {
  100ffe:	83 fa 01             	cmp    $0x1,%edx
  101001:	74 11                	je     101014 <pci_read+0x24>
  101003:	83 fa 02             	cmp    $0x2,%edx
  101006:	75 15                	jne    10101d <pci_read+0x2d>
		access_size = SYS_PCI_ACCESS_8BIT;
		access_offset = addr.field.offset;
		break;
	case 2:
		access_size = SYS_PCI_ACCESS_16BIT;
		access_offset = addr.field.offset;
  101008:	89 c1                	mov    %eax,%ecx
	case 1:
		access_size = SYS_PCI_ACCESS_8BIT;
		access_offset = addr.field.offset;
		break;
	case 2:
		access_size = SYS_PCI_ACCESS_16BIT;
  10100a:	be 01 00 00 00       	mov    $0x1,%esi
		access_offset = addr.field.offset;
  10100f:	83 e1 03             	and    $0x3,%ecx
		break;
  101012:	eb 10                	jmp    101024 <pci_read+0x34>
	/* validate the access size */

	switch (size) {
	case 1:
		access_size = SYS_PCI_ACCESS_8BIT;
		access_offset = addr.field.offset;
  101014:	89 c1                	mov    %eax,%ecx

	/* validate the access size */

	switch (size) {
	case 1:
		access_size = SYS_PCI_ACCESS_8BIT;
  101016:	31 f6                	xor    %esi,%esi
		access_offset = addr.field.offset;
  101018:	83 e1 03             	and    $0x3,%ecx
		break;
  10101b:	eb 07                	jmp    101024 <pci_read+0x34>
		access_offset = addr.field.offset;
		break;
	case 4:
	default:
		access_size = SYS_PCI_ACCESS_32BIT;
		access_offset = 0;
  10101d:	31 c9                	xor    %ecx,%ecx
		access_size = SYS_PCI_ACCESS_16BIT;
		access_offset = addr.field.offset;
		break;
	case 4:
	default:
		access_size = SYS_PCI_ACCESS_32BIT;
  10101f:	be 03 00 00 00       	mov    $0x3,%esi
		break;
	}

	/* ensure enable has been set */

	addr.field.enable = 1;
  101024:	0d 00 00 00 80       	or     $0x80000000,%eax

	/* clear the offset for the address register */

	addr.field.offset = 0;
  101029:	83 e0 fc             	and    $0xfffffffc,%eax
static int pci_ctrl_addr_write(uint32_t controller, uint32_t offset,
			       uint32_t data, uint32_t size)
{
	/* we only support one controller */

	if (controller != DEFAULT_PCI_CONTROLLER) {
  10102c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  101030:	75 2a                	jne    10105c <pci_read+0x6c>


static ALWAYS_INLINE
	void sys_out32(uint32_t data, io_port_t port)
{
	__asm__ volatile("outl	%0, %w1;\n\t"
  101032:	ba f8 0c 00 00       	mov    $0xcf8,%edx
  101037:	ef                   	out    %eax,(%dx)

	if (controller != DEFAULT_PCI_CONTROLLER) {
		return (-1);
	}

	pci_ctrl_read(PCI_CTRL_DATA_REG + offset, data, size);
  101038:	8d 91 fc 0c 00 00    	lea    0xcfc(%ecx),%edx

static void pci_ctrl_read(uint32_t reg, uint32_t *data, uint32_t size)
{
	/* read based on the size requested */

	switch (size) {
  10103e:	83 fe 01             	cmp    $0x1,%esi
  101041:	74 0a                	je     10104d <pci_read+0x5d>
  101043:	72 11                	jb     101056 <pci_read+0x66>
  101045:	83 fe 03             	cmp    $0x3,%esi
  101048:	75 12                	jne    10105c <pci_read+0x6c>
static ALWAYS_INLINE
	uint32_t sys_in32(io_port_t port)
{
	uint32_t ret;

	__asm__ volatile("inl	%w1, %0;\n\t"
  10104a:	ed                   	in     (%dx),%eax
  10104b:	eb 05                	jmp    101052 <pci_read+0x62>
static ALWAYS_INLINE
	uint16_t sys_in16(io_port_t port)
{
	uint16_t ret;

	__asm__ volatile("inw	%w1, %w0;\n\t"
  10104d:	66 ed                	in     (%dx),%ax
	case SYS_PCI_ACCESS_32BIT:
		*data = sys_in32(reg);
		break;
		/* word (16 bits) */
	case SYS_PCI_ACCESS_16BIT:
		*data = sys_in16(reg);
  10104f:	0f b7 c0             	movzwl %ax,%eax
  101052:	89 03                	mov    %eax,(%ebx)
  101054:	eb 06                	jmp    10105c <pci_read+0x6c>
static ALWAYS_INLINE
	uint8_t sys_in8(io_port_t port)
{
	uint8_t ret;

	__asm__ volatile("inb	%w1, %b0;\n\t"
  101056:	ec                   	in     (%dx),%al
		break;
		/* byte (8 bits) */
	case SYS_PCI_ACCESS_8BIT:
		*data = sys_in8(reg);
  101057:	0f b6 d0             	movzbl %al,%edx
  10105a:	89 13                	mov    %edx,(%ebx)

	pci_ctrl_addr_write(
		controller, PCI_NO_OFFSET, addr.value, SYS_PCI_ACCESS_32BIT);

	pci_ctrl_data_read(controller, access_offset, data, access_size);
}
  10105c:	5b                   	pop    %ebx
  10105d:	5e                   	pop    %esi
  10105e:	5d                   	pop    %ebp
  10105f:	c3                   	ret    

00101060 <pci_write>:
 *
 */

void pci_write(uint32_t controller, union pci_addr_reg addr,
	       uint32_t size, uint32_t data)
{
  101060:	55                   	push   %ebp
  101061:	89 e5                	mov    %esp,%ebp
  101063:	53                   	push   %ebx
  101064:	8b 55 10             	mov    0x10(%ebp),%edx
  101067:	8b 45 0c             	mov    0xc(%ebp),%eax
	uint32_t access_size;
	uint32_t access_offset;

	/* validate the access size */

	switch (size) {
  10106a:	83 fa 01             	cmp    $0x1,%edx
  10106d:	74 11                	je     101080 <pci_write+0x20>
  10106f:	83 fa 02             	cmp    $0x2,%edx
  101072:	75 15                	jne    101089 <pci_write+0x29>
		access_size = SYS_PCI_ACCESS_8BIT;
		access_offset = addr.field.offset;
		break;
	case 2:
		access_size = SYS_PCI_ACCESS_16BIT;
		access_offset = addr.field.offset;
  101074:	89 c1                	mov    %eax,%ecx
	case 1:
		access_size = SYS_PCI_ACCESS_8BIT;
		access_offset = addr.field.offset;
		break;
	case 2:
		access_size = SYS_PCI_ACCESS_16BIT;
  101076:	bb 01 00 00 00       	mov    $0x1,%ebx
		access_offset = addr.field.offset;
  10107b:	83 e1 03             	and    $0x3,%ecx
		break;
  10107e:	eb 10                	jmp    101090 <pci_write+0x30>
	/* validate the access size */

	switch (size) {
	case 1:
		access_size = SYS_PCI_ACCESS_8BIT;
		access_offset = addr.field.offset;
  101080:	89 c1                	mov    %eax,%ecx

	/* validate the access size */

	switch (size) {
	case 1:
		access_size = SYS_PCI_ACCESS_8BIT;
  101082:	31 db                	xor    %ebx,%ebx
		access_offset = addr.field.offset;
  101084:	83 e1 03             	and    $0x3,%ecx
		break;
  101087:	eb 07                	jmp    101090 <pci_write+0x30>
		access_offset = addr.field.offset;
		break;
	case 4:
	default:
		access_size = SYS_PCI_ACCESS_32BIT;
		access_offset = 0;
  101089:	31 c9                	xor    %ecx,%ecx
		access_size = SYS_PCI_ACCESS_16BIT;
		access_offset = addr.field.offset;
		break;
	case 4:
	default:
		access_size = SYS_PCI_ACCESS_32BIT;
  10108b:	bb 03 00 00 00       	mov    $0x3,%ebx
		break;
	}

	/* ensure enable has been set */

	addr.field.enable = 1;
  101090:	0d 00 00 00 80       	or     $0x80000000,%eax

	/* clear the offset for the address register */

	addr.field.offset = 0;
  101095:	83 e0 fc             	and    $0xfffffffc,%eax
static int pci_ctrl_addr_write(uint32_t controller, uint32_t offset,
			       uint32_t data, uint32_t size)
{
	/* we only support one controller */

	if (controller != DEFAULT_PCI_CONTROLLER) {
  101098:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10109c:	75 29                	jne    1010c7 <pci_write+0x67>


static ALWAYS_INLINE
	void sys_out32(uint32_t data, io_port_t port)
{
	__asm__ volatile("outl	%0, %w1;\n\t"
  10109e:	ba f8 0c 00 00       	mov    $0xcf8,%edx
  1010a3:	ef                   	out    %eax,(%dx)

	if (controller != DEFAULT_PCI_CONTROLLER) {
		return (-1);
	}

	pci_ctrl_write(PCI_CTRL_DATA_REG + offset, data, size);
  1010a4:	8d 91 fc 0c 00 00    	lea    0xcfc(%ecx),%edx

static void pci_ctrl_write(uint32_t reg, uint32_t data, uint32_t size)
{
	/* write based on the size requested */

	switch (size) {
  1010aa:	83 fb 01             	cmp    $0x1,%ebx
  1010ad:	74 0d                	je     1010bc <pci_write+0x5c>
  1010af:	72 12                	jb     1010c3 <pci_write+0x63>
  1010b1:	83 fb 03             	cmp    $0x3,%ebx
  1010b4:	75 11                	jne    1010c7 <pci_write+0x67>
  1010b6:	8b 45 14             	mov    0x14(%ebp),%eax
  1010b9:	ef                   	out    %eax,(%dx)
  1010ba:	eb 0b                	jmp    1010c7 <pci_write+0x67>


static ALWAYS_INLINE
	void sys_out16(uint16_t data, io_port_t port)
{
	__asm__ volatile("outw	%w0, %w1;\n\t"
  1010bc:	8b 45 14             	mov    0x14(%ebp),%eax
  1010bf:	66 ef                	out    %ax,(%dx)
  1010c1:	eb 04                	jmp    1010c7 <pci_write+0x67>
/* Implementation of sys_io.h's documented functions */

static ALWAYS_INLINE
void sys_out8(uint8_t data, io_port_t port)
{
	__asm__ volatile("outb	%b0, %w1;\n\t"
  1010c3:	8a 45 14             	mov    0x14(%ebp),%al
  1010c6:	ee                   	out    %al,(%dx)
	/* write the data to the PCI controller */

	pci_ctrl_addr_write(
		controller, PCI_NO_OFFSET, addr.value, SYS_PCI_ACCESS_32BIT);
	pci_ctrl_data_write(controller, access_offset, data, access_size);
}
  1010c7:	5b                   	pop    %ebx
  1010c8:	5d                   	pop    %ebp
  1010c9:	c3                   	ret    

001010ca <pci_header_get>:
 */

void pci_header_get(uint32_t controller,
		    union pci_addr_reg pci_ctrl_addr,
		    union pci_dev *pci_dev_header)
{
  1010ca:	55                   	push   %ebp
  1010cb:	89 e5                	mov    %esp,%ebp
  1010cd:	57                   	push   %edi
  1010ce:	56                   	push   %esi
  1010cf:	53                   	push   %ebx
  1010d0:	8b 5d 10             	mov    0x10(%ebp),%ebx
	uint32_t i;

	/* clear out the header */

	memset(pci_dev_header, 0, sizeof(*pci_dev_header));
  1010d3:	68 00 01 00 00       	push   $0x100
  1010d8:	6a 00                	push   $0x0
  1010da:	53                   	push   %ebx
 */

void pci_header_get(uint32_t controller,
		    union pci_addr_reg pci_ctrl_addr,
		    union pci_dev *pci_dev_header)
{
  1010db:	8b 75 0c             	mov    0xc(%ebp),%esi

	memset(pci_dev_header, 0, sizeof(*pci_dev_header));

	/* fill in the PCI header from the device */

	for (i = 0; i < PCI_HEADER_WORDS; i++) {
  1010de:	31 ff                	xor    %edi,%edi
{
	uint32_t i;

	/* clear out the header */

	memset(pci_dev_header, 0, sizeof(*pci_dev_header));
  1010e0:	e8 c8 1b 00 00       	call   102cad <memset>
  1010e5:	83 c4 0c             	add    $0xc,%esp

	/* fill in the PCI header from the device */

	for (i = 0; i < PCI_HEADER_WORDS; i++) {
		pci_ctrl_addr.field.reg = i;
  1010e8:	89 f8                	mov    %edi,%eax
  1010ea:	81 e6 03 ff ff ff    	and    $0xffffff03,%esi
  1010f0:	83 e0 3f             	and    $0x3f,%eax
		pci_read(controller,
  1010f3:	53                   	push   %ebx
	memset(pci_dev_header, 0, sizeof(*pci_dev_header));

	/* fill in the PCI header from the device */

	for (i = 0; i < PCI_HEADER_WORDS; i++) {
		pci_ctrl_addr.field.reg = i;
  1010f4:	c1 e0 02             	shl    $0x2,%eax
		pci_read(controller,
  1010f7:	6a 04                	push   $0x4
	memset(pci_dev_header, 0, sizeof(*pci_dev_header));

	/* fill in the PCI header from the device */

	for (i = 0; i < PCI_HEADER_WORDS; i++) {
		pci_ctrl_addr.field.reg = i;
  1010f9:	09 c6                	or     %eax,%esi

	memset(pci_dev_header, 0, sizeof(*pci_dev_header));

	/* fill in the PCI header from the device */

	for (i = 0; i < PCI_HEADER_WORDS; i++) {
  1010fb:	47                   	inc    %edi
		pci_ctrl_addr.field.reg = i;
		pci_read(controller,
  1010fc:	56                   	push   %esi
  1010fd:	83 c3 04             	add    $0x4,%ebx
  101100:	ff 75 08             	pushl  0x8(%ebp)
  101103:	e8 e8 fe ff ff       	call   100ff0 <pci_read>
  101108:	83 c4 10             	add    $0x10,%esp

	memset(pci_dev_header, 0, sizeof(*pci_dev_header));

	/* fill in the PCI header from the device */

	for (i = 0; i < PCI_HEADER_WORDS; i++) {
  10110b:	83 ff 40             	cmp    $0x40,%edi
  10110e:	75 d8                	jne    1010e8 <pci_header_get+0x1e>
		pci_read(controller,
			pci_ctrl_addr,
			sizeof(uint32_t),
			&pci_dev_header->words.word[i]);
	}
}
  101110:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101113:	5b                   	pop    %ebx
  101114:	5e                   	pop    %esi
  101115:	5f                   	pop    %edi
  101116:	5d                   	pop    %ebp
  101117:	c3                   	ret    

00101118 <pci_legacy_bridge_detect>:
 *
 * @return 0 if legacy bridge is detected and -1 otherwise
 */

int pci_legacy_bridge_detect(struct pci_dev_info *dev_info)
{
  101118:	55                   	push   %ebp
  101119:	89 e5                	mov    %esp,%ebp
  10111b:	53                   	push   %ebx
  10111c:	83 ec 10             	sub    $0x10,%esp
	pci_ctrl_addr.field.device = CONFIG_PCI_LEGACY_BRIDGE_DEV;

	/* verify first if there is a valid device at this point */
	pci_ctrl_addr.field.func = 0;

	pci_read(DEFAULT_PCI_CONTROLLER,
  10111f:	8d 45 ec             	lea    -0x14(%ebp),%eax
 *
 * @return 0 if legacy bridge is detected and -1 otherwise
 */

int pci_legacy_bridge_detect(struct pci_dev_info *dev_info)
{
  101122:	8b 5d 08             	mov    0x8(%ebp),%ebx
	pci_ctrl_addr.field.device = CONFIG_PCI_LEGACY_BRIDGE_DEV;

	/* verify first if there is a valid device at this point */
	pci_ctrl_addr.field.func = 0;

	pci_read(DEFAULT_PCI_CONTROLLER,
  101125:	50                   	push   %eax
  101126:	6a 04                	push   $0x4
  101128:	68 00 f8 00 00       	push   $0xf800
  10112d:	6a 00                	push   $0x0
  10112f:	e8 bc fe ff ff       	call   100ff0 <pci_read>
  101134:	83 c4 10             	add    $0x10,%esp
			pci_ctrl_addr,
			sizeof(pci_data),
			&pci_data);

	if (pci_data == 0xffffffff) {
  101137:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
  10113b:	75 08                	jne    101145 <pci_legacy_bridge_detect+0x2d>
		return -1;
  10113d:	83 c8 ff             	or     $0xffffffff,%eax
  101140:	e9 05 01 00 00       	jmp    10124a <pci_legacy_bridge_detect+0x132>
	}

	/* get the PCI header from the device */
	pci_header_get(DEFAULT_PCI_CONTROLLER,
  101145:	68 60 73 10 00       	push   $0x107360
  10114a:	68 00 f8 00 00       	push   $0xf800
  10114f:	6a 00                	push   $0x0
  101151:	e8 74 ff ff ff       	call   1010ca <pci_header_get>
  101156:	83 c4 0c             	add    $0xc,%esp
		       pci_ctrl_addr,
		       &pci_dev_header);

	if (pci_dev_header.field.vendor_id != CONFIG_PCI_LEGACY_BRIDGE_VENDOR_ID ||
  101159:	81 3d 60 73 10 00 86 	cmpl   $0x95e8086,0x107360
  101160:	80 5e 09 
  101163:	75 d8                	jne    10113d <pci_legacy_bridge_detect+0x25>
	}

	pci_ctrl_addr.field.reg = PCI_LEGACY_BRIDGE_REG;

	/* read RCBA PCI register */
	pci_read(DEFAULT_PCI_CONTROLLER,
  101165:	8d 45 f0             	lea    -0x10(%ebp),%eax
  101168:	50                   	push   %eax
  101169:	6a 04                	push   $0x4
  10116b:	68 f0 f8 00 00       	push   $0xf8f0
  101170:	6a 00                	push   $0x0
  101172:	e8 79 fe ff ff       	call   100ff0 <pci_read>
  101177:	83 c4 10             	add    $0x10,%esp
			     uint32_t *mask)
{
	uint32_t old_value;

	/* save the current setting */
	pci_read(DEFAULT_PCI_CONTROLLER,
  10117a:	8d 45 f8             	lea    -0x8(%ebp),%eax
  10117d:	50                   	push   %eax
  10117e:	6a 04                	push   $0x4
  101180:	68 f0 f8 00 00       	push   $0xf8f0
  101185:	6a 00                	push   $0x0
  101187:	e8 64 fe ff ff       	call   100ff0 <pci_read>
  10118c:	83 c4 10             	add    $0x10,%esp
			pci_ctrl_addr,
			sizeof(old_value),
			&old_value);

	/* write to the RCBA to see how large it is */
	pci_write(DEFAULT_PCI_CONTROLLER,
  10118f:	6a ff                	push   $0xffffffff
  101191:	6a 04                	push   $0x4
  101193:	68 f0 f8 00 00       	push   $0xf8f0
  101198:	6a 00                	push   $0x0
  10119a:	e8 c1 fe ff ff       	call   101060 <pci_write>
  10119f:	83 c4 10             	add    $0x10,%esp
			pci_ctrl_addr,
			sizeof(uint32_t),
			0xffffffff);

	pci_read(DEFAULT_PCI_CONTROLLER,
  1011a2:	8d 45 f4             	lea    -0xc(%ebp),%eax
  1011a5:	50                   	push   %eax
  1011a6:	6a 04                	push   $0x4
  1011a8:	68 f0 f8 00 00       	push   $0xf8f0
  1011ad:	6a 00                	push   $0x0
  1011af:	e8 3c fe ff ff       	call   100ff0 <pci_read>
  1011b4:	83 c4 10             	add    $0x10,%esp
			pci_ctrl_addr,
			sizeof(*mask),
			mask);

	/* put back the old configuration */
	pci_write(DEFAULT_PCI_CONTROLLER,
  1011b7:	ff 75 f8             	pushl  -0x8(%ebp)
  1011ba:	6a 04                	push   $0x4
  1011bc:	68 f0 f8 00 00       	push   $0xf8f0
  1011c1:	6a 00                	push   $0x0
  1011c3:	e8 98 fe ff ff       	call   101060 <pci_write>
			pci_ctrl_addr,
			sizeof(old_value),
			old_value);

	/* check if this RCBA is implemented */
	if (*mask != 0xffffffff && *mask != 0) {
  1011c8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
			pci_ctrl_addr,
			sizeof(*mask),
			mask);

	/* put back the old configuration */
	pci_write(DEFAULT_PCI_CONTROLLER,
  1011cb:	83 c4 10             	add    $0x10,%esp
			pci_ctrl_addr,
			sizeof(old_value),
			old_value);

	/* check if this RCBA is implemented */
	if (*mask != 0xffffffff && *mask != 0) {
  1011ce:	8d 41 ff             	lea    -0x1(%ecx),%eax
  1011d1:	83 f8 fd             	cmp    $0xfffffffd,%eax
  1011d4:	0f 87 63 ff ff ff    	ja     10113d <pci_legacy_bridge_detect+0x25>
		/* clear the least address unrelated bit */
		*mask &= ~0x01;
  1011da:	83 e1 fe             	and    $0xfffffffe,%ecx

	if (pci_rcba_mask_get(pci_ctrl_addr, &rcba_mask) != 0) {
		return -1;
	}

	dev_info->addr = rcba & rcba_mask;
  1011dd:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1011e0:	21 ca                	and    %ecx,%edx

	/* check if this RCBA is implemented */
	if (*mask != 0xffffffff && *mask != 0) {
		/* clear the least address unrelated bit */
		*mask &= ~0x01;
		return 0;
  1011e2:	31 c0                	xor    %eax,%eax

	if (pci_rcba_mask_get(pci_ctrl_addr, &rcba_mask) != 0) {
		return -1;
	}

	dev_info->addr = rcba & rcba_mask;
  1011e4:	89 13                	mov    %edx,(%ebx)
	if (dev_info->addr != 0) {
  1011e6:	85 d2                	test   %edx,%edx
  1011e8:	74 14                	je     1011fe <pci_legacy_bridge_detect+0xe6>

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
	unsigned int bitpos;

	__asm__ volatile (
  1011ea:	0f bc c9             	bsf    %ecx,%ecx
  1011ed:	75 05                	jne    1011f4 <pci_legacy_bridge_detect+0xdc>
  1011ef:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
		/* calculate the size of the root complex memory required */
		dev_info->size = 1 << (find_lsb_set(rcba_mask) - 1);
  1011f4:	ba 01 00 00 00       	mov    $0x1,%edx
  1011f9:	d3 e2                	shl    %cl,%edx
  1011fb:	89 53 04             	mov    %edx,0x4(%ebx)
	}

	dev_info->irq = -1;
	dev_info->bus = CONFIG_PCI_LEGACY_BRIDGE_BUS;
	dev_info->dev = CONFIG_PCI_LEGACY_BRIDGE_DEV;
  1011fe:	80 4b 0d 1f          	orb    $0x1f,0xd(%ebx)
		/* calculate the size of the root complex memory required */
		dev_info->size = 1 << (find_lsb_set(rcba_mask) - 1);
	}

	dev_info->irq = -1;
	dev_info->bus = CONFIG_PCI_LEGACY_BRIDGE_BUS;
  101202:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
	if (dev_info->addr != 0) {
		/* calculate the size of the root complex memory required */
		dev_info->size = 1 << (find_lsb_set(rcba_mask) - 1);
	}

	dev_info->irq = -1;
  101206:	c7 43 08 ff ff ff ff 	movl   $0xffffffff,0x8(%ebx)
	dev_info->bus = CONFIG_PCI_LEGACY_BRIDGE_BUS;
	dev_info->dev = CONFIG_PCI_LEGACY_BRIDGE_DEV;
	dev_info->function = 0;
  10120d:	81 63 0c ff 1f fe ff 	andl   $0xfffe1fff,0xc(%ebx)
	dev_info->mem_type = BAR_SPACE_MEM;
  101214:	80 63 0e fd          	andb   $0xfd,0xe(%ebx)
	dev_info->class_type = pci_dev_header.field.class;
  101218:	0f b6 15 6b 73 10 00 	movzbl 0x10736b,%edx
  10121f:	c1 e2 02             	shl    $0x2,%edx
  101222:	66 8b 4b 0e          	mov    0xe(%ebx),%cx
  101226:	66 81 e1 03 fc       	and    $0xfc03,%cx
  10122b:	09 ca                	or     %ecx,%edx
  10122d:	66 89 53 0e          	mov    %dx,0xe(%ebx)
	dev_info->bar = 0;
  101231:	80 63 0f e3          	andb   $0xe3,0xf(%ebx)
	dev_info->vendor_id = pci_dev_header.field.vendor_id;
  101235:	8b 15 60 73 10 00    	mov    0x107360,%edx
  10123b:	66 89 53 10          	mov    %dx,0x10(%ebx)
	dev_info->device_id = pci_dev_header.field.device_id;
  10123f:	66 8b 15 62 73 10 00 	mov    0x107362,%dx
  101246:	66 89 53 12          	mov    %dx,0x12(%ebx)

	return 0;
}
  10124a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10124d:	c9                   	leave  
  10124e:	c3                   	ret    

0010124f <pci_legacy_bridge_configure>:
 */
void pci_legacy_bridge_configure(struct pci_dev_info *dev_info,
				 int io_block_num,
				 int pci_interrupt_pin,
				 int irq_number)
{
  10124f:	55                   	push   %ebp
  101250:	89 e5                	mov    %esp,%ebp
  101252:	57                   	push   %edi
  101253:	56                   	push   %esi
  101254:	53                   	push   %ebx
	uint32_t addr = (io_block_num == 0) ? PCI_ADDR_IRQAGENT1 :
  101255:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
	 *            0-7, which corresponds IRQ 16 - IRQ 23
	 * Bits 11:8  indicates which IRQ is used for INTC.
	 * Bits 7:4   indicates which IRQ is used for INTB.
	 * Bits 3:0   indicates which IRQ is used for INTA.
	 */
	int offset = (pci_interrupt_pin - 1) * 4;
  101259:	8b 55 10             	mov    0x10(%ebp),%edx
 */
void pci_legacy_bridge_configure(struct pci_dev_info *dev_info,
				 int io_block_num,
				 int pci_interrupt_pin,
				 int irq_number)
{
  10125c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint32_t addr = (io_block_num == 0) ? PCI_ADDR_IRQAGENT1 :
  10125f:	19 c0                	sbb    %eax,%eax
  101261:	83 e0 fc             	and    $0xfffffffc,%eax
	 *            0-7, which corresponds IRQ 16 - IRQ 23
	 * Bits 11:8  indicates which IRQ is used for INTC.
	 * Bits 7:4   indicates which IRQ is used for INTB.
	 * Bits 3:0   indicates which IRQ is used for INTA.
	 */
	int offset = (pci_interrupt_pin - 1) * 4;
  101264:	8d 0c 95 fc ff ff ff 	lea    -0x4(,%edx,4),%ecx
void pci_legacy_bridge_configure(struct pci_dev_info *dev_info,
				 int io_block_num,
				 int pci_interrupt_pin,
				 int irq_number)
{
	uint32_t addr = (io_block_num == 0) ? PCI_ADDR_IRQAGENT1 :
  10126b:	05 46 31 00 00       	add    $0x3146,%eax
{
	uint16_t ret;

	__asm__ volatile("movw	%1, %0;\n\t"
			 : "=r"(ret)
			 : "m" (*(volatile uint16_t *) addr)
  101270:	8b 13                	mov    (%ebx),%edx
  101272:	01 c2                	add    %eax,%edx
static ALWAYS_INLINE
	uint16_t sys_read16(mm_reg_t addr)
{
	uint16_t ret;

	__asm__ volatile("movw	%1, %0;\n\t"
  101274:	66 8b 3a             	mov    (%edx),%di
	 */
	int offset = (pci_interrupt_pin - 1) * 4;
	uint16_t irq_routing = sys_read16(dev_info->addr + addr);

	irq_routing &= ~(0x0f << offset);
	irq_routing |= (irq_number - NUM_STD_IRQS) << offset;
  101277:	be 0f 00 00 00       	mov    $0xf,%esi
static ALWAYS_INLINE
	void sys_write16(uint16_t data, mm_reg_t addr)
{
	__asm__ volatile("movw	%0, %1;\n\t"
			 :
			 : "r"(data), "m" (*(volatile uint16_t *) addr)
  10127c:	03 03                	add    (%ebx),%eax
  10127e:	d3 e6                	shl    %cl,%esi
  101280:	f7 d6                	not    %esi
  101282:	21 fe                	and    %edi,%esi
  101284:	8b 7d 14             	mov    0x14(%ebp),%edi
  101287:	8d 57 f0             	lea    -0x10(%edi),%edx
  10128a:	d3 e2                	shl    %cl,%edx
  10128c:	09 f2                	or     %esi,%edx
}

static ALWAYS_INLINE
	void sys_write16(uint16_t data, mm_reg_t addr)
{
	__asm__ volatile("movw	%0, %1;\n\t"
  10128e:	66 89 10             	mov    %dx,(%eax)
	sys_write16(irq_routing, dev_info->addr + addr);
}
  101291:	5b                   	pop    %ebx
  101292:	5e                   	pop    %esi
  101293:	5f                   	pop    %edi
  101294:	5d                   	pop    %ebp
  101295:	c3                   	ret    

00101296 <isr_register>:
 *  @param isr_func Pointer to the ISR function for the device.
 *  @param isr_dev Pointer to the device that will service the interrupt.
 */
static int isr_register(struct device *dev, isr_t isr_func,
				 struct device *isr_dev)
{
  101296:	55                   	push   %ebp
	struct shared_irq_runtime *clients = dev->driver_data;
	const struct shared_irq_config *config = dev->config->config_info;
	uint32_t i;

	for (i = 0; i < config->client_count; i++) {
  101297:	31 d2                	xor    %edx,%edx
 *  @param isr_func Pointer to the ISR function for the device.
 *  @param isr_dev Pointer to the device that will service the interrupt.
 */
static int isr_register(struct device *dev, isr_t isr_func,
				 struct device *isr_dev)
{
  101299:	89 e5                	mov    %esp,%ebp
  10129b:	53                   	push   %ebx
  10129c:	8b 45 08             	mov    0x8(%ebp),%eax
	struct shared_irq_runtime *clients = dev->driver_data;
  10129f:	8b 48 08             	mov    0x8(%eax),%ecx
	const struct shared_irq_config *config = dev->config->config_info;
  1012a2:	8b 00                	mov    (%eax),%eax
	uint32_t i;

	for (i = 0; i < config->client_count; i++) {
  1012a4:	8b 40 08             	mov    0x8(%eax),%eax
  1012a7:	8b 58 08             	mov    0x8(%eax),%ebx
  1012aa:	39 da                	cmp    %ebx,%edx
  1012ac:	74 1d                	je     1012cb <isr_register+0x35>
  1012ae:	6b c2 0c             	imul   $0xc,%edx,%eax
		if (!clients->client[i].isr_dev) {
  1012b1:	83 3c 01 00          	cmpl   $0x0,(%ecx,%eax,1)
  1012b5:	75 11                	jne    1012c8 <isr_register+0x32>
  1012b7:	01 c8                	add    %ecx,%eax
			clients->client[i].isr_dev = isr_dev;
  1012b9:	8b 55 10             	mov    0x10(%ebp),%edx
  1012bc:	89 10                	mov    %edx,(%eax)
			clients->client[i].isr_func = isr_func;
  1012be:	8b 55 0c             	mov    0xc(%ebp),%edx
  1012c1:	89 50 04             	mov    %edx,0x4(%eax)
			return 0;
  1012c4:	31 c0                	xor    %eax,%eax
  1012c6:	eb 08                	jmp    1012d0 <isr_register+0x3a>
{
	struct shared_irq_runtime *clients = dev->driver_data;
	const struct shared_irq_config *config = dev->config->config_info;
	uint32_t i;

	for (i = 0; i < config->client_count; i++) {
  1012c8:	42                   	inc    %edx
  1012c9:	eb df                	jmp    1012aa <isr_register+0x14>
			clients->client[i].isr_dev = isr_dev;
			clients->client[i].isr_func = isr_func;
			return 0;
		}
	}
	return -EIO;
  1012cb:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  1012d0:	5b                   	pop    %ebx
  1012d1:	5d                   	pop    %ebp
  1012d2:	c3                   	ret    

001012d3 <shared_irq_isr>:
	}
	return -EIO;
}

void shared_irq_isr(struct device *dev)
{
  1012d3:	55                   	push   %ebp
  1012d4:	89 e5                	mov    %esp,%ebp
  1012d6:	57                   	push   %edi
  1012d7:	56                   	push   %esi
  1012d8:	53                   	push   %ebx
  1012d9:	8b 45 08             	mov    0x8(%ebp),%eax
	struct shared_irq_runtime *clients = dev->driver_data;
	const struct shared_irq_config *config = dev->config->config_info;
	uint32_t i;

	for (i = 0; i < config->client_count; i++) {
  1012dc:	31 f6                	xor    %esi,%esi
}

void shared_irq_isr(struct device *dev)
{
	struct shared_irq_runtime *clients = dev->driver_data;
	const struct shared_irq_config *config = dev->config->config_info;
  1012de:	8b 10                	mov    (%eax),%edx
  1012e0:	8b 58 08             	mov    0x8(%eax),%ebx
  1012e3:	8b 7a 08             	mov    0x8(%edx),%edi
	uint32_t i;

	for (i = 0; i < config->client_count; i++) {
  1012e6:	3b 77 08             	cmp    0x8(%edi),%esi
  1012e9:	73 11                	jae    1012fc <shared_irq_isr+0x29>
		if (clients->client[i].isr_dev) {
  1012eb:	8b 03                	mov    (%ebx),%eax
  1012ed:	85 c0                	test   %eax,%eax
  1012ef:	74 05                	je     1012f6 <shared_irq_isr+0x23>
			clients->client[i].isr_func(clients->client[i].isr_dev);
  1012f1:	50                   	push   %eax
  1012f2:	ff 53 04             	call   *0x4(%ebx)
  1012f5:	58                   	pop    %eax
{
	struct shared_irq_runtime *clients = dev->driver_data;
	const struct shared_irq_config *config = dev->config->config_info;
	uint32_t i;

	for (i = 0; i < config->client_count; i++) {
  1012f6:	46                   	inc    %esi
  1012f7:	83 c3 0c             	add    $0xc,%ebx
  1012fa:	eb ea                	jmp    1012e6 <shared_irq_isr+0x13>
		if (clients->client[i].isr_dev) {
			clients->client[i].isr_func(clients->client[i].isr_dev);
		}
	}
}
  1012fc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1012ff:	5b                   	pop    %ebx
  101300:	5e                   	pop    %esi
  101301:	5f                   	pop    %edi
  101302:	5d                   	pop    %ebp
  101303:	c3                   	ret    

00101304 <shared_irq_initialize>:
	.disable = disable,
};


int shared_irq_initialize(struct device *dev)
{
  101304:	55                   	push   %ebp
  101305:	89 e5                	mov    %esp,%ebp
  101307:	8b 45 08             	mov    0x8(%ebp),%eax
	const struct shared_irq_config *config = dev->config->config_info;
  10130a:	8b 10                	mov    (%eax),%edx
  10130c:	8b 52 08             	mov    0x8(%edx),%edx

	dev->driver_api = &api_funcs;
  10130f:	c7 40 04 d0 47 10 00 	movl   $0x1047d0,0x4(%eax)
	config->config();
  101316:	ff 52 04             	call   *0x4(%edx)

	return 0;
}
  101319:	31 c0                	xor    %eax,%eax
  10131b:	5d                   	pop    %ebp
  10131c:	c3                   	ret    

0010131d <disable>:
 *  @brief Disable ISR for device
 *  @param dev Pointer to device structure for SHARED_IRQ driver instance.
 *  @param isr_dev Pointer to the device that will service the interrupt.
 */
static inline int disable(struct device *dev, struct device *isr_dev)
{
  10131d:	55                   	push   %ebp
  10131e:	89 e5                	mov    %esp,%ebp
  101320:	57                   	push   %edi
  101321:	56                   	push   %esi
  101322:	53                   	push   %ebx
  101323:	8b 45 08             	mov    0x8(%ebp),%eax
	struct shared_irq_runtime *clients = dev->driver_data;
  101326:	8b 50 08             	mov    0x8(%eax),%edx
	const struct shared_irq_config *config = dev->config->config_info;
  101329:	8b 00                	mov    (%eax),%eax
  10132b:	8b 48 08             	mov    0x8(%eax),%ecx
	uint32_t i;

	for (i = 0; i < config->client_count; i++) {
  10132e:	31 c0                	xor    %eax,%eax
  101330:	8b 59 08             	mov    0x8(%ecx),%ebx
  101333:	39 d8                	cmp    %ebx,%eax
  101335:	74 29                	je     101360 <disable+0x43>
		if (clients->client[i].isr_dev == isr_dev) {
  101337:	6b f0 0c             	imul   $0xc,%eax,%esi
  10133a:	8b 7d 0c             	mov    0xc(%ebp),%edi
  10133d:	39 3c 32             	cmp    %edi,(%edx,%esi,1)
  101340:	75 1b                	jne    10135d <disable+0x40>
			clients->client[i].enabled = 0;
  101342:	c7 44 32 08 00 00 00 	movl   $0x0,0x8(%edx,%esi,1)
  101349:	00 

static int last_enabled_isr(struct shared_irq_runtime *clients, int count)
{
	uint32_t i;

	for (i = 0; i < count; i++) {
  10134a:	31 c0                	xor    %eax,%eax
  10134c:	39 c3                	cmp    %eax,%ebx
  10134e:	74 17                	je     101367 <disable+0x4a>
		if (clients->client[i].enabled) {
  101350:	6b f0 0c             	imul   $0xc,%eax,%esi
  101353:	83 7c 32 08 00       	cmpl   $0x0,0x8(%edx,%esi,1)
  101358:	75 15                	jne    10136f <disable+0x52>

static int last_enabled_isr(struct shared_irq_runtime *clients, int count)
{
	uint32_t i;

	for (i = 0; i < count; i++) {
  10135a:	40                   	inc    %eax
  10135b:	eb ef                	jmp    10134c <disable+0x2f>
{
	struct shared_irq_runtime *clients = dev->driver_data;
	const struct shared_irq_config *config = dev->config->config_info;
	uint32_t i;

	for (i = 0; i < config->client_count; i++) {
  10135d:	40                   	inc    %eax
  10135e:	eb d3                	jmp    101333 <disable+0x16>
				irq_disable(config->irq_num);
			}
			return 0;
		}
	}
	return -EIO;
  101360:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  101365:	eb 0a                	jmp    101371 <disable+0x54>

	for (i = 0; i < config->client_count; i++) {
		if (clients->client[i].isr_dev == isr_dev) {
			clients->client[i].enabled = 0;
			if (last_enabled_isr(clients, config->client_count)) {
				irq_disable(config->irq_num);
  101367:	ff 31                	pushl  (%ecx)
  101369:	e8 f3 f4 ff ff       	call   100861 <_arch_irq_disable>
  10136e:	58                   	pop    %eax
			}
			return 0;
  10136f:	31 c0                	xor    %eax,%eax
		}
	}
	return -EIO;
}
  101371:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101374:	5b                   	pop    %ebx
  101375:	5e                   	pop    %esi
  101376:	5f                   	pop    %edi
  101377:	5d                   	pop    %ebp
  101378:	c3                   	ret    

00101379 <enable>:
 *  @brief Enable ISR for device
 *  @param dev Pointer to device structure for SHARED_IRQ driver instance.
 *  @param isr_dev Pointer to the device that will service the interrupt.
 */
static inline int enable(struct device *dev, struct device *isr_dev)
{
  101379:	55                   	push   %ebp
  10137a:	89 e5                	mov    %esp,%ebp
  10137c:	57                   	push   %edi
  10137d:	56                   	push   %esi
  10137e:	53                   	push   %ebx
  10137f:	8b 45 08             	mov    0x8(%ebp),%eax
	struct shared_irq_runtime *clients = dev->driver_data;
  101382:	8b 50 08             	mov    0x8(%eax),%edx
	const struct shared_irq_config *config = dev->config->config_info;
  101385:	8b 00                	mov    (%eax),%eax
  101387:	8b 48 08             	mov    0x8(%eax),%ecx
	uint32_t i;

	for (i = 0; i < config->client_count; i++) {
  10138a:	31 c0                	xor    %eax,%eax
  10138c:	8b 71 08             	mov    0x8(%ecx),%esi
  10138f:	39 f0                	cmp    %esi,%eax
  101391:	74 22                	je     1013b5 <enable+0x3c>
		if (clients->client[i].isr_dev == isr_dev) {
  101393:	6b d8 0c             	imul   $0xc,%eax,%ebx
  101396:	8b 7d 0c             	mov    0xc(%ebp),%edi
  101399:	39 3c 1a             	cmp    %edi,(%edx,%ebx,1)
  10139c:	75 14                	jne    1013b2 <enable+0x39>
			clients->client[i].enabled = 1;
  10139e:	c7 44 1a 08 01 00 00 	movl   $0x1,0x8(%edx,%ebx,1)
  1013a5:	00 
			irq_enable(config->irq_num);
  1013a6:	ff 31                	pushl  (%ecx)
  1013a8:	e8 97 f4 ff ff       	call   100844 <_arch_irq_enable>
  1013ad:	58                   	pop    %eax
			return 0;
  1013ae:	31 c0                	xor    %eax,%eax
  1013b0:	eb 08                	jmp    1013ba <enable+0x41>
{
	struct shared_irq_runtime *clients = dev->driver_data;
	const struct shared_irq_config *config = dev->config->config_info;
	uint32_t i;

	for (i = 0; i < config->client_count; i++) {
  1013b2:	40                   	inc    %eax
  1013b3:	eb da                	jmp    10138f <enable+0x16>
			clients->client[i].enabled = 1;
			irq_enable(config->irq_num);
			return 0;
		}
	}
	return -EIO;
  1013b5:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  1013ba:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1013bd:	5b                   	pop    %ebx
  1013be:	5e                   	pop    %esi
  1013bf:	5f                   	pop    %edi
  1013c0:	5d                   	pop    %ebp
  1013c1:	c3                   	ret    

001013c2 <shared_irq_config_0_irq>:
#else
	#define SHARED_IRQ_0_FLAGS 0
#endif /* CONFIG_IOAPIC */

void shared_irq_config_0_irq(void)
{
  1013c2:	55                   	push   %ebp
  1013c3:	89 e5                	mov    %esp,%ebp
  1013c5:	0f b6 05 ba 6d 10 00 	movzbl 0x106dba,%eax
  1013cc:	68 00 a0 00 00       	push   $0xa000
  1013d1:	6a 12                	push   $0x12
  1013d3:	50                   	push   %eax
  1013d4:	e8 45 f4 ff ff       	call   10081e <__irq_controller_irq_config>
  1013d9:	83 c4 0c             	add    $0xc,%esp
	IRQ_CONNECT(CONFIG_SHARED_IRQ_0_IRQ, CONFIG_SHARED_IRQ_0_PRI,
		    shared_irq_isr, DEVICE_GET(shared_irq_0),
		    SHARED_IRQ_0_FLAGS);
}
  1013dc:	c9                   	leave  
  1013dd:	c3                   	ret    

001013de <spi_intel_configure>:
	}
}

static int spi_intel_configure(struct device *dev,
				struct spi_config *config)
{
  1013de:	55                   	push   %ebp
  1013df:	89 e5                	mov    %esp,%ebp
  1013e1:	57                   	push   %edi
  1013e2:	56                   	push   %esi
  1013e3:	53                   	push   %ebx
	struct spi_intel_data *spi = dev->driver_data;
  1013e4:	8b 45 08             	mov    0x8(%ebp),%eax
	}
}

static int spi_intel_configure(struct device *dev,
				struct spi_config *config)
{
  1013e7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	struct spi_intel_data *spi = dev->driver_data;
  1013ea:	8b 50 08             	mov    0x8(%eax),%edx
	uint32_t flags = config->config;
  1013ed:	8b 19                	mov    (%ecx),%ebx
{
	int ret;

	__asm__ volatile("btl	%2, %1;\n\t"
			 "sbb	%0, %0\n\t"
			 : "=r" (ret), "+m" (*(volatile uint32_t *) (addr))
  1013ef:	8b 02                	mov    (%edx),%eax
static ALWAYS_INLINE
	int sys_test_bit(mem_addr_t addr, unsigned int bit)
{
	int ret;

	__asm__ volatile("btl	%2, %1;\n\t"
  1013f1:	0f ba 20 07          	btl    $0x7,(%eax)
  1013f5:	19 f6                	sbb    %esi,%esi

	SYS_LOG_DBG("spi_intel_configure: %p (0x%x), %p", dev, spi->regs,
		    config);

	/* Check status */
	if (test_bit_sscr0_sse(spi->regs) && test_bit_sssr_bsy(spi->regs)) {
  1013f7:	85 f6                	test   %esi,%esi
  1013f9:	75 48                	jne    101443 <spi_intel_configure+0x65>
		SYS_LOG_DBG("spi_intel_configure: Controller is busy");
		return -EBUSY;
	}

	/* Pre-configuring the registers to a clean state*/
	spi->sscr0 = spi->sscr1 = 0;
  1013fb:	c7 42 34 00 00 00 00 	movl   $0x0,0x34(%edx)
  101402:	c7 42 30 00 00 00 00 	movl   $0x0,0x30(%edx)
static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
			 :
			 : "r"(data), "m" (*(volatile uint32_t *) addr)
  101409:	8b 32                	mov    (%edx),%esi
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  10140b:	31 c0                	xor    %eax,%eax
  10140d:	89 06                	mov    %eax,(%esi)
	write_sscr0(spi->sscr0, spi->regs);
	write_sscr1(spi->sscr1, spi->regs);
  10140f:	8b 42 34             	mov    0x34(%edx),%eax
			 :
			 : "r"(data), "m" (*(volatile uint32_t *) addr)
  101412:	8b 32                	mov    (%edx),%esi
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  101414:	89 46 04             	mov    %eax,0x4(%esi)
			SPI_WORD_SIZE_GET(flags),
			INTEL_SPI_DSS_RATE(config->max_sys_freq),
			INTEL_SPI_SSCR0_SCR(config->max_sys_freq) >> 8);

	/* Word size and clock rate */
	spi->sscr0 = INTEL_SPI_SSCR0_DSS(SPI_WORD_SIZE_GET(flags)) |
  101417:	89 d8                	mov    %ebx,%eax
				INTEL_SPI_SSCR0_SCR(config->max_sys_freq);
  101419:	8b 49 04             	mov    0x4(%ecx),%ecx
			SPI_WORD_SIZE_GET(flags),
			INTEL_SPI_DSS_RATE(config->max_sys_freq),
			INTEL_SPI_SSCR0_SCR(config->max_sys_freq) >> 8);

	/* Word size and clock rate */
	spi->sscr0 = INTEL_SPI_SSCR0_DSS(SPI_WORD_SIZE_GET(flags)) |
  10141c:	25 f0 0f 00 00       	and    $0xff0,%eax
  101421:	89 ce                	mov    %ecx,%esi
  101423:	c1 e8 04             	shr    $0x4,%eax
  101426:	c1 e6 08             	shl    $0x8,%esi
  101429:	8d 78 ff             	lea    -0x1(%eax),%edi
  10142c:	0f b7 c6             	movzwl %si,%eax
  10142f:	09 f8                	or     %edi,%eax
  101431:	89 42 30             	mov    %eax,0x30(%edx)
	/* Tx/Rx thresholds
	 * Note: Rx thresholds needs to be 1, it does not seem to be able
	 * to trigger reliably any interrupt with another value though the
	 * rx fifo would be full
	 */
	spi->sscr1 |= INTEL_SPI_SSCR1_TFT(INTEL_SPI_SSCR1_TFT_DFLT) |
  101434:	8b 42 34             	mov    0x34(%edx),%eax
		      INTEL_SPI_SSCR1_RFT(INTEL_SPI_SSCR1_RFT_DFLT);

	/* SPI mode */
	mode = SPI_MODE(flags);
	if (mode & SPI_MODE_CPOL) {
  101437:	f6 c3 01             	test   $0x1,%bl
  10143a:	75 1b                	jne    101457 <spi_intel_configure+0x79>
	/* Tx/Rx thresholds
	 * Note: Rx thresholds needs to be 1, it does not seem to be able
	 * to trigger reliably any interrupt with another value though the
	 * rx fifo would be full
	 */
	spi->sscr1 |= INTEL_SPI_SSCR1_TFT(INTEL_SPI_SSCR1_TFT_DFLT) |
  10143c:	0d c0 01 00 00       	or     $0x1c0,%eax
  101441:	eb 19                	jmp    10145c <spi_intel_configure+0x7e>
{
	int ret;

	__asm__ volatile("btl	%2, %1;\n\t"
			 "sbb	%0, %0\n\t"
			 : "=r" (ret), "+m" (*(volatile uint32_t *) (addr))
  101443:	8b 02                	mov    (%edx),%eax
static ALWAYS_INLINE
	int sys_test_bit(mem_addr_t addr, unsigned int bit)
{
	int ret;

	__asm__ volatile("btl	%2, %1;\n\t"
  101445:	0f ba 60 08 04       	btl    $0x4,0x8(%eax)
  10144a:	19 f6                	sbb    %esi,%esi
		    config);

	/* Check status */
	if (test_bit_sscr0_sse(spi->regs) && test_bit_sssr_bsy(spi->regs)) {
		SYS_LOG_DBG("spi_intel_configure: Controller is busy");
		return -EBUSY;
  10144c:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax

	SYS_LOG_DBG("spi_intel_configure: %p (0x%x), %p", dev, spi->regs,
		    config);

	/* Check status */
	if (test_bit_sscr0_sse(spi->regs) && test_bit_sssr_bsy(spi->regs)) {
  101451:	85 f6                	test   %esi,%esi
  101453:	74 a6                	je     1013fb <spi_intel_configure+0x1d>
  101455:	eb 24                	jmp    10147b <spi_intel_configure+0x9d>
		      INTEL_SPI_SSCR1_RFT(INTEL_SPI_SSCR1_RFT_DFLT);

	/* SPI mode */
	mode = SPI_MODE(flags);
	if (mode & SPI_MODE_CPOL) {
		spi->sscr1 |= INTEL_SPI_SSCR1_SPO;
  101457:	0d c8 01 00 00       	or     $0x1c8,%eax
  10145c:	89 42 34             	mov    %eax,0x34(%edx)
	}

	if (mode & SPI_MODE_CPHA) {
  10145f:	f6 c3 02             	test   $0x2,%bl
  101462:	74 04                	je     101468 <spi_intel_configure+0x8a>
		spi->sscr1 |= INTEL_SPI_SSCR1_SPH;
  101464:	83 4a 34 10          	orl    $0x10,0x34(%edx)
	}

	if (mode & SPI_MODE_LOOP) {
  101468:	80 e3 04             	and    $0x4,%bl
  10146b:	74 04                	je     101471 <spi_intel_configure+0x93>
		spi->sscr1 |= INTEL_SPI_SSCR1_LBM;
  10146d:	83 4a 34 04          	orl    $0x4,0x34(%edx)
	}

	/* Configuring the rate */
	write_dds_rate(INTEL_SPI_DSS_RATE(config->max_sys_freq), spi->regs);
  101471:	c1 e9 08             	shr    $0x8,%ecx
static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
			 :
			 : "r"(data), "m" (*(volatile uint32_t *) addr)
  101474:	8b 02                	mov    (%edx),%eax
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  101476:	89 48 28             	mov    %ecx,0x28(%eax)

	return 0;
  101479:	31 c0                	xor    %eax,%eax
}
  10147b:	5b                   	pop    %ebx
  10147c:	5e                   	pop    %esi
  10147d:	5f                   	pop    %edi
  10147e:	5d                   	pop    %ebp
  10147f:	c3                   	ret    

00101480 <spi_config_0_irq>:
DEVICE_DEFINE(spi_intel_port_0, CONFIG_SPI_0_NAME, spi_intel_init,
	      spi_intel_device_ctrl, &spi_intel_data_port_0,
	      &spi_intel_config_0, POST_KERNEL, CONFIG_SPI_INIT_PRIORITY, NULL);

void spi_config_0_irq(void)
{
  101480:	55                   	push   %ebp
  101481:	89 e5                	mov    %esp,%ebp
  101483:	0f b6 05 b8 6d 10 00 	movzbl 0x106db8,%eax
  10148a:	6a 00                	push   $0x0
  10148c:	6a 10                	push   $0x10
  10148e:	50                   	push   %eax
  10148f:	e8 8a f3 ff ff       	call   10081e <__irq_controller_irq_config>
  101494:	83 c4 0c             	add    $0xc,%esp
	IRQ_CONNECT(SPI_INTEL_PORT_0_IRQ, CONFIG_SPI_0_IRQ_PRI,
		    spi_intel_isr, DEVICE_GET(spi_intel_port_0),
		    SPI_INTEL_IRQ_FLAGS);
}
  101497:	c9                   	leave  
  101498:	c3                   	ret    

00101499 <spi_intel_init>:
#else
#define spi_intel_set_power_state(...)
#endif

int spi_intel_init(struct device *dev)
{
  101499:	55                   	push   %ebp
  10149a:	89 e5                	mov    %esp,%ebp
  10149c:	57                   	push   %edi
  10149d:	56                   	push   %esi
  10149e:	53                   	push   %ebx
  10149f:	83 ec 0c             	sub    $0xc,%esp
  1014a2:	8b 7d 08             	mov    0x8(%ebp),%edi
	const struct spi_intel_config *info = dev->config->config_info;
  1014a5:	8b 07                	mov    (%edi),%eax
	struct spi_intel_data *spi = dev->driver_data;
  1014a7:	8b 5f 08             	mov    0x8(%edi),%ebx
#define spi_intel_set_power_state(...)
#endif

int spi_intel_init(struct device *dev)
{
	const struct spi_intel_config *info = dev->config->config_info;
  1014aa:	8b 40 08             	mov    0x8(%eax),%eax
{
	struct spi_intel_data *spi = dev->driver_data;

	pci_bus_scan_init();

	if (!pci_bus_scan(&spi->pci_dev)) {
  1014ad:	8d 73 04             	lea    0x4(%ebx),%esi
#define spi_intel_set_power_state(...)
#endif

int spi_intel_init(struct device *dev)
{
	const struct spi_intel_config *info = dev->config->config_info;
  1014b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
#ifdef CONFIG_PCI
static inline int spi_intel_setup(struct device *dev)
{
	struct spi_intel_data *spi = dev->driver_data;

	pci_bus_scan_init();
  1014b3:	e8 e8 f4 ff ff       	call   1009a0 <pci_bus_scan_init>

	if (!pci_bus_scan(&spi->pci_dev)) {
  1014b8:	56                   	push   %esi
  1014b9:	e8 50 f5 ff ff       	call   100a0e <pci_bus_scan>
  1014be:	5a                   	pop    %edx
  1014bf:	83 ca ff             	or     $0xffffffff,%edx
  1014c2:	85 c0                	test   %eax,%eax
  1014c4:	0f 84 91 00 00 00    	je     10155b <spi_intel_init+0xc2>
		SYS_LOG_DBG("Could not find device");
		return 0;
	}

#ifdef CONFIG_PCI_ENUMERATION
	spi->regs = spi->pci_dev.addr;
  1014ca:	8b 43 04             	mov    0x4(%ebx),%eax
  1014cd:	89 03                	mov    %eax,(%ebx)
#endif

	pci_enable_regs(&spi->pci_dev);
  1014cf:	56                   	push   %esi
  1014d0:	e8 0a fb ff ff       	call   100fdf <pci_enable_regs>

	if (!spi_intel_setup(dev)) {
		return -EPERM;
	}

	info->config_func();
  1014d5:	8b 45 f0             	mov    -0x10(%ebp),%eax

#ifdef CONFIG_PCI_ENUMERATION
	spi->regs = spi->pci_dev.addr;
#endif

	pci_enable_regs(&spi->pci_dev);
  1014d8:	5a                   	pop    %edx

	if (!spi_intel_setup(dev)) {
		return -EPERM;
	}

	info->config_func();
  1014d9:	ff 50 04             	call   *0x4(%eax)

#include <gpio.h>

static inline void _spi_config_cs(struct device *dev)
{
	const struct spi_intel_config *info = dev->config->config_info;
  1014dc:	8b 07                	mov    (%edi),%eax
  1014de:	8b 50 08             	mov    0x8(%eax),%edx
	struct spi_intel_data *spi = dev->driver_data;
  1014e1:	8b 47 08             	mov    0x8(%edi),%eax
	struct device *gpio;

	gpio = device_get_binding(info->cs_gpio_name);
  1014e4:	89 55 e8             	mov    %edx,-0x18(%ebp)
#include <gpio.h>

static inline void _spi_config_cs(struct device *dev)
{
	const struct spi_intel_config *info = dev->config->config_info;
	struct spi_intel_data *spi = dev->driver_data;
  1014e7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct device *gpio;

	gpio = device_get_binding(info->cs_gpio_name);
  1014ea:	ff 72 08             	pushl  0x8(%edx)
  1014ed:	e8 f5 21 00 00       	call   1036e7 <device_get_binding>
  1014f2:	59                   	pop    %ecx
  1014f3:	89 c6                	mov    %eax,%esi
	if (!gpio) {
  1014f5:	85 c0                	test   %eax,%eax
  1014f7:	8b 55 e8             	mov    -0x18(%ebp),%edx
  1014fa:	75 0c                	jne    101508 <spi_intel_init+0x6f>
		spi->cs_gpio_port = NULL;
  1014fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1014ff:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  101506:	eb 2f                	jmp    101537 <spi_intel_init+0x9e>
static inline int gpio_pin_configure(struct device *port, uint8_t pin,
				     int flags)
{
	const struct gpio_driver_api *api = port->driver_api;

	return api->config(port, GPIO_ACCESS_BY_PIN, pin, flags);
  101508:	8b 40 04             	mov    0x4(%eax),%eax
  10150b:	6a 01                	push   $0x1
  10150d:	0f b6 4a 0c          	movzbl 0xc(%edx),%ecx
  101511:	51                   	push   %ecx
  101512:	6a 00                	push   $0x0
  101514:	56                   	push   %esi
  101515:	89 55 e8             	mov    %edx,-0x18(%ebp)
  101518:	ff 10                	call   *(%eax)
  10151a:	83 c4 10             	add    $0x10,%esp
static inline int gpio_pin_write(struct device *port, uint32_t pin,
				 uint32_t value)
{
	const struct gpio_driver_api *api = port->driver_api;

	return api->write(port, GPIO_ACCESS_BY_PIN, pin, value);
  10151d:	8b 55 e8             	mov    -0x18(%ebp),%edx
  101520:	8b 46 04             	mov    0x4(%esi),%eax
  101523:	6a 01                	push   $0x1
  101525:	ff 72 0c             	pushl  0xc(%edx)
  101528:	6a 00                	push   $0x0
  10152a:	56                   	push   %esi
  10152b:	ff 50 04             	call   *0x4(%eax)

	gpio_pin_configure(gpio, info->cs_gpio_pin, GPIO_DIR_OUT);
	/* Default CS line to high (idling) */
	gpio_pin_write(gpio, info->cs_gpio_pin, 1);

	spi->cs_gpio_port = gpio;
  10152e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101531:	83 c4 10             	add    $0x10,%esp
  101534:	89 70 2c             	mov    %esi,0x2c(%eax)
 *
 * @param sync A pointer to a valid device_sync_call_t
 */
static inline void device_sync_call_init(device_sync_call_t *sync)
{
	k_sem_init(&sync->f_sem, 0, UINT_MAX);
  101537:	83 c3 18             	add    $0x18,%ebx
  10153a:	6a ff                	push   $0xffffffff
  10153c:	6a 00                	push   $0x0
  10153e:	53                   	push   %ebx
  10153f:	e8 3b 28 00 00       	call   103d7f <k_sem_init>

	device_sync_call_init(&spi->sync);

	spi_intel_set_power_state(dev, DEVICE_PM_ACTIVE_STATE);

	irq_enable(info->irq);
  101544:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101547:	83 c4 0c             	add    $0xc,%esp
  10154a:	ff 30                	pushl  (%eax)
  10154c:	e8 f3 f2 ff ff       	call   100844 <_arch_irq_enable>
  101551:	58                   	pop    %eax

	SYS_LOG_DBG("SPI Intel Driver initialized on device: %p", dev);

	dev->driver_api = &intel_spi_api;

	return 0;
  101552:	31 d2                	xor    %edx,%edx

	irq_enable(info->irq);

	SYS_LOG_DBG("SPI Intel Driver initialized on device: %p", dev);

	dev->driver_api = &intel_spi_api;
  101554:	c7 47 04 08 48 10 00 	movl   $0x104808,0x4(%edi)

	return 0;
}
  10155b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10155e:	89 d0                	mov    %edx,%eax
  101560:	5b                   	pop    %ebx
  101561:	5e                   	pop    %esi
  101562:	5f                   	pop    %edi
  101563:	5d                   	pop    %ebp
  101564:	c3                   	ret    

00101565 <_spi_control_cs>:
static inline void _spi_control_cs(struct device *dev, int on)
{
	const struct spi_intel_config *info = dev->config->config_info;
	struct spi_intel_data *spi = dev->driver_data;

	if (!spi->cs_gpio_port) {
  101565:	8b 48 08             	mov    0x8(%eax),%ecx
  101568:	8b 49 2c             	mov    0x2c(%ecx),%ecx
  10156b:	85 c9                	test   %ecx,%ecx
  10156d:	74 25                	je     101594 <_spi_control_cs+0x2f>

	spi->cs_gpio_port = gpio;
}

static inline void _spi_control_cs(struct device *dev, int on)
{
  10156f:	55                   	push   %ebp
  101570:	85 d2                	test   %edx,%edx
  101572:	0f 94 c2             	sete   %dl
  101575:	89 e5                	mov    %esp,%ebp
  101577:	53                   	push   %ebx
  101578:	0f b6 d2             	movzbl %dl,%edx
  10157b:	8b 59 04             	mov    0x4(%ecx),%ebx
  10157e:	52                   	push   %edx
	const struct spi_intel_config *info = dev->config->config_info;
  10157f:	8b 00                	mov    (%eax),%eax

	if (!spi->cs_gpio_port) {
		return;
	}

	gpio_pin_write(spi->cs_gpio_port, info->cs_gpio_pin, !on);
  101581:	8b 40 08             	mov    0x8(%eax),%eax
  101584:	ff 70 0c             	pushl  0xc(%eax)
  101587:	6a 00                	push   $0x0
  101589:	51                   	push   %ecx
  10158a:	ff 53 04             	call   *0x4(%ebx)
  10158d:	83 c4 10             	add    $0x10,%esp
}
  101590:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  101593:	c9                   	leave  
  101594:	c3                   	ret    

00101595 <spi_intel_isr>:

	return 0;
}

void spi_intel_isr(void *arg)
{
  101595:	55                   	push   %ebp
  101596:	89 e5                	mov    %esp,%ebp
  101598:	57                   	push   %edi
  101599:	56                   	push   %esi
  10159a:	53                   	push   %ebx
  10159b:	51                   	push   %ecx
  10159c:	8b 45 08             	mov    0x8(%ebp),%eax
	struct device *dev = arg;
	struct spi_intel_data *spi = dev->driver_data;
  10159f:	8b 58 08             	mov    0x8(%eax),%ebx
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
			 : "=r"(ret)
			 : "m" (*(volatile uint32_t *) addr)
  1015a2:	8b 13                	mov    (%ebx),%edx
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  1015a4:	8b 72 08             	mov    0x8(%edx),%esi
  1015a7:	89 75 f0             	mov    %esi,-0x10(%ebp)

	SYS_LOG_DBG("spi_intel_isr: %p", dev);

	status = read_sssr(spi->regs);

	if (status & INTEL_SPI_SSSR_ROR) {
  1015aa:	81 e6 80 00 00 00    	and    $0x80,%esi
  1015b0:	74 11                	je     1015c3 <spi_intel_isr+0x2e>

static ALWAYS_INLINE
	void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btrl	%1, %0;\n\t"
			 : "+m" (*(volatile uint32_t *) (addr))
  1015b2:	8b 13                	mov    (%ebx),%edx
}

static ALWAYS_INLINE
	void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btrl	%1, %0;\n\t"
  1015b4:	0f ba 72 08 07       	btrl   $0x7,0x8(%edx)
		/* Unrecoverable error, ack it */
		clear_bit_sssr_ror(spi->regs);
		error = 1;
  1015b9:	ba 01 00 00 00       	mov    $0x1,%edx
  1015be:	e9 90 00 00 00       	jmp    101653 <spi_intel_isr+0xbe>
		goto out;
	}

	if (status & INTEL_SPI_SSSR_RFS) {
  1015c3:	f6 45 f0 40          	testb  $0x40,-0x10(%ebp)
  1015c7:	75 0f                	jne    1015d8 <spi_intel_isr+0x43>
{
	int ret;

	__asm__ volatile("btl	%2, %1;\n\t"
			 "sbb	%0, %0\n\t"
			 : "=r" (ret), "+m" (*(volatile uint32_t *) (addr))
  1015c9:	8b 13                	mov    (%ebx),%edx
static ALWAYS_INLINE
	int sys_test_bit(mem_addr_t addr, unsigned int bit)
{
	int ret;

	__asm__ volatile("btl	%2, %1;\n\t"
  1015cb:	0f ba 62 04 01       	btl    $0x1,0x4(%edx)
  1015d0:	19 db                	sbb    %ebx,%ebx
		pull_data(dev);
	}

	if (test_bit_sscr1_tie(spi->regs)) {
  1015d2:	85 db                	test   %ebx,%ebx
  1015d4:	75 2e                	jne    101604 <spi_intel_isr+0x6f>
  1015d6:	eb 79                	jmp    101651 <spi_intel_isr+0xbc>
  1015d8:	8b 50 08             	mov    0x8(%eax),%edx
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
			 : "=r"(ret)
			 : "m" (*(volatile uint32_t *) addr)
  1015db:	8b 32                	mov    (%edx),%esi
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  1015dd:	8b 76 08             	mov    0x8(%esi),%esi
{
	struct spi_intel_data *spi = dev->driver_data;
	uint32_t cnt = 0;
	uint8_t data = 0;

	while (read_sssr(spi->regs) & INTEL_SPI_SSSR_RNE) {
  1015e0:	83 e6 08             	and    $0x8,%esi
  1015e3:	74 e4                	je     1015c9 <spi_intel_isr+0x34>
			 : "=r"(ret)
			 : "m" (*(volatile uint32_t *) addr)
  1015e5:	8b 32                	mov    (%edx),%esi
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  1015e7:	8b 7e 10             	mov    0x10(%esi),%edi
		data = (uint8_t) read_ssdr(spi->regs);
		cnt++;
		spi->received++;
  1015ea:	8b 72 4c             	mov    0x4c(%edx),%esi
  1015ed:	89 f9                	mov    %edi,%ecx

		if ((spi->received - 1) < spi->r_buf_len) {
  1015ef:	3b 72 44             	cmp    0x44(%edx),%esi
	uint8_t data = 0;

	while (read_sssr(spi->regs) & INTEL_SPI_SSSR_RNE) {
		data = (uint8_t) read_ssdr(spi->regs);
		cnt++;
		spi->received++;
  1015f2:	8d 7e 01             	lea    0x1(%esi),%edi
  1015f5:	89 7a 4c             	mov    %edi,0x4c(%edx)

		if ((spi->received - 1) < spi->r_buf_len) {
  1015f8:	73 e1                	jae    1015db <spi_intel_isr+0x46>
			*(uint8_t *)(spi->rx_buf) = data;
  1015fa:	8b 72 3c             	mov    0x3c(%edx),%esi
  1015fd:	88 0e                	mov    %cl,(%esi)
			spi->rx_buf++;
  1015ff:	ff 42 3c             	incl   0x3c(%edx)
  101602:	eb d7                	jmp    1015db <spi_intel_isr+0x46>
	if (status & INTEL_SPI_SSSR_RFS) {
		pull_data(dev);
	}

	if (test_bit_sscr1_tie(spi->regs)) {
		if (status & INTEL_SPI_SSSR_TFS) {
  101604:	f6 45 f0 20          	testb  $0x20,-0x10(%ebp)
  101608:	74 47                	je     101651 <spi_intel_isr+0xbc>
  10160a:	8b 50 08             	mov    0x8(%eax),%edx
			 : "=r"(ret)
			 : "m" (*(volatile uint32_t *) addr)
  10160d:	8b 0a                	mov    (%edx),%ecx
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  10160f:	8b 49 08             	mov    0x8(%ecx),%ecx
	struct spi_intel_data *spi = dev->driver_data;
	uint32_t cnt = 0;
	uint8_t data;
	uint32_t status;

	while ((status = read_sssr(spi->regs)) & INTEL_SPI_SSSR_TNF) {
  101612:	f6 c1 04             	test   $0x4,%cl
  101615:	8b 5a 48             	mov    0x48(%edx),%ebx
  101618:	74 2b                	je     101645 <spi_intel_isr+0xb0>
		if (status & INTEL_SPI_SSSR_RFS) {
  10161a:	80 e1 40             	and    $0x40,%cl
  10161d:	75 26                	jne    101645 <spi_intel_isr+0xb0>
			break;
		}
		if (spi->tx_buf && (spi->transmitted < spi->t_buf_len)) {
  10161f:	8b 4a 38             	mov    0x38(%edx),%ecx
  101622:	85 c9                	test   %ecx,%ecx
  101624:	74 0e                	je     101634 <spi_intel_isr+0x9f>
  101626:	3b 5a 40             	cmp    0x40(%edx),%ebx
  101629:	73 09                	jae    101634 <spi_intel_isr+0x9f>
			data = *(uint8_t *)(spi->tx_buf);
  10162b:	0f b6 19             	movzbl (%ecx),%ebx
			spi->tx_buf++;
  10162e:	41                   	inc    %ecx
  10162f:	89 4a 38             	mov    %ecx,0x38(%edx)
  101632:	eb 07                	jmp    10163b <spi_intel_isr+0xa6>
		} else if (spi->transmitted < spi->trans_len) {
  101634:	3b 5a 50             	cmp    0x50(%edx),%ebx
  101637:	73 0c                	jae    101645 <spi_intel_isr+0xb0>
			data = 0;
  101639:	31 db                	xor    %ebx,%ebx
static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
			 :
			 : "r"(data), "m" (*(volatile uint32_t *) addr)
  10163b:	8b 0a                	mov    (%edx),%ecx
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  10163d:	89 59 10             	mov    %ebx,0x10(%ecx)
		}

		cnt++;
		SYS_LOG_DBG("Pushing 1 byte (total: %d)", cnt);
		write_ssdr(data, spi->regs);
		spi->transmitted++;
  101640:	ff 42 48             	incl   0x48(%edx)
  101643:	eb c8                	jmp    10160d <spi_intel_isr+0x78>
	}

	SYS_LOG_DBG("Pushed: %d (total: %d)", cnt, spi->transmitted);

	if (spi->transmitted == spi->trans_len) {
  101645:	3b 5a 50             	cmp    0x50(%edx),%ebx
  101648:	75 07                	jne    101651 <spi_intel_isr+0xbc>

static ALWAYS_INLINE
	void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btrl	%1, %0;\n\t"
			 : "+m" (*(volatile uint32_t *) (addr))
  10164a:	8b 12                	mov    (%edx),%edx
}

static ALWAYS_INLINE
	void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btrl	%1, %0;\n\t"
  10164c:	0f ba 72 04 01       	btrl   $0x1,0x4(%edx)

void spi_intel_isr(void *arg)
{
	struct device *dev = arg;
	struct spi_intel_data *spi = dev->driver_data;
	uint32_t error = 0;
  101651:	31 d2                	xor    %edx,%edx
#define _spi_config_cs(...) { ; }
#endif /* CONFIG_SPI_CS_GPIO */

static void completed(struct device *dev, uint32_t error)
{
	struct spi_intel_data *spi = dev->driver_data;
  101653:	8b 58 08             	mov    0x8(%eax),%ebx

	/* if received == trans_len, then transmitted == trans_len */
	if (!(spi->received == spi->trans_len) && !error) {
  101656:	8b 7b 50             	mov    0x50(%ebx),%edi
  101659:	39 7b 4c             	cmp    %edi,0x4c(%ebx)
  10165c:	74 04                	je     101662 <spi_intel_isr+0xcd>
  10165e:	85 d2                	test   %edx,%edx
  101660:	74 28                	je     10168a <spi_intel_isr+0xf5>
		return;
	}

	spi->error = error;
  101662:	88 53 28             	mov    %dl,0x28(%ebx)

	_spi_control_cs(dev, 0);
  101665:	31 d2                	xor    %edx,%edx
  101667:	e8 f9 fe ff ff       	call   101565 <_spi_control_cs>

	write_sscr1(spi->sscr1, spi->regs);
  10166c:	8b 43 34             	mov    0x34(%ebx),%eax
static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
			 :
			 : "r"(data), "m" (*(volatile uint32_t *) addr)
  10166f:	8b 13                	mov    (%ebx),%edx
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  101671:	89 42 04             	mov    %eax,0x4(%edx)

static ALWAYS_INLINE
	void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btrl	%1, %0;\n\t"
			 : "+m" (*(volatile uint32_t *) (addr))
  101674:	8b 03                	mov    (%ebx),%eax
}

static ALWAYS_INLINE
	void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btrl	%1, %0;\n\t"
  101676:	0f ba 30 07          	btrl   $0x7,(%eax)
 *
 * @param sync A pointer to a valid device_sync_call_t
 */
static inline void device_sync_call_complete(device_sync_call_t *sync)
{
	k_sem_give(&sync->f_sem);
  10167a:	83 c3 18             	add    $0x18,%ebx
  10167d:	89 5d 08             	mov    %ebx,0x8(%ebp)
			push_data(dev);
		}
	}
out:
	completed(dev, error);
}
  101680:	5a                   	pop    %edx
  101681:	5b                   	pop    %ebx
  101682:	5e                   	pop    %esi
  101683:	5f                   	pop    %edi
  101684:	5d                   	pop    %ebp
  101685:	e9 0e 27 00 00       	jmp    103d98 <k_sem_give>
  10168a:	58                   	pop    %eax
  10168b:	5b                   	pop    %ebx
  10168c:	5e                   	pop    %esi
  10168d:	5f                   	pop    %edi
  10168e:	5d                   	pop    %ebp
  10168f:	c3                   	ret    

00101690 <spi_intel_transceive>:
}

static int spi_intel_transceive(struct device *dev,
				const void *tx_buf, uint32_t tx_buf_len,
				void *rx_buf, uint32_t rx_buf_len)
{
  101690:	55                   	push   %ebp
  101691:	89 e5                	mov    %esp,%ebp
  101693:	57                   	push   %edi
  101694:	56                   	push   %esi
  101695:	53                   	push   %ebx
  101696:	8b 45 08             	mov    0x8(%ebp),%eax
  101699:	8b 55 10             	mov    0x10(%ebp),%edx
  10169c:	8b 75 18             	mov    0x18(%ebp),%esi
	struct spi_intel_data *spi = dev->driver_data;
  10169f:	8b 58 08             	mov    0x8(%eax),%ebx
{
	int ret;

	__asm__ volatile("btl	%2, %1;\n\t"
			 "sbb	%0, %0\n\t"
			 : "=r" (ret), "+m" (*(volatile uint32_t *) (addr))
  1016a2:	8b 0b                	mov    (%ebx),%ecx
static ALWAYS_INLINE
	int sys_test_bit(mem_addr_t addr, unsigned int bit)
{
	int ret;

	__asm__ volatile("btl	%2, %1;\n\t"
  1016a4:	0f ba 21 07          	btl    $0x7,(%ecx)
  1016a8:	19 ff                	sbb    %edi,%edi

	SYS_LOG_DBG("spi_dw_transceive: %p, %p, %u, %p, %u",
			dev, tx_buf, tx_buf_len, rx_buf, rx_buf_len);

	/* Check status */
	if (test_bit_sscr0_sse(spi->regs) && test_bit_sssr_bsy(spi->regs)) {
  1016aa:	85 ff                	test   %edi,%edi
  1016ac:	75 67                	jne    101715 <spi_intel_transceive+0x85>
		SYS_LOG_DBG("spi_intel_transceive: Controller is busy");
		return -EBUSY;
	}

	/* Set buffers info */
	spi->tx_buf = tx_buf;
  1016ae:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	spi->rx_buf = rx_buf;
	spi->t_buf_len = tx_buf_len;
  1016b1:	89 53 40             	mov    %edx,0x40(%ebx)
		SYS_LOG_DBG("spi_intel_transceive: Controller is busy");
		return -EBUSY;
	}

	/* Set buffers info */
	spi->tx_buf = tx_buf;
  1016b4:	89 4b 38             	mov    %ecx,0x38(%ebx)
	spi->rx_buf = rx_buf;
  1016b7:	8b 4d 14             	mov    0x14(%ebp),%ecx
  1016ba:	89 4b 3c             	mov    %ecx,0x3c(%ebx)
	spi->t_buf_len = tx_buf_len;
	spi->r_buf_len = rx_buf_len;
  1016bd:	89 73 44             	mov    %esi,0x44(%ebx)
	spi->transmitted = 0;
  1016c0:	c7 43 48 00 00 00 00 	movl   $0x0,0x48(%ebx)
	spi->received = 0;
  1016c7:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
	spi->trans_len = max(tx_buf_len, rx_buf_len);
  1016ce:	39 f2                	cmp    %esi,%edx
  1016d0:	73 02                	jae    1016d4 <spi_intel_transceive+0x44>
  1016d2:	89 f2                	mov    %esi,%edx
  1016d4:	89 53 50             	mov    %edx,0x50(%ebx)

	_spi_control_cs(dev, 1);
  1016d7:	ba 01 00 00 00       	mov    $0x1,%edx
  1016dc:	e8 84 fe ff ff       	call   101565 <_spi_control_cs>

	/* Enabling the controller */
	write_sscr0(spi->sscr0 | INTEL_SPI_SSCR0_SSE, spi->regs);
  1016e1:	8b 43 30             	mov    0x30(%ebx),%eax
  1016e4:	0c 80                	or     $0x80,%al
static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
			 :
			 : "r"(data), "m" (*(volatile uint32_t *) addr)
  1016e6:	8b 13                	mov    (%ebx),%edx
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  1016e8:	89 02                	mov    %eax,(%edx)

	/* Installing the registers */
	write_sscr1(spi->sscr1 | INTEL_SPI_SSCR1_RIE |
  1016ea:	8b 43 34             	mov    0x34(%ebx),%eax
			 :
			 : "r"(data), "m" (*(volatile uint32_t *) addr)
  1016ed:	8b 13                	mov    (%ebx),%edx
  1016ef:	83 c8 03             	or     $0x3,%eax
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  1016f2:	89 42 04             	mov    %eax,0x4(%edx)
 *
 * @param sync A pointer to a valid device_sync_call_t
 */
static inline void device_sync_call_wait(device_sync_call_t *sync)
{
	k_sem_take(&sync->f_sem, K_FOREVER);
  1016f5:	8d 43 18             	lea    0x18(%ebx),%eax
  1016f8:	6a ff                	push   $0xffffffff
  1016fa:	50                   	push   %eax
  1016fb:	e8 be 26 00 00       	call   103dbe <k_sem_take>
  101700:	58                   	pop    %eax
	if (spi->error) {
		spi->error = 0;
		return -EIO;
	}

	return 0;
  101701:	31 c9                	xor    %ecx,%ecx
  101703:	5a                   	pop    %edx
	write_sscr1(spi->sscr1 | INTEL_SPI_SSCR1_RIE |
				INTEL_SPI_SSCR1_TIE, spi->regs);

	device_sync_call_wait(&spi->sync);

	if (spi->error) {
  101704:	80 7b 28 00          	cmpb   $0x0,0x28(%ebx)
  101708:	74 1d                	je     101727 <spi_intel_transceive+0x97>
		spi->error = 0;
  10170a:	c6 43 28 00          	movb   $0x0,0x28(%ebx)
		return -EIO;
  10170e:	b9 fb ff ff ff       	mov    $0xfffffffb,%ecx
  101713:	eb 12                	jmp    101727 <spi_intel_transceive+0x97>
{
	int ret;

	__asm__ volatile("btl	%2, %1;\n\t"
			 "sbb	%0, %0\n\t"
			 : "=r" (ret), "+m" (*(volatile uint32_t *) (addr))
  101715:	8b 0b                	mov    (%ebx),%ecx
static ALWAYS_INLINE
	int sys_test_bit(mem_addr_t addr, unsigned int bit)
{
	int ret;

	__asm__ volatile("btl	%2, %1;\n\t"
  101717:	0f ba 61 08 04       	btl    $0x4,0x8(%ecx)
  10171c:	19 ff                	sbb    %edi,%edi
			dev, tx_buf, tx_buf_len, rx_buf, rx_buf_len);

	/* Check status */
	if (test_bit_sscr0_sse(spi->regs) && test_bit_sssr_bsy(spi->regs)) {
		SYS_LOG_DBG("spi_intel_transceive: Controller is busy");
		return -EBUSY;
  10171e:	b9 f0 ff ff ff       	mov    $0xfffffff0,%ecx

	SYS_LOG_DBG("spi_dw_transceive: %p, %p, %u, %p, %u",
			dev, tx_buf, tx_buf_len, rx_buf, rx_buf_len);

	/* Check status */
	if (test_bit_sscr0_sse(spi->regs) && test_bit_sssr_bsy(spi->regs)) {
  101723:	85 ff                	test   %edi,%edi
  101725:	74 87                	je     1016ae <spi_intel_transceive+0x1e>
		spi->error = 0;
		return -EIO;
	}

	return 0;
}
  101727:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10172a:	89 c8                	mov    %ecx,%eax
  10172c:	5b                   	pop    %ebx
  10172d:	5e                   	pop    %esi
  10172e:	5f                   	pop    %edi
  10172f:	5d                   	pop    %ebp
  101730:	c3                   	ret    

00101731 <dw_set_bit>:
	sys_write32(val, base_addr + offset);
}

static void dw_set_bit(uint32_t base_addr, uint32_t offset,
		       uint32_t bit, uint8_t value)
{
  101731:	55                   	push   %ebp
  101732:	8d 04 10             	lea    (%eax,%edx,1),%eax
  101735:	89 e5                	mov    %esp,%ebp
	if (!value) {
  101737:	80 7d 08 00          	cmpb   $0x0,0x8(%ebp)
  10173b:	75 05                	jne    101742 <dw_set_bit+0x11>
}

static ALWAYS_INLINE
	void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btrl	%1, %0;\n\t"
  10173d:	0f b3 08             	btr    %ecx,(%eax)
  101740:	eb 03                	jmp    101745 <dw_set_bit+0x14>


static ALWAYS_INLINE
	void sys_set_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btsl	%1, %0;\n\t"
  101742:	0f ab 08             	bts    %ecx,(%eax)
		sys_clear_bit(base_addr + offset, bit);
	} else {
		sys_set_bit(base_addr + offset, bit);
	}
}
  101745:	5d                   	pop    %ebp
  101746:	c3                   	ret    

00101747 <gpio_dw_write>:
	return 0;
}

static inline int gpio_dw_write(struct device *port, int access_op,
				uint32_t pin, uint32_t value)
{
  101747:	55                   	push   %ebp
  101748:	89 e5                	mov    %esp,%ebp
	struct gpio_dw_runtime *context = port->driver_data;
	uint32_t base_addr = context->base_addr;
  10174a:	8b 45 08             	mov    0x8(%ebp),%eax
	return 0;
}

static inline int gpio_dw_write(struct device *port, int access_op,
				uint32_t pin, uint32_t value)
{
  10174d:	8b 55 14             	mov    0x14(%ebp),%edx
	struct gpio_dw_runtime *context = port->driver_data;
	uint32_t base_addr = context->base_addr;

	if (GPIO_ACCESS_BY_PIN == access_op) {
  101750:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)

static inline int gpio_dw_write(struct device *port, int access_op,
				uint32_t pin, uint32_t value)
{
	struct gpio_dw_runtime *context = port->driver_data;
	uint32_t base_addr = context->base_addr;
  101754:	8b 40 08             	mov    0x8(%eax),%eax
  101757:	8b 00                	mov    (%eax),%eax

	if (GPIO_ACCESS_BY_PIN == access_op) {
  101759:	75 11                	jne    10176c <gpio_dw_write+0x25>
		dw_set_bit(base_addr, SWPORTA_DR, pin, value);
  10175b:	0f b6 d2             	movzbl %dl,%edx
  10175e:	52                   	push   %edx
  10175f:	8b 4d 10             	mov    0x10(%ebp),%ecx
  101762:	31 d2                	xor    %edx,%edx
  101764:	e8 c8 ff ff ff       	call   101731 <dw_set_bit>
  101769:	58                   	pop    %eax
  10176a:	eb 02                	jmp    10176e <gpio_dw_write+0x27>
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  10176c:	89 10                	mov    %edx,(%eax)
	} else {
		dw_write(base_addr, SWPORTA_DR, value);
	}

	return 0;
}
  10176e:	31 c0                	xor    %eax,%eax
  101770:	c9                   	leave  
  101771:	c3                   	ret    

00101772 <gpio_dw_read>:

static inline int gpio_dw_read(struct device *port, int access_op,
			       uint32_t pin, uint32_t *value)
{
  101772:	55                   	push   %ebp
  101773:	b9 0c 00 00 00       	mov    $0xc,%ecx
  101778:	89 e5                	mov    %esp,%ebp
  10177a:	56                   	push   %esi
  10177b:	53                   	push   %ebx
  10177c:	31 d2                	xor    %edx,%edx
	struct gpio_dw_runtime *context = port->driver_data;
	uint32_t base_addr = context->base_addr;
  10177e:	8b 45 08             	mov    0x8(%ebp),%eax
	return 0;
}

static inline int gpio_dw_read(struct device *port, int access_op,
			       uint32_t pin, uint32_t *value)
{
  101781:	8b 5d 14             	mov    0x14(%ebp),%ebx
	struct gpio_dw_runtime *context = port->driver_data;
	uint32_t base_addr = context->base_addr;
  101784:	8b 40 08             	mov    0x8(%eax),%eax
  101787:	8b 30                	mov    (%eax),%esi
  101789:	89 f0                	mov    %esi,%eax
  10178b:	83 e0 3f             	and    $0x3f,%eax
  10178e:	f7 f1                	div    %ecx
  101790:	b9 50 00 00 00       	mov    $0x50,%ecx
  101795:	8d 50 ff             	lea    -0x1(%eax),%edx
  101798:	83 fa 02             	cmp    $0x2,%edx
  10179b:	77 07                	ja     1017a4 <gpio_dw_read+0x32>
  10179d:	0f b6 88 13 48 10 00 	movzbl 0x104813(%eax),%ecx
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
			 : "=r"(ret)
			 : "m" (*(volatile uint32_t *) addr)
  1017a4:	83 e6 c0             	and    $0xffffffc0,%esi
  1017a7:	01 f1                	add    %esi,%ecx
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  1017a9:	8b 01                	mov    (%ecx),%eax
		break;
	}
	*value = dw_read(dw_base_to_block_base(base_addr), ext_port);
#endif

	if (GPIO_ACCESS_BY_PIN == access_op) {
  1017ab:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  1017af:	75 08                	jne    1017b9 <gpio_dw_read+0x47>
		*value = !!(*value & BIT(pin));
  1017b1:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1017b4:	d3 e8                	shr    %cl,%eax
  1017b6:	83 e0 01             	and    $0x1,%eax
  1017b9:	89 03                	mov    %eax,(%ebx)
	}
	return 0;
}
  1017bb:	31 c0                	xor    %eax,%eax
  1017bd:	5b                   	pop    %ebx
  1017be:	5e                   	pop    %esi
  1017bf:	5d                   	pop    %ebp
  1017c0:	c3                   	ret    

001017c1 <gpio_dw_manage_callback>:

static inline int gpio_dw_manage_callback(struct device *port,
					  struct gpio_callback *callback,
					  bool set)
{
  1017c1:	55                   	push   %ebp
  1017c2:	89 e5                	mov    %esp,%ebp
  1017c4:	53                   	push   %ebx
 * @param node A pointer on the node to remove from the list
 */
static inline void sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node)
{
	sys_snode_t *prev = NULL;
  1017c5:	31 db                	xor    %ebx,%ebx
	struct gpio_dw_runtime *context = port->driver_data;
  1017c7:	8b 45 08             	mov    0x8(%ebp),%eax
}

static inline int gpio_dw_manage_callback(struct device *port,
					  struct gpio_callback *callback,
					  bool set)
{
  1017ca:	8b 55 0c             	mov    0xc(%ebp),%edx
					 bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (set) {
  1017cd:	80 7d 10 00          	cmpb   $0x0,0x10(%ebp)
	struct gpio_dw_runtime *context = port->driver_data;
  1017d1:	8b 40 08             	mov    0x8(%eax),%eax
 * @param node A pointer on the node to prepend
 */
static inline void sys_slist_prepend(sys_slist_t *list,
				     sys_snode_t *node)
{
	node->next = list->head;
  1017d4:	8b 48 18             	mov    0x18(%eax),%ecx
  1017d7:	74 18                	je     1017f1 <gpio_dw_manage_callback+0x30>
  1017d9:	89 0a                	mov    %ecx,(%edx)
	list->head = node;
  1017db:	89 50 18             	mov    %edx,0x18(%eax)

	if (!list->tail) {
  1017de:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
  1017e2:	75 36                	jne    10181a <gpio_dw_manage_callback+0x59>
		list->tail = list->head;
  1017e4:	89 50 1c             	mov    %edx,0x1c(%eax)
  1017e7:	eb 31                	jmp    10181a <gpio_dw_manage_callback+0x59>
{
	sys_snode_t *prev = NULL;
	sys_snode_t *test;

	SYS_SLIST_FOR_EACH_NODE(list, test) {
		if (test == node) {
  1017e9:	39 ca                	cmp    %ecx,%edx
  1017eb:	74 0a                	je     1017f7 <gpio_dw_manage_callback+0x36>
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node)
{
	return !node ? NULL : node->next;
  1017ed:	89 cb                	mov    %ecx,%ebx
  1017ef:	8b 09                	mov    (%ecx),%ecx
					     sys_snode_t *node)
{
	sys_snode_t *prev = NULL;
	sys_snode_t *test;

	SYS_SLIST_FOR_EACH_NODE(list, test) {
  1017f1:	85 c9                	test   %ecx,%ecx
  1017f3:	75 f4                	jne    1017e9 <gpio_dw_manage_callback+0x28>
  1017f5:	eb 23                	jmp    10181a <gpio_dw_manage_callback+0x59>
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node)
{
	if (!prev_node) {
  1017f7:	85 db                	test   %ebx,%ebx
  1017f9:	8b 0a                	mov    (%edx),%ecx
  1017fb:	75 0d                	jne    10180a <gpio_dw_manage_callback+0x49>
		list->head = node->next;
  1017fd:	89 48 18             	mov    %ecx,0x18(%eax)

		/* Was node also the tail? */
		if (list->tail == node) {
  101800:	3b 50 1c             	cmp    0x1c(%eax),%edx
  101803:	75 0f                	jne    101814 <gpio_dw_manage_callback+0x53>
			list->tail = list->head;
  101805:	89 48 1c             	mov    %ecx,0x1c(%eax)
  101808:	eb 0a                	jmp    101814 <gpio_dw_manage_callback+0x53>
		}
	} else {
		prev_node->next = node->next;
  10180a:	89 0b                	mov    %ecx,(%ebx)

		/* Was node the tail? */
		if (list->tail == node) {
  10180c:	3b 50 1c             	cmp    0x1c(%eax),%edx
  10180f:	75 03                	jne    101814 <gpio_dw_manage_callback+0x53>
			list->tail = prev_node;
  101811:	89 58 1c             	mov    %ebx,0x1c(%eax)
		}
	}

	node->next = NULL;
  101814:	c7 02 00 00 00 00    	movl   $0x0,(%edx)

	_gpio_manage_callback(&context->callbacks, callback, set);

	return 0;
}
  10181a:	31 c0                	xor    %eax,%eax
  10181c:	5b                   	pop    %ebx
  10181d:	5d                   	pop    %ebp
  10181e:	c3                   	ret    

0010181f <gpio_dw_enable_callback>:

static inline int gpio_dw_enable_callback(struct device *port, int access_op,
					  uint32_t pin)
{
  10181f:	55                   	push   %ebp
  101820:	89 e5                	mov    %esp,%ebp
  101822:	8b 55 08             	mov    0x8(%ebp),%edx
  101825:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const struct gpio_dw_config *config = port->config->config_info;
	struct gpio_dw_runtime *context = port->driver_data;
	uint32_t base_addr = dw_base_to_block_base(context->base_addr);
  101828:	8b 42 08             	mov    0x8(%edx),%eax
  10182b:	8b 00                	mov    (%eax),%eax
  10182d:	83 e0 c0             	and    $0xffffffc0,%eax

	if (GPIO_ACCESS_BY_PIN == access_op) {
  101830:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  101834:	75 19                	jne    10184f <gpio_dw_enable_callback+0x30>
		dw_write(base_addr, PORTA_EOI, BIT(pin));
  101836:	ba 01 00 00 00       	mov    $0x1,%edx
  10183b:	d3 e2                	shl    %cl,%edx
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  10183d:	89 50 4c             	mov    %edx,0x4c(%eax)
		dw_set_bit(base_addr, INTMASK, pin, 0);
  101840:	ba 34 00 00 00       	mov    $0x34,%edx
  101845:	6a 00                	push   $0x0
  101847:	e8 e5 fe ff ff       	call   101731 <dw_set_bit>
  10184c:	58                   	pop    %eax
  10184d:	eb 17                	jmp    101866 <gpio_dw_enable_callback+0x47>
}

static inline int gpio_dw_enable_callback(struct device *port, int access_op,
					  uint32_t pin)
{
	const struct gpio_dw_config *config = port->config->config_info;
  10184f:	8b 12                	mov    (%edx),%edx

	if (GPIO_ACCESS_BY_PIN == access_op) {
		dw_write(base_addr, PORTA_EOI, BIT(pin));
		dw_set_bit(base_addr, INTMASK, pin, 0);
	} else {
		dw_write(base_addr, PORTA_EOI, BIT_MASK(config->bits));
  101851:	8b 52 08             	mov    0x8(%edx),%edx
  101854:	8b 0a                	mov    (%edx),%ecx
  101856:	ba 01 00 00 00       	mov    $0x1,%edx
  10185b:	d3 e2                	shl    %cl,%edx
  10185d:	4a                   	dec    %edx
  10185e:	89 50 4c             	mov    %edx,0x4c(%eax)
  101861:	31 d2                	xor    %edx,%edx
  101863:	89 50 34             	mov    %edx,0x34(%eax)
		dw_write(base_addr, INTMASK, 0);
	}

	return 0;
}
  101866:	31 c0                	xor    %eax,%eax
  101868:	c9                   	leave  
  101869:	c3                   	ret    

0010186a <gpio_dw_disable_callback>:

static inline int gpio_dw_disable_callback(struct device *port, int access_op,
					   uint32_t pin)
{
  10186a:	55                   	push   %ebp
  10186b:	89 e5                	mov    %esp,%ebp
  10186d:	8b 55 08             	mov    0x8(%ebp),%edx
	const struct gpio_dw_config *config = port->config->config_info;
	struct gpio_dw_runtime *context = port->driver_data;
	uint32_t base_addr = dw_base_to_block_base(context->base_addr);
  101870:	8b 42 08             	mov    0x8(%edx),%eax
  101873:	8b 00                	mov    (%eax),%eax
  101875:	83 e0 c0             	and    $0xffffffc0,%eax

	if (GPIO_ACCESS_BY_PIN == access_op) {
  101878:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10187c:	75 12                	jne    101890 <gpio_dw_disable_callback+0x26>
		dw_set_bit(base_addr, INTMASK, pin, 1);
  10187e:	8b 4d 10             	mov    0x10(%ebp),%ecx
  101881:	ba 34 00 00 00       	mov    $0x34,%edx
  101886:	6a 01                	push   $0x1
  101888:	e8 a4 fe ff ff       	call   101731 <dw_set_bit>
  10188d:	58                   	pop    %eax
  10188e:	eb 12                	jmp    1018a2 <gpio_dw_disable_callback+0x38>
}

static inline int gpio_dw_disable_callback(struct device *port, int access_op,
					   uint32_t pin)
{
	const struct gpio_dw_config *config = port->config->config_info;
  101890:	8b 12                	mov    (%edx),%edx
	uint32_t base_addr = dw_base_to_block_base(context->base_addr);

	if (GPIO_ACCESS_BY_PIN == access_op) {
		dw_set_bit(base_addr, INTMASK, pin, 1);
	} else {
		dw_write(base_addr, INTMASK, BIT_MASK(config->bits));
  101892:	8b 52 08             	mov    0x8(%edx),%edx
  101895:	8b 0a                	mov    (%edx),%ecx
  101897:	ba 01 00 00 00       	mov    $0x1,%edx
  10189c:	d3 e2                	shl    %cl,%edx
  10189e:	4a                   	dec    %edx
  10189f:	89 50 34             	mov    %edx,0x34(%eax)
	}

	return 0;
}
  1018a2:	31 c0                	xor    %eax,%eax
  1018a4:	c9                   	leave  
  1018a5:	c3                   	ret    

001018a6 <gpio_dw_isr>:
#else
#define gpio_dw_unmask_int(...)
#endif

static void gpio_dw_isr(void *arg)
{
  1018a6:	55                   	push   %ebp
  1018a7:	89 e5                	mov    %esp,%ebp
  1018a9:	57                   	push   %edi
  1018aa:	56                   	push   %esi
  1018ab:	53                   	push   %ebx
  1018ac:	8b 7d 08             	mov    0x8(%ebp),%edi
	struct device *port = (struct device *)arg;
	struct gpio_dw_runtime *context = port->driver_data;
  1018af:	8b 57 08             	mov    0x8(%edi),%edx
	uint32_t base_addr = dw_base_to_block_base(context->base_addr);
  1018b2:	8b 02                	mov    (%edx),%eax
  1018b4:	83 e0 c0             	and    $0xffffffc0,%eax
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  1018b7:	8b 70 40             	mov    0x40(%eax),%esi
#ifdef CONFIG_SHARED_IRQ
	/* If using with shared IRQ, this function will be called
	 * by the shared IRQ driver. So check here if the interrupt
	 * is coming from the GPIO controller (or somewhere else).
	 */
	if (!int_status) {
  1018ba:	85 f6                	test   %esi,%esi
  1018bc:	74 1c                	je     1018da <gpio_dw_isr+0x34>
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  1018be:	89 70 4c             	mov    %esi,0x4c(%eax)
  1018c1:	8b 5a 18             	mov    0x18(%edx),%ebx
					uint32_t pins)
{
	struct gpio_callback *cb;
	sys_snode_t *node;

	SYS_SLIST_FOR_EACH_NODE(list, node) {
  1018c4:	85 db                	test   %ebx,%ebx
  1018c6:	74 12                	je     1018da <gpio_dw_isr+0x34>
		cb = (struct gpio_callback *)node;

		if (cb->pin_mask & pins) {
  1018c8:	85 73 08             	test   %esi,0x8(%ebx)
  1018cb:	74 09                	je     1018d6 <gpio_dw_isr+0x30>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, pins);
  1018cd:	56                   	push   %esi
  1018ce:	53                   	push   %ebx
  1018cf:	57                   	push   %edi
  1018d0:	ff 53 04             	call   *0x4(%ebx)
  1018d3:	83 c4 0c             	add    $0xc,%esp
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node)
{
	return !node ? NULL : node->next;
  1018d6:	8b 1b                	mov    (%ebx),%ebx
  1018d8:	eb ea                	jmp    1018c4 <gpio_dw_isr+0x1e>
#endif

	dw_write(base_addr, PORTA_EOI, int_status);

	_gpio_fire_callbacks(&context->callbacks, port, int_status);
}
  1018da:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1018dd:	5b                   	pop    %ebx
  1018de:	5e                   	pop    %esi
  1018df:	5f                   	pop    %edi
  1018e0:	5d                   	pop    %ebp
  1018e1:	c3                   	ret    

001018e2 <dw_pin_config>:
	}
}

static inline void dw_pin_config(struct device *port,
				 uint32_t pin, int flags)
{
  1018e2:	55                   	push   %ebp
  1018e3:	89 e5                	mov    %esp,%ebp
  1018e5:	57                   	push   %edi
  1018e6:	56                   	push   %esi
  1018e7:	53                   	push   %ebx
  1018e8:	83 ec 08             	sub    $0x8,%esp
  1018eb:	89 c6                	mov    %eax,%esi
	struct gpio_dw_runtime *context = port->driver_data;
	const struct gpio_dw_config *config = port->config->config_info;
	uint32_t base_addr = dw_base_to_block_base(context->base_addr);
  1018ed:	8b 40 08             	mov    0x8(%eax),%eax
	}
}

static inline void dw_pin_config(struct device *port,
				 uint32_t pin, int flags)
{
  1018f0:	89 d7                	mov    %edx,%edi
  1018f2:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	struct gpio_dw_runtime *context = port->driver_data;
	const struct gpio_dw_config *config = port->config->config_info;
	uint32_t base_addr = dw_base_to_block_base(context->base_addr);
  1018f5:	8b 00                	mov    (%eax),%eax
  1018f7:	89 45 ec             	mov    %eax,-0x14(%ebp)

static inline void dw_pin_config(struct device *port,
				 uint32_t pin, int flags)
{
	struct gpio_dw_runtime *context = port->driver_data;
	const struct gpio_dw_config *config = port->config->config_info;
  1018fa:	8b 06                	mov    (%esi),%eax
  1018fc:	8b 40 08             	mov    0x8(%eax),%eax
	uint32_t port = (base_addr & 0x3f) / 12;
	return port;
}
static inline int dw_interrupt_support(const struct gpio_dw_config *config)
{
	return ((int)(config->irq_num) > 0);
  1018ff:	8b 58 04             	mov    0x4(%eax),%ebx
	const struct gpio_dw_config *config = port->config->config_info;
	uint32_t base_addr = dw_base_to_block_base(context->base_addr);
	uint32_t port_base_addr = context->base_addr;
	int interrupt_support = dw_interrupt_support(config);

	if (interrupt_support) {
  101902:	85 db                	test   %ebx,%ebx
  101904:	7e 15                	jle    10191b <dw_pin_config+0x39>
		/* clear interrupt enable */
		dw_set_bit(base_addr, INTEN, pin, 0);
  101906:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101909:	89 d1                	mov    %edx,%ecx
  10190b:	83 e0 c0             	and    $0xffffffc0,%eax
  10190e:	ba 30 00 00 00       	mov    $0x30,%edx
  101913:	6a 00                	push   $0x0
  101915:	e8 17 fe ff ff       	call   101731 <dw_set_bit>
  10191a:	58                   	pop    %eax
	}

	/* set direction */
	dw_set_bit(port_base_addr, SWPORTA_DDR, pin, (flags & GPIO_DIR_MASK));
  10191b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10191e:	89 f9                	mov    %edi,%ecx
  101920:	83 e0 01             	and    $0x1,%eax
  101923:	ba 04 00 00 00       	mov    $0x4,%edx
  101928:	50                   	push   %eax
  101929:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10192c:	e8 00 fe ff ff       	call   101731 <dw_set_bit>
  101931:	58                   	pop    %eax

	if (interrupt_support && (flags & GPIO_INT)) {
  101932:	85 db                	test   %ebx,%ebx
  101934:	0f 8e c0 00 00 00    	jle    1019fa <dw_pin_config+0x118>
  10193a:	f6 45 f0 02          	testb  $0x2,-0x10(%ebp)
  10193e:	0f 84 b6 00 00 00    	je     1019fa <dw_pin_config+0x118>

static inline void dw_interrupt_config(struct device *port, int access_op,
				       uint32_t pin, int flags)
{
	struct gpio_dw_runtime *context = port->driver_data;
	const struct gpio_dw_config *config = port->config->config_info;
  101944:	8b 06                	mov    (%esi),%eax
	uint32_t base_addr = dw_base_to_block_base(context->base_addr);
	uint8_t flag_is_set;

	/* set as an input pin */
	dw_set_bit(context->base_addr, SWPORTA_DDR, pin, 0);
  101946:	89 f9                	mov    %edi,%ecx
  101948:	ba 04 00 00 00       	mov    $0x4,%edx

static inline void dw_interrupt_config(struct device *port, int access_op,
				       uint32_t pin, int flags)
{
	struct gpio_dw_runtime *context = port->driver_data;
	const struct gpio_dw_config *config = port->config->config_info;
  10194d:	8b 58 08             	mov    0x8(%eax),%ebx
	uint32_t base_addr = dw_base_to_block_base(context->base_addr);
  101950:	8b 46 08             	mov    0x8(%esi),%eax
  101953:	8b 30                	mov    (%eax),%esi
	uint8_t flag_is_set;

	/* set as an input pin */
	dw_set_bit(context->base_addr, SWPORTA_DDR, pin, 0);
  101955:	6a 00                	push   $0x0
  101957:	89 f0                	mov    %esi,%eax
  101959:	e8 d3 fd ff ff       	call   101731 <dw_set_bit>
  10195e:	58                   	pop    %eax

	if (dw_interrupt_support(config)) {
  10195f:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  101963:	0f 8e 91 00 00 00    	jle    1019fa <dw_pin_config+0x118>

		/* level or edge */
		flag_is_set = (flags & GPIO_INT_EDGE);
		dw_set_bit(base_addr, INTTYPE_LEVEL, pin, flag_is_set);
  101969:	8a 45 f0             	mov    -0x10(%ebp),%al
static inline void dw_interrupt_config(struct device *port, int access_op,
				       uint32_t pin, int flags)
{
	struct gpio_dw_runtime *context = port->driver_data;
	const struct gpio_dw_config *config = port->config->config_info;
	uint32_t base_addr = dw_base_to_block_base(context->base_addr);
  10196c:	83 e6 c0             	and    $0xffffffc0,%esi

	if (dw_interrupt_support(config)) {

		/* level or edge */
		flag_is_set = (flags & GPIO_INT_EDGE);
		dw_set_bit(base_addr, INTTYPE_LEVEL, pin, flag_is_set);
  10196f:	83 e0 20             	and    $0x20,%eax
  101972:	89 f9                	mov    %edi,%ecx
  101974:	0f b6 c0             	movzbl %al,%eax
  101977:	50                   	push   %eax
  101978:	ba 38 00 00 00       	mov    $0x38,%edx
  10197d:	89 f0                	mov    %esi,%eax
  10197f:	e8 ad fd ff ff       	call   101731 <dw_set_bit>

		/* Active low/high */
		flag_is_set = (flags & GPIO_INT_ACTIVE_HIGH);
		dw_set_bit(base_addr, INT_POLARITY, pin, flag_is_set);
  101984:	8a 45 f0             	mov    -0x10(%ebp),%al
  101987:	83 e0 04             	and    $0x4,%eax
  10198a:	89 f9                	mov    %edi,%ecx
  10198c:	0f b6 c0             	movzbl %al,%eax
  10198f:	89 04 24             	mov    %eax,(%esp)
  101992:	ba 3c 00 00 00       	mov    $0x3c,%edx
  101997:	89 f0                	mov    %esi,%eax
  101999:	e8 93 fd ff ff       	call   101731 <dw_set_bit>

		/* both edges */
		flag_is_set = (flags & GPIO_INT_DOUBLE_EDGE);
		if (flag_is_set) {
  10199e:	8a 5d f0             	mov    -0x10(%ebp),%bl
  1019a1:	80 e3 40             	and    $0x40,%bl
		flag_is_set = (flags & GPIO_INT_EDGE);
		dw_set_bit(base_addr, INTTYPE_LEVEL, pin, flag_is_set);

		/* Active low/high */
		flag_is_set = (flags & GPIO_INT_ACTIVE_HIGH);
		dw_set_bit(base_addr, INT_POLARITY, pin, flag_is_set);
  1019a4:	59                   	pop    %ecx

		/* both edges */
		flag_is_set = (flags & GPIO_INT_DOUBLE_EDGE);
		if (flag_is_set) {
  1019a5:	74 25                	je     1019cc <dw_pin_config+0xea>
	return 1;
}
#else
static inline void dw_set_both_edges(uint32_t base_addr, uint32_t pin)
{
	dw_set_bit(base_addr, INT_BOTHEDGE, pin, 1);
  1019a7:	89 f9                	mov    %edi,%ecx
  1019a9:	ba 68 00 00 00       	mov    $0x68,%edx
  1019ae:	89 f0                	mov    %esi,%eax
  1019b0:	6a 01                	push   $0x1

		/* both edges */
		flag_is_set = (flags & GPIO_INT_DOUBLE_EDGE);
		if (flag_is_set) {
			dw_set_both_edges(base_addr, pin);
			dw_set_bit(base_addr, INTTYPE_LEVEL, pin, flag_is_set);
  1019b2:	0f b6 db             	movzbl %bl,%ebx
	return 1;
}
#else
static inline void dw_set_both_edges(uint32_t base_addr, uint32_t pin)
{
	dw_set_bit(base_addr, INT_BOTHEDGE, pin, 1);
  1019b5:	e8 77 fd ff ff       	call   101731 <dw_set_bit>

		/* both edges */
		flag_is_set = (flags & GPIO_INT_DOUBLE_EDGE);
		if (flag_is_set) {
			dw_set_both_edges(base_addr, pin);
			dw_set_bit(base_addr, INTTYPE_LEVEL, pin, flag_is_set);
  1019ba:	ba 38 00 00 00       	mov    $0x38,%edx
  1019bf:	89 f9                	mov    %edi,%ecx
  1019c1:	89 f0                	mov    %esi,%eax
  1019c3:	89 1c 24             	mov    %ebx,(%esp)
  1019c6:	e8 66 fd ff ff       	call   101731 <dw_set_bit>
  1019cb:	5a                   	pop    %edx
		}

		/* use built-in debounce  */
		flag_is_set = (flags & GPIO_INT_DEBOUNCE);
		dw_set_bit(base_addr, PORTA_DEBOUNCE, pin, flag_is_set);
  1019cc:	8a 45 f0             	mov    -0x10(%ebp),%al
  1019cf:	89 f9                	mov    %edi,%ecx
  1019d1:	83 e0 10             	and    $0x10,%eax
  1019d4:	ba 48 00 00 00       	mov    $0x48,%edx
  1019d9:	0f b6 c0             	movzbl %al,%eax
  1019dc:	50                   	push   %eax
  1019dd:	89 f0                	mov    %esi,%eax
  1019df:	e8 4d fd ff ff       	call   101731 <dw_set_bit>

		/* Finally enabling interrupt */
		dw_set_bit(base_addr, INTEN, pin, 1);
  1019e4:	89 f0                	mov    %esi,%eax
  1019e6:	89 f9                	mov    %edi,%ecx
  1019e8:	ba 30 00 00 00       	mov    $0x30,%edx
  1019ed:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1019f4:	e8 38 fd ff ff       	call   101731 <dw_set_bit>
  1019f9:	58                   	pop    %eax
	dw_set_bit(port_base_addr, SWPORTA_DDR, pin, (flags & GPIO_DIR_MASK));

	if (interrupt_support && (flags & GPIO_INT)) {
		dw_interrupt_config(port, GPIO_ACCESS_BY_PIN, pin, flags);
	}
}
  1019fa:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1019fd:	5b                   	pop    %ebx
  1019fe:	5e                   	pop    %esi
  1019ff:	5f                   	pop    %edi
  101a00:	5d                   	pop    %ebp
  101a01:	c3                   	ret    

00101a02 <gpio_dw_config>:
	}
}

static inline int gpio_dw_config(struct device *port, int access_op,
				 uint32_t pin, int flags)
{
  101a02:	55                   	push   %ebp
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
		return -1;
  101a03:	83 c8 ff             	or     $0xffffffff,%eax
	}
}

static inline int gpio_dw_config(struct device *port, int access_op,
				 uint32_t pin, int flags)
{
  101a06:	89 e5                	mov    %esp,%ebp
  101a08:	57                   	push   %edi
  101a09:	56                   	push   %esi
  101a0a:	53                   	push   %ebx
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
  101a0b:	8b 55 14             	mov    0x14(%ebp),%edx
	}
}

static inline int gpio_dw_config(struct device *port, int access_op,
				 uint32_t pin, int flags)
{
  101a0e:	8b 75 08             	mov    0x8(%ebp),%esi
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
  101a11:	83 e2 03             	and    $0x3,%edx
  101a14:	83 fa 03             	cmp    $0x3,%edx
  101a17:	74 31                	je     101a4a <gpio_dw_config+0x48>
		return -1;
	}

	if (GPIO_ACCESS_BY_PIN == access_op) {
  101a19:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  101a1d:	75 0f                	jne    101a2e <gpio_dw_config+0x2c>
		dw_pin_config(port, pin, flags);
  101a1f:	8b 4d 14             	mov    0x14(%ebp),%ecx
  101a22:	8b 55 10             	mov    0x10(%ebp),%edx
  101a25:	89 f0                	mov    %esi,%eax
  101a27:	e8 b6 fe ff ff       	call   1018e2 <dw_pin_config>
  101a2c:	eb 1a                	jmp    101a48 <gpio_dw_config+0x46>
	}
}

static inline void dw_port_config(struct device *port, int flags)
{
	const struct gpio_dw_config *config = port->config->config_info;
  101a2e:	8b 06                	mov    (%esi),%eax
	int i;

	for (i = 0; i < config->bits; i++) {
  101a30:	31 db                	xor    %ebx,%ebx
	}
}

static inline void dw_port_config(struct device *port, int flags)
{
	const struct gpio_dw_config *config = port->config->config_info;
  101a32:	8b 78 08             	mov    0x8(%eax),%edi
	int i;

	for (i = 0; i < config->bits; i++) {
  101a35:	3b 1f                	cmp    (%edi),%ebx
  101a37:	73 0f                	jae    101a48 <gpio_dw_config+0x46>
		dw_pin_config(port, i, flags);
  101a39:	89 da                	mov    %ebx,%edx
  101a3b:	8b 4d 14             	mov    0x14(%ebp),%ecx
  101a3e:	89 f0                	mov    %esi,%eax
static inline void dw_port_config(struct device *port, int flags)
{
	const struct gpio_dw_config *config = port->config->config_info;
	int i;

	for (i = 0; i < config->bits; i++) {
  101a40:	43                   	inc    %ebx
		dw_pin_config(port, i, flags);
  101a41:	e8 9c fe ff ff       	call   1018e2 <dw_pin_config>
  101a46:	eb ed                	jmp    101a35 <gpio_dw_config+0x33>
	if (GPIO_ACCESS_BY_PIN == access_op) {
		dw_pin_config(port, pin, flags);
	} else {
		dw_port_config(port, flags);
	}
	return 0;
  101a48:	31 c0                	xor    %eax,%eax
}
  101a4a:	5b                   	pop    %ebx
  101a4b:	5e                   	pop    %esi
  101a4c:	5f                   	pop    %edi
  101a4d:	5d                   	pop    %ebp
  101a4e:	c3                   	ret    

00101a4f <gpio_dw_initialize>:
#define gpio_dw_setup(_unused_) (1)
#endif /* CONFIG_PCI */


static int gpio_dw_initialize(struct device *port)
{
  101a4f:	55                   	push   %ebp
  101a50:	89 e5                	mov    %esp,%ebp
  101a52:	57                   	push   %edi
  101a53:	56                   	push   %esi
  101a54:	53                   	push   %ebx
  101a55:	51                   	push   %ecx
  101a56:	8b 75 08             	mov    0x8(%ebp),%esi
	struct gpio_dw_runtime *context = port->driver_data;
	const struct gpio_dw_config *config = port->config->config_info;
  101a59:	8b 06                	mov    (%esi),%eax
#endif /* CONFIG_PCI */


static int gpio_dw_initialize(struct device *port)
{
	struct gpio_dw_runtime *context = port->driver_data;
  101a5b:	8b 5e 08             	mov    0x8(%esi),%ebx
	const struct gpio_dw_config *config = port->config->config_info;
  101a5e:	8b 78 08             	mov    0x8(%eax),%edi
#ifdef CONFIG_PCI
static inline int gpio_dw_setup(struct device *dev)
{
	struct gpio_dw_runtime *context = dev->driver_data;

	pci_bus_scan_init();
  101a61:	e8 3a ef ff ff       	call   1009a0 <pci_bus_scan_init>

	if (!pci_bus_scan(&context->pci_dev)) {
  101a66:	8d 53 04             	lea    0x4(%ebx),%edx
  101a69:	52                   	push   %edx
  101a6a:	89 55 f0             	mov    %edx,-0x10(%ebp)
  101a6d:	e8 9c ef ff ff       	call   100a0e <pci_bus_scan>
  101a72:	5a                   	pop    %edx
  101a73:	85 c0                	test   %eax,%eax
  101a75:	8b 55 f0             	mov    -0x10(%ebp),%edx
  101a78:	74 42                	je     101abc <gpio_dw_initialize+0x6d>
		return 0;
	}

#ifdef CONFIG_PCI_ENUMERATION
	context->base_addr = context->pci_dev.addr;
  101a7a:	8b 43 04             	mov    0x4(%ebx),%eax
  101a7d:	89 03                	mov    %eax,(%ebx)
#endif
	pci_enable_regs(&context->pci_dev);
  101a7f:	52                   	push   %edx
  101a80:	e8 5a f5 ff ff       	call   100fdf <pci_enable_regs>
		config->config_func(port);
	}

	gpio_dw_set_power_state(port, DEVICE_PM_ACTIVE_STATE);

	return 0;
  101a85:	31 c0                	xor    %eax,%eax
	}

#ifdef CONFIG_PCI_ENUMERATION
	context->base_addr = context->pci_dev.addr;
#endif
	pci_enable_regs(&context->pci_dev);
  101a87:	5a                   	pop    %edx
	if (!gpio_dw_setup(port)) {
		port->driver_api = NULL;
		return -EPERM;
	}

	if (dw_interrupt_support(config)) {
  101a88:	83 7f 04 00          	cmpl   $0x0,0x4(%edi)
  101a8c:	7e 38                	jle    101ac6 <gpio_dw_initialize+0x77>

		base_addr = dw_base_to_block_base(context->base_addr);
  101a8e:	8b 1b                	mov    (%ebx),%ebx
		/* Need to enable clock for GPIO controller */
		dw_set_bit(base_addr, INT_CLOCK_SYNC, CLK_ENA_POS, 1);
#endif /* CONFIG_SOC_QUARK_SE_C1000_SS */

		/* interrupts in sync with system clock */
		dw_set_bit(base_addr, INT_CLOCK_SYNC, LS_SYNC_POS, 1);
  101a90:	31 c9                	xor    %ecx,%ecx
		return -EPERM;
	}

	if (dw_interrupt_support(config)) {

		base_addr = dw_base_to_block_base(context->base_addr);
  101a92:	83 e3 c0             	and    $0xffffffc0,%ebx
		/* Need to enable clock for GPIO controller */
		dw_set_bit(base_addr, INT_CLOCK_SYNC, CLK_ENA_POS, 1);
#endif /* CONFIG_SOC_QUARK_SE_C1000_SS */

		/* interrupts in sync with system clock */
		dw_set_bit(base_addr, INT_CLOCK_SYNC, LS_SYNC_POS, 1);
  101a95:	ba 60 00 00 00       	mov    $0x60,%edx
  101a9a:	89 d8                	mov    %ebx,%eax
  101a9c:	6a 01                	push   $0x1
  101a9e:	e8 8e fc ff ff       	call   101731 <dw_set_bit>
  101aa3:	83 c8 ff             	or     $0xffffffff,%eax
  101aa6:	89 43 34             	mov    %eax,0x34(%ebx)
  101aa9:	31 d2                	xor    %edx,%edx
  101aab:	89 53 30             	mov    %edx,0x30(%ebx)
  101aae:	89 43 4c             	mov    %eax,0x4c(%ebx)
		/* mask and disable interrupts */
		dw_write(base_addr, INTMASK, ~(0));
		dw_write(base_addr, INTEN, 0);
		dw_write(base_addr, PORTA_EOI, ~(0));

		config->config_func(port);
  101ab1:	89 34 24             	mov    %esi,(%esp)
  101ab4:	ff 57 08             	call   *0x8(%edi)
  101ab7:	58                   	pop    %eax
	}

	gpio_dw_set_power_state(port, DEVICE_PM_ACTIVE_STATE);

	return 0;
  101ab8:	31 c0                	xor    %eax,%eax
  101aba:	eb 0a                	jmp    101ac6 <gpio_dw_initialize+0x77>
	struct gpio_dw_runtime *context = port->driver_data;
	const struct gpio_dw_config *config = port->config->config_info;
	uint32_t base_addr;

	if (!gpio_dw_setup(port)) {
		port->driver_api = NULL;
  101abc:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
		return -EPERM;
  101ac3:	83 c8 ff             	or     $0xffffffff,%eax
	}

	gpio_dw_set_power_state(port, DEVICE_PM_ACTIVE_STATE);

	return 0;
}
  101ac6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101ac9:	5b                   	pop    %ebx
  101aca:	5e                   	pop    %esi
  101acb:	5f                   	pop    %edi
  101acc:	5d                   	pop    %ebp
  101acd:	c3                   	ret    

00101ace <gpio_config_0_irq>:
		    POST_KERNEL, CONFIG_GPIO_DW_INIT_PRIORITY,
		    &api_funcs);
#endif

static void gpio_config_0_irq(struct device *port)
{
  101ace:	55                   	push   %ebp
  101acf:	89 e5                	mov    %esp,%ebp
  101ad1:	56                   	push   %esi
  101ad2:	53                   	push   %ebx
  101ad3:	8b 75 08             	mov    0x8(%ebp),%esi
#if (GPIO_DW_0_IRQ > 0)
	const struct gpio_dw_config *config = port->config->config_info;
  101ad6:	8b 06                	mov    (%esi),%eax
		    DEVICE_GET(gpio_dw_0), GPIO_DW_0_IRQ_FLAGS);
	irq_enable(config->irq_num);
#elif defined(CONFIG_GPIO_DW_0_IRQ_SHARED)
	struct device *shared_irq_dev;

	shared_irq_dev = device_get_binding(config->shared_irq_dev_name);
  101ad8:	8b 40 08             	mov    0x8(%eax),%eax
  101adb:	ff 70 0c             	pushl  0xc(%eax)
  101ade:	e8 04 1c 00 00       	call   1036e7 <device_get_binding>
  101ae3:	89 c3                	mov    %eax,%ebx
static inline int shared_irq_isr_register(struct device *dev, isr_t isr_func,
				 struct device *isr_dev)
{
	const struct shared_irq_driver_api *api = dev->driver_api;

	return api->isr_register(dev, isr_func, isr_dev);
  101ae5:	8b 40 04             	mov    0x4(%eax),%eax
  101ae8:	89 34 24             	mov    %esi,(%esp)
  101aeb:	68 a6 18 10 00       	push   $0x1018a6
  101af0:	53                   	push   %ebx
  101af1:	ff 10                	call   *(%eax)
  101af3:	83 c4 0c             	add    $0xc,%esp
 */
static inline int shared_irq_enable(struct device *dev, struct device *isr_dev)
{
	const struct shared_irq_driver_api *api = dev->driver_api;

	return api->enable(dev, isr_dev);
  101af6:	8b 43 04             	mov    0x4(%ebx),%eax
  101af9:	56                   	push   %esi
  101afa:	53                   	push   %ebx
  101afb:	ff 50 04             	call   *0x4(%eax)
  101afe:	58                   	pop    %eax
  101aff:	5a                   	pop    %edx
	shared_irq_isr_register(shared_irq_dev, (isr_t)gpio_dw_isr, port);
	shared_irq_enable(shared_irq_dev, port);
#endif
	gpio_dw_unmask_int(GPIO_DW_PORT_0_INT_MASK);
#endif
}
  101b00:	8d 65 f8             	lea    -0x8(%ebp),%esp
  101b03:	5b                   	pop    %ebx
  101b04:	5e                   	pop    %esi
  101b05:	5d                   	pop    %ebp
  101b06:	c3                   	ret    

00101b07 <gpio_pcal9535a_manage_callback>:
}

static int gpio_pcal9535a_manage_callback(struct device *dev,
					  struct gpio_callback *callback,
					  bool set)
{
  101b07:	55                   	push   %ebp
	ARG_UNUSED(dev);
	ARG_UNUSED(callback);
	ARG_UNUSED(set);

	return -ENOTSUP;
}
  101b08:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
}

static int gpio_pcal9535a_manage_callback(struct device *dev,
					  struct gpio_callback *callback,
					  bool set)
{
  101b0d:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(dev);
	ARG_UNUSED(callback);
	ARG_UNUSED(set);

	return -ENOTSUP;
}
  101b0f:	5d                   	pop    %ebp
  101b10:	c3                   	ret    

00101b11 <gpio_pcal9535a_disable_callback>:
	return -ENOTSUP;
}

static int gpio_pcal9535a_disable_callback(struct device *dev,
					   int access_op, uint32_t pin)
{
  101b11:	55                   	push   %ebp
	ARG_UNUSED(dev);
	ARG_UNUSED(access_op);
	ARG_UNUSED(pin);

	return -ENOTSUP;
}
  101b12:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
	return -ENOTSUP;
}

static int gpio_pcal9535a_disable_callback(struct device *dev,
					   int access_op, uint32_t pin)
{
  101b17:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(dev);
	ARG_UNUSED(access_op);
	ARG_UNUSED(pin);

	return -ENOTSUP;
}
  101b19:	5d                   	pop    %ebp
  101b1a:	c3                   	ret    

00101b1b <gpio_pcal9535a_read>:
 *
 * @return 0 if successful, failed otherwise
 */
static int gpio_pcal9535a_read(struct device *dev, int access_op,
			       uint32_t pin, uint32_t *value)
{
  101b1b:	55                   	push   %ebp
  101b1c:	89 e5                	mov    %esp,%ebp
  101b1e:	57                   	push   %edi
  101b1f:	56                   	push   %esi
  101b20:	53                   	push   %ebx
  101b21:	83 ec 1c             	sub    $0x1c,%esp
  101b24:	8b 55 08             	mov    0x8(%ebp),%edx
  101b27:	8b 75 0c             	mov    0xc(%ebp),%esi
  101b2a:	8b 5d 14             	mov    0x14(%ebp),%ebx
 */
static inline int _has_i2c_master(struct device *dev)
{
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	struct device * const i2c_master = drv_data->i2c_master;
  101b2d:	8b 42 08             	mov    0x8(%edx),%eax
  101b30:	8b 00                	mov    (%eax),%eax

	if (i2c_master)
  101b32:	85 c0                	test   %eax,%eax
  101b34:	75 07                	jne    101b3d <gpio_pcal9535a_read+0x22>
{
	union gpio_pcal9535a_port_data buf;
	int ret;

	if (!_has_i2c_master(dev)) {
		return -EINVAL;
  101b36:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  101b3b:	eb 66                	jmp    101ba3 <gpio_pcal9535a_read+0x88>
 * @return 0 if successful, failed otherwise.
 */
static int _read_port_regs(struct device *dev, uint8_t reg,
			   union gpio_pcal9535a_port_data *buf)
{
	const struct gpio_pcal9535a_config * const config =
  101b3d:	8b 12                	mov    (%edx),%edx
				 uint8_t num_bytes)
{
	const struct i2c_driver_api *api = dev->driver_api;
	struct i2c_msg msg[2];

	msg[0].buf = &start_addr;
  101b3f:	8d 7d d9             	lea    -0x27(%ebp),%edi
 */
static inline int i2c_burst_read(struct device *dev, uint16_t dev_addr,
				 uint8_t start_addr, uint8_t *buf,
				 uint8_t num_bytes)
{
	const struct i2c_driver_api *api = dev->driver_api;
  101b42:	8b 48 04             	mov    0x4(%eax),%ecx
	struct i2c_msg msg[2];

	msg[0].buf = &start_addr;
  101b45:	89 7d dc             	mov    %edi,-0x24(%ebp)
		dev->config->config_info;
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	struct device * const i2c_master = drv_data->i2c_master;
	uint16_t i2c_addr = config->i2c_slave_addr;
  101b48:	8b 52 08             	mov    0x8(%edx),%edx
	msg[0].len = 1;
	msg[0].flags = I2C_MSG_WRITE;

	msg[1].buf = buf;
  101b4b:	8d 7d da             	lea    -0x26(%ebp),%edi
  101b4e:	c6 45 d9 00          	movb   $0x0,-0x27(%ebp)
  101b52:	0f b7 52 04          	movzwl 0x4(%edx),%edx
{
	const struct i2c_driver_api *api = dev->driver_api;
	struct i2c_msg msg[2];

	msg[0].buf = &start_addr;
	msg[0].len = 1;
  101b56:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	msg[1].buf = buf;
	msg[1].len = num_bytes;
	msg[1].flags = I2C_MSG_RESTART | I2C_MSG_READ | I2C_MSG_STOP;

	return api->transfer(dev, msg, 2, dev_addr);
  101b5d:	52                   	push   %edx
	const struct i2c_driver_api *api = dev->driver_api;
	struct i2c_msg msg[2];

	msg[0].buf = &start_addr;
	msg[0].len = 1;
	msg[0].flags = I2C_MSG_WRITE;
  101b5e:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)

	msg[1].buf = buf;
	msg[1].len = num_bytes;
	msg[1].flags = I2C_MSG_RESTART | I2C_MSG_READ | I2C_MSG_STOP;

	return api->transfer(dev, msg, 2, dev_addr);
  101b62:	8d 55 dc             	lea    -0x24(%ebp),%edx

	msg[0].buf = &start_addr;
	msg[0].len = 1;
	msg[0].flags = I2C_MSG_WRITE;

	msg[1].buf = buf;
  101b65:	89 7d e8             	mov    %edi,-0x18(%ebp)
	msg[1].len = num_bytes;
  101b68:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)
	msg[1].flags = I2C_MSG_RESTART | I2C_MSG_READ | I2C_MSG_STOP;
  101b6f:	c6 45 f0 07          	movb   $0x7,-0x10(%ebp)

	return api->transfer(dev, msg, 2, dev_addr);
  101b73:	6a 02                	push   $0x2
  101b75:	52                   	push   %edx
  101b76:	50                   	push   %eax
  101b77:	ff 51 04             	call   *0x4(%ecx)
  101b7a:	83 c4 10             	add    $0x10,%esp
	if (!_has_i2c_master(dev)) {
		return -EINVAL;
	}

	ret = _read_port_regs(dev, REG_INPUT_PORT0, &buf);
	if (ret != 0) {
  101b7d:	85 c0                	test   %eax,%eax
  101b7f:	75 22                	jne    101ba3 <gpio_pcal9535a_read+0x88>
		goto done;
	}

	switch (access_op) {
  101b81:	85 f6                	test   %esi,%esi
  101b83:	74 09                	je     101b8e <gpio_pcal9535a_read+0x73>
  101b85:	4e                   	dec    %esi
  101b86:	75 16                	jne    101b9e <gpio_pcal9535a_read+0x83>
	case GPIO_ACCESS_BY_PIN:
		*value = (buf.all >> pin) & 0x01;
		break;
	case GPIO_ACCESS_BY_PORT:
		*value = buf.all;
  101b88:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
  101b8c:	eb 0c                	jmp    101b9a <gpio_pcal9535a_read+0x7f>
		goto done;
	}

	switch (access_op) {
	case GPIO_ACCESS_BY_PIN:
		*value = (buf.all >> pin) & 0x01;
  101b8e:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
  101b92:	8b 4d 10             	mov    0x10(%ebp),%ecx
  101b95:	d3 fa                	sar    %cl,%edx
  101b97:	83 e2 01             	and    $0x1,%edx
		break;
	case GPIO_ACCESS_BY_PORT:
		*value = buf.all;
  101b9a:	89 13                	mov    %edx,(%ebx)
		break;
  101b9c:	eb 05                	jmp    101ba3 <gpio_pcal9535a_read+0x88>
	default:
		ret = -ENOTSUP;
  101b9e:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
		break;
	}

done:
	return ret;
}
  101ba3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101ba6:	5b                   	pop    %ebx
  101ba7:	5e                   	pop    %esi
  101ba8:	5f                   	pop    %edi
  101ba9:	5d                   	pop    %ebp
  101baa:	c3                   	ret    

00101bab <gpio_pcal9535a_init>:
 *
 * @param dev Device struct
 * @return 0 if successful, failed otherwise.
 */
static int gpio_pcal9535a_init(struct device *dev)
{
  101bab:	55                   	push   %ebp
  101bac:	89 e5                	mov    %esp,%ebp
  101bae:	56                   	push   %esi
  101baf:	53                   	push   %ebx
  101bb0:	8b 5d 08             	mov    0x8(%ebp),%ebx
	const struct gpio_pcal9535a_config * const config =
  101bb3:	8b 03                	mov    (%ebx),%eax
		dev->config->config_info;
	struct gpio_pcal9535a_drv_data * const drv_data =
  101bb5:	8b 73 08             	mov    0x8(%ebx),%esi
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	struct device *i2c_master;

	/* Find out the device struct of the I2C master */
	i2c_master = device_get_binding((char *)config->i2c_master_dev_name);
  101bb8:	8b 40 08             	mov    0x8(%eax),%eax
  101bbb:	ff 30                	pushl  (%eax)
  101bbd:	e8 25 1b 00 00       	call   1036e7 <device_get_binding>
  101bc2:	5a                   	pop    %edx
	if (!i2c_master) {
  101bc3:	85 c0                	test   %eax,%eax
  101bc5:	ba ea ff ff ff       	mov    $0xffffffea,%edx
  101bca:	74 22                	je     101bee <gpio_pcal9535a_init+0x43>
		return -EINVAL;
	}
	drv_data->i2c_master = i2c_master;
  101bcc:	89 06                	mov    %eax,(%esi)

	nano_timer_init(&drv_data->timer, (void *) 0);
  101bce:	8d 46 08             	lea    0x8(%esi),%eax
 * @return N/A
 */
static inline __deprecated void
nano_timer_init(struct k_timer *timer, void *data)
{
	k_timer_init(timer, NULL, NULL);
  101bd1:	6a 00                	push   $0x0
  101bd3:	6a 00                	push   $0x0
  101bd5:	50                   	push   %eax
  101bd6:	e8 a2 28 00 00       	call   10447d <k_timer_init>
	timer->_legacy_data = data;
  101bdb:	c7 46 38 00 00 00 00 	movl   $0x0,0x38(%esi)
 * @return N/A
 */
static inline __deprecated void
nano_timer_init(struct k_timer *timer, void *data)
{
	k_timer_init(timer, NULL, NULL);
  101be2:	83 c4 0c             	add    $0xc,%esp

	dev->driver_api = &gpio_pcal9535a_drv_api_funcs;
  101be5:	c7 43 04 40 48 10 00 	movl   $0x104840,0x4(%ebx)

	return 0;
  101bec:	31 d2                	xor    %edx,%edx
}
  101bee:	8d 65 f8             	lea    -0x8(%ebp),%esp
  101bf1:	89 d0                	mov    %edx,%eax
  101bf3:	5b                   	pop    %ebx
  101bf4:	5e                   	pop    %esi
  101bf5:	5d                   	pop    %ebp
  101bf6:	c3                   	ret    

00101bf7 <_write_port_regs>:
 *
 * @return 0 if successful, failed otherwise.
 */
static int _write_port_regs(struct device *dev, uint8_t reg,
			    union gpio_pcal9535a_port_data *buf)
{
  101bf7:	55                   	push   %ebp
  101bf8:	89 e5                	mov    %esp,%ebp
  101bfa:	56                   	push   %esi
  101bfb:	53                   	push   %ebx
  101bfc:	83 ec 1c             	sub    $0x1c,%esp
				  uint8_t num_bytes)
{
	const struct i2c_driver_api *api = dev->driver_api;
	struct i2c_msg msg[2];

	msg[0].buf = &start_addr;
  101bff:	8d 75 df             	lea    -0x21(%ebp),%esi
	const struct gpio_pcal9535a_config * const config =
		dev->config->config_info;
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	struct device * const i2c_master = drv_data->i2c_master;
  101c02:	8b 58 08             	mov    0x8(%eax),%ebx
 * @return 0 if successful, failed otherwise.
 */
static int _write_port_regs(struct device *dev, uint8_t reg,
			    union gpio_pcal9535a_port_data *buf)
{
	const struct gpio_pcal9535a_config * const config =
  101c05:	8b 00                	mov    (%eax),%eax
		dev->config->config_info;
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	struct device * const i2c_master = drv_data->i2c_master;
	uint16_t i2c_addr = config->i2c_slave_addr;
  101c07:	8b 40 08             	mov    0x8(%eax),%eax
{
	const struct gpio_pcal9535a_config * const config =
		dev->config->config_info;
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	struct device * const i2c_master = drv_data->i2c_master;
  101c0a:	8b 1b                	mov    (%ebx),%ebx
  101c0c:	88 55 df             	mov    %dl,-0x21(%ebp)
  101c0f:	89 75 e0             	mov    %esi,-0x20(%ebp)
	uint16_t i2c_addr = config->i2c_slave_addr;
  101c12:	0f b7 40 04          	movzwl 0x4(%eax),%eax
 */
static inline int i2c_burst_write(struct device *dev, uint16_t dev_addr,
				  uint8_t start_addr, uint8_t *buf,
				  uint8_t num_bytes)
{
	const struct i2c_driver_api *api = dev->driver_api;
  101c16:	8b 53 04             	mov    0x4(%ebx),%edx

	msg[1].buf = buf;
	msg[1].len = num_bytes;
	msg[1].flags = I2C_MSG_WRITE | I2C_MSG_STOP;

	return api->transfer(dev, msg, 2, dev_addr);
  101c19:	50                   	push   %eax
  101c1a:	8d 45 e0             	lea    -0x20(%ebp),%eax
  101c1d:	6a 02                	push   $0x2
{
	const struct i2c_driver_api *api = dev->driver_api;
	struct i2c_msg msg[2];

	msg[0].buf = &start_addr;
	msg[0].len = 1;
  101c1f:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

	msg[1].buf = buf;
	msg[1].len = num_bytes;
	msg[1].flags = I2C_MSG_WRITE | I2C_MSG_STOP;

	return api->transfer(dev, msg, 2, dev_addr);
  101c26:	50                   	push   %eax
	const struct i2c_driver_api *api = dev->driver_api;
	struct i2c_msg msg[2];

	msg[0].buf = &start_addr;
	msg[0].len = 1;
	msg[0].flags = I2C_MSG_WRITE;
  101c27:	c6 45 e8 00          	movb   $0x0,-0x18(%ebp)

	msg[1].buf = buf;
	msg[1].len = num_bytes;
	msg[1].flags = I2C_MSG_WRITE | I2C_MSG_STOP;

	return api->transfer(dev, msg, 2, dev_addr);
  101c2b:	53                   	push   %ebx

	msg[0].buf = &start_addr;
	msg[0].len = 1;
	msg[0].flags = I2C_MSG_WRITE;

	msg[1].buf = buf;
  101c2c:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	msg[1].len = num_bytes;
  101c2f:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
	msg[1].flags = I2C_MSG_WRITE | I2C_MSG_STOP;
  101c36:	c6 45 f4 02          	movb   $0x2,-0xc(%ebp)

	return api->transfer(dev, msg, 2, dev_addr);
  101c3a:	ff 52 04             	call   *0x4(%edx)
  101c3d:	83 c4 10             	add    $0x10,%esp
		SYS_LOG_ERR("PCAL9535A[0x%X]: error writing from register 0x%X "
			    "(%d)", i2c_addr, reg, ret);
	}

	return ret;
}
  101c40:	8d 65 f8             	lea    -0x8(%ebp),%esp
  101c43:	5b                   	pop    %ebx
  101c44:	5e                   	pop    %esi
  101c45:	5d                   	pop    %ebp
  101c46:	c3                   	ret    

00101c47 <gpio_pcal9535a_config>:
 *
 * @return 0 if successful, failed otherwise
 */
static int gpio_pcal9535a_config(struct device *dev, int access_op,
				 uint32_t pin, int flags)
{
  101c47:	55                   	push   %ebp
  101c48:	89 e5                	mov    %esp,%ebp
  101c4a:	57                   	push   %edi
  101c4b:	56                   	push   %esi
  101c4c:	53                   	push   %ebx
  101c4d:	83 ec 08             	sub    $0x8,%esp
  101c50:	8b 7d 08             	mov    0x8(%ebp),%edi
  101c53:	8b 45 10             	mov    0x10(%ebp),%eax
  101c56:	89 45 f0             	mov    %eax,-0x10(%ebp)
  101c59:	8b 45 14             	mov    0x14(%ebp),%eax
  101c5c:	8b 57 08             	mov    0x8(%edi),%edx
  101c5f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  101c62:	8b 75 0c             	mov    0xc(%ebp),%esi
		dev->config->config_info;
	uint16_t i2c_addr = config->i2c_slave_addr;
#endif

	if (!_has_i2c_master(dev)) {
		return -EINVAL;
  101c65:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
{
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	struct device * const i2c_master = drv_data->i2c_master;

	if (i2c_master)
  101c6a:	83 3a 00             	cmpl   $0x0,(%edx)
  101c6d:	0f 84 67 01 00 00    	je     101dda <gpio_pcal9535a_config+0x193>
	union gpio_pcal9535a_port_data *port = &drv_data->reg_cache.dir;
	uint16_t bit_mask;
	uint16_t new_value = 0;
	int ret;

	switch (access_op) {
  101c73:	85 f6                	test   %esi,%esi
  101c75:	75 1e                	jne    101c95 <gpio_pcal9535a_config+0x4e>
	case GPIO_ACCESS_BY_PIN:
		bit_mask = 1 << pin;
  101c77:	8a 4d f0             	mov    -0x10(%ebp),%cl
  101c7a:	b8 01 00 00 00       	mov    $0x1,%eax
  101c7f:	d3 e0                	shl    %cl,%eax
{
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	union gpio_pcal9535a_port_data *port = &drv_data->reg_cache.dir;
	uint16_t bit_mask;
	uint16_t new_value = 0;
  101c81:	31 c9                	xor    %ecx,%ecx
	switch (access_op) {
	case GPIO_ACCESS_BY_PIN:
		bit_mask = 1 << pin;

		/* Config 0 == output, 1 == input */
		if ((flags & GPIO_DIR_MASK) == GPIO_DIR_IN) {
  101c83:	f6 45 ec 01          	testb  $0x1,-0x14(%ebp)
  101c87:	75 02                	jne    101c8b <gpio_pcal9535a_config+0x44>
			new_value = 1 << pin;
  101c89:	89 c1                	mov    %eax,%ecx
		}

		port->all &= ~bit_mask;
		port->all |= new_value;
  101c8b:	f7 d0                	not    %eax
  101c8d:	66 23 42 40          	and    0x40(%edx),%ax
  101c91:	09 c8                	or     %ecx,%eax
  101c93:	eb 10                	jmp    101ca5 <gpio_pcal9535a_config+0x5e>
	union gpio_pcal9535a_port_data *port = &drv_data->reg_cache.dir;
	uint16_t bit_mask;
	uint16_t new_value = 0;
	int ret;

	switch (access_op) {
  101c95:	83 fe 01             	cmp    $0x1,%esi
  101c98:	0f 85 dc 00 00 00    	jne    101d7a <gpio_pcal9535a_config+0x133>

		break;
	case GPIO_ACCESS_BY_PORT:
		/* Config 0 == output, 1 == input */
		if ((flags & GPIO_DIR_MASK) == GPIO_DIR_IN) {
			port->all = 0xFFFF;
  101c9e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101ca1:	83 e0 01             	and    $0x1,%eax
  101ca4:	48                   	dec    %eax
  101ca5:	66 89 42 40          	mov    %ax,0x40(%edx)
static int _setup_pin_dir(struct device *dev, int access_op,
			  uint32_t pin, int flags)
{
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	union gpio_pcal9535a_port_data *port = &drv_data->reg_cache.dir;
  101ca9:	8d 4a 40             	lea    0x40(%edx),%ecx
	default:
		ret = -ENOTSUP;
		goto done;
	}

	ret = _write_port_regs(dev, REG_CONF_PORT0, port);
  101cac:	89 f8                	mov    %edi,%eax
  101cae:	ba 06 00 00 00       	mov    $0x6,%edx
  101cb3:	e8 3f ff ff ff       	call   101bf7 <_write_port_regs>
	if (!_has_i2c_master(dev)) {
		return -EINVAL;
	}

	ret = _setup_pin_dir(dev, access_op, pin, flags);
	if (ret) {
  101cb8:	85 c0                	test   %eax,%eax
  101cba:	0f 85 1a 01 00 00    	jne    101dda <gpio_pcal9535a_config+0x193>
 * @return 0 if successful, failed otherwise
 */
static int _setup_pin_polarity(struct device *dev, int access_op,
			       uint32_t pin, int flags)
{
	struct gpio_pcal9535a_drv_data * const drv_data =
  101cc0:	8b 5f 08             	mov    0x8(%edi),%ebx
	union gpio_pcal9535a_port_data *port = &drv_data->reg_cache.pol_inv;
	uint16_t bit_mask;
	uint16_t new_value = 0;
	int ret;

	switch (access_op) {
  101cc3:	85 f6                	test   %esi,%esi
  101cc5:	74 15                	je     101cdc <gpio_pcal9535a_config+0x95>
  101cc7:	83 fe 01             	cmp    $0x1,%esi
  101cca:	0f 85 aa 00 00 00    	jne    101d7a <gpio_pcal9535a_config+0x133>

		break;
	case GPIO_ACCESS_BY_PORT:
		/* normal == 0, invert == 1 */
		if ((flags & GPIO_POL_MASK) == GPIO_POL_INV) {
			port->all = 0xFFFF;
  101cd0:	31 c0                	xor    %eax,%eax
  101cd2:	f6 45 ec 80          	testb  $0x80,-0x14(%ebp)
  101cd6:	0f 94 c0             	sete   %al
  101cd9:	48                   	dec    %eax
  101cda:	eb 1c                	jmp    101cf8 <gpio_pcal9535a_config+0xb1>
	uint16_t new_value = 0;
	int ret;

	switch (access_op) {
	case GPIO_ACCESS_BY_PIN:
		bit_mask = BIT(pin);
  101cdc:	b8 01 00 00 00       	mov    $0x1,%eax
  101ce1:	8a 4d f0             	mov    -0x10(%ebp),%cl
  101ce4:	d3 e0                	shl    %cl,%eax
{
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	union gpio_pcal9535a_port_data *port = &drv_data->reg_cache.pol_inv;
	uint16_t bit_mask;
	uint16_t new_value = 0;
  101ce6:	31 d2                	xor    %edx,%edx
	switch (access_op) {
	case GPIO_ACCESS_BY_PIN:
		bit_mask = BIT(pin);

		/* normal == 0, invert == 1 */
		if ((flags & GPIO_POL_MASK) == GPIO_POL_INV) {
  101ce8:	f6 45 ec 80          	testb  $0x80,-0x14(%ebp)
  101cec:	74 02                	je     101cf0 <gpio_pcal9535a_config+0xa9>
			new_value = BIT(pin);
  101cee:	89 c2                	mov    %eax,%edx
		}

		port->all &= ~bit_mask;
		port->all |= new_value;
  101cf0:	f7 d0                	not    %eax
  101cf2:	66 23 43 3e          	and    0x3e(%ebx),%ax
  101cf6:	09 d0                	or     %edx,%eax

		break;
	case GPIO_ACCESS_BY_PORT:
		/* normal == 0, invert == 1 */
		if ((flags & GPIO_POL_MASK) == GPIO_POL_INV) {
			port->all = 0xFFFF;
  101cf8:	66 89 43 3e          	mov    %ax,0x3e(%ebx)
static int _setup_pin_polarity(struct device *dev, int access_op,
			       uint32_t pin, int flags)
{
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	union gpio_pcal9535a_port_data *port = &drv_data->reg_cache.pol_inv;
  101cfc:	8d 4b 3e             	lea    0x3e(%ebx),%ecx
	default:
		ret = -ENOTSUP;
		goto done;
	}

	ret = _write_port_regs(dev, REG_POL_INV_PORT0, port);
  101cff:	ba 04 00 00 00       	mov    $0x4,%edx
  101d04:	89 f8                	mov    %edi,%eax
  101d06:	e8 ec fe ff ff       	call   101bf7 <_write_port_regs>
	if (!ret) {
  101d0b:	85 c0                	test   %eax,%eax
  101d0d:	0f 85 c7 00 00 00    	jne    101dda <gpio_pcal9535a_config+0x193>
		drv_data->out_pol_inv = port->all;
  101d13:	0f b7 43 3e          	movzwl 0x3e(%ebx),%eax
	int ret;

	/* If disabling pull up/down, there is no need to set the selection
	 * register. Just go straight to disabling.
	 */
	if ((flags & GPIO_PUD_MASK) == GPIO_PUD_NORMAL) {
  101d17:	8b 55 ec             	mov    -0x14(%ebp),%edx
		goto done;
	}

	ret = _write_port_regs(dev, REG_POL_INV_PORT0, port);
	if (!ret) {
		drv_data->out_pol_inv = port->all;
  101d1a:	89 43 04             	mov    %eax,0x4(%ebx)
	int ret;

	/* If disabling pull up/down, there is no need to set the selection
	 * register. Just go straight to disabling.
	 */
	if ((flags & GPIO_PUD_MASK) == GPIO_PUD_NORMAL) {
  101d1d:	81 e2 00 03 00 00    	and    $0x300,%edx
 * @return 0 if successful, failed otherwise
 */
static int _setup_pin_pullupdown(struct device *dev, int access_op,
				 uint32_t pin, int flags)
{
	struct gpio_pcal9535a_drv_data * const drv_data =
  101d23:	8b 5f 08             	mov    0x8(%edi),%ebx
	int ret;

	/* If disabling pull up/down, there is no need to set the selection
	 * register. Just go straight to disabling.
	 */
	if ((flags & GPIO_PUD_MASK) == GPIO_PUD_NORMAL) {
  101d26:	0f 84 91 00 00 00    	je     101dbd <gpio_pcal9535a_config+0x176>
		goto en_dis;
	}

	/* Setup pin pull up or pull down */
	port = &drv_data->reg_cache.pud_sel;
	switch (access_op) {
  101d2c:	85 f6                	test   %esi,%esi
  101d2e:	74 13                	je     101d43 <gpio_pcal9535a_config+0xfc>
  101d30:	83 fe 01             	cmp    $0x1,%esi
  101d33:	75 45                	jne    101d7a <gpio_pcal9535a_config+0x133>

		break;
	case GPIO_ACCESS_BY_PORT:
		/* pull down == 0, pull up == 1*/
		if ((flags & GPIO_PUD_MASK) == GPIO_PUD_PULL_UP) {
			port->all = 0xFFFF;
  101d35:	31 c0                	xor    %eax,%eax
  101d37:	81 fa 00 01 00 00    	cmp    $0x100,%edx
  101d3d:	0f 95 c0             	setne  %al
  101d40:	48                   	dec    %eax
  101d41:	eb 1e                	jmp    101d61 <gpio_pcal9535a_config+0x11a>

	/* Setup pin pull up or pull down */
	port = &drv_data->reg_cache.pud_sel;
	switch (access_op) {
	case GPIO_ACCESS_BY_PIN:
		bit_mask = 1 << pin;
  101d43:	8a 4d f0             	mov    -0x10(%ebp),%cl
  101d46:	b8 01 00 00 00       	mov    $0x1,%eax
  101d4b:	d3 e0                	shl    %cl,%eax
{
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	union gpio_pcal9535a_port_data *port;
	uint16_t bit_mask;
	uint16_t new_value = 0;
  101d4d:	31 c9                	xor    %ecx,%ecx
	switch (access_op) {
	case GPIO_ACCESS_BY_PIN:
		bit_mask = 1 << pin;

		/* pull down == 0, pull up == 1*/
		if ((flags & GPIO_PUD_MASK) == GPIO_PUD_PULL_UP) {
  101d4f:	81 fa 00 01 00 00    	cmp    $0x100,%edx
  101d55:	75 02                	jne    101d59 <gpio_pcal9535a_config+0x112>
			new_value = 1 << pin;
  101d57:	89 c1                	mov    %eax,%ecx
		}

		port->all &= ~bit_mask;
		port->all |= new_value;
  101d59:	f7 d0                	not    %eax
  101d5b:	66 23 43 44          	and    0x44(%ebx),%ax
  101d5f:	09 c8                	or     %ecx,%eax

		break;
	case GPIO_ACCESS_BY_PORT:
		/* pull down == 0, pull up == 1*/
		if ((flags & GPIO_PUD_MASK) == GPIO_PUD_PULL_UP) {
			port->all = 0xFFFF;
  101d61:	66 89 43 44          	mov    %ax,0x44(%ebx)
	if ((flags & GPIO_PUD_MASK) == GPIO_PUD_NORMAL) {
		goto en_dis;
	}

	/* Setup pin pull up or pull down */
	port = &drv_data->reg_cache.pud_sel;
  101d65:	8d 4b 44             	lea    0x44(%ebx),%ecx
	default:
		ret = -ENOTSUP;
		goto done;
	}

	ret = _write_port_regs(dev, REG_PUD_SEL_PORT0, port);
  101d68:	ba 48 00 00 00       	mov    $0x48,%edx
  101d6d:	89 f8                	mov    %edi,%eax
  101d6f:	e8 83 fe ff ff       	call   101bf7 <_write_port_regs>
	if (ret) {
  101d74:	85 c0                	test   %eax,%eax
  101d76:	74 09                	je     101d81 <gpio_pcal9535a_config+0x13a>
  101d78:	eb 60                	jmp    101dda <gpio_pcal9535a_config+0x193>
		} else {
			port->all = 0x0;
		}
		break;
	default:
		ret = -ENOTSUP;
  101d7a:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
  101d7f:	eb 59                	jmp    101dda <gpio_pcal9535a_config+0x193>
	}

en_dis:
	/* enable/disable pull up/down */
	port = &drv_data->reg_cache.pud_en;
	switch (access_op) {
  101d81:	85 f6                	test   %esi,%esi
  101d83:	75 2d                	jne    101db2 <gpio_pcal9535a_config+0x16b>
	case GPIO_ACCESS_BY_PIN:
		bit_mask = 1 << pin;
  101d85:	b8 01 00 00 00       	mov    $0x1,%eax
  101d8a:	8a 4d f0             	mov    -0x10(%ebp),%cl
  101d8d:	d3 e0                	shl    %cl,%eax

		if ((flags & GPIO_PUD_MASK) != GPIO_PUD_NORMAL) {
			new_value = 1 << pin;
  101d8f:	89 c2                	mov    %eax,%edx
		}

		port->all &= ~bit_mask;
		port->all |= new_value;
  101d91:	f7 d0                	not    %eax
  101d93:	66 23 43 42          	and    0x42(%ebx),%ax
  101d97:	09 d0                	or     %edx,%eax
  101d99:	66 89 43 42          	mov    %ax,0x42(%ebx)
		goto done;
	}

en_dis:
	/* enable/disable pull up/down */
	port = &drv_data->reg_cache.pud_en;
  101d9d:	8d 4b 42             	lea    0x42(%ebx),%ecx
	default:
		ret = -ENOTSUP;
		goto done;
	}

	ret = _write_port_regs(dev, REG_PUD_EN_PORT0, port);
  101da0:	89 f8                	mov    %edi,%eax
  101da2:	ba 46 00 00 00       	mov    $0x46,%edx
		goto done;
	}

done:
	return ret;
}
  101da7:	5b                   	pop    %ebx
  101da8:	5e                   	pop    %esi
  101da9:	5b                   	pop    %ebx
  101daa:	5e                   	pop    %esi
  101dab:	5f                   	pop    %edi
  101dac:	5d                   	pop    %ebp
	default:
		ret = -ENOTSUP;
		goto done;
	}

	ret = _write_port_regs(dev, REG_PUD_EN_PORT0, port);
  101dad:	e9 45 fe ff ff       	jmp    101bf7 <_write_port_regs>
	}

en_dis:
	/* enable/disable pull up/down */
	port = &drv_data->reg_cache.pud_en;
	switch (access_op) {
  101db2:	4e                   	dec    %esi
  101db3:	75 c5                	jne    101d7a <gpio_pcal9535a_config+0x133>
		port->all |= new_value;

		break;
	case GPIO_ACCESS_BY_PORT:
		if ((flags & GPIO_PUD_MASK) != GPIO_PUD_NORMAL) {
			port->all = 0xFFFF;
  101db5:	66 c7 43 42 ff ff    	movw   $0xffff,0x42(%ebx)
  101dbb:	eb e0                	jmp    101d9d <gpio_pcal9535a_config+0x156>
	}

en_dis:
	/* enable/disable pull up/down */
	port = &drv_data->reg_cache.pud_en;
	switch (access_op) {
  101dbd:	85 f6                	test   %esi,%esi
  101dbf:	75 0e                	jne    101dcf <gpio_pcal9535a_config+0x188>
	case GPIO_ACCESS_BY_PIN:
		bit_mask = 1 << pin;
  101dc1:	b8 01 00 00 00       	mov    $0x1,%eax
  101dc6:	8a 4d f0             	mov    -0x10(%ebp),%cl
  101dc9:	d3 e0                	shl    %cl,%eax
{
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	union gpio_pcal9535a_port_data *port;
	uint16_t bit_mask;
	uint16_t new_value = 0;
  101dcb:	31 d2                	xor    %edx,%edx
  101dcd:	eb c2                	jmp    101d91 <gpio_pcal9535a_config+0x14a>
	}

en_dis:
	/* enable/disable pull up/down */
	port = &drv_data->reg_cache.pud_en;
	switch (access_op) {
  101dcf:	4e                   	dec    %esi
  101dd0:	75 a8                	jne    101d7a <gpio_pcal9535a_config+0x133>
		break;
	case GPIO_ACCESS_BY_PORT:
		if ((flags & GPIO_PUD_MASK) != GPIO_PUD_NORMAL) {
			port->all = 0xFFFF;
		} else {
			port->all = 0x0;
  101dd2:	66 c7 43 42 00 00    	movw   $0x0,0x42(%ebx)
  101dd8:	eb c3                	jmp    101d9d <gpio_pcal9535a_config+0x156>
		goto done;
	}

done:
	return ret;
}
  101dda:	5a                   	pop    %edx
  101ddb:	59                   	pop    %ecx
  101ddc:	5b                   	pop    %ebx
  101ddd:	5e                   	pop    %esi
  101dde:	5f                   	pop    %edi
  101ddf:	5d                   	pop    %ebp
  101de0:	c3                   	ret    

00101de1 <gpio_pcal9535a_write>:
 *
 * @return 0 if successful, failed otherwise
 */
static int gpio_pcal9535a_write(struct device *dev, int access_op,
				uint32_t pin, uint32_t value)
{
  101de1:	55                   	push   %ebp
  101de2:	89 e5                	mov    %esp,%ebp
  101de4:	57                   	push   %edi
  101de5:	56                   	push   %esi
  101de6:	53                   	push   %ebx
  101de7:	8b 45 08             	mov    0x8(%ebp),%eax
  101dea:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  101ded:	8b 4d 10             	mov    0x10(%ebp),%ecx
  101df0:	8b 75 14             	mov    0x14(%ebp),%esi
	struct gpio_pcal9535a_drv_data * const drv_data =
  101df3:	8b 50 08             	mov    0x8(%eax),%edx
{
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	struct device * const i2c_master = drv_data->i2c_master;

	if (i2c_master)
  101df6:	83 3a 00             	cmpl   $0x0,(%edx)
  101df9:	75 07                	jne    101e02 <gpio_pcal9535a_write+0x21>
	uint16_t bit_mask;
	uint16_t new_value;
	int ret;

	if (!_has_i2c_master(dev)) {
		return -EINVAL;
  101dfb:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  101e00:	eb 4e                	jmp    101e50 <gpio_pcal9535a_write+0x6f>
	}

	/* Invert input value for pins configurated as active low. */
	switch (access_op) {
  101e02:	85 db                	test   %ebx,%ebx
  101e04:	75 1a                	jne    101e20 <gpio_pcal9535a_write+0x3f>
	case GPIO_ACCESS_BY_PIN:
		bit_mask = BIT(pin);
  101e06:	bb 01 00 00 00       	mov    $0x1,%ebx
  101e0b:	d3 e3                	shl    %cl,%ebx

		new_value = (value << pin) & bit_mask;
  101e0d:	d3 e6                	shl    %cl,%esi
		new_value ^= (drv_data->out_pol_inv & bit_mask);
		new_value &= bit_mask;

		port->all &= ~bit_mask;
		port->all |= new_value;
  101e0f:	89 d9                	mov    %ebx,%ecx
	switch (access_op) {
	case GPIO_ACCESS_BY_PIN:
		bit_mask = BIT(pin);

		new_value = (value << pin) & bit_mask;
		new_value ^= (drv_data->out_pol_inv & bit_mask);
  101e11:	33 72 04             	xor    0x4(%edx),%esi
		new_value &= bit_mask;

		port->all &= ~bit_mask;
		port->all |= new_value;
  101e14:	f7 d1                	not    %ecx
  101e16:	66 23 4a 3c          	and    0x3c(%edx),%cx
  101e1a:	21 f3                	and    %esi,%ebx
  101e1c:	09 cb                	or     %ecx,%ebx
  101e1e:	eb 16                	jmp    101e36 <gpio_pcal9535a_write+0x55>
	if (!_has_i2c_master(dev)) {
		return -EINVAL;
	}

	/* Invert input value for pins configurated as active low. */
	switch (access_op) {
  101e20:	4b                   	dec    %ebx
  101e21:	75 28                	jne    101e4b <gpio_pcal9535a_write+0x6a>
		port->all |= new_value;

		break;
	case GPIO_ACCESS_BY_PORT:
		port->all = value;
		bit_mask = drv_data->out_pol_inv;
  101e23:	8b 4a 04             	mov    0x4(%edx),%ecx

		new_value = value & bit_mask;
		new_value ^= drv_data->out_pol_inv;
  101e26:	89 f7                	mov    %esi,%edi
		new_value &= bit_mask;

		port->all &= ~bit_mask;
		port->all |= new_value;
  101e28:	89 cb                	mov    %ecx,%ebx
  101e2a:	f7 d3                	not    %ebx
	case GPIO_ACCESS_BY_PORT:
		port->all = value;
		bit_mask = drv_data->out_pol_inv;

		new_value = value & bit_mask;
		new_value ^= drv_data->out_pol_inv;
  101e2c:	f7 d7                	not    %edi
		new_value &= bit_mask;

		port->all &= ~bit_mask;
		port->all |= new_value;
  101e2e:	21 de                	and    %ebx,%esi
  101e30:	21 f9                	and    %edi,%ecx
  101e32:	09 ce                	or     %ecx,%esi
  101e34:	89 f3                	mov    %esi,%ebx
  101e36:	66 89 5a 3c          	mov    %bx,0x3c(%edx)
static int gpio_pcal9535a_write(struct device *dev, int access_op,
				uint32_t pin, uint32_t value)
{
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	union gpio_pcal9535a_port_data *port = &drv_data->reg_cache.output;
  101e3a:	8d 4a 3c             	lea    0x3c(%edx),%ecx
	default:
		ret = -ENOTSUP;
		goto done;
	}

	ret = _write_port_regs(dev, REG_OUTPUT_PORT0, port);
  101e3d:	ba 02 00 00 00       	mov    $0x2,%edx

done:
	return ret;
}
  101e42:	5b                   	pop    %ebx
  101e43:	5e                   	pop    %esi
  101e44:	5f                   	pop    %edi
  101e45:	5d                   	pop    %ebp
	default:
		ret = -ENOTSUP;
		goto done;
	}

	ret = _write_port_regs(dev, REG_OUTPUT_PORT0, port);
  101e46:	e9 ac fd ff ff       	jmp    101bf7 <_write_port_regs>
		port->all &= ~bit_mask;
		port->all |= new_value;

		break;
	default:
		ret = -ENOTSUP;
  101e4b:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax

	ret = _write_port_regs(dev, REG_OUTPUT_PORT0, port);

done:
	return ret;
}
  101e50:	5b                   	pop    %ebx
  101e51:	5e                   	pop    %esi
  101e52:	5f                   	pop    %edi
  101e53:	5d                   	pop    %ebp
  101e54:	c3                   	ret    

00101e55 <gpio_pcal9535a_enable_callback>:
  101e55:	55                   	push   %ebp
  101e56:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
  101e5b:	89 e5                	mov    %esp,%ebp
  101e5d:	5d                   	pop    %ebp
  101e5e:	c3                   	ret    

00101e5f <gpio_sch_read>:
	return 0;
}

static int gpio_sch_read(struct device *dev,
			 int access_op, uint32_t pin, uint32_t *value)
{
  101e5f:	55                   	push   %ebp
  101e60:	89 e5                	mov    %esp,%ebp
  101e62:	56                   	push   %esi
  101e63:	53                   	push   %ebx
	const struct gpio_sch_config *info = dev->config->config_info;
  101e64:	8b 45 08             	mov    0x8(%ebp),%eax
	return 0;
}

static int gpio_sch_read(struct device *dev,
			 int access_op, uint32_t pin, uint32_t *value)
{
  101e67:	8b 4d 10             	mov    0x10(%ebp),%ecx
  101e6a:	8b 5d 14             	mov    0x14(%ebp),%ebx
	const struct gpio_sch_config *info = dev->config->config_info;
  101e6d:	8b 00                	mov    (%eax),%eax
  101e6f:	8b 70 08             	mov    0x8(%eax),%esi
static ALWAYS_INLINE
	uint32_t sys_in32(io_port_t port)
{
	uint32_t ret;

	__asm__ volatile("inl	%w1, %0;\n\t"
  101e72:	8b 06                	mov    (%esi),%eax
  101e74:	8d 50 08             	lea    0x8(%eax),%edx
  101e77:	ed                   	in     (%dx),%eax
  101e78:	89 c2                	mov    %eax,%edx

	*value = _read_glvl(info->regs);
  101e7a:	89 03                	mov    %eax,(%ebx)
		}

		*value = !!(*value & BIT(pin));
	}

	return 0;
  101e7c:	31 c0                	xor    %eax,%eax
{
	const struct gpio_sch_config *info = dev->config->config_info;

	*value = _read_glvl(info->regs);

	if (access_op == GPIO_ACCESS_BY_PIN) {
  101e7e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  101e82:	75 16                	jne    101e9a <gpio_sch_read+0x3b>
		if (pin >= info->bits) {
  101e84:	0f b6 76 04          	movzbl 0x4(%esi),%esi
  101e88:	39 ce                	cmp    %ecx,%esi
  101e8a:	76 09                	jbe    101e95 <gpio_sch_read+0x36>
			return -ENOTSUP;
		}

		*value = !!(*value & BIT(pin));
  101e8c:	d3 ea                	shr    %cl,%edx
  101e8e:	83 e2 01             	and    $0x1,%edx
  101e91:	89 13                	mov    %edx,(%ebx)
  101e93:	eb 05                	jmp    101e9a <gpio_sch_read+0x3b>

	*value = _read_glvl(info->regs);

	if (access_op == GPIO_ACCESS_BY_PIN) {
		if (pin >= info->bits) {
			return -ENOTSUP;
  101e95:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax

		*value = !!(*value & BIT(pin));
	}

	return 0;
}
  101e9a:	5b                   	pop    %ebx
  101e9b:	5e                   	pop    %esi
  101e9c:	5d                   	pop    %ebp
  101e9d:	c3                   	ret    

00101e9e <gpio_sch_init>:
	.enable_callback = gpio_sch_enable_callback,
	.disable_callback = gpio_sch_disable_callback,
};

static int gpio_sch_init(struct device *dev)
{
  101e9e:	55                   	push   %ebp
  101e9f:	89 e5                	mov    %esp,%ebp
  101ea1:	8b 55 08             	mov    0x8(%ebp),%edx
	struct gpio_sch_data *gpio = dev->driver_data;
  101ea4:	8b 42 08             	mov    0x8(%edx),%eax

	dev->driver_api = &gpio_sch_api;
  101ea7:	c7 42 04 6c 48 10 00 	movl   $0x10486c,0x4(%edx)

	k_timer_init(&gpio->poll_timer, NULL, NULL);
  101eae:	05 08 04 00 00       	add    $0x408,%eax
  101eb3:	6a 00                	push   $0x0
  101eb5:	6a 00                	push   $0x0
  101eb7:	50                   	push   %eax
  101eb8:	e8 c0 25 00 00       	call   10447d <k_timer_init>
  101ebd:	83 c4 0c             	add    $0xc,%esp

	SYS_LOG_DBG("SCH GPIO Intel Driver initialized on device: %p", dev);

	return 0;
}
  101ec0:	31 c0                	xor    %eax,%eax
  101ec2:	c9                   	leave  
  101ec3:	c3                   	ret    

00101ec4 <_gpio_sch_manage_callback>:
	}
}

static void _gpio_sch_manage_callback(struct device *dev)
{
	struct gpio_sch_data *gpio = dev->driver_data;
  101ec4:	8b 50 08             	mov    0x8(%eax),%edx

	/* Start the fiber only when relevant */
	if (!sys_slist_is_empty(&gpio->callbacks) && gpio->cb_enabled) {
  101ec7:	83 ba 00 04 00 00 00 	cmpl   $0x0,0x400(%edx)
  101ece:	74 3d                	je     101f0d <_gpio_sch_manage_callback+0x49>
  101ed0:	83 ba 44 04 00 00 00 	cmpl   $0x0,0x444(%edx)
  101ed7:	74 34                	je     101f0d <_gpio_sch_manage_callback+0x49>
		if (!gpio->poll) {
  101ed9:	80 ba 48 04 00 00 00 	cmpb   $0x0,0x448(%edx)
  101ee0:	75 33                	jne    101f15 <_gpio_sch_manage_callback+0x51>
		k_timer_status_sync(&gpio->poll_timer);
	}
}

static void _gpio_sch_manage_callback(struct device *dev)
{
  101ee2:	55                   	push   %ebp

	/* Start the fiber only when relevant */
	if (!sys_slist_is_empty(&gpio->callbacks) && gpio->cb_enabled) {
		if (!gpio->poll) {
			SYS_LOG_DBG("Starting SCH GPIO polling fiber");
			gpio->poll = 1;
  101ee3:	c6 82 48 04 00 00 01 	movb   $0x1,0x448(%edx)
		k_timer_status_sync(&gpio->poll_timer);
	}
}

static void _gpio_sch_manage_callback(struct device *dev)
{
  101eea:	89 e5                	mov    %esp,%ebp
	/* Start the fiber only when relevant */
	if (!sys_slist_is_empty(&gpio->callbacks) && gpio->cb_enabled) {
		if (!gpio->poll) {
			SYS_LOG_DBG("Starting SCH GPIO polling fiber");
			gpio->poll = 1;
			k_thread_spawn(gpio->polling_stack,
  101eec:	6a 00                	push   $0x0
  101eee:	6a 00                	push   $0x0
  101ef0:	6a f1                	push   $0xfffffff1
  101ef2:	6a 00                	push   $0x0
  101ef4:	6a 00                	push   $0x0
  101ef6:	50                   	push   %eax
  101ef7:	68 a2 20 10 00       	push   $0x1020a2
  101efc:	68 00 04 00 00       	push   $0x400
  101f01:	52                   	push   %edx
  101f02:	e8 f7 21 00 00       	call   1040fe <k_thread_spawn>
  101f07:	83 c4 24             	add    $0x24,%esp
				       K_PRIO_COOP(1), 0, 0);
		}
	} else {
		gpio->poll = 0;
	}
}
  101f0a:	c9                   	leave  
  101f0b:	eb 08                	jmp    101f15 <_gpio_sch_manage_callback+0x51>
				       (k_thread_entry_t)_gpio_sch_poll_status,
				       dev, NULL, NULL,
				       K_PRIO_COOP(1), 0, 0);
		}
	} else {
		gpio->poll = 0;
  101f0d:	c6 82 48 04 00 00 00 	movb   $0x0,0x448(%edx)
	}
}
  101f14:	c3                   	ret    
  101f15:	c3                   	ret    

00101f16 <gpio_sch_manage_callback>:

static int gpio_sch_manage_callback(struct device *dev,
				    struct gpio_callback *callback, bool set)
{
  101f16:	55                   	push   %ebp
  101f17:	89 e5                	mov    %esp,%ebp
  101f19:	56                   	push   %esi
  101f1a:	53                   	push   %ebx
 * @param node A pointer on the node to remove from the list
 */
static inline void sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node)
{
	sys_snode_t *prev = NULL;
  101f1b:	31 f6                	xor    %esi,%esi
  101f1d:	8b 45 08             	mov    0x8(%ebp),%eax
  101f20:	8b 4d 0c             	mov    0xc(%ebp),%ecx
					 bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (set) {
  101f23:	80 7d 10 00          	cmpb   $0x0,0x10(%ebp)
	struct gpio_sch_data *gpio = dev->driver_data;
  101f27:	8b 50 08             	mov    0x8(%eax),%edx
 * @param node A pointer on the node to prepend
 */
static inline void sys_slist_prepend(sys_slist_t *list,
				     sys_snode_t *node)
{
	node->next = list->head;
  101f2a:	8b 9a 00 04 00 00    	mov    0x400(%edx),%ebx
  101f30:	74 21                	je     101f53 <gpio_sch_manage_callback+0x3d>
  101f32:	89 19                	mov    %ebx,(%ecx)
	list->head = node;
  101f34:	89 8a 00 04 00 00    	mov    %ecx,0x400(%edx)

	if (!list->tail) {
  101f3a:	83 ba 04 04 00 00 00 	cmpl   $0x0,0x404(%edx)
  101f41:	75 48                	jne    101f8b <gpio_sch_manage_callback+0x75>
		list->tail = list->head;
  101f43:	89 8a 04 04 00 00    	mov    %ecx,0x404(%edx)
  101f49:	eb 40                	jmp    101f8b <gpio_sch_manage_callback+0x75>
{
	sys_snode_t *prev = NULL;
	sys_snode_t *test;

	SYS_SLIST_FOR_EACH_NODE(list, test) {
		if (test == node) {
  101f4b:	39 d9                	cmp    %ebx,%ecx
  101f4d:	74 0a                	je     101f59 <gpio_sch_manage_callback+0x43>
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node)
{
	return !node ? NULL : node->next;
  101f4f:	89 de                	mov    %ebx,%esi
  101f51:	8b 1b                	mov    (%ebx),%ebx
					     sys_snode_t *node)
{
	sys_snode_t *prev = NULL;
	sys_snode_t *test;

	SYS_SLIST_FOR_EACH_NODE(list, test) {
  101f53:	85 db                	test   %ebx,%ebx
  101f55:	75 f4                	jne    101f4b <gpio_sch_manage_callback+0x35>
  101f57:	eb 32                	jmp    101f8b <gpio_sch_manage_callback+0x75>
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node)
{
	if (!prev_node) {
  101f59:	85 f6                	test   %esi,%esi
  101f5b:	8b 19                	mov    (%ecx),%ebx
  101f5d:	75 16                	jne    101f75 <gpio_sch_manage_callback+0x5f>
		list->head = node->next;
  101f5f:	89 9a 00 04 00 00    	mov    %ebx,0x400(%edx)

		/* Was node also the tail? */
		if (list->tail == node) {
  101f65:	3b 8a 04 04 00 00    	cmp    0x404(%edx),%ecx
  101f6b:	75 18                	jne    101f85 <gpio_sch_manage_callback+0x6f>
			list->tail = list->head;
  101f6d:	89 9a 04 04 00 00    	mov    %ebx,0x404(%edx)
  101f73:	eb 10                	jmp    101f85 <gpio_sch_manage_callback+0x6f>
		}
	} else {
		prev_node->next = node->next;
  101f75:	89 1e                	mov    %ebx,(%esi)

		/* Was node the tail? */
		if (list->tail == node) {
  101f77:	3b 8a 04 04 00 00    	cmp    0x404(%edx),%ecx
  101f7d:	75 06                	jne    101f85 <gpio_sch_manage_callback+0x6f>
			list->tail = prev_node;
  101f7f:	89 b2 04 04 00 00    	mov    %esi,0x404(%edx)
		}
	}

	node->next = NULL;
  101f85:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)

	_gpio_manage_callback(&gpio->callbacks, callback, set);

	_gpio_sch_manage_callback(dev);
  101f8b:	e8 34 ff ff ff       	call   101ec4 <_gpio_sch_manage_callback>

	return 0;
}
  101f90:	5b                   	pop    %ebx
  101f91:	31 c0                	xor    %eax,%eax
  101f93:	5e                   	pop    %esi
  101f94:	5d                   	pop    %ebp
  101f95:	c3                   	ret    

00101f96 <_set_bit>:
DEFINE_MM_REG_READ(gts, GPIO_SCH_REG_GTS)
DEFINE_MM_REG_WRITE(gts, GPIO_SCH_REG_GTS)

static void _set_bit(uint32_t base_addr,
		     uint32_t bit, uint8_t set)
{
  101f96:	55                   	push   %ebp
  101f97:	89 e5                	mov    %esp,%ebp
  101f99:	56                   	push   %esi
  101f9a:	53                   	push   %ebx
  101f9b:	89 c3                	mov    %eax,%ebx
  101f9d:	89 d6                	mov    %edx,%esi
static ALWAYS_INLINE
	void sys_io_clear_bit(io_port_t port, unsigned int bit)
{
	uint32_t reg = 0;

	__asm__ volatile("inl	%w1, %0;\n\t"
  101f9f:	31 c0                	xor    %eax,%eax
  101fa1:	89 da                	mov    %ebx,%edx
	if (!set) {
  101fa3:	84 c9                	test   %cl,%cl
  101fa5:	75 07                	jne    101fae <_set_bit+0x18>
  101fa7:	ed                   	in     (%dx),%eax
  101fa8:	0f b3 f0             	btr    %esi,%eax
  101fab:	ef                   	out    %eax,(%dx)
  101fac:	eb 05                	jmp    101fb3 <_set_bit+0x1d>
static ALWAYS_INLINE
	void sys_io_set_bit(io_port_t port, unsigned int bit)
{
	uint32_t reg = 0;

	__asm__ volatile("inl	%w1, %0;\n\t"
  101fae:	ed                   	in     (%dx),%eax
  101faf:	0f ab f0             	bts    %esi,%eax
  101fb2:	ef                   	out    %eax,(%dx)
		_REG_CLEAR_BIT(base_addr, bit);
	} else {
		_REG_SET_BIT(base_addr, bit);
	}
}
  101fb3:	5b                   	pop    %ebx
  101fb4:	5e                   	pop    %esi
  101fb5:	5d                   	pop    %ebp
  101fb6:	c3                   	ret    

00101fb7 <gpio_sch_write>:
	return 0;
}

static int gpio_sch_write(struct device *dev,
			  int access_op, uint32_t pin, uint32_t value)
{
  101fb7:	55                   	push   %ebp
  101fb8:	89 e5                	mov    %esp,%ebp
  101fba:	56                   	push   %esi
  101fbb:	53                   	push   %ebx
	const struct gpio_sch_config *info = dev->config->config_info;
  101fbc:	8b 45 08             	mov    0x8(%ebp),%eax
	return 0;
}

static int gpio_sch_write(struct device *dev,
			  int access_op, uint32_t pin, uint32_t value)
{
  101fbf:	8b 55 10             	mov    0x10(%ebp),%edx
  101fc2:	8b 4d 14             	mov    0x14(%ebp),%ecx
	const struct gpio_sch_config *info = dev->config->config_info;
  101fc5:	8b 00                	mov    (%eax),%eax

	if (access_op == GPIO_ACCESS_BY_PIN) {
  101fc7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
}

static int gpio_sch_write(struct device *dev,
			  int access_op, uint32_t pin, uint32_t value)
{
	const struct gpio_sch_config *info = dev->config->config_info;
  101fcb:	8b 58 08             	mov    0x8(%eax),%ebx

	if (access_op == GPIO_ACCESS_BY_PIN) {
  101fce:	75 1c                	jne    101fec <gpio_sch_write+0x35>
		if (pin >= info->bits) {
  101fd0:	0f b6 73 04          	movzbl 0x4(%ebx),%esi
			return -ENOTSUP;
  101fd4:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
			  int access_op, uint32_t pin, uint32_t value)
{
	const struct gpio_sch_config *info = dev->config->config_info;

	if (access_op == GPIO_ACCESS_BY_PIN) {
		if (pin >= info->bits) {
  101fd9:	39 d6                	cmp    %edx,%esi
  101fdb:	76 17                	jbe    101ff4 <gpio_sch_write+0x3d>
		_set_bit(addr + __off, bit, set);                       \
	}

DEFINE_MM_REG_SET_BIT(gen, GPIO_SCH_REG_GEN)
DEFINE_MM_REG_SET_BIT(gio, GPIO_SCH_REG_GIO)
DEFINE_MM_REG_SET_BIT(glvl, GPIO_SCH_REG_GLVL)
  101fdd:	8b 03                	mov    (%ebx),%eax
  101fdf:	0f b6 c9             	movzbl %cl,%ecx
  101fe2:	83 c0 08             	add    $0x8,%eax
  101fe5:	e8 ac ff ff ff       	call   101f96 <_set_bit>
  101fea:	eb 06                	jmp    101ff2 <gpio_sch_write+0x3b>


static ALWAYS_INLINE
	void sys_out32(uint32_t data, io_port_t port)
{
	__asm__ volatile("outl	%0, %w1;\n\t"
  101fec:	8b 03                	mov    (%ebx),%eax
  101fee:	8d 51 08             	lea    0x8(%ecx),%edx
  101ff1:	ef                   	out    %eax,(%dx)
		_set_bit_glvl(info->regs, pin, value);
	} else {
		_write_glvl(info->regs, value);
	}

	return 0;
  101ff2:	31 c0                	xor    %eax,%eax
}
  101ff4:	5b                   	pop    %ebx
  101ff5:	5e                   	pop    %esi
  101ff6:	5d                   	pop    %ebp
  101ff7:	c3                   	ret    

00101ff8 <gpio_sch_enable_callback>:
	return 0;
}

static int gpio_sch_enable_callback(struct device *dev,
				    int access_op, uint32_t pin)
{
  101ff8:	55                   	push   %ebp
  101ff9:	89 e5                	mov    %esp,%ebp
  101ffb:	57                   	push   %edi
  101ffc:	56                   	push   %esi
  101ffd:	53                   	push   %ebx
  101ffe:	51                   	push   %ecx
	const struct gpio_sch_config *info = dev->config->config_info;
  101fff:	8b 45 08             	mov    0x8(%ebp),%eax
	struct gpio_sch_data *gpio = dev->driver_data;

	if (access_op == GPIO_ACCESS_BY_PIN) {
  102002:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
}

static int gpio_sch_enable_callback(struct device *dev,
				    int access_op, uint32_t pin)
{
	const struct gpio_sch_config *info = dev->config->config_info;
  102006:	8b 00                	mov    (%eax),%eax
  102008:	8b 70 08             	mov    0x8(%eax),%esi
	struct gpio_sch_data *gpio = dev->driver_data;
  10200b:	8b 45 08             	mov    0x8(%ebp),%eax
  10200e:	8b 58 08             	mov    0x8(%eax),%ebx
  102011:	0f b6 46 04          	movzbl 0x4(%esi),%eax
  102015:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (access_op == GPIO_ACCESS_BY_PIN) {
  102018:	75 51                	jne    10206b <gpio_sch_enable_callback+0x73>
		uint32_t bits = BIT(pin);
  10201a:	b8 01 00 00 00       	mov    $0x1,%eax
  10201f:	8a 4d 10             	mov    0x10(%ebp),%cl
  102022:	d3 e0                	shl    %cl,%eax

		if (pin >= info->bits) {
  102024:	8b 55 f0             	mov    -0x10(%ebp),%edx
{
	const struct gpio_sch_config *info = dev->config->config_info;
	struct gpio_sch_data *gpio = dev->driver_data;

	if (access_op == GPIO_ACCESS_BY_PIN) {
		uint32_t bits = BIT(pin);
  102027:	89 c7                	mov    %eax,%edi

		if (pin >= info->bits) {
  102029:	39 55 10             	cmp    %edx,0x10(%ebp)
			return -ENOTSUP;
  10202c:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
	struct gpio_sch_data *gpio = dev->driver_data;

	if (access_op == GPIO_ACCESS_BY_PIN) {
		uint32_t bits = BIT(pin);

		if (pin >= info->bits) {
  102031:	73 69                	jae    10209c <gpio_sch_enable_callback+0xa4>
	}

DEFINE_MM_REG_SET_BIT(gen, GPIO_SCH_REG_GEN)
DEFINE_MM_REG_SET_BIT(gio, GPIO_SCH_REG_GIO)
DEFINE_MM_REG_SET_BIT(glvl, GPIO_SCH_REG_GLVL)
DEFINE_MM_REG_SET_BIT(gtpe, GPIO_SCH_REG_GTPE)
  102033:	31 c9                	xor    %ecx,%ecx
  102035:	8b 06                	mov    (%esi),%eax
  102037:	85 bb 3c 04 00 00    	test   %edi,0x43c(%ebx)
  10203d:	8b 55 10             	mov    0x10(%ebp),%edx
  102040:	0f 95 c1             	setne  %cl
  102043:	83 c0 0c             	add    $0xc,%eax
  102046:	e8 4b ff ff ff       	call   101f96 <_set_bit>
DEFINE_MM_REG_SET_BIT(gtne, GPIO_SCH_REG_GTNE)
  10204b:	31 c9                	xor    %ecx,%ecx
  10204d:	8b 06                	mov    (%esi),%eax
  10204f:	85 bb 40 04 00 00    	test   %edi,0x440(%ebx)
  102055:	8b 55 10             	mov    0x10(%ebp),%edx
  102058:	0f 95 c1             	setne  %cl
  10205b:	83 c0 10             	add    $0x10,%eax
  10205e:	e8 33 ff ff ff       	call   101f96 <_set_bit>
		}

		_set_bit_gtpe(info->regs, pin, !!(bits & gpio->int_regs.gtpe));
		_set_bit_gtne(info->regs, pin, !!(bits & gpio->int_regs.gtne));

		gpio->cb_enabled |= bits;
  102063:	09 bb 44 04 00 00    	or     %edi,0x444(%ebx)
  102069:	eb 27                	jmp    102092 <gpio_sch_enable_callback+0x9a>
	} else {
		_write_gtpe(gpio->int_regs.gtpe, info->regs);
  10206b:	8b 0e                	mov    (%esi),%ecx
  10206d:	8b 83 3c 04 00 00    	mov    0x43c(%ebx),%eax
  102073:	8d 51 0c             	lea    0xc(%ecx),%edx
  102076:	ef                   	out    %eax,(%dx)
  102077:	8b 83 40 04 00 00    	mov    0x440(%ebx),%eax
  10207d:	8d 51 10             	lea    0x10(%ecx),%edx
  102080:	ef                   	out    %eax,(%dx)
		_write_gtne(gpio->int_regs.gtne, info->regs);

		gpio->cb_enabled = BIT_MASK(info->bits);
  102081:	b8 01 00 00 00       	mov    $0x1,%eax
  102086:	8a 4d f0             	mov    -0x10(%ebp),%cl
  102089:	d3 e0                	shl    %cl,%eax
  10208b:	48                   	dec    %eax
  10208c:	89 83 44 04 00 00    	mov    %eax,0x444(%ebx)
	}

	_gpio_sch_manage_callback(dev);
  102092:	8b 45 08             	mov    0x8(%ebp),%eax
  102095:	e8 2a fe ff ff       	call   101ec4 <_gpio_sch_manage_callback>

	return 0;
  10209a:	31 c0                	xor    %eax,%eax
}
  10209c:	5a                   	pop    %edx
  10209d:	5b                   	pop    %ebx
  10209e:	5e                   	pop    %esi
  10209f:	5f                   	pop    %edi
  1020a0:	5d                   	pop    %ebp
  1020a1:	c3                   	ret    

001020a2 <_gpio_sch_poll_status>:

	return 0;
}

static void _gpio_sch_poll_status(void *arg1, void *unused1, void *unused2)
{
  1020a2:	55                   	push   %ebp
  1020a3:	89 e5                	mov    %esp,%ebp
  1020a5:	57                   	push   %edi
  1020a6:	56                   	push   %esi
  1020a7:	53                   	push   %ebx
  1020a8:	83 ec 08             	sub    $0x8,%esp
	struct device *dev = (struct device *)arg1;
	const struct gpio_sch_config *info = dev->config->config_info;
  1020ab:	8b 45 08             	mov    0x8(%ebp),%eax
  1020ae:	8b 00                	mov    (%eax),%eax
  1020b0:	8b 70 08             	mov    0x8(%eax),%esi
	struct gpio_sch_data *gpio = dev->driver_data;
  1020b3:	8b 45 08             	mov    0x8(%ebp),%eax
  1020b6:	8b 58 08             	mov    0x8(%eax),%ebx

DEFINE_MM_REG_READ(glvl, GPIO_SCH_REG_GLVL)
DEFINE_MM_REG_WRITE(glvl, GPIO_SCH_REG_GLVL)
DEFINE_MM_REG_WRITE(gtpe, GPIO_SCH_REG_GTPE)
DEFINE_MM_REG_WRITE(gtne, GPIO_SCH_REG_GTNE)
DEFINE_MM_REG_READ(gts, GPIO_SCH_REG_GTS)
  1020b9:	8b 06                	mov    (%esi),%eax
  1020bb:	8d 50 1c             	lea    0x1c(%eax),%edx
static ALWAYS_INLINE
	uint32_t sys_in32(io_port_t port)
{
	uint32_t ret;

	__asm__ volatile("inl	%w1, %0;\n\t"
  1020be:	ed                   	in     (%dx),%eax


static ALWAYS_INLINE
	void sys_out32(uint32_t data, io_port_t port)
{
	__asm__ volatile("outl	%0, %w1;\n\t"
  1020bf:	ef                   	out    %eax,(%dx)
		/* It's not documented but writing the same status value
		 * into GTS tells to the controller it got handled.
		 */
		_write_gts(status, info->regs);
loop:
		k_timer_start(&gpio->poll_timer, GPIO_SCH_POLLING_MSEC, 0);
  1020c0:	8d bb 08 04 00 00    	lea    0x408(%ebx),%edi
	ARG_UNUSED(unused2);

	/* Cleaning up GTS first */
	_write_gts(_read_gts(info->regs), info->regs);

	while (gpio->poll) {
  1020c6:	80 bb 48 04 00 00 00 	cmpb   $0x0,0x448(%ebx)
  1020cd:	74 53                	je     102122 <_gpio_sch_poll_status+0x80>
static ALWAYS_INLINE
	uint32_t sys_in32(io_port_t port)
{
	uint32_t ret;

	__asm__ volatile("inl	%w1, %0;\n\t"
  1020cf:	8b 06                	mov    (%esi),%eax
  1020d1:	8d 50 1c             	lea    0x1c(%eax),%edx
  1020d4:	ed                   	in     (%dx),%eax
		uint32_t status;

		status = _read_gts(info->regs);
		if (!status) {
  1020d5:	85 c0                	test   %eax,%eax
  1020d7:	74 30                	je     102109 <_gpio_sch_poll_status+0x67>
  1020d9:	8b 93 00 04 00 00    	mov    0x400(%ebx),%edx
					uint32_t pins)
{
	struct gpio_callback *cb;
	sys_snode_t *node;

	SYS_SLIST_FOR_EACH_NODE(list, node) {
  1020df:	85 d2                	test   %edx,%edx
  1020e1:	74 20                	je     102103 <_gpio_sch_poll_status+0x61>
		cb = (struct gpio_callback *)node;

		if (cb->pin_mask & pins) {
  1020e3:	85 42 08             	test   %eax,0x8(%edx)
  1020e6:	74 17                	je     1020ff <_gpio_sch_poll_status+0x5d>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, pins);
  1020e8:	50                   	push   %eax
  1020e9:	52                   	push   %edx
  1020ea:	ff 75 08             	pushl  0x8(%ebp)
  1020ed:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1020f0:	89 55 f0             	mov    %edx,-0x10(%ebp)
  1020f3:	ff 52 04             	call   *0x4(%edx)
  1020f6:	83 c4 0c             	add    $0xc,%esp
  1020f9:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1020fc:	8b 55 f0             	mov    -0x10(%ebp),%edx
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node)
{
	return !node ? NULL : node->next;
  1020ff:	8b 12                	mov    (%edx),%edx
  102101:	eb dc                	jmp    1020df <_gpio_sch_poll_status+0x3d>


static ALWAYS_INLINE
	void sys_out32(uint32_t data, io_port_t port)
{
	__asm__ volatile("outl	%0, %w1;\n\t"
  102103:	8b 0e                	mov    (%esi),%ecx
  102105:	8d 51 1c             	lea    0x1c(%ecx),%edx
  102108:	ef                   	out    %eax,(%dx)
		/* It's not documented but writing the same status value
		 * into GTS tells to the controller it got handled.
		 */
		_write_gts(status, info->regs);
loop:
		k_timer_start(&gpio->poll_timer, GPIO_SCH_POLLING_MSEC, 0);
  102109:	6a 00                	push   $0x0
  10210b:	68 c8 00 00 00       	push   $0xc8
  102110:	57                   	push   %edi
  102111:	e8 ae 23 00 00       	call   1044c4 <k_timer_start>
  102116:	83 c4 0c             	add    $0xc,%esp
		k_timer_status_sync(&gpio->poll_timer);
  102119:	57                   	push   %edi
  10211a:	e8 1f 24 00 00       	call   10453e <k_timer_status_sync>
  10211f:	58                   	pop    %eax
  102120:	eb a4                	jmp    1020c6 <_gpio_sch_poll_status+0x24>
	}
}
  102122:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102125:	5b                   	pop    %ebx
  102126:	5e                   	pop    %esi
  102127:	5f                   	pop    %edi
  102128:	5d                   	pop    %ebp
  102129:	c3                   	ret    

0010212a <_gpio_pin_config>:
	*reg &= ~(BIT(pin));
	*reg |= (set << pin) & BIT(pin);
}

static void _gpio_pin_config(struct device *dev, uint32_t pin, int flags)
{
  10212a:	55                   	push   %ebp
  10212b:	89 e5                	mov    %esp,%ebp
  10212d:	57                   	push   %edi
  10212e:	56                   	push   %esi
  10212f:	53                   	push   %ebx
  102130:	53                   	push   %ebx
  102131:	89 55 f0             	mov    %edx,-0x10(%ebp)
	const struct gpio_sch_config *info = dev->config->config_info;
  102134:	8b 10                	mov    (%eax),%edx
	*reg &= ~(BIT(pin));
	*reg |= (set << pin) & BIT(pin);
}

static void _gpio_pin_config(struct device *dev, uint32_t pin, int flags)
{
  102136:	89 cb                	mov    %ecx,%ebx
	const struct gpio_sch_config *info = dev->config->config_info;
	struct gpio_sch_data *gpio = dev->driver_data;
  102138:	8b 70 08             	mov    0x8(%eax),%esi
					    uint32_t bit, uint8_t set)  \
	{                                                               \
		_set_bit(addr + __off, bit, set);                       \
	}

DEFINE_MM_REG_SET_BIT(gen, GPIO_SCH_REG_GEN)
  10213b:	b9 01 00 00 00       	mov    $0x1,%ecx
	*reg |= (set << pin) & BIT(pin);
}

static void _gpio_pin_config(struct device *dev, uint32_t pin, int flags)
{
	const struct gpio_sch_config *info = dev->config->config_info;
  102140:	8b 7a 08             	mov    0x8(%edx),%edi
					    uint32_t bit, uint8_t set)  \
	{                                                               \
		_set_bit(addr + __off, bit, set);                       \
	}

DEFINE_MM_REG_SET_BIT(gen, GPIO_SCH_REG_GEN)
  102143:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102146:	8b 07                	mov    (%edi),%eax
  102148:	e8 49 fe ff ff       	call   101f96 <_set_bit>
  10214d:	89 d9                	mov    %ebx,%ecx
  10214f:	83 e1 01             	and    $0x1,%ecx
DEFINE_MM_REG_SET_BIT(gio, GPIO_SCH_REG_GIO)
  102152:	8b 07                	mov    (%edi),%eax
  102154:	83 f1 01             	xor    $0x1,%ecx
  102157:	83 c0 04             	add    $0x4,%eax
  10215a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10215d:	e8 34 fe ff ff       	call   101f96 <_set_bit>
	uint8_t active_low = 0;

	_set_bit_gen(info->regs, pin, 1);
	_set_bit_gio(info->regs, pin, !(flags & GPIO_DIR_MASK));

	if (flags & GPIO_INT) {
  102162:	f6 c3 02             	test   $0x2,%bl
  102165:	74 0e                	je     102175 <_gpio_pin_config+0x4b>
		if (flags & GPIO_INT_ACTIVE_HIGH) {
  102167:	83 e3 04             	and    $0x4,%ebx
			active_high = 1;
		} else {
			active_low = 1;
  10216a:	83 fb 01             	cmp    $0x1,%ebx
  10216d:	0f 92 c2             	setb   %dl
  102170:	19 c0                	sbb    %eax,%eax
  102172:	40                   	inc    %eax
  102173:	eb 04                	jmp    102179 <_gpio_pin_config+0x4f>
static void _gpio_pin_config(struct device *dev, uint32_t pin, int flags)
{
	const struct gpio_sch_config *info = dev->config->config_info;
	struct gpio_sch_data *gpio = dev->driver_data;
	uint8_t active_high = 0;
	uint8_t active_low = 0;
  102175:	31 d2                	xor    %edx,%edx

static void _gpio_pin_config(struct device *dev, uint32_t pin, int flags)
{
	const struct gpio_sch_config *info = dev->config->config_info;
	struct gpio_sch_data *gpio = dev->driver_data;
	uint8_t active_high = 0;
  102177:	31 c0                	xor    %eax,%eax
DEFINE_MM_REG_SET_BIT(gtpe, GPIO_SCH_REG_GTPE)
DEFINE_MM_REG_SET_BIT(gtne, GPIO_SCH_REG_GTNE)

static inline void _set_data_reg(uint32_t *reg, uint8_t pin, uint8_t set)
{
	*reg &= ~(BIT(pin));
  102179:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
	*reg |= (set << pin) & BIT(pin);
  10217d:	0f b6 c0             	movzbl %al,%eax
DEFINE_MM_REG_SET_BIT(gtpe, GPIO_SCH_REG_GTPE)
DEFINE_MM_REG_SET_BIT(gtne, GPIO_SCH_REG_GTNE)

static inline void _set_data_reg(uint32_t *reg, uint8_t pin, uint8_t set)
{
	*reg &= ~(BIT(pin));
  102180:	8b 9e 3c 04 00 00    	mov    0x43c(%esi),%ebx
  102186:	bf 01 00 00 00       	mov    $0x1,%edi
	*reg |= (set << pin) & BIT(pin);
  10218b:	d3 e0                	shl    %cl,%eax
DEFINE_MM_REG_SET_BIT(gtpe, GPIO_SCH_REG_GTPE)
DEFINE_MM_REG_SET_BIT(gtne, GPIO_SCH_REG_GTNE)

static inline void _set_data_reg(uint32_t *reg, uint8_t pin, uint8_t set)
{
	*reg &= ~(BIT(pin));
  10218d:	d3 e7                	shl    %cl,%edi
	*reg |= (set << pin) & BIT(pin);
  10218f:	31 d8                	xor    %ebx,%eax
  102191:	21 f8                	and    %edi,%eax
  102193:	0f b6 d2             	movzbl %dl,%edx
  102196:	31 c3                	xor    %eax,%ebx
DEFINE_MM_REG_SET_BIT(gtpe, GPIO_SCH_REG_GTPE)
DEFINE_MM_REG_SET_BIT(gtne, GPIO_SCH_REG_GTNE)

static inline void _set_data_reg(uint32_t *reg, uint8_t pin, uint8_t set)
{
	*reg &= ~(BIT(pin));
  102198:	8b 86 40 04 00 00    	mov    0x440(%esi),%eax
	*reg |= (set << pin) & BIT(pin);
  10219e:	d3 e2                	shl    %cl,%edx
  1021a0:	31 c2                	xor    %eax,%edx
  1021a2:	89 9e 3c 04 00 00    	mov    %ebx,0x43c(%esi)
  1021a8:	21 fa                	and    %edi,%edx
  1021aa:	31 d0                	xor    %edx,%eax
  1021ac:	89 86 40 04 00 00    	mov    %eax,0x440(%esi)
	/* We store the gtpe/gtne settings. These will be used once
	 * we enable the callback for the pin, or the whole port
	 */
	_set_data_reg(&gpio->int_regs.gtpe, pin, active_high);
	_set_data_reg(&gpio->int_regs.gtne, pin, active_low);
}
  1021b2:	58                   	pop    %eax
  1021b3:	5b                   	pop    %ebx
  1021b4:	5e                   	pop    %esi
  1021b5:	5f                   	pop    %edi
  1021b6:	5d                   	pop    %ebp
  1021b7:	c3                   	ret    

001021b8 <gpio_sch_config>:
	}
}

static int gpio_sch_config(struct device *dev,
			   int access_op, uint32_t pin, int flags)
{
  1021b8:	55                   	push   %ebp
  1021b9:	89 e5                	mov    %esp,%ebp
  1021bb:	57                   	push   %edi
  1021bc:	56                   	push   %esi
  1021bd:	53                   	push   %ebx
  1021be:	8b 75 08             	mov    0x8(%ebp),%esi
  1021c1:	31 db                	xor    %ebx,%ebx
  1021c3:	8b 55 10             	mov    0x10(%ebp),%edx
	const struct gpio_sch_config *info = dev->config->config_info;
  1021c6:	8b 06                	mov    (%esi),%eax

	if (access_op == GPIO_ACCESS_BY_PIN) {
  1021c8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
}

static int gpio_sch_config(struct device *dev,
			   int access_op, uint32_t pin, int flags)
{
	const struct gpio_sch_config *info = dev->config->config_info;
  1021cc:	8b 78 08             	mov    0x8(%eax),%edi

	if (access_op == GPIO_ACCESS_BY_PIN) {
  1021cf:	75 19                	jne    1021ea <gpio_sch_config+0x32>
		if (pin >= info->bits) {
  1021d1:	0f b6 4f 04          	movzbl 0x4(%edi),%ecx
			return -EINVAL;
  1021d5:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
			   int access_op, uint32_t pin, int flags)
{
	const struct gpio_sch_config *info = dev->config->config_info;

	if (access_op == GPIO_ACCESS_BY_PIN) {
		if (pin >= info->bits) {
  1021da:	39 d1                	cmp    %edx,%ecx
  1021dc:	76 25                	jbe    102203 <gpio_sch_config+0x4b>
			return -EINVAL;
		}

		_gpio_pin_config(dev, pin, flags);
  1021de:	8b 4d 14             	mov    0x14(%ebp),%ecx
  1021e1:	89 f0                	mov    %esi,%eax
  1021e3:	e8 42 ff ff ff       	call   10212a <_gpio_pin_config>
  1021e8:	eb 17                	jmp    102201 <gpio_sch_config+0x49>
static inline void _gpio_port_config(struct device *dev, int flags)
{
	const struct gpio_sch_config *info = dev->config->config_info;
	int pin;

	for (pin = 0; pin < info->bits; pin++) {
  1021ea:	0f b6 47 04          	movzbl 0x4(%edi),%eax
  1021ee:	39 c3                	cmp    %eax,%ebx
  1021f0:	7d 0f                	jge    102201 <gpio_sch_config+0x49>
		_gpio_pin_config(dev, pin, flags);
  1021f2:	89 da                	mov    %ebx,%edx
  1021f4:	8b 4d 14             	mov    0x14(%ebp),%ecx
  1021f7:	89 f0                	mov    %esi,%eax
static inline void _gpio_port_config(struct device *dev, int flags)
{
	const struct gpio_sch_config *info = dev->config->config_info;
	int pin;

	for (pin = 0; pin < info->bits; pin++) {
  1021f9:	43                   	inc    %ebx
		_gpio_pin_config(dev, pin, flags);
  1021fa:	e8 2b ff ff ff       	call   10212a <_gpio_pin_config>
  1021ff:	eb e9                	jmp    1021ea <gpio_sch_config+0x32>
		_gpio_pin_config(dev, pin, flags);
	} else {
		_gpio_port_config(dev, flags);
	}

	return 0;
  102201:	31 c0                	xor    %eax,%eax
}
  102203:	5b                   	pop    %ebx
  102204:	5e                   	pop    %esi
  102205:	5f                   	pop    %edi
  102206:	5d                   	pop    %ebp
  102207:	c3                   	ret    

00102208 <gpio_sch_disable_callback>:
	return 0;
}

static int gpio_sch_disable_callback(struct device *dev,
				     int access_op, uint32_t pin)
{
  102208:	55                   	push   %ebp
  102209:	89 e5                	mov    %esp,%ebp
  10220b:	57                   	push   %edi
  10220c:	56                   	push   %esi
  10220d:	53                   	push   %ebx
  10220e:	8b 75 08             	mov    0x8(%ebp),%esi
	const struct gpio_sch_config *info = dev->config->config_info;
	struct gpio_sch_data *gpio = dev->driver_data;

	if (access_op == GPIO_ACCESS_BY_PIN) {
  102211:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
}

static int gpio_sch_disable_callback(struct device *dev,
				     int access_op, uint32_t pin)
{
	const struct gpio_sch_config *info = dev->config->config_info;
  102215:	8b 06                	mov    (%esi),%eax
	struct gpio_sch_data *gpio = dev->driver_data;
  102217:	8b 7e 08             	mov    0x8(%esi),%edi
}

static int gpio_sch_disable_callback(struct device *dev,
				     int access_op, uint32_t pin)
{
	const struct gpio_sch_config *info = dev->config->config_info;
  10221a:	8b 58 08             	mov    0x8(%eax),%ebx
	struct gpio_sch_data *gpio = dev->driver_data;

	if (access_op == GPIO_ACCESS_BY_PIN) {
  10221d:	75 3e                	jne    10225d <gpio_sch_disable_callback+0x55>
		if (pin >= info->bits) {
  10221f:	0f b6 53 04          	movzbl 0x4(%ebx),%edx
			return -ENOTSUP;
  102223:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
{
	const struct gpio_sch_config *info = dev->config->config_info;
	struct gpio_sch_data *gpio = dev->driver_data;

	if (access_op == GPIO_ACCESS_BY_PIN) {
		if (pin >= info->bits) {
  102228:	3b 55 10             	cmp    0x10(%ebp),%edx
  10222b:	76 4f                	jbe    10227c <gpio_sch_disable_callback+0x74>
	}

DEFINE_MM_REG_SET_BIT(gen, GPIO_SCH_REG_GEN)
DEFINE_MM_REG_SET_BIT(gio, GPIO_SCH_REG_GIO)
DEFINE_MM_REG_SET_BIT(glvl, GPIO_SCH_REG_GLVL)
DEFINE_MM_REG_SET_BIT(gtpe, GPIO_SCH_REG_GTPE)
  10222d:	8b 03                	mov    (%ebx),%eax
  10222f:	31 c9                	xor    %ecx,%ecx
  102231:	83 c0 0c             	add    $0xc,%eax
  102234:	8b 55 10             	mov    0x10(%ebp),%edx
  102237:	e8 5a fd ff ff       	call   101f96 <_set_bit>
DEFINE_MM_REG_SET_BIT(gtne, GPIO_SCH_REG_GTNE)
  10223c:	8b 03                	mov    (%ebx),%eax
  10223e:	83 c0 10             	add    $0x10,%eax
  102241:	31 c9                	xor    %ecx,%ecx
  102243:	8b 55 10             	mov    0x10(%ebp),%edx
  102246:	e8 4b fd ff ff       	call   101f96 <_set_bit>
		}

		_set_bit_gtpe(info->regs, pin, 0);
		_set_bit_gtne(info->regs, pin, 0);

		gpio->cb_enabled &= ~BIT(pin);
  10224b:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  102250:	8a 4d 10             	mov    0x10(%ebp),%cl
  102253:	d3 c0                	rol    %cl,%eax
  102255:	21 87 44 04 00 00    	and    %eax,0x444(%edi)
  10225b:	eb 16                	jmp    102273 <gpio_sch_disable_callback+0x6b>
	} else {
		_write_gtpe(0, info->regs);
  10225d:	8b 0b                	mov    (%ebx),%ecx
  10225f:	31 c0                	xor    %eax,%eax
  102261:	8d 51 0c             	lea    0xc(%ecx),%edx
  102264:	ef                   	out    %eax,(%dx)
  102265:	8d 51 10             	lea    0x10(%ecx),%edx
  102268:	ef                   	out    %eax,(%dx)
		_write_gtne(0, info->regs);

		gpio->cb_enabled = 0;
  102269:	c7 87 44 04 00 00 00 	movl   $0x0,0x444(%edi)
  102270:	00 00 00 
	}

	_gpio_sch_manage_callback(dev);
  102273:	89 f0                	mov    %esi,%eax
  102275:	e8 4a fc ff ff       	call   101ec4 <_gpio_sch_manage_callback>

	return 0;
  10227a:	31 c0                	xor    %eax,%eax
}
  10227c:	5b                   	pop    %ebx
  10227d:	5e                   	pop    %esi
  10227e:	5f                   	pop    %edi
  10227f:	5d                   	pop    %ebp
  102280:	c3                   	ret    

00102281 <i2c_dw_runtime_configure>:

	return ret;
}

static int i2c_dw_runtime_configure(struct device *dev, uint32_t config)
{
  102281:	55                   	push   %ebp
  102282:	89 e5                	mov    %esp,%ebp
  102284:	53                   	push   %ebx
	struct i2c_dw_dev_config * const dw = dev->driver_data;
  102285:	8b 55 08             	mov    0x8(%ebp),%edx

	return ret;
}

static int i2c_dw_runtime_configure(struct device *dev, uint32_t config)
{
  102288:	8b 45 0c             	mov    0xc(%ebp),%eax
	struct i2c_dw_dev_config * const dw = dev->driver_data;
  10228b:	8b 4a 08             	mov    0x8(%edx),%ecx
	uint32_t	rc = 0;

	volatile struct i2c_dw_registers * const regs =
		(struct i2c_dw_registers *)dw->base_address;

	dw->app_config.raw = config;
  10228e:	89 41 14             	mov    %eax,0x14(%ecx)
{
	struct i2c_dw_dev_config * const dw = dev->driver_data;
	uint32_t	value = 0;
	uint32_t	rc = 0;

	volatile struct i2c_dw_registers * const regs =
  102291:	8b 11                	mov    (%ecx),%edx

	dw->app_config.raw = config;

	/* Make sure we have a supported speed for the DesignWare model */
	/* and have setup the clock frequency and speed mode */
	switch (dw->app_config.bits.speed) {
  102293:	d0 e8                	shr    %al
  102295:	83 e0 07             	and    $0x7,%eax
  102298:	3c 03                	cmp    $0x3,%al
  10229a:	77 0d                	ja     1022a9 <i2c_dw_runtime_configure+0x28>
  10229c:	3c 02                	cmp    $0x2,%al
  10229e:	73 45                	jae    1022e5 <i2c_dw_runtime_configure+0x64>
  1022a0:	fe c8                	dec    %al
  1022a2:	74 0e                	je     1022b2 <i2c_dw_runtime_configure+0x31>
  1022a4:	e9 c6 00 00 00       	jmp    10236f <i2c_dw_runtime_configure+0xee>
  1022a9:	3c 04                	cmp    $0x4,%al
  1022ab:	74 73                	je     102320 <i2c_dw_runtime_configure+0x9f>
  1022ad:	e9 bd 00 00 00       	jmp    10236f <i2c_dw_runtime_configure+0xee>
	case I2C_SPEED_STANDARD:
		/* Following the directions on DW spec page 59, IC_SS_SCL_LCNT
		 * must have register values larger than IC_FS_SPKLEN + 7
		 */
		if (I2C_STD_LCNT <= (regs->ic_fs_spklen + 7)) {
  1022b2:	8b 9a a0 00 00 00    	mov    0xa0(%edx),%ebx
			value = regs->ic_fs_spklen + 8;
		} else {
			value = I2C_STD_LCNT;
  1022b8:	b8 7d 00 00 00       	mov    $0x7d,%eax
	switch (dw->app_config.bits.speed) {
	case I2C_SPEED_STANDARD:
		/* Following the directions on DW spec page 59, IC_SS_SCL_LCNT
		 * must have register values larger than IC_FS_SPKLEN + 7
		 */
		if (I2C_STD_LCNT <= (regs->ic_fs_spklen + 7)) {
  1022bd:	83 c3 07             	add    $0x7,%ebx
  1022c0:	83 fb 7c             	cmp    $0x7c,%ebx
  1022c3:	76 09                	jbe    1022ce <i2c_dw_runtime_configure+0x4d>
			value = regs->ic_fs_spklen + 8;
  1022c5:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
  1022cb:	83 c0 08             	add    $0x8,%eax
		dw->lcnt = value;

		/* Following the directions on DW spec page 59, IC_SS_SCL_HCNT
		 * must have register values larger than IC_FS_SPKLEN + 5
		 */
		if (I2C_STD_HCNT <= (regs->ic_fs_spklen + 5)) {
  1022ce:	8b 9a a0 00 00 00    	mov    0xa0(%edx),%ebx
			value = regs->ic_fs_spklen + 8;
		} else {
			value = I2C_STD_LCNT;
		}

		dw->lcnt = value;
  1022d4:	66 89 41 26          	mov    %ax,0x26(%ecx)

		/* Following the directions on DW spec page 59, IC_SS_SCL_HCNT
		 * must have register values larger than IC_FS_SPKLEN + 5
		 */
		if (I2C_STD_HCNT <= (regs->ic_fs_spklen + 5)) {
  1022d8:	83 c3 05             	add    $0x5,%ebx
			value = regs->ic_fs_spklen + 6;
		} else {
			value = I2C_STD_HCNT;
  1022db:	b8 64 00 00 00       	mov    $0x64,%eax
		dw->lcnt = value;

		/* Following the directions on DW spec page 59, IC_SS_SCL_HCNT
		 * must have register values larger than IC_FS_SPKLEN + 5
		 */
		if (I2C_STD_HCNT <= (regs->ic_fs_spklen + 5)) {
  1022e0:	83 fb 63             	cmp    $0x63,%ebx
  1022e3:	eb 31                	jmp    102316 <i2c_dw_runtime_configure+0x95>
	case I2C_SPEED_FAST_PLUS:
		/*
		 * Following the directions on DW spec page 59, IC_FS_SCL_LCNT
		 * must have register values larger than IC_FS_SPKLEN + 7
		 */
		if (I2C_FS_LCNT <= (regs->ic_fs_spklen + 7)) {
  1022e5:	8b 9a a0 00 00 00    	mov    0xa0(%edx),%ebx
			value = regs->ic_fs_spklen + 8;
		} else {
			value = I2C_FS_LCNT;
  1022eb:	b8 15 00 00 00       	mov    $0x15,%eax
	case I2C_SPEED_FAST_PLUS:
		/*
		 * Following the directions on DW spec page 59, IC_FS_SCL_LCNT
		 * must have register values larger than IC_FS_SPKLEN + 7
		 */
		if (I2C_FS_LCNT <= (regs->ic_fs_spklen + 7)) {
  1022f0:	83 c3 07             	add    $0x7,%ebx
  1022f3:	83 fb 14             	cmp    $0x14,%ebx
  1022f6:	76 09                	jbe    102301 <i2c_dw_runtime_configure+0x80>
			value = regs->ic_fs_spklen + 8;
  1022f8:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
  1022fe:	83 c0 08             	add    $0x8,%eax

		/*
		 * Following the directions on DW spec page 59, IC_FS_SCL_HCNT
		 * must have register values larger than IC_FS_SPKLEN + 5
		 */
		if (I2C_FS_HCNT <= (regs->ic_fs_spklen + 5)) {
  102301:	8b 9a a0 00 00 00    	mov    0xa0(%edx),%ebx
			value = regs->ic_fs_spklen + 8;
		} else {
			value = I2C_FS_LCNT;
		}

		dw->lcnt = value;
  102307:	66 89 41 26          	mov    %ax,0x26(%ecx)

		/*
		 * Following the directions on DW spec page 59, IC_FS_SCL_HCNT
		 * must have register values larger than IC_FS_SPKLEN + 5
		 */
		if (I2C_FS_HCNT <= (regs->ic_fs_spklen + 5)) {
  10230b:	83 c3 05             	add    $0x5,%ebx
			value = regs->ic_fs_spklen + 6;
		} else {
			value = I2C_FS_HCNT;
  10230e:	b8 12 00 00 00       	mov    $0x12,%eax

		/*
		 * Following the directions on DW spec page 59, IC_FS_SCL_HCNT
		 * must have register values larger than IC_FS_SPKLEN + 5
		 */
		if (I2C_FS_HCNT <= (regs->ic_fs_spklen + 5)) {
  102313:	83 fb 11             	cmp    $0x11,%ebx
  102316:	76 4f                	jbe    102367 <i2c_dw_runtime_configure+0xe6>
			value = regs->ic_fs_spklen + 6;
  102318:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
  10231e:	eb 44                	jmp    102364 <i2c_dw_runtime_configure+0xe3>
				value = I2C_HS_HCNT;
			}

			dw->hcnt = value;
		} else {
			rc = -EINVAL;
  102320:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
		}

		dw->hcnt = value;
		break;
	case I2C_SPEED_HIGH:
		if (dw->support_hs_mode) {
  102325:	80 79 2b 00          	cmpb   $0x0,0x2b(%ecx)
  102329:	74 49                	je     102374 <i2c_dw_runtime_configure+0xf3>
			if (I2C_HS_LCNT <= (regs->ic_hs_spklen + 7)) {
  10232b:	8b 9a a4 00 00 00    	mov    0xa4(%edx),%ebx
				value = regs->ic_hs_spklen + 8;
			} else {
				value = I2C_HS_LCNT;
  102331:	b8 15 00 00 00       	mov    $0x15,%eax

		dw->hcnt = value;
		break;
	case I2C_SPEED_HIGH:
		if (dw->support_hs_mode) {
			if (I2C_HS_LCNT <= (regs->ic_hs_spklen + 7)) {
  102336:	83 c3 07             	add    $0x7,%ebx
  102339:	83 fb 14             	cmp    $0x14,%ebx
  10233c:	76 09                	jbe    102347 <i2c_dw_runtime_configure+0xc6>
				value = regs->ic_hs_spklen + 8;
  10233e:	8b 82 a4 00 00 00    	mov    0xa4(%edx),%eax
  102344:	83 c0 08             	add    $0x8,%eax
				value = I2C_HS_LCNT;
			}

			dw->lcnt = value;

			if (I2C_HS_HCNT <= (regs->ic_hs_spklen + 5)) {
  102347:	8b 9a a4 00 00 00    	mov    0xa4(%edx),%ebx
				value = regs->ic_hs_spklen + 8;
			} else {
				value = I2C_HS_LCNT;
			}

			dw->lcnt = value;
  10234d:	66 89 41 26          	mov    %ax,0x26(%ecx)

			if (I2C_HS_HCNT <= (regs->ic_hs_spklen + 5)) {
  102351:	83 c3 05             	add    $0x5,%ebx
				value = regs->ic_hs_spklen + 6;
			} else {
				value = I2C_HS_HCNT;
  102354:	b8 12 00 00 00       	mov    $0x12,%eax
				value = I2C_HS_LCNT;
			}

			dw->lcnt = value;

			if (I2C_HS_HCNT <= (regs->ic_hs_spklen + 5)) {
  102359:	83 fb 11             	cmp    $0x11,%ebx
  10235c:	76 09                	jbe    102367 <i2c_dw_runtime_configure+0xe6>
				value = regs->ic_hs_spklen + 6;
  10235e:	8b 82 a4 00 00 00    	mov    0xa4(%edx),%eax
  102364:	83 c0 06             	add    $0x6,%eax
			} else {
				value = I2C_HS_HCNT;
			}

			dw->hcnt = value;
  102367:	66 89 41 24          	mov    %ax,0x24(%ecx)

static int i2c_dw_runtime_configure(struct device *dev, uint32_t config)
{
	struct i2c_dw_dev_config * const dw = dev->driver_data;
	uint32_t	value = 0;
	uint32_t	rc = 0;
  10236b:	31 c0                	xor    %eax,%eax
  10236d:	eb 05                	jmp    102374 <i2c_dw_runtime_configure+0xf3>
			rc = -EINVAL;
		}
		break;
	default:
		/* TODO change */
		rc = -EINVAL;
  10236f:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	}

	/*
	 * Clear any interrupts currently waiting in the controller
	 */
	value = regs->ic_clr_intr;
  102374:	66 8b 52 40          	mov    0x40(%edx),%dx
	/*
	 * TEMPORARY HACK - The I2C does not work in any mode other than Master
	 * currently.  This "hack" forces us to always be configured for master
	 * mode, until we can verify that Slave mode works correctly.
	 */
	dw->app_config.bits.is_master_device = 1;
  102378:	80 49 14 10          	orb    $0x10,0x14(%ecx)

	return rc;
}
  10237c:	5b                   	pop    %ebx
  10237d:	5d                   	pop    %ebp
  10237e:	c3                   	ret    

0010237f <i2c_dw_transfer>:
}

static int i2c_dw_transfer(struct device *dev,
			   struct i2c_msg *msgs, uint8_t num_msgs,
			   uint16_t slave_address)
{
  10237f:	55                   	push   %ebp
  102380:	89 e5                	mov    %esp,%ebp
  102382:	57                   	push   %edi
  102383:	56                   	push   %esi
  102384:	53                   	push   %ebx
  102385:	83 ec 08             	sub    $0x8,%esp
	struct i2c_dw_dev_config * const dw = dev->driver_data;
  102388:	8b 7d 08             	mov    0x8(%ebp),%edi
}

static int i2c_dw_transfer(struct device *dev,
			   struct i2c_msg *msgs, uint8_t num_msgs,
			   uint16_t slave_address)
{
  10238b:	8b 75 14             	mov    0x14(%ebp),%esi
  10238e:	8b 45 10             	mov    0x10(%ebp),%eax
  102391:	89 75 ec             	mov    %esi,-0x14(%ebp)
	struct i2c_dw_dev_config * const dw = dev->driver_data;
  102394:	8b 5f 08             	mov    0x8(%edi),%ebx
}

static int i2c_dw_transfer(struct device *dev,
			   struct i2c_msg *msgs, uint8_t num_msgs,
			   uint16_t slave_address)
{
  102397:	88 45 f3             	mov    %al,-0xd(%ebp)

	volatile struct i2c_dw_registers * const regs =
		(struct i2c_dw_registers *)dw->base_address;

	/* Why bother processing no messages */
	if (!msgs || !num_msgs) {
  10239a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
	struct i2c_msg *cur_msg = msgs;
	uint8_t msg_left = num_msgs;
	uint8_t pflags;
	int ret;

	volatile struct i2c_dw_registers * const regs =
  10239e:	8b 33                	mov    (%ebx),%esi
		(struct i2c_dw_registers *)dw->base_address;

	/* Why bother processing no messages */
	if (!msgs || !num_msgs) {
  1023a0:	0f 84 e1 01 00 00    	je     102587 <i2c_dw_transfer+0x208>
  1023a6:	84 c0                	test   %al,%al
  1023a8:	0f 84 d9 01 00 00    	je     102587 <i2c_dw_transfer+0x208>
		return -ENOTSUP;
	}

	/* First step, check if there is current activity */
	if ((regs->ic_status.bits.activity) || (dw->state & I2C_DW_BUSY)) {
  1023ae:	8b 56 70             	mov    0x70(%esi),%edx
		return -EIO;
  1023b1:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	if (!msgs || !num_msgs) {
		return -ENOTSUP;
	}

	/* First step, check if there is current activity */
	if ((regs->ic_status.bits.activity) || (dw->state & I2C_DW_BUSY)) {
  1023b6:	80 e2 01             	and    $0x1,%dl
  1023b9:	0f 85 cd 01 00 00    	jne    10258c <i2c_dw_transfer+0x20d>
  1023bf:	8a 53 28             	mov    0x28(%ebx),%dl
  1023c2:	80 e2 08             	and    $0x8,%dl
  1023c5:	0f 85 c1 01 00 00    	jne    10258c <i2c_dw_transfer+0x20d>
		return -EIO;
	}

	dw->state |= I2C_DW_BUSY;
  1023cb:	8a 43 28             	mov    0x28(%ebx),%al
	uint32_t value;
	union ic_con_register ic_con;
	volatile struct i2c_dw_registers * const regs =
		(struct i2c_dw_registers *)dw->base_address;

	ic_con.raw = 0;
  1023ce:	31 d2                	xor    %edx,%edx
	/* First step, check if there is current activity */
	if ((regs->ic_status.bits.activity) || (dw->state & I2C_DW_BUSY)) {
		return -EIO;
	}

	dw->state |= I2C_DW_BUSY;
  1023d0:	83 c8 08             	or     $0x8,%eax
  1023d3:	88 43 28             	mov    %al,0x28(%ebx)
}


static int _i2c_dw_setup(struct device *dev, uint16_t slave_address)
{
	struct i2c_dw_dev_config * const dw = dev->driver_data;
  1023d6:	8b 7f 08             	mov    0x8(%edi),%edi
	uint32_t value;
	union ic_con_register ic_con;
	volatile struct i2c_dw_registers * const regs =
  1023d9:	8b 07                	mov    (%edi),%eax
		(struct i2c_dw_registers *)dw->base_address;

	ic_con.raw = 0;

	/* Disable the device controller to be able set TAR */
	regs->ic_enable.bits.enable = 0;
  1023db:	66 8b 48 6c          	mov    0x6c(%eax),%cx
  1023df:	83 e1 fe             	and    $0xfffffffe,%ecx
  1023e2:	66 89 48 6c          	mov    %cx,0x6c(%eax)

	/* Disable interrupts */
	regs->ic_intr_mask.raw = 0;
  1023e6:	66 c7 40 30 00 00    	movw   $0x0,0x30(%eax)

	/* Clear interrupts */
	value = regs->ic_clr_intr;
  1023ec:	66 8b 48 40          	mov    0x40(%eax),%cx

	/* Set master or slave mode - (initialization = slave) */
	if (dw->app_config.bits.is_master_device) {
  1023f0:	8a 4f 14             	mov    0x14(%edi),%cl
  1023f3:	f6 c1 10             	test   $0x10,%cl
  1023f6:	74 05                	je     1023fd <i2c_dw_transfer+0x7e>
		 * Make sure to set both the master_mode and slave_disable_bit
		 * to both 0 or both 1
		 */
		SYS_LOG_DBG("I2C: host configured as Master Device");
		ic_con.bits.master_mode = 1;
		ic_con.bits.slave_disable = 1;
  1023f8:	ba 41 00 00 00       	mov    $0x41,%edx
	}

	ic_con.bits.restart_en = 1;
  1023fd:	83 ca 20             	or     $0x20,%edx

	/* Set addressing mode - (initialization = 7 bit) */
	if (dw->app_config.bits.use_10_bit_addr) {
  102400:	f6 c1 01             	test   $0x1,%cl
  102403:	74 03                	je     102408 <i2c_dw_transfer+0x89>
		SYS_LOG_DBG("I2C: using 10-bit address");
		ic_con.bits.addr_master_10bit = 1;
		ic_con.bits.addr_slave_10bit = 1;
  102405:	83 ca 18             	or     $0x18,%edx
	}

	/* Setup the clock frequency and speed mode */
	switch (dw->app_config.bits.speed) {
  102408:	d0 e9                	shr    %cl
  10240a:	83 e1 07             	and    $0x7,%ecx
  10240d:	80 f9 03             	cmp    $0x3,%cl
  102410:	77 24                	ja     102436 <i2c_dw_transfer+0xb7>
  102412:	80 f9 02             	cmp    $0x2,%cl
  102415:	73 26                	jae    10243d <i2c_dw_transfer+0xbe>
  102417:	fe c9                	dec    %cl
  102419:	0f 85 92 00 00 00    	jne    1024b1 <i2c_dw_transfer+0x132>
	case I2C_SPEED_STANDARD:
		SYS_LOG_DBG("I2C: speed set to STANDARD");
		regs->ic_ss_scl_lcnt = dw->lcnt;
  10241f:	66 8b 4f 26          	mov    0x26(%edi),%cx
		regs->ic_ss_scl_hcnt = dw->hcnt;
		ic_con.bits.speed = I2C_DW_SPEED_STANDARD;
  102423:	83 e2 f9             	and    $0xfffffff9,%edx

	/* Setup the clock frequency and speed mode */
	switch (dw->app_config.bits.speed) {
	case I2C_SPEED_STANDARD:
		SYS_LOG_DBG("I2C: speed set to STANDARD");
		regs->ic_ss_scl_lcnt = dw->lcnt;
  102426:	66 89 48 18          	mov    %cx,0x18(%eax)
		regs->ic_ss_scl_hcnt = dw->hcnt;
  10242a:	8b 4f 24             	mov    0x24(%edi),%ecx
  10242d:	66 89 48 14          	mov    %cx,0x14(%eax)
		ic_con.bits.speed = I2C_DW_SPEED_STANDARD;
  102431:	83 ca 02             	or     $0x2,%edx
  102434:	eb 36                	jmp    10246c <i2c_dw_transfer+0xed>
		ic_con.bits.addr_master_10bit = 1;
		ic_con.bits.addr_slave_10bit = 1;
	}

	/* Setup the clock frequency and speed mode */
	switch (dw->app_config.bits.speed) {
  102436:	80 f9 04             	cmp    $0x4,%cl
  102439:	74 19                	je     102454 <i2c_dw_transfer+0xd5>
  10243b:	eb 74                	jmp    1024b1 <i2c_dw_transfer+0x132>
		break;
	case I2C_SPEED_FAST:
		/* fall through */
	case I2C_SPEED_FAST_PLUS:
		SYS_LOG_DBG("I2C: speed set to FAST or FAST_PLUS");
		regs->ic_fs_scl_lcnt = dw->lcnt;
  10243d:	66 8b 4f 26          	mov    0x26(%edi),%cx
		regs->ic_fs_scl_hcnt = dw->hcnt;
		ic_con.bits.speed = I2C_DW_SPEED_FAST;
  102441:	83 e2 f9             	and    $0xfffffff9,%edx
		break;
	case I2C_SPEED_FAST:
		/* fall through */
	case I2C_SPEED_FAST_PLUS:
		SYS_LOG_DBG("I2C: speed set to FAST or FAST_PLUS");
		regs->ic_fs_scl_lcnt = dw->lcnt;
  102444:	66 89 48 20          	mov    %cx,0x20(%eax)
		regs->ic_fs_scl_hcnt = dw->hcnt;
  102448:	8b 4f 24             	mov    0x24(%edi),%ecx
  10244b:	66 89 48 1c          	mov    %cx,0x1c(%eax)
		ic_con.bits.speed = I2C_DW_SPEED_FAST;
  10244f:	83 ca 04             	or     $0x4,%edx
  102452:	eb 18                	jmp    10246c <i2c_dw_transfer+0xed>

		break;
	case I2C_SPEED_HIGH:
		if (!dw->support_hs_mode) {
  102454:	80 7f 2b 00          	cmpb   $0x0,0x2b(%edi)
  102458:	74 57                	je     1024b1 <i2c_dw_transfer+0x132>
			return -EINVAL;
		}

		SYS_LOG_DBG("I2C: speed set to HIGH");
		regs->ic_hs_scl_lcnt = dw->lcnt;
  10245a:	66 8b 4f 26          	mov    0x26(%edi),%cx
		regs->ic_hs_scl_hcnt = dw->hcnt;
		ic_con.bits.speed = I2C_DW_SPEED_HIGH;
  10245e:	83 ca 06             	or     $0x6,%edx
		if (!dw->support_hs_mode) {
			return -EINVAL;
		}

		SYS_LOG_DBG("I2C: speed set to HIGH");
		regs->ic_hs_scl_lcnt = dw->lcnt;
  102461:	66 89 48 28          	mov    %cx,0x28(%eax)
		regs->ic_hs_scl_hcnt = dw->hcnt;
  102465:	8b 4f 24             	mov    0x24(%edi),%ecx
  102468:	66 89 48 24          	mov    %cx,0x24(%eax)

	SYS_LOG_DBG("I2C: lcnt = %d", dw->lcnt);
	SYS_LOG_DBG("I2C: hcnt = %d", dw->hcnt);

	/* Set the IC_CON register */
	regs->ic_con = ic_con;
  10246c:	66 89 10             	mov    %dx,(%eax)
	 * Setting it to zero automatically triggers interrupt
	 * RX_FULL whenever there is data received.
	 *
	 * TODO: extend the threshold for multi-byte RX.
	 */
	regs->ic_rx_tl = 0;
  10246f:	66 c7 40 38 00 00    	movw   $0x0,0x38(%eax)
	 * the controller do the transfers for longer period
	 * before we need to fill the FIFO again. This may
	 * cause some pauses during transfers, but this keeps
	 * the device from interrupting often.
	 */
	regs->ic_tx_tl = 0;
  102475:	66 c7 40 3c 00 00    	movw   $0x0,0x3c(%eax)

	if (regs->ic_con.bits.master_mode) {
  10247b:	8b 10                	mov    (%eax),%edx
  10247d:	80 e2 01             	and    $0x1,%dl
		/* Set address of target slave */
		regs->ic_tar.bits.ic_tar = slave_address;
  102480:	8b 55 ec             	mov    -0x14(%ebp),%edx
	 * cause some pauses during transfers, but this keeps
	 * the device from interrupting often.
	 */
	regs->ic_tx_tl = 0;

	if (regs->ic_con.bits.master_mode) {
  102483:	74 16                	je     10249b <i2c_dw_transfer+0x11c>
		/* Set address of target slave */
		regs->ic_tar.bits.ic_tar = slave_address;
  102485:	66 81 e2 ff 01       	and    $0x1ff,%dx
  10248a:	66 8b 48 04          	mov    0x4(%eax),%cx
  10248e:	66 81 e1 00 fe       	and    $0xfe00,%cx
  102493:	09 ca                	or     %ecx,%edx
  102495:	66 89 50 04          	mov    %dx,0x4(%eax)
  102499:	eb 24                	jmp    1024bf <i2c_dw_transfer+0x140>
	} else {
		/* Set slave address for device */
		regs->ic_sar.bits.ic_sar = slave_address;
  10249b:	66 81 e2 ff 01       	and    $0x1ff,%dx
  1024a0:	66 8b 48 08          	mov    0x8(%eax),%cx
  1024a4:	66 81 e1 00 fe       	and    $0xfe00,%cx
  1024a9:	09 ca                	or     %ecx,%edx
  1024ab:	66 89 50 08          	mov    %dx,0x8(%eax)
  1024af:	eb 0e                	jmp    1024bf <i2c_dw_transfer+0x140>
		ic_con.bits.speed = I2C_DW_SPEED_FAST;

		break;
	case I2C_SPEED_HIGH:
		if (!dw->support_hs_mode) {
			return -EINVAL;
  1024b1:	b8 ea ff ff ff       	mov    $0xffffffea,%eax

	dw->state |= I2C_DW_BUSY;

	ret = _i2c_dw_setup(dev, slave_address);
	if (ret) {
		dw->state = I2C_DW_STATE_READY;
  1024b6:	c6 43 28 00          	movb   $0x0,0x28(%ebx)
		return ret;
  1024ba:	e9 cd 00 00 00       	jmp    10258c <i2c_dw_transfer+0x20d>
	}

	/* Enable controller */
	regs->ic_enable.bits.enable = 1;
  1024bf:	66 8b 46 6c          	mov    0x6c(%esi),%ax
  1024c3:	83 c8 01             	or     $0x1,%eax
  1024c6:	66 89 46 6c          	mov    %ax,0x6c(%esi)
	 * Note : This is just a sample to show a possible use of the API, it is
	 * upto the driver expert to see, if he actually needs it here, or
	 * somewhere else, or not needed as the driver's suspend()/resume()
	 * can handle everything
	 */
	device_busy_set(dev);
  1024ca:	ff 75 08             	pushl  0x8(%ebp)
  1024cd:	e8 4e 12 00 00       	call   103720 <device_busy_set>
  1024d2:	5f                   	pop    %edi
  1024d3:	8d 7b 04             	lea    0x4(%ebx),%edi

		/* Process all the messages */
	while (msg_left > 0) {
		pflags = dw->xfr_flags;

		dw->xfr_buf = cur_msg->buf;
  1024d6:	8b 45 0c             	mov    0xc(%ebp),%eax
	 */
	device_busy_set(dev);

		/* Process all the messages */
	while (msg_left > 0) {
		pflags = dw->xfr_flags;
  1024d9:	8a 53 2a             	mov    0x2a(%ebx),%dl

		dw->xfr_buf = cur_msg->buf;
  1024dc:	8b 00                	mov    (%eax),%eax
  1024de:	89 43 18             	mov    %eax,0x18(%ebx)
		dw->xfr_len = cur_msg->len;
  1024e1:	8b 45 0c             	mov    0xc(%ebp),%eax
  1024e4:	8b 48 04             	mov    0x4(%eax),%ecx
  1024e7:	89 4b 1c             	mov    %ecx,0x1c(%ebx)
		dw->xfr_flags = cur_msg->flags;
  1024ea:	8a 40 08             	mov    0x8(%eax),%al
		dw->rx_pending = 0;
  1024ed:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)

		/* Need to RESTART if changing transfer direction */
		if ((pflags & I2C_MSG_RW_MASK)
  1024f4:	31 c2                	xor    %eax,%edx
	while (msg_left > 0) {
		pflags = dw->xfr_flags;

		dw->xfr_buf = cur_msg->buf;
		dw->xfr_len = cur_msg->len;
		dw->xfr_flags = cur_msg->flags;
  1024f6:	88 43 2a             	mov    %al,0x2a(%ebx)
		dw->rx_pending = 0;

		/* Need to RESTART if changing transfer direction */
		if ((pflags & I2C_MSG_RW_MASK)
  1024f9:	80 e2 01             	and    $0x1,%dl
  1024fc:	74 06                	je     102504 <i2c_dw_transfer+0x185>
		    != (dw->xfr_flags & I2C_MSG_RW_MASK)) {
			dw->xfr_flags |= I2C_MSG_RESTART;
  1024fe:	83 c8 04             	or     $0x4,%eax
  102501:	88 43 2a             	mov    %al,0x2a(%ebx)
		}

		/* Send STOP if this is the last message */
		if (msg_left == 1) {
  102504:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
  102508:	75 04                	jne    10250e <i2c_dw_transfer+0x18f>
			dw->xfr_flags |= I2C_MSG_STOP;
  10250a:	80 4b 2a 02          	orb    $0x2,0x2a(%ebx)
		}

		dw->state &= ~(I2C_DW_CMD_SEND | I2C_DW_CMD_RECV);
  10250e:	8a 43 28             	mov    0x28(%ebx),%al
  102511:	83 e0 fc             	and    $0xfffffffc,%eax

		if ((dw->xfr_flags & I2C_MSG_RW_MASK) == I2C_MSG_WRITE) {
  102514:	f6 43 2a 01          	testb  $0x1,0x2a(%ebx)
		/* Send STOP if this is the last message */
		if (msg_left == 1) {
			dw->xfr_flags |= I2C_MSG_STOP;
		}

		dw->state &= ~(I2C_DW_CMD_SEND | I2C_DW_CMD_RECV);
  102518:	88 43 28             	mov    %al,0x28(%ebx)

		if ((dw->xfr_flags & I2C_MSG_RW_MASK) == I2C_MSG_WRITE) {
			dw->state |= I2C_DW_CMD_SEND;
  10251b:	8a 43 28             	mov    0x28(%ebx),%al
			dw->xfr_flags |= I2C_MSG_STOP;
		}

		dw->state &= ~(I2C_DW_CMD_SEND | I2C_DW_CMD_RECV);

		if ((dw->xfr_flags & I2C_MSG_RW_MASK) == I2C_MSG_WRITE) {
  10251e:	75 0c                	jne    10252c <i2c_dw_transfer+0x1ad>
			dw->state |= I2C_DW_CMD_SEND;
  102520:	83 c8 01             	or     $0x1,%eax
			dw->request_bytes = 0;
  102523:	c6 43 29 00          	movb   $0x0,0x29(%ebx)
		}

		dw->state &= ~(I2C_DW_CMD_SEND | I2C_DW_CMD_RECV);

		if ((dw->xfr_flags & I2C_MSG_RW_MASK) == I2C_MSG_WRITE) {
			dw->state |= I2C_DW_CMD_SEND;
  102527:	88 43 28             	mov    %al,0x28(%ebx)
  10252a:	eb 09                	jmp    102535 <i2c_dw_transfer+0x1b6>
			dw->request_bytes = 0;
		} else {
			dw->state |= I2C_DW_CMD_RECV;
  10252c:	83 c8 02             	or     $0x2,%eax
			dw->request_bytes = dw->xfr_len;
  10252f:	88 4b 29             	mov    %cl,0x29(%ebx)

		if ((dw->xfr_flags & I2C_MSG_RW_MASK) == I2C_MSG_WRITE) {
			dw->state |= I2C_DW_CMD_SEND;
			dw->request_bytes = 0;
		} else {
			dw->state |= I2C_DW_CMD_RECV;
  102532:	88 43 28             	mov    %al,0x28(%ebx)
			dw->request_bytes = dw->xfr_len;
		}

		/* Enable interrupts to trigger ISR */
		if (regs->ic_con.bits.master_mode) {
  102535:	8b 06                	mov    (%esi),%eax
  102537:	a8 01                	test   $0x1,%al
  102539:	74 08                	je     102543 <i2c_dw_transfer+0x1c4>
			/* Enable necessary interrupts */
			regs->ic_intr_mask.raw = (DW_ENABLE_TX_INT_I2C_MASTER |
  10253b:	66 c7 46 30 5f 02    	movw   $0x25f,0x30(%esi)
  102541:	eb 06                	jmp    102549 <i2c_dw_transfer+0x1ca>
						  DW_ENABLE_RX_INT_I2C_MASTER);
		} else {
			/* Enable necessary interrupts */
			regs->ic_intr_mask.raw = DW_ENABLE_TX_INT_I2C_SLAVE;
  102543:	66 c7 46 30 60 02    	movw   $0x260,0x30(%esi)
  102549:	6a ff                	push   $0xffffffff
  10254b:	57                   	push   %edi
  10254c:	e8 6d 18 00 00       	call   103dbe <k_sem_take>
		}

		/* Wait for transfer to be done */
		device_sync_call_wait(&dw->sync);

		if (dw->state & I2C_DW_CMD_ERROR) {
  102551:	8a 43 28             	mov    0x28(%ebx),%al
  102554:	5a                   	pop    %edx
  102555:	a8 04                	test   $0x4,%al
  102557:	59                   	pop    %ecx
  102558:	75 17                	jne    102571 <i2c_dw_transfer+0x1f2>
			ret = -EIO;
			break;
		}

		/* Something wrong if there is something left to do */
		if (dw->xfr_len > 0) {
  10255a:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  10255e:	75 11                	jne    102571 <i2c_dw_transfer+0x1f2>
			ret = -EIO;
			break;
		}

		cur_msg++;
  102560:	83 45 0c 0c          	addl   $0xc,0xc(%ebp)
	 * can handle everything
	 */
	device_busy_set(dev);

		/* Process all the messages */
	while (msg_left > 0) {
  102564:	fe 4d f3             	decb   -0xd(%ebp)
  102567:	0f 85 69 ff ff ff    	jne    1024d6 <i2c_dw_transfer+0x157>
  10256d:	31 f6                	xor    %esi,%esi
  10256f:	eb 05                	jmp    102576 <i2c_dw_transfer+0x1f7>

		/* Wait for transfer to be done */
		device_sync_call_wait(&dw->sync);

		if (dw->state & I2C_DW_CMD_ERROR) {
			ret = -EIO;
  102571:	be fb ff ff ff       	mov    $0xfffffffb,%esi

		cur_msg++;
		msg_left--;
	}

	device_busy_clear(dev);
  102576:	ff 75 08             	pushl  0x8(%ebp)
  102579:	e8 a7 11 00 00       	call   103725 <device_busy_clear>
  10257e:	58                   	pop    %eax

	dw->state = I2C_DW_STATE_READY;
  10257f:	c6 43 28 00          	movb   $0x0,0x28(%ebx)

	return ret;
  102583:	89 f0                	mov    %esi,%eax
  102585:	eb 05                	jmp    10258c <i2c_dw_transfer+0x20d>
	volatile struct i2c_dw_registers * const regs =
		(struct i2c_dw_registers *)dw->base_address;

	/* Why bother processing no messages */
	if (!msgs || !num_msgs) {
		return -ENOTSUP;
  102587:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
	device_busy_clear(dev);

	dw->state = I2C_DW_STATE_READY;

	return ret;
}
  10258c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10258f:	5b                   	pop    %ebx
  102590:	5e                   	pop    %esi
  102591:	5f                   	pop    %edi
  102592:	5d                   	pop    %ebp
  102593:	c3                   	ret    

00102594 <_i2c_dw_data_read.isra.1>:
		dw->request_bytes--;
		cnt--;
	}
}

static void _i2c_dw_data_read(struct device *dev)
  102594:	55                   	push   %ebp
{
	struct i2c_dw_dev_config * const dw = dev->driver_data;

	volatile struct i2c_dw_registers * const regs =
  102595:	8b 08                	mov    (%eax),%ecx
		dw->request_bytes--;
		cnt--;
	}
}

static void _i2c_dw_data_read(struct device *dev)
  102597:	89 e5                	mov    %esp,%ebp
  102599:	53                   	push   %ebx
	struct i2c_dw_dev_config * const dw = dev->driver_data;

	volatile struct i2c_dw_registers * const regs =
		(struct i2c_dw_registers *)dw->base_address;

	while (regs->ic_status.bits.rfne && (dw->xfr_len > 0)) {
  10259a:	8b 51 70             	mov    0x70(%ecx),%edx
  10259d:	80 e2 08             	and    $0x8,%dl
  1025a0:	75 11                	jne    1025b3 <_i2c_dw_data_read.isra.1+0x1f>
			break;
		}
	}

	/* Nothing to receive anymore */
	if (dw->xfr_len == 0) {
  1025a2:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
  1025a6:	75 2f                	jne    1025d7 <_i2c_dw_data_read.isra.1+0x43>
		dw->state &= ~I2C_DW_CMD_RECV;
  1025a8:	8a 50 28             	mov    0x28(%eax),%dl
  1025ab:	83 e2 fd             	and    $0xfffffffd,%edx
  1025ae:	88 50 28             	mov    %dl,0x28(%eax)
  1025b1:	eb 24                	jmp    1025d7 <_i2c_dw_data_read.isra.1+0x43>
	struct i2c_dw_dev_config * const dw = dev->driver_data;

	volatile struct i2c_dw_registers * const regs =
		(struct i2c_dw_registers *)dw->base_address;

	while (regs->ic_status.bits.rfne && (dw->xfr_len > 0)) {
  1025b3:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
  1025b7:	74 e9                	je     1025a2 <_i2c_dw_data_read.isra.1+0xe>
		dw->xfr_buf[0] = regs->ic_data_cmd.raw;
  1025b9:	8b 50 18             	mov    0x18(%eax),%edx
  1025bc:	66 8b 59 10          	mov    0x10(%ecx),%bx
  1025c0:	88 1a                	mov    %bl,(%edx)

		dw->xfr_buf++;
		dw->xfr_len--;
  1025c2:	8b 58 1c             	mov    0x1c(%eax),%ebx
		(struct i2c_dw_registers *)dw->base_address;

	while (regs->ic_status.bits.rfne && (dw->xfr_len > 0)) {
		dw->xfr_buf[0] = regs->ic_data_cmd.raw;

		dw->xfr_buf++;
  1025c5:	ff 40 18             	incl   0x18(%eax)
		dw->xfr_len--;
  1025c8:	8d 53 ff             	lea    -0x1(%ebx),%edx
		dw->rx_pending--;
  1025cb:	ff 48 20             	decl   0x20(%eax)

	while (regs->ic_status.bits.rfne && (dw->xfr_len > 0)) {
		dw->xfr_buf[0] = regs->ic_data_cmd.raw;

		dw->xfr_buf++;
		dw->xfr_len--;
  1025ce:	89 50 1c             	mov    %edx,0x1c(%eax)
		dw->rx_pending--;

		if (dw->xfr_len == 0) {
  1025d1:	85 d2                	test   %edx,%edx
  1025d3:	75 c5                	jne    10259a <_i2c_dw_data_read.isra.1+0x6>
  1025d5:	eb cb                	jmp    1025a2 <_i2c_dw_data_read.isra.1+0xe>
	/* Nothing to receive anymore */
	if (dw->xfr_len == 0) {
		dw->state &= ~I2C_DW_CMD_RECV;
		return;
	}
}
  1025d7:	5b                   	pop    %ebx
  1025d8:	5d                   	pop    %ebp
  1025d9:	c3                   	ret    

001025da <_i2c_dw_data_send.isra.2>:
static int _i2c_dw_data_send(struct device *dev)
{
	struct i2c_dw_dev_config * const dw = dev->driver_data;
	uint32_t data = 0;

	volatile struct i2c_dw_registers * const regs =
  1025da:	8b 10                	mov    (%eax),%edx
		(struct i2c_dw_registers *)dw->base_address;

	/* Nothing to send anymore, mask the interrupt */
	if (dw->xfr_len == 0) {
  1025dc:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
  1025e0:	75 17                	jne    1025f9 <_i2c_dw_data_send.isra.2+0x1f>
		regs->ic_intr_mask.bits.tx_empty = 0;
  1025e2:	66 8b 4a 30          	mov    0x30(%edx),%cx
  1025e6:	83 e1 ef             	and    $0xffffffef,%ecx
  1025e9:	66 89 4a 30          	mov    %cx,0x30(%edx)

		dw->state &= ~I2C_DW_CMD_SEND;
  1025ed:	8a 50 28             	mov    0x28(%eax),%dl
  1025f0:	83 e2 fe             	and    $0xfffffffe,%edx
  1025f3:	88 50 28             	mov    %dl,0x28(%eax)

		return 0;
  1025f6:	31 c0                	xor    %eax,%eax
			return -EIO;
		}
	}

	return 0;
}
  1025f8:	c3                   	ret    
		return;
	}
}


static int _i2c_dw_data_send(struct device *dev)
  1025f9:	55                   	push   %ebp
  1025fa:	89 e5                	mov    %esp,%ebp
  1025fc:	56                   	push   %esi
  1025fd:	53                   	push   %ebx
		dw->state &= ~I2C_DW_CMD_SEND;

		return 0;
	}

	while (regs->ic_status.bits.tfnf && (dw->xfr_len > 0)) {
  1025fe:	8b 4a 70             	mov    0x70(%edx),%ecx
  102601:	80 e1 02             	and    $0x2,%cl
  102604:	74 43                	je     102649 <_i2c_dw_data_send.isra.2+0x6f>
  102606:	8b 70 1c             	mov    0x1c(%eax),%esi
  102609:	85 f6                	test   %esi,%esi
  10260b:	74 3c                	je     102649 <_i2c_dw_data_send.isra.2+0x6f>
		/* We have something to transmit to a specific host */
		data = dw->xfr_buf[0];
  10260d:	8b 48 18             	mov    0x18(%eax),%ecx

		/* Send RESTART if needed */
		if (dw->xfr_flags & I2C_MSG_RESTART) {
  102610:	8a 58 2a             	mov    0x2a(%eax),%bl
  102613:	f6 c3 04             	test   $0x4,%bl
		return 0;
	}

	while (regs->ic_status.bits.tfnf && (dw->xfr_len > 0)) {
		/* We have something to transmit to a specific host */
		data = dw->xfr_buf[0];
  102616:	0f b6 09             	movzbl (%ecx),%ecx

		/* Send RESTART if needed */
		if (dw->xfr_flags & I2C_MSG_RESTART) {
  102619:	74 09                	je     102624 <_i2c_dw_data_send.isra.2+0x4a>
			data |= IC_DATA_CMD_RESTART;
			dw->xfr_flags &= ~(I2C_MSG_RESTART);
  10261b:	83 e3 fb             	and    $0xfffffffb,%ebx
		/* We have something to transmit to a specific host */
		data = dw->xfr_buf[0];

		/* Send RESTART if needed */
		if (dw->xfr_flags & I2C_MSG_RESTART) {
			data |= IC_DATA_CMD_RESTART;
  10261e:	80 cd 04             	or     $0x4,%ch
			dw->xfr_flags &= ~(I2C_MSG_RESTART);
  102621:	88 58 2a             	mov    %bl,0x2a(%eax)
		}

		/* Send STOP if needed */
		if ((dw->xfr_len == 1) && (dw->xfr_flags & I2C_MSG_STOP)) {
  102624:	4e                   	dec    %esi
  102625:	75 09                	jne    102630 <_i2c_dw_data_send.isra.2+0x56>
  102627:	f6 40 2a 02          	testb  $0x2,0x2a(%eax)
  10262b:	74 03                	je     102630 <_i2c_dw_data_send.isra.2+0x56>
			data |= IC_DATA_CMD_STOP;
  10262d:	80 cd 02             	or     $0x2,%ch
		}

		regs->ic_data_cmd.raw = data;
  102630:	66 89 4a 10          	mov    %cx,0x10(%edx)

		dw->xfr_len--;
  102634:	ff 48 1c             	decl   0x1c(%eax)
		dw->xfr_buf++;
  102637:	ff 40 18             	incl   0x18(%eax)

		if (regs->ic_intr_stat.bits.tx_abrt) {
  10263a:	8b 4a 2c             	mov    0x2c(%edx),%ecx
  10263d:	80 e1 40             	and    $0x40,%cl
  102640:	74 bc                	je     1025fe <_i2c_dw_data_send.isra.2+0x24>
			return -EIO;
  102642:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  102647:	eb 02                	jmp    10264b <_i2c_dw_data_send.isra.2+0x71>
		}
	}

	return 0;
  102649:	31 c0                	xor    %eax,%eax
}
  10264b:	5b                   	pop    %ebx
  10264c:	5e                   	pop    %esi
  10264d:	5d                   	pop    %ebp
  10264e:	c3                   	ret    

0010264f <i2c_dw_isr>:

	device_sync_call_complete(&dw->sync);
}

static void i2c_dw_isr(void *arg)
{
  10264f:	55                   	push   %ebp
  102650:	89 e5                	mov    %esp,%ebp
  102652:	57                   	push   %edi
  102653:	56                   	push   %esi
  102654:	53                   	push   %ebx
  102655:	83 ec 08             	sub    $0x8,%esp
  102658:	8b 7d 08             	mov    0x8(%ebp),%edi
	struct device *port = (struct device *)arg;
	struct i2c_dw_dev_config * const dw = port->driver_data;
  10265b:	8b 5f 08             	mov    0x8(%edi),%ebx
	union ic_interrupt_register intr_stat;
	uint32_t value;
	int ret = 0;

	volatile struct i2c_dw_registers * const regs =
  10265e:	8b 03                	mov    (%ebx),%eax
  102660:	89 45 ec             	mov    %eax,-0x14(%ebp)
		(struct i2c_dw_registers *)dw->base_address;

	/* Cache ic_intr_stat for processing, so there is no need to read
	 * the register multiple times.
	 */
	intr_stat.raw = regs->ic_intr_stat.raw;
  102663:	66 8b 40 2c          	mov    0x2c(%eax),%ax
#if CONFIG_SHARED_IRQ
	/* If using with shared IRQ, this function will be called
	 * by the shared IRQ driver. So check here if the interrupt
	 * is coming from the I2C controller (or somewhere else).
	 */
	if (!intr_stat.raw) {
  102667:	66 85 c0             	test   %ax,%ax
		(struct i2c_dw_registers *)dw->base_address;

	/* Cache ic_intr_stat for processing, so there is no need to read
	 * the register multiple times.
	 */
	intr_stat.raw = regs->ic_intr_stat.raw;
  10266a:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
#if CONFIG_SHARED_IRQ
	/* If using with shared IRQ, this function will be called
	 * by the shared IRQ driver. So check here if the interrupt
	 * is coming from the I2C controller (or somewhere else).
	 */
	if (!intr_stat.raw) {
  10266e:	0f 84 5a 01 00 00    	je     1027ce <i2c_dw_isr+0x17f>
	 */

	SYS_LOG_DBG("I2C: interrupt received");

	/* Check if we are configured as a master device */
	if (regs->ic_con.bits.master_mode) {
  102674:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102677:	8b 00                	mov    (%eax),%eax
  102679:	a8 01                	test   $0x1,%al
  10267b:	0f 84 e2 00 00 00    	je     102763 <i2c_dw_isr+0x114>
		/* Bail early if there is any error. */
		if ((DW_INTR_STAT_TX_ABRT | DW_INTR_STAT_TX_OVER |
  102681:	f6 45 f2 4b          	testb  $0x4b,-0xe(%ebp)
  102685:	74 09                	je     102690 <i2c_dw_isr+0x41>
		     DW_INTR_STAT_RX_OVER | DW_INTR_STAT_RX_UNDER) &
		    intr_stat.raw) {
			dw->state = I2C_DW_CMD_ERROR;
  102687:	c6 43 28 04          	movb   $0x4,0x28(%ebx)
			goto done;
  10268b:	e9 1d 01 00 00       	jmp    1027ad <i2c_dw_isr+0x15e>
		}

		/* Check if the RX FIFO reached threshold */
		if (intr_stat.bits.rx_full) {
  102690:	f6 45 f2 04          	testb  $0x4,-0xe(%ebp)
  102694:	74 07                	je     10269d <i2c_dw_isr+0x4e>
			_i2c_dw_data_read(port);
  102696:	89 d8                	mov    %ebx,%eax
  102698:	e8 f7 fe ff ff       	call   102594 <_i2c_dw_data_read.isra.1>

		/* Check if the TX FIFO is ready for commands.
		 * TX FIFO also serves as command queue where read requests
		 * are written to TX FIFO.
		 */
		if (intr_stat.bits.tx_empty) {
  10269d:	f6 45 f2 10          	testb  $0x10,-0xe(%ebp)
  1026a1:	0f 84 f7 00 00 00    	je     10279e <i2c_dw_isr+0x14f>
			if ((dw->xfr_flags & I2C_MSG_RW_MASK)
  1026a7:	f6 43 2a 01          	testb  $0x1,0x2a(%ebx)
  1026ab:	8b 47 08             	mov    0x8(%edi),%eax
  1026ae:	75 0a                	jne    1026ba <i2c_dw_isr+0x6b>
			    == I2C_MSG_WRITE) {
				ret = _i2c_dw_data_send(port);
  1026b0:	e8 25 ff ff ff       	call   1025da <_i2c_dw_data_send.isra.2>
  1026b5:	e9 97 00 00 00       	jmp    102751 <i2c_dw_isr+0x102>

	volatile struct i2c_dw_registers * const regs =
		(struct i2c_dw_registers *)dw->base_address;

	/* No more bytes to request, so command queue is no longer needed */
	if (dw->request_bytes == 0) {
  1026ba:	8a 50 29             	mov    0x29(%eax),%dl
	uint32_t data;
	uint8_t tx_empty;
	int8_t rx_empty;
	uint8_t cnt;

	volatile struct i2c_dw_registers * const regs =
  1026bd:	8b 30                	mov    (%eax),%esi
		(struct i2c_dw_registers *)dw->base_address;

	/* No more bytes to request, so command queue is no longer needed */
	if (dw->request_bytes == 0) {
  1026bf:	88 55 f1             	mov    %dl,-0xf(%ebp)
  1026c2:	84 d2                	test   %dl,%dl
  1026c4:	75 0d                	jne    1026d3 <i2c_dw_isr+0x84>
		regs->ic_intr_mask.bits.tx_empty = 0;
  1026c6:	66 8b 46 30          	mov    0x30(%esi),%ax
  1026ca:	83 e0 ef             	and    $0xffffffef,%eax
  1026cd:	66 89 46 30          	mov    %ax,0x30(%esi)
  1026d1:	eb 0f                	jmp    1026e2 <i2c_dw_isr+0x93>
		return;
	}

	/* How many bytes we can actually ask */
	rx_empty = (I2C_DW_FIFO_DEPTH - regs->ic_rxflr) - dw->rx_pending;
  1026d3:	8b 4e 78             	mov    0x78(%esi),%ecx

	if (rx_empty < 0) {
  1026d6:	b2 10                	mov    $0x10,%dl
		regs->ic_intr_mask.bits.tx_empty = 0;
		return;
	}

	/* How many bytes we can actually ask */
	rx_empty = (I2C_DW_FIFO_DEPTH - regs->ic_rxflr) - dw->rx_pending;
  1026d8:	03 48 20             	add    0x20(%eax),%ecx

	if (rx_empty < 0) {
  1026db:	28 ca                	sub    %cl,%dl
  1026dd:	88 55 f0             	mov    %dl,-0x10(%ebp)
  1026e0:	79 04                	jns    1026e6 <i2c_dw_isr+0x97>
{
	struct device *port = (struct device *)arg;
	struct i2c_dw_dev_config * const dw = port->driver_data;
	union ic_interrupt_register intr_stat;
	uint32_t value;
	int ret = 0;
  1026e2:	31 c0                	xor    %eax,%eax
  1026e4:	eb 6b                	jmp    102751 <i2c_dw_isr+0x102>
		 */
		return;
	}

	/* How many empty slots in TX FIFO (as command queue) */
	tx_empty = I2C_DW_FIFO_DEPTH - regs->ic_txflr;
  1026e6:	8b 4e 74             	mov    0x74(%esi),%ecx

	/* Figure out how many bytes we can request */
	cnt = min(I2C_DW_FIFO_DEPTH, dw->request_bytes);
	cnt = min(min(tx_empty, rx_empty), cnt);
  1026e9:	80 7d f1 10          	cmpb   $0x10,-0xf(%ebp)
  1026ed:	76 04                	jbe    1026f3 <i2c_dw_isr+0xa4>
  1026ef:	c6 45 f1 10          	movb   $0x10,-0xf(%ebp)
  1026f3:	b2 10                	mov    $0x10,%dl
  1026f5:	29 ca                	sub    %ecx,%edx
  1026f7:	0f b6 ca             	movzbl %dl,%ecx
  1026fa:	0f b6 55 f1          	movzbl -0xf(%ebp),%edx
  1026fe:	39 ca                	cmp    %ecx,%edx
  102700:	7e 02                	jle    102704 <i2c_dw_isr+0xb5>
  102702:	89 ca                	mov    %ecx,%edx
  102704:	0f be 4d f0          	movsbl -0x10(%ebp),%ecx
  102708:	39 ca                	cmp    %ecx,%edx
  10270a:	7e 34                	jle    102740 <i2c_dw_isr+0xf1>
  10270c:	89 ca                	mov    %ecx,%edx
  10270e:	eb 30                	jmp    102740 <i2c_dw_isr+0xf1>
	while (cnt > 0) {
		/* Tell controller to get another byte */
		data = IC_DATA_CMD_CMD;

		/* Send RESTART if needed */
		if (dw->xfr_flags & I2C_MSG_RESTART) {
  102710:	8a 48 2a             	mov    0x2a(%eax),%cl
  102713:	88 4d f1             	mov    %cl,-0xf(%ebp)
	cnt = min(I2C_DW_FIFO_DEPTH, dw->request_bytes);
	cnt = min(min(tx_empty, rx_empty), cnt);

	while (cnt > 0) {
		/* Tell controller to get another byte */
		data = IC_DATA_CMD_CMD;
  102716:	b9 00 01 00 00       	mov    $0x100,%ecx

		/* Send RESTART if needed */
		if (dw->xfr_flags & I2C_MSG_RESTART) {
  10271b:	f6 45 f1 04          	testb  $0x4,-0xf(%ebp)
  10271f:	74 0e                	je     10272f <i2c_dw_isr+0xe0>
			data |= IC_DATA_CMD_RESTART;
			dw->xfr_flags &= ~(I2C_MSG_RESTART);
  102721:	8a 4d f1             	mov    -0xf(%ebp),%cl
  102724:	83 e1 fb             	and    $0xfffffffb,%ecx
  102727:	88 48 2a             	mov    %cl,0x2a(%eax)
		/* Tell controller to get another byte */
		data = IC_DATA_CMD_CMD;

		/* Send RESTART if needed */
		if (dw->xfr_flags & I2C_MSG_RESTART) {
			data |= IC_DATA_CMD_RESTART;
  10272a:	b9 00 05 00 00       	mov    $0x500,%ecx
			dw->xfr_flags &= ~(I2C_MSG_RESTART);
		}

		/* After receiving the last byte, send STOP if needed */
		if ((dw->xfr_flags & I2C_MSG_STOP)
  10272f:	f6 40 2a 02          	testb  $0x2,0x2a(%eax)
  102733:	75 11                	jne    102746 <i2c_dw_isr+0xf7>
		    && (dw->request_bytes == 1)) {
			data |= IC_DATA_CMD_STOP;
		}

		regs->ic_data_cmd.raw = data;
  102735:	66 89 4e 10          	mov    %cx,0x10(%esi)

		dw->rx_pending++;
		dw->request_bytes--;
		cnt--;
  102739:	4a                   	dec    %edx
			data |= IC_DATA_CMD_STOP;
		}

		regs->ic_data_cmd.raw = data;

		dw->rx_pending++;
  10273a:	ff 40 20             	incl   0x20(%eax)
		dw->request_bytes--;
  10273d:	fe 48 29             	decb   0x29(%eax)

	/* Figure out how many bytes we can request */
	cnt = min(I2C_DW_FIFO_DEPTH, dw->request_bytes);
	cnt = min(min(tx_empty, rx_empty), cnt);

	while (cnt > 0) {
  102740:	84 d2                	test   %dl,%dl
  102742:	75 cc                	jne    102710 <i2c_dw_isr+0xc1>
  102744:	eb 9c                	jmp    1026e2 <i2c_dw_isr+0x93>
			dw->xfr_flags &= ~(I2C_MSG_RESTART);
		}

		/* After receiving the last byte, send STOP if needed */
		if ((dw->xfr_flags & I2C_MSG_STOP)
		    && (dw->request_bytes == 1)) {
  102746:	80 78 29 01          	cmpb   $0x1,0x29(%eax)
  10274a:	75 e9                	jne    102735 <i2c_dw_isr+0xe6>
			data |= IC_DATA_CMD_STOP;
  10274c:	80 cd 02             	or     $0x2,%ch
  10274f:	eb e4                	jmp    102735 <i2c_dw_isr+0xe6>
			}

			/* If STOP is not expected, finish processing this
			 * message if there is nothing left to do anymore.
			 */
			if (((dw->xfr_len == 0)
  102751:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  102755:	75 06                	jne    10275d <i2c_dw_isr+0x10e>
			     && !(dw->xfr_flags & I2C_MSG_STOP))
  102757:	f6 43 2a 02          	testb  $0x2,0x2a(%ebx)
  10275b:	74 50                	je     1027ad <i2c_dw_isr+0x15e>
			    || (ret != 0)) {
  10275d:	85 c0                	test   %eax,%eax
  10275f:	75 4c                	jne    1027ad <i2c_dw_isr+0x15e>
  102761:	eb 3b                	jmp    10279e <i2c_dw_isr+0x14f>
			}
		}
	} else { /* we must be configured as a slave device */

		/* We have a read requested by the master device */
		if (intr_stat.bits.rd_req &&
  102763:	f6 45 f2 20          	testb  $0x20,-0xe(%ebp)
  102767:	74 21                	je     10278a <i2c_dw_isr+0x13b>
  102769:	f6 43 14 20          	testb  $0x20,0x14(%ebx)
  10276d:	75 1b                	jne    10278a <i2c_dw_isr+0x13b>
		    (!dw->app_config.bits.is_slave_read)) {

			/* data is not ready to send */
			if (intr_stat.bits.tx_abrt) {
  10276f:	f6 45 f2 40          	testb  $0x40,-0xe(%ebp)
  102773:	74 07                	je     10277c <i2c_dw_isr+0x12d>
				/* clear the TX_ABRT interrupt */
				value = regs->ic_clr_tx_abrt;
  102775:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102778:	66 8b 40 54          	mov    0x54(%eax),%ax
			}

			_i2c_dw_data_send(port);
  10277c:	89 d8                	mov    %ebx,%eax
  10277e:	e8 57 fe ff ff       	call   1025da <_i2c_dw_data_send.isra.2>
			value = regs->ic_clr_rd_req;
  102783:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102786:	66 8b 40 50          	mov    0x50(%eax),%ax
		}

		/* The slave device is ready to receive */
		if (intr_stat.bits.rx_full &&
  10278a:	f6 45 f2 04          	testb  $0x4,-0xe(%ebp)
  10278e:	74 0e                	je     10279e <i2c_dw_isr+0x14f>
  102790:	f6 43 14 20          	testb  $0x20,0x14(%ebx)
  102794:	74 08                	je     10279e <i2c_dw_isr+0x14f>
		    dw->app_config.bits.is_slave_read) {
			_i2c_dw_data_read(port);
  102796:	8b 47 08             	mov    0x8(%edi),%eax
  102799:	e8 f6 fd ff ff       	call   102594 <_i2c_dw_data_read.isra.1>
		}
	}

	/* STOP detected: finish processing this message */
	if (intr_stat.bits.stop_det) {
  10279e:	66 f7 45 f2 00 02    	testw  $0x200,-0xe(%ebp)
  1027a4:	74 28                	je     1027ce <i2c_dw_isr+0x17f>
		value = regs->ic_clr_stop_det;
  1027a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1027a9:	66 8b 40 60          	mov    0x60(%eax),%ax
  1027ad:	8b 47 08             	mov    0x8(%edi),%eax
 *
 * @param sync A pointer to a valid device_sync_call_t
 */
static inline void device_sync_call_complete(device_sync_call_t *sync)
{
	k_sem_give(&sync->f_sem);
  1027b0:	83 c0 04             	add    $0x4,%eax
static inline void _i2c_dw_transfer_complete(struct device *dev)
{
	struct i2c_dw_dev_config * const dw = dev->driver_data;
	uint32_t value;

	volatile struct i2c_dw_registers * const regs =
  1027b3:	8b 50 fc             	mov    -0x4(%eax),%edx
		(struct i2c_dw_registers *)dw->base_address;

	regs->ic_intr_mask.raw = DW_DISABLE_ALL_I2C_INT;
  1027b6:	66 c7 42 30 00 00    	movw   $0x0,0x30(%edx)
	value = regs->ic_clr_intr;
  1027bc:	66 8b 52 40          	mov    0x40(%edx),%dx
  1027c0:	89 45 08             	mov    %eax,0x8(%ebp)

	return;

done:
	_i2c_dw_transfer_complete(port);
}
  1027c3:	59                   	pop    %ecx
  1027c4:	5b                   	pop    %ebx
  1027c5:	5b                   	pop    %ebx
  1027c6:	5e                   	pop    %esi
  1027c7:	5f                   	pop    %edi
  1027c8:	5d                   	pop    %ebp
  1027c9:	e9 ca 15 00 00       	jmp    103d98 <k_sem_give>
  1027ce:	58                   	pop    %eax
  1027cf:	5a                   	pop    %edx
  1027d0:	5b                   	pop    %ebx
  1027d1:	5e                   	pop    %esi
  1027d2:	5f                   	pop    %edi
  1027d3:	5d                   	pop    %ebp
  1027d4:	c3                   	ret    

001027d5 <i2c_dw_initialize>:
#else
#define i2c_dw_pci_setup(_unused_) (1)
#endif /* CONFIG_PCI */

static int i2c_dw_initialize(struct device *port)
{
  1027d5:	55                   	push   %ebp
  1027d6:	89 e5                	mov    %esp,%ebp
  1027d8:	57                   	push   %edi
  1027d9:	56                   	push   %esi
  1027da:	53                   	push   %ebx
  1027db:	53                   	push   %ebx
  1027dc:	8b 75 08             	mov    0x8(%ebp),%esi
	const struct i2c_dw_rom_config * const rom = port->config->config_info;
  1027df:	8b 06                	mov    (%esi),%eax
	struct i2c_dw_dev_config * const dev = port->driver_data;
  1027e1:	8b 5e 08             	mov    0x8(%esi),%ebx
#define i2c_dw_pci_setup(_unused_) (1)
#endif /* CONFIG_PCI */

static int i2c_dw_initialize(struct device *port)
{
	const struct i2c_dw_rom_config * const rom = port->config->config_info;
  1027e4:	8b 78 08             	mov    0x8(%eax),%edi
#ifdef CONFIG_PCI
static inline int i2c_dw_pci_setup(struct device *dev)
{
	struct i2c_dw_dev_config * const dw = dev->driver_data;

	pci_bus_scan_init();
  1027e7:	e8 b4 e1 ff ff       	call   1009a0 <pci_bus_scan_init>

	if (!pci_bus_scan(&dw->pci_dev)) {
  1027ec:	8d 53 2c             	lea    0x2c(%ebx),%edx
  1027ef:	52                   	push   %edx
  1027f0:	89 55 f0             	mov    %edx,-0x10(%ebp)
  1027f3:	e8 16 e2 ff ff       	call   100a0e <pci_bus_scan>
  1027f8:	5a                   	pop    %edx
  1027f9:	85 c0                	test   %eax,%eax
  1027fb:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1027fe:	74 30                	je     102830 <i2c_dw_initialize+0x5b>
		SYS_LOG_DBG("Could not find device");
		return 0;
	}

#ifdef CONFIG_PCI_ENUMERATION
	dw->base_address = dw->pci_dev.addr;
  102800:	8b 43 2c             	mov    0x2c(%ebx),%eax
  102803:	89 03                	mov    %eax,(%ebx)
#endif
	pci_enable_regs(&dw->pci_dev);
  102805:	52                   	push   %edx
  102806:	e8 d4 e7 ff ff       	call   100fdf <pci_enable_regs>
 *
 * @param sync A pointer to a valid device_sync_call_t
 */
static inline void device_sync_call_init(device_sync_call_t *sync)
{
	k_sem_init(&sync->f_sem, 0, UINT_MAX);
  10280b:	8d 43 04             	lea    0x4(%ebx),%eax
  10280e:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  102815:	6a 00                	push   $0x0
  102817:	50                   	push   %eax
  102818:	e8 62 15 00 00       	call   103d7f <k_sem_init>
		return -EPERM;
	}

	device_sync_call_init(&dev->sync);

	regs = (struct i2c_dw_registers *) dev->base_address;
  10281d:	8b 03                	mov    (%ebx),%eax
  10281f:	83 c4 0c             	add    $0xc,%esp

	/* verify that we have a valid DesignWare register first */
	if (regs->ic_comp_type != I2C_DW_MAGIC_KEY) {
  102822:	8b 90 fc 00 00 00    	mov    0xfc(%eax),%edx
  102828:	81 fa 40 01 57 44    	cmp    $0x44570140,%edx
  10282e:	74 09                	je     102839 <i2c_dw_initialize+0x64>
		port->driver_api = NULL;
  102830:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
  102837:	eb 25                	jmp    10285e <i2c_dw_initialize+0x89>
	/*
	 * grab the default value on initialization.  This should be set to the
	 * IC_MAX_SPEED_MODE in the hardware.  If it does support high speed we
	 * can move provide support for it
	 */
	if (regs->ic_con.bits.speed == I2C_DW_SPEED_HIGH) {
  102839:	8b 00                	mov    (%eax),%eax
  10283b:	83 f0 06             	xor    $0x6,%eax
		SYS_LOG_DBG("I2C: high speed supported");
		dev->support_hs_mode = true;
  10283e:	a8 06                	test   $0x6,%al
  102840:	0f 94 43 2b          	sete   0x2b(%ebx)
	} else {
		SYS_LOG_DBG("I2C: high speed NOT supported");
		dev->support_hs_mode = false;
	}

	rom->config_func(port);
  102844:	56                   	push   %esi
  102845:	ff 57 08             	call   *0x8(%edi)
  102848:	58                   	pop    %eax

	if (i2c_dw_runtime_configure(port, dev->app_config.raw) != 0) {
  102849:	ff 73 14             	pushl  0x14(%ebx)
  10284c:	56                   	push   %esi
  10284d:	e8 2f fa ff ff       	call   102281 <i2c_dw_runtime_configure>
  102852:	5a                   	pop    %edx
  102853:	85 c0                	test   %eax,%eax
  102855:	59                   	pop    %ecx
  102856:	75 06                	jne    10285e <i2c_dw_initialize+0x89>
		SYS_LOG_DBG("I2C: Cannot set default configuration 0x%x",
		    dev->app_config.raw);
		return -EPERM;
	}

	dev->state = I2C_DW_STATE_READY;
  102858:	c6 43 28 00          	movb   $0x0,0x28(%ebx)

	return 0;
  10285c:	eb 03                	jmp    102861 <i2c_dw_initialize+0x8c>
	rom->config_func(port);

	if (i2c_dw_runtime_configure(port, dev->app_config.raw) != 0) {
		SYS_LOG_DBG("I2C: Cannot set default configuration 0x%x",
		    dev->app_config.raw);
		return -EPERM;
  10285e:	83 c8 ff             	or     $0xffffffff,%eax
	}

	dev->state = I2C_DW_STATE_READY;

	return 0;
}
  102861:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102864:	5b                   	pop    %ebx
  102865:	5e                   	pop    %esi
  102866:	5f                   	pop    %edi
  102867:	5d                   	pop    %ebp
  102868:	c3                   	ret    

00102869 <i2c_config_0>:
		    &i2c_0_runtime, &i2c_config_dw_0,
		    POST_KERNEL, CONFIG_I2C_INIT_PRIORITY,
		    &funcs);

static void i2c_config_0(struct device *port)
{
  102869:	55                   	push   %ebp
  10286a:	89 e5                	mov    %esp,%ebp
  10286c:	56                   	push   %esi
  10286d:	53                   	push   %ebx
  10286e:	8b 75 08             	mov    0x8(%ebp),%esi

	IRQ_CONNECT(I2C_DW_0_IRQ, CONFIG_I2C_0_IRQ_PRI,
		    i2c_dw_isr, DEVICE_GET(i2c_0), I2C_DW_IRQ_FLAGS);
	irq_enable(rom->irq_num);
#elif defined(CONFIG_I2C_0_IRQ_SHARED)
	const struct i2c_dw_rom_config * const config =
  102871:	8b 06                	mov    (%esi),%eax
		port->config->config_info;
	struct device *shared_irq_dev;

	shared_irq_dev = device_get_binding(config->shared_irq_dev_name);
  102873:	8b 40 08             	mov    0x8(%eax),%eax
  102876:	ff 70 0c             	pushl  0xc(%eax)
  102879:	e8 69 0e 00 00       	call   1036e7 <device_get_binding>
  10287e:	89 c3                	mov    %eax,%ebx
static inline int shared_irq_isr_register(struct device *dev, isr_t isr_func,
				 struct device *isr_dev)
{
	const struct shared_irq_driver_api *api = dev->driver_api;

	return api->isr_register(dev, isr_func, isr_dev);
  102880:	8b 40 04             	mov    0x4(%eax),%eax
  102883:	89 34 24             	mov    %esi,(%esp)
  102886:	68 4f 26 10 00       	push   $0x10264f
  10288b:	53                   	push   %ebx
  10288c:	ff 10                	call   *(%eax)
  10288e:	83 c4 0c             	add    $0xc,%esp
 */
static inline int shared_irq_enable(struct device *dev, struct device *isr_dev)
{
	const struct shared_irq_driver_api *api = dev->driver_api;

	return api->enable(dev, isr_dev);
  102891:	8b 43 04             	mov    0x4(%ebx),%eax
  102894:	56                   	push   %esi
  102895:	53                   	push   %ebx
  102896:	ff 50 04             	call   *0x4(%eax)
  102899:	58                   	pop    %eax
  10289a:	5a                   	pop    %edx
	shared_irq_isr_register(shared_irq_dev, (isr_t)i2c_dw_isr, port);
	shared_irq_enable(shared_irq_dev, port);
#endif
}
  10289b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10289e:	5b                   	pop    %ebx
  10289f:	5e                   	pop    %esi
  1028a0:	5d                   	pop    %ebp
  1028a1:	c3                   	ret    

001028a2 <pwm_pca9685_configure>:
		return 0;
}

static int pwm_pca9685_configure(struct device *dev, int access_op,
				 uint32_t pwm, int flags)
{
  1028a2:	55                   	push   %ebp
	ARG_UNUSED(access_op);
	ARG_UNUSED(pwm);
	ARG_UNUSED(flags);

	return 0;
}
  1028a3:	31 c0                	xor    %eax,%eax
		return 0;
}

static int pwm_pca9685_configure(struct device *dev, int access_op,
				 uint32_t pwm, int flags)
{
  1028a5:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(access_op);
	ARG_UNUSED(pwm);
	ARG_UNUSED(flags);

	return 0;
}
  1028a7:	5d                   	pop    %ebp
  1028a8:	c3                   	ret    

001028a9 <pwm_pca9685_set_values>:

static int pwm_pca9685_set_values(struct device *dev, int access_op,
				  uint32_t pwm, uint32_t on, uint32_t off)
{
  1028a9:	55                   	push   %ebp
		dev->config->config_info;
	struct pwm_pca9685_drv_data * const drv_data =
		(struct pwm_pca9685_drv_data * const)dev->driver_data;
	struct device * const i2c_master = drv_data->i2c_master;
	uint16_t i2c_addr = config->i2c_slave_addr;
	uint8_t buf[] = { 0, 0, 0, 0, 0};
  1028aa:	b9 05 00 00 00       	mov    $0x5,%ecx
	return 0;
}

static int pwm_pca9685_set_values(struct device *dev, int access_op,
				  uint32_t pwm, uint32_t on, uint32_t off)
{
  1028af:	89 e5                	mov    %esp,%ebp
  1028b1:	57                   	push   %edi
  1028b2:	56                   	push   %esi
  1028b3:	53                   	push   %ebx
  1028b4:	83 ec 14             	sub    $0x14,%esp
		dev->config->config_info;
	struct pwm_pca9685_drv_data * const drv_data =
		(struct pwm_pca9685_drv_data * const)dev->driver_data;
	struct device * const i2c_master = drv_data->i2c_master;
	uint16_t i2c_addr = config->i2c_slave_addr;
	uint8_t buf[] = { 0, 0, 0, 0, 0};
  1028b7:	8d 7d e3             	lea    -0x1d(%ebp),%edi
	return 0;
}

static int pwm_pca9685_set_values(struct device *dev, int access_op,
				  uint32_t pwm, uint32_t on, uint32_t off)
{
  1028ba:	8b 45 08             	mov    0x8(%ebp),%eax
	const struct pwm_pca9685_config * const config =
		dev->config->config_info;
	struct pwm_pca9685_drv_data * const drv_data =
  1028bd:	8b 50 08             	mov    0x8(%eax),%edx
}

static int pwm_pca9685_set_values(struct device *dev, int access_op,
				  uint32_t pwm, uint32_t on, uint32_t off)
{
	const struct pwm_pca9685_config * const config =
  1028c0:	8b 00                	mov    (%eax),%eax
		dev->config->config_info;
	struct pwm_pca9685_drv_data * const drv_data =
		(struct pwm_pca9685_drv_data * const)dev->driver_data;
	struct device * const i2c_master = drv_data->i2c_master;
	uint16_t i2c_addr = config->i2c_slave_addr;
  1028c2:	8b 40 08             	mov    0x8(%eax),%eax
{
	const struct pwm_pca9685_config * const config =
		dev->config->config_info;
	struct pwm_pca9685_drv_data * const drv_data =
		(struct pwm_pca9685_drv_data * const)dev->driver_data;
	struct device * const i2c_master = drv_data->i2c_master;
  1028c5:	8b 1a                	mov    (%edx),%ebx
	uint16_t i2c_addr = config->i2c_slave_addr;
  1028c7:	0f b7 70 04          	movzwl 0x4(%eax),%esi
	uint8_t buf[] = { 0, 0, 0, 0, 0};
  1028cb:	31 c0                	xor    %eax,%eax
  1028cd:	f3 aa                	rep stos %al,%es:(%edi)

	if (!_has_i2c_master(dev)) {
		return -EINVAL;
  1028cf:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
{
	struct pwm_pca9685_drv_data * const drv_data =
		(struct pwm_pca9685_drv_data * const)dev->driver_data;
	struct device * const i2c_master = drv_data->i2c_master;

	if (i2c_master)
  1028d4:	83 3a 00             	cmpl   $0x0,(%edx)
  1028d7:	0f 84 99 00 00 00    	je     102976 <pwm_pca9685_set_values+0xcd>

	if (!_has_i2c_master(dev)) {
		return -EINVAL;
	}

	switch (access_op) {
  1028dd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  1028e1:	75 1e                	jne    102901 <pwm_pca9685_set_values+0x58>
	struct device * const i2c_master = drv_data->i2c_master;
	uint16_t i2c_addr = config->i2c_slave_addr;
	uint8_t buf[] = { 0, 0, 0, 0, 0};

	if (!_has_i2c_master(dev)) {
		return -EINVAL;
  1028e3:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	}

	switch (access_op) {
	case PWM_ACCESS_BY_PIN:
		if (pwm > MAX_PWM_OUT) {
  1028e8:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  1028ec:	0f 87 84 00 00 00    	ja     102976 <pwm_pca9685_set_values+0xcd>
			return -EINVAL;
		}
		buf[0] = REG_LED_ON_L(pwm);
  1028f2:	8a 45 10             	mov    0x10(%ebp),%al
  1028f5:	8d 04 85 06 00 00 00 	lea    0x6(,%eax,4),%eax
  1028fc:	88 45 e3             	mov    %al,-0x1d(%ebp)
		break;
  1028ff:	eb 0a                	jmp    10290b <pwm_pca9685_set_values+0x62>

	if (!_has_i2c_master(dev)) {
		return -EINVAL;
	}

	switch (access_op) {
  102901:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  102905:	75 6a                	jne    102971 <pwm_pca9685_set_values+0xc8>
			return -EINVAL;
		}
		buf[0] = REG_LED_ON_L(pwm);
		break;
	case PWM_ACCESS_ALL:
		buf[0] = REG_ALL_LED_ON_L;
  102907:	c6 45 e3 fa          	movb   $0xfa,-0x1d(%ebp)

	/* If either ON and/or OFF > max ticks, treat PWM as 100%.
	 * If OFF value == 0, treat it as 0%.
	 * Otherwise, populate registers accordingly.
	 */
	if ((on >= PWM_ONE_PERIOD_TICKS) || (off >= PWM_ONE_PERIOD_TICKS)) {
  10290b:	81 7d 14 ff 0f 00 00 	cmpl   $0xfff,0x14(%ebp)
  102912:	77 09                	ja     10291d <pwm_pca9685_set_values+0x74>
  102914:	81 7d 18 ff 0f 00 00 	cmpl   $0xfff,0x18(%ebp)
  10291b:	76 06                	jbe    102923 <pwm_pca9685_set_values+0x7a>
		buf[1] = 0x0;
		buf[2] = (1 << 4);
  10291d:	c6 45 e5 10          	movb   $0x10,-0x1b(%ebp)
  102921:	eb 2a                	jmp    10294d <pwm_pca9685_set_values+0xa4>
		buf[3] = 0x0;
		buf[4] = 0x0;
	} else if (off == 0) {
  102923:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  102927:	75 06                	jne    10292f <pwm_pca9685_set_values+0x86>
		buf[1] = 0x0;
		buf[2] = 0x0;
		buf[3] = 0x0;
		buf[4] = (1 << 4);
  102929:	c6 45 e7 10          	movb   $0x10,-0x19(%ebp)
  10292d:	eb 1e                	jmp    10294d <pwm_pca9685_set_values+0xa4>
	} else {
		buf[1] = (on & 0xFF);
  10292f:	8a 45 14             	mov    0x14(%ebp),%al
  102932:	88 45 e4             	mov    %al,-0x1c(%ebp)
		buf[2] = ((on >> 8) & 0x0F);
  102935:	8b 45 14             	mov    0x14(%ebp),%eax
  102938:	c1 e8 08             	shr    $0x8,%eax
  10293b:	88 45 e5             	mov    %al,-0x1b(%ebp)
		buf[3] = (off & 0xFF);
  10293e:	8a 45 18             	mov    0x18(%ebp),%al
  102941:	88 45 e6             	mov    %al,-0x1a(%ebp)
		buf[4] = ((off >> 8) & 0x0F);
  102944:	8b 45 18             	mov    0x18(%ebp),%eax
  102947:	c1 e8 08             	shr    $0x8,%eax
  10294a:	88 45 e7             	mov    %al,-0x19(%ebp)
			    uint32_t len, uint16_t addr)
{
	const struct i2c_driver_api *api = dev->driver_api;
	struct i2c_msg msg;

	msg.buf = buf;
  10294d:	8d 55 e3             	lea    -0x1d(%ebp),%edx
 * @retval Negative errno code if failure.
 */
static inline int i2c_write(struct device *dev, uint8_t *buf,
			    uint32_t len, uint16_t addr)
{
	const struct i2c_driver_api *api = dev->driver_api;
  102950:	8b 43 04             	mov    0x4(%ebx),%eax
	struct i2c_msg msg;

	msg.buf = buf;
  102953:	89 55 e8             	mov    %edx,-0x18(%ebp)
	msg.len = len;
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;

	return api->transfer(dev, &msg, 1, addr);
  102956:	8d 55 e8             	lea    -0x18(%ebp),%edx
  102959:	56                   	push   %esi
{
	const struct i2c_driver_api *api = dev->driver_api;
	struct i2c_msg msg;

	msg.buf = buf;
	msg.len = len;
  10295a:	c7 45 ec 05 00 00 00 	movl   $0x5,-0x14(%ebp)
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;

	return api->transfer(dev, &msg, 1, addr);
  102961:	6a 01                	push   $0x1
	const struct i2c_driver_api *api = dev->driver_api;
	struct i2c_msg msg;

	msg.buf = buf;
	msg.len = len;
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
  102963:	c6 45 f0 02          	movb   $0x2,-0x10(%ebp)

	return api->transfer(dev, &msg, 1, addr);
  102967:	52                   	push   %edx
  102968:	53                   	push   %ebx
  102969:	ff 50 04             	call   *0x4(%eax)
  10296c:	83 c4 10             	add    $0x10,%esp
	}

	return i2c_write(i2c_master, buf, sizeof(buf), i2c_addr);
  10296f:	eb 05                	jmp    102976 <pwm_pca9685_set_values+0xcd>
		break;
	case PWM_ACCESS_ALL:
		buf[0] = REG_ALL_LED_ON_L;
		break;
	default:
		return -ENOTSUP;
  102971:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
		buf[3] = (off & 0xFF);
		buf[4] = ((off >> 8) & 0x0F);
	}

	return i2c_write(i2c_master, buf, sizeof(buf), i2c_addr);
}
  102976:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102979:	5b                   	pop    %ebx
  10297a:	5e                   	pop    %esi
  10297b:	5f                   	pop    %edi
  10297c:	5d                   	pop    %ebp
  10297d:	c3                   	ret    

0010297e <pwm_pca9685_set_duty_cycle>:
 * Duty cycle describes the percentage of time a signal is turned
 * to the ON state.
 */
static int pwm_pca9685_set_duty_cycle(struct device *dev, int access_op,
				      uint32_t pwm, uint8_t duty)
{
  10297e:	55                   	push   %ebp
  10297f:	89 e5                	mov    %esp,%ebp
  102981:	8b 45 14             	mov    0x14(%ebp),%eax
	uint32_t on, off, phase;

	phase = 0;     /* Hard coded until API changes */

	if (duty == 0) {
  102984:	84 c0                	test   %al,%al
  102986:	74 14                	je     10299c <pwm_pca9685_set_duty_cycle+0x1e>
		/* Turn off PWM */
		on = 0;
		off = 0;
	} else if (duty >= 100) {
  102988:	3c 63                	cmp    $0x63,%al
  10298a:	77 16                	ja     1029a2 <pwm_pca9685_set_duty_cycle+0x24>
		/* Force PWM to be 100% */
		on = PWM_ONE_PERIOD_TICKS + 1;
		off = PWM_ONE_PERIOD_TICKS + 1;
	} else {
		off = PWM_ONE_PERIOD_TICKS * duty / 100;
  10298c:	0f b6 c0             	movzbl %al,%eax
  10298f:	c1 e0 0c             	shl    $0xc,%eax
  102992:	b9 64 00 00 00       	mov    $0x64,%ecx
  102997:	99                   	cltd   
  102998:	f7 f9                	idiv   %ecx
  10299a:	eb 02                	jmp    10299e <pwm_pca9685_set_duty_cycle+0x20>
	phase = 0;     /* Hard coded until API changes */

	if (duty == 0) {
		/* Turn off PWM */
		on = 0;
		off = 0;
  10299c:	31 c0                	xor    %eax,%eax

	phase = 0;     /* Hard coded until API changes */

	if (duty == 0) {
		/* Turn off PWM */
		on = 0;
  10299e:	31 d2                	xor    %edx,%edx
  1029a0:	eb 0a                	jmp    1029ac <pwm_pca9685_set_duty_cycle+0x2e>
		off = 0;
	} else if (duty >= 100) {
		/* Force PWM to be 100% */
		on = PWM_ONE_PERIOD_TICKS + 1;
		off = PWM_ONE_PERIOD_TICKS + 1;
  1029a2:	b8 01 10 00 00       	mov    $0x1001,%eax
		/* Turn off PWM */
		on = 0;
		off = 0;
	} else if (duty >= 100) {
		/* Force PWM to be 100% */
		on = PWM_ONE_PERIOD_TICKS + 1;
  1029a7:	ba 01 10 00 00       	mov    $0x1001,%edx
	} else {
		off = PWM_ONE_PERIOD_TICKS * duty / 100;
		on = phase;
	}

	return pwm_pca9685_set_values(dev, access_op, pwm, on, off);
  1029ac:	50                   	push   %eax
  1029ad:	52                   	push   %edx
  1029ae:	ff 75 10             	pushl  0x10(%ebp)
  1029b1:	ff 75 0c             	pushl  0xc(%ebp)
  1029b4:	ff 75 08             	pushl  0x8(%ebp)
  1029b7:	e8 ed fe ff ff       	call   1028a9 <pwm_pca9685_set_values>
  1029bc:	83 c4 14             	add    $0x14,%esp
}
  1029bf:	c9                   	leave  
  1029c0:	c3                   	ret    

001029c1 <pwm_pca9685_init>:
 *
 * @param dev Device struct
 * @return 0 if successful, failed otherwise.
 */
int pwm_pca9685_init(struct device *dev)
{
  1029c1:	55                   	push   %ebp
  1029c2:	89 e5                	mov    %esp,%ebp
  1029c4:	57                   	push   %edi
  1029c5:	56                   	push   %esi
  1029c6:	53                   	push   %ebx
  1029c7:	83 ec 10             	sub    $0x10,%esp
	const struct pwm_pca9685_config * const config =
		dev->config->config_info;
	struct pwm_pca9685_drv_data * const drv_data =
		(struct pwm_pca9685_drv_data * const)dev->driver_data;
	struct device *i2c_master;
	uint8_t buf[] = {0, 0};
  1029ca:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
 *
 * @param dev Device struct
 * @return 0 if successful, failed otherwise.
 */
int pwm_pca9685_init(struct device *dev)
{
  1029ce:	8b 5d 08             	mov    0x8(%ebp),%ebx
	const struct pwm_pca9685_config * const config =
		dev->config->config_info;
	struct pwm_pca9685_drv_data * const drv_data =
		(struct pwm_pca9685_drv_data * const)dev->driver_data;
	struct device *i2c_master;
	uint8_t buf[] = {0, 0};
  1029d1:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
 * @param dev Device struct
 * @return 0 if successful, failed otherwise.
 */
int pwm_pca9685_init(struct device *dev)
{
	const struct pwm_pca9685_config * const config =
  1029d5:	8b 03                	mov    (%ebx),%eax
		dev->config->config_info;
	struct pwm_pca9685_drv_data * const drv_data =
  1029d7:	8b 7b 08             	mov    0x8(%ebx),%edi
 * @param dev Device struct
 * @return 0 if successful, failed otherwise.
 */
int pwm_pca9685_init(struct device *dev)
{
	const struct pwm_pca9685_config * const config =
  1029da:	8b 70 08             	mov    0x8(%eax),%esi
	struct device *i2c_master;
	uint8_t buf[] = {0, 0};
	int ret;

	/* Find out the device struct of the I2C master */
	i2c_master = device_get_binding((char *)config->i2c_master_dev_name);
  1029dd:	ff 36                	pushl  (%esi)
  1029df:	e8 03 0d 00 00       	call   1036e7 <device_get_binding>
  1029e4:	5a                   	pop    %edx
  1029e5:	89 c2                	mov    %eax,%edx
	if (!i2c_master) {
		return -EINVAL;
  1029e7:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	uint8_t buf[] = {0, 0};
	int ret;

	/* Find out the device struct of the I2C master */
	i2c_master = device_get_binding((char *)config->i2c_master_dev_name);
	if (!i2c_master) {
  1029ec:	85 d2                	test   %edx,%edx
  1029ee:	74 40                	je     102a30 <pwm_pca9685_init+0x6f>
	/* MODE1 register */

	buf[0] = REG_MODE1;
	buf[1] = (1 << 5); /* register addr auto increment */

	ret = i2c_write(i2c_master, buf, 2, config->i2c_slave_addr);
  1029f0:	0f b7 46 04          	movzwl 0x4(%esi),%eax
 * @retval Negative errno code if failure.
 */
static inline int i2c_write(struct device *dev, uint8_t *buf,
			    uint32_t len, uint16_t addr)
{
	const struct i2c_driver_api *api = dev->driver_api;
  1029f4:	8b 4a 04             	mov    0x4(%edx),%ecx
	struct i2c_msg msg;

	msg.buf = buf;
  1029f7:	8d 75 e6             	lea    -0x1a(%ebp),%esi
	/* Find out the device struct of the I2C master */
	i2c_master = device_get_binding((char *)config->i2c_master_dev_name);
	if (!i2c_master) {
		return -EINVAL;
	}
	drv_data->i2c_master = i2c_master;
  1029fa:	89 17                	mov    %edx,(%edi)
	msg.len = len;
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;

	return api->transfer(dev, &msg, 1, addr);
  1029fc:	50                   	push   %eax

	/* MODE1 register */

	buf[0] = REG_MODE1;
  1029fd:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  102a01:	8d 45 e8             	lea    -0x18(%ebp),%eax
	buf[1] = (1 << 5); /* register addr auto increment */
  102a04:	c6 45 e7 20          	movb   $0x20,-0x19(%ebp)
			    uint32_t len, uint16_t addr)
{
	const struct i2c_driver_api *api = dev->driver_api;
	struct i2c_msg msg;

	msg.buf = buf;
  102a08:	89 75 e8             	mov    %esi,-0x18(%ebp)
	msg.len = len;
  102a0b:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
  102a12:	c6 45 f0 02          	movb   $0x2,-0x10(%ebp)

	return api->transfer(dev, &msg, 1, addr);
  102a16:	6a 01                	push   $0x1
  102a18:	50                   	push   %eax
  102a19:	52                   	push   %edx
  102a1a:	ff 51 04             	call   *0x4(%ecx)
  102a1d:	83 c4 10             	add    $0x10,%esp

	ret = i2c_write(i2c_master, buf, 2, config->i2c_slave_addr);
	if (ret != 0) {
  102a20:	85 c0                	test   %eax,%eax
  102a22:	75 09                	jne    102a2d <pwm_pca9685_init+0x6c>
		return -EPERM;
	}

	dev->driver_api = &pwm_pca9685_drv_api_funcs;
  102a24:	c7 43 04 a8 48 10 00 	movl   $0x1048a8,0x4(%ebx)

	return 0;
  102a2b:	eb 03                	jmp    102a30 <pwm_pca9685_init+0x6f>
	buf[0] = REG_MODE1;
	buf[1] = (1 << 5); /* register addr auto increment */

	ret = i2c_write(i2c_master, buf, 2, config->i2c_slave_addr);
	if (ret != 0) {
		return -EPERM;
  102a2d:	83 c8 ff             	or     $0xffffffff,%eax
	}

	dev->driver_api = &pwm_pca9685_drv_api_funcs;

	return 0;
}
  102a30:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102a33:	5b                   	pop    %ebx
  102a34:	5e                   	pop    %esi
  102a35:	5f                   	pop    %edi
  102a36:	5d                   	pop    %ebp
  102a37:	c3                   	ret    

00102a38 <ti_adc108s102_disable>:
	 * SPI will release CS)
	 */
}

static void ti_adc108s102_disable(struct device *dev)
{
  102a38:	55                   	push   %ebp
  102a39:	89 e5                	mov    %esp,%ebp
	/* Same issue as with ti_adc108s102_enable() */
}
  102a3b:	5d                   	pop    %ebp
  102a3c:	c3                   	ret    

00102a3d <ti_adc108s102_init>:
	.disable = ti_adc108s102_disable,
	.read = ti_adc108s102_read,
};

static int ti_adc108s102_init(struct device *dev)
{
  102a3d:	55                   	push   %ebp
  102a3e:	89 e5                	mov    %esp,%ebp
  102a40:	56                   	push   %esi
  102a41:	53                   	push   %ebx
  102a42:	8b 5d 08             	mov    0x8(%ebp),%ebx
	const struct ti_adc108s102_config *config = dev->config->config_info;
  102a45:	8b 03                	mov    (%ebx),%eax
	struct ti_adc108s102_data *adc = dev->driver_data;
  102a47:	8b 73 08             	mov    0x8(%ebx),%esi

	adc->spi = device_get_binding((char *)config->spi_port);
  102a4a:	8b 40 08             	mov    0x8(%eax),%eax
  102a4d:	ff 30                	pushl  (%eax)
  102a4f:	e8 93 0c 00 00       	call   1036e7 <device_get_binding>
  102a54:	5a                   	pop    %edx
  102a55:	83 ca ff             	or     $0xffffffff,%edx
  102a58:	89 46 24             	mov    %eax,0x24(%esi)
	if (!adc->spi) {
  102a5b:	85 c0                	test   %eax,%eax
  102a5d:	74 09                	je     102a68 <ti_adc108s102_init+0x2b>
		return -EPERM;
	}

	SYS_LOG_DBG("ADC108s102 initialized\n");

	dev->driver_api = &ti_adc108s102_api;
  102a5f:	c7 43 04 d4 48 10 00 	movl   $0x1048d4,0x4(%ebx)

	return 0;
  102a66:	31 d2                	xor    %edx,%edx
}
  102a68:	8d 65 f8             	lea    -0x8(%ebp),%esp
  102a6b:	89 d0                	mov    %edx,%eax
  102a6d:	5b                   	pop    %ebx
  102a6e:	5e                   	pop    %esi
  102a6f:	5d                   	pop    %ebp
  102a70:	c3                   	ret    

00102a71 <ti_adc108s102_read>:
	return chans_set;
}

static int ti_adc108s102_read(struct device *dev,
					struct adc_seq_table *seq_table)
{
  102a71:	55                   	push   %ebp
  102a72:	89 e5                	mov    %esp,%ebp
  102a74:	57                   	push   %edi
  102a75:	56                   	push   %esi
  102a76:	53                   	push   %ebx
  102a77:	83 ec 4c             	sub    $0x4c,%esp
	const struct ti_adc108s102_config *config = dev->config->config_info;
	struct ti_adc108s102_data *adc = dev->driver_data;
	struct spi_config spi_conf;
	uint32_t data[2] = {0, 0};
  102a7a:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
}

static int ti_adc108s102_read(struct device *dev,
					struct adc_seq_table *seq_table)
{
	const struct ti_adc108s102_config *config = dev->config->config_info;
  102a81:	8b 45 08             	mov    0x8(%ebp),%eax
	return chans_set;
}

static int ti_adc108s102_read(struct device *dev,
					struct adc_seq_table *seq_table)
{
  102a84:	8b 7d 0c             	mov    0xc(%ebp),%edi
	const struct ti_adc108s102_config *config = dev->config->config_info;
  102a87:	8b 00                	mov    (%eax),%eax
  102a89:	8b 70 08             	mov    0x8(%eax),%esi
	struct ti_adc108s102_data *adc = dev->driver_data;
  102a8c:	8b 45 08             	mov    0x8(%ebp),%eax
	struct spi_config spi_conf;
	uint32_t data[2] = {0, 0};
  102a8f:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)

static int ti_adc108s102_read(struct device *dev,
					struct adc_seq_table *seq_table)
{
	const struct ti_adc108s102_config *config = dev->config->config_info;
	struct ti_adc108s102_data *adc = dev->driver_data;
  102a96:	8b 58 08             	mov    0x8(%eax),%ebx
	uint32_t data[2] = {0, 0};
	struct nano_timer timer;
	int ret = 0;
	int32_t delay;

	spi_conf.config = config->spi_config_flags;
  102a99:	8b 46 04             	mov    0x4(%esi),%eax
  102a9c:	89 45 b0             	mov    %eax,-0x50(%ebp)
	spi_conf.max_sys_freq = config->spi_freq;
  102a9f:	8b 46 08             	mov    0x8(%esi),%eax
  102aa2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  102aa5:	8d 45 c0             	lea    -0x40(%ebp),%eax
  102aa8:	6a 00                	push   $0x0
  102aaa:	6a 00                	push   $0x0
  102aac:	50                   	push   %eax
  102aad:	e8 cb 19 00 00       	call   10447d <k_timer_init>
	timer->_legacy_data = data;
  102ab2:	8d 45 b8             	lea    -0x48(%ebp),%eax
 * @return N/A
 */
static inline __deprecated void
nano_timer_init(struct k_timer *timer, void *data)
{
	k_timer_init(timer, NULL, NULL);
  102ab5:	83 c4 0c             	add    $0xc,%esp
	timer->_legacy_data = data;
  102ab8:	89 45 f0             	mov    %eax,-0x10(%ebp)

	nano_timer_init(&timer, data);

	if (spi_configure(adc->spi, &spi_conf)) {
  102abb:	8b 43 24             	mov    0x24(%ebx),%eax
static inline int spi_configure(struct device *dev,
				struct spi_config *config)
{
	const struct spi_driver_api *api = dev->driver_api;

	return api->configure(dev, config);
  102abe:	8d 4d b0             	lea    -0x50(%ebp),%ecx
  102ac1:	8b 50 04             	mov    0x4(%eax),%edx
  102ac4:	51                   	push   %ecx
  102ac5:	50                   	push   %eax
  102ac6:	ff 12                	call   *(%edx)
  102ac8:	5a                   	pop    %edx
  102ac9:	89 45 ac             	mov    %eax,-0x54(%ebp)
  102acc:	59                   	pop    %ecx
  102acd:	85 c0                	test   %eax,%eax
  102acf:	0f 85 90 01 00 00    	jne    102c65 <ti_adc108s102_read+0x1f4>
		return -EIO;
	}

	if (spi_slave_select(adc->spi, config->spi_slave)) {
  102ad5:	8b 53 24             	mov    0x24(%ebx),%edx
 */
static inline int spi_slave_select(struct device *dev, uint32_t slave)
{
	const struct spi_driver_api *api = dev->driver_api;

	if (!api->slave_select) {
  102ad8:	8b 42 04             	mov    0x4(%edx),%eax
  102adb:	8b 40 04             	mov    0x4(%eax),%eax
  102ade:	85 c0                	test   %eax,%eax
  102ae0:	75 1a                	jne    102afc <ti_adc108s102_read+0x8b>
		return -EIO;
	}

	/* Resetting all internal channel data */
	memset(adc->chans, 0, ADC108S102_CHANNELS_SIZE);
  102ae2:	8d 43 28             	lea    0x28(%ebx),%eax
  102ae5:	6a 20                	push   $0x20
  102ae7:	6a 00                	push   $0x0
  102ae9:	50                   	push   %eax
  102aea:	e8 be 01 00 00       	call   102cad <memset>
  102aef:	83 c4 0c             	add    $0xc,%esp
{
	struct adc_seq_entry *entry;
	uint32_t chans_set = 0;
	int i;

	for (i = 0; i < seq_table->num_entries; i++) {
  102af2:	0f b6 77 04          	movzbl 0x4(%edi),%esi
  102af6:	31 d2                	xor    %edx,%edx
}

static inline int _verify_entries(struct adc_seq_table *seq_table)
{
	struct adc_seq_entry *entry;
	uint32_t chans_set = 0;
  102af8:	31 c9                	xor    %ecx,%ecx
  102afa:	eb 33                	jmp    102b2f <ti_adc108s102_read+0xbe>
		return 0;
	}

	return api->slave_select(dev, slave);
  102afc:	ff 76 0c             	pushl  0xc(%esi)
  102aff:	52                   	push   %edx
  102b00:	ff d0                	call   *%eax
  102b02:	59                   	pop    %ecx

	if (spi_configure(adc->spi, &spi_conf)) {
		return -EIO;
	}

	if (spi_slave_select(adc->spi, config->spi_slave)) {
  102b03:	85 c0                	test   %eax,%eax
  102b05:	5e                   	pop    %esi
  102b06:	74 da                	je     102ae2 <ti_adc108s102_read+0x71>
  102b08:	e9 58 01 00 00       	jmp    102c65 <ti_adc108s102_read+0x1f4>
	struct adc_seq_entry *entry;
	uint32_t chans_set = 0;
	int i;

	for (i = 0; i < seq_table->num_entries; i++) {
		entry = &seq_table->entries[i];
  102b0d:	89 d0                	mov    %edx,%eax
  102b0f:	c1 e0 04             	shl    $0x4,%eax
  102b12:	03 07                	add    (%edi),%eax

		if (entry->sampling_delay <= 0 ||
  102b14:	83 38 00             	cmpl   $0x0,(%eax)
  102b17:	0f 8e 51 01 00 00    	jle    102c6e <ti_adc108s102_read+0x1fd>
  102b1d:	80 78 0c 08          	cmpb   $0x8,0xc(%eax)
  102b21:	0f 87 47 01 00 00    	ja     102c6e <ti_adc108s102_read+0x1fd>

		if (!entry->buffer_length) {
			continue;
		}

		chans_set++;
  102b27:	83 78 08 01          	cmpl   $0x1,0x8(%eax)
  102b2b:	83 d9 ff             	sbb    $0xffffffff,%ecx
{
	struct adc_seq_entry *entry;
	uint32_t chans_set = 0;
	int i;

	for (i = 0; i < seq_table->num_entries; i++) {
  102b2e:	42                   	inc    %edx
  102b2f:	39 f2                	cmp    %esi,%edx
  102b31:	7c da                	jl     102b0d <ti_adc108s102_read+0x9c>
	}

	/* Resetting all internal channel data */
	memset(adc->chans, 0, ADC108S102_CHANNELS_SIZE);

	if (_verify_entries(seq_table) == 0) {
  102b33:	85 c9                	test   %ecx,%ecx
  102b35:	0f 84 33 01 00 00    	je     102c6e <ti_adc108s102_read+0x1fd>
		return -EINVAL;
	}

	adc->seq_table = seq_table;
  102b3b:	89 7b 48             	mov    %edi,0x48(%ebx)
  102b3e:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t i;

	adc->cmd_buf_len = 0;
	adc->sampling_buf_len = 1; /* Counting the dummy byte */

	for (i = 0; i < seq_table->num_entries; i++) {
  102b41:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
static inline int32_t _ti_adc108s102_prepare(struct device *dev)
{
	struct ti_adc108s102_data *adc = dev->driver_data;
	struct adc_seq_table *seq_table = adc->seq_table;
	struct ti_adc108s102_chan *chan;
	int32_t sampling_delay = 0;
  102b48:	31 ff                	xor    %edi,%edi
  102b4a:	8b 50 08             	mov    0x8(%eax),%edx
}

static inline int32_t _ti_adc108s102_prepare(struct device *dev)
{
	struct ti_adc108s102_data *adc = dev->driver_data;
	struct adc_seq_table *seq_table = adc->seq_table;
  102b4d:	8b 72 48             	mov    0x48(%edx),%esi
	struct ti_adc108s102_chan *chan;
	int32_t sampling_delay = 0;
	uint32_t i;

	adc->cmd_buf_len = 0;
  102b50:	c6 42 4c 00          	movb   $0x0,0x4c(%edx)
	adc->sampling_buf_len = 1; /* Counting the dummy byte */
  102b54:	c6 42 4d 01          	movb   $0x1,0x4d(%edx)

	for (i = 0; i < seq_table->num_entries; i++) {
  102b58:	0f b6 46 04          	movzbl 0x4(%esi),%eax
  102b5c:	39 45 a8             	cmp    %eax,-0x58(%ebp)
  102b5f:	73 35                	jae    102b96 <ti_adc108s102_read+0x125>
		struct adc_seq_entry *entry = &seq_table->entries[i];
  102b61:	8b 5d a8             	mov    -0x58(%ebp),%ebx
  102b64:	c1 e3 04             	shl    $0x4,%ebx
  102b67:	03 1e                	add    (%esi),%ebx

		/* No more space in the buffer? */
		chan = &adc->chans[entry->channel_id];
  102b69:	0f b6 4b 0c          	movzbl 0xc(%ebx),%ecx
		if (entry->buffer_length - chan->buf_idx == 0) {
  102b6d:	8b 44 8a 28          	mov    0x28(%edx,%ecx,4),%eax
  102b71:	39 43 08             	cmp    %eax,0x8(%ebx)
  102b74:	74 1b                	je     102b91 <ti_adc108s102_read+0x120>
			continue;
		}

		SYS_LOG_DBG("Requesting channel %d\n", entry->channel_id);
		adc->cmd_buffer[adc->cmd_buf_len] =
  102b76:	0f b6 7a 4c          	movzbl 0x4c(%edx),%edi
  102b7a:	c1 e1 03             	shl    $0x3,%ecx
  102b7d:	89 f8                	mov    %edi,%eax
  102b7f:	66 81 e1 ff 00       	and    $0xff,%cx
				ADC108S102_CHANNEL_CMD(entry->channel_id);

		adc->cmd_buf_len++;
  102b84:	40                   	inc    %eax
		if (entry->buffer_length - chan->buf_idx == 0) {
			continue;
		}

		SYS_LOG_DBG("Requesting channel %d\n", entry->channel_id);
		adc->cmd_buffer[adc->cmd_buf_len] =
  102b85:	66 89 0c 7a          	mov    %cx,(%edx,%edi,2)
				ADC108S102_CHANNEL_CMD(entry->channel_id);

		adc->cmd_buf_len++;
  102b89:	88 42 4c             	mov    %al,0x4c(%edx)
		adc->sampling_buf_len++;
  102b8c:	fe 42 4d             	incb   0x4d(%edx)

		sampling_delay = entry->sampling_delay;
  102b8f:	8b 3b                	mov    (%ebx),%edi
	uint32_t i;

	adc->cmd_buf_len = 0;
	adc->sampling_buf_len = 1; /* Counting the dummy byte */

	for (i = 0; i < seq_table->num_entries; i++) {
  102b91:	ff 45 a8             	incl   -0x58(%ebp)
  102b94:	eb c2                	jmp    102b58 <ti_adc108s102_read+0xe7>
		adc->sampling_buf_len++;

		sampling_delay = entry->sampling_delay;
	}

	if (adc->cmd_buf_len == 0) {
  102b96:	8a 42 4c             	mov    0x4c(%edx),%al
  102b99:	84 c0                	test   %al,%al
  102b9b:	0f 84 d9 00 00 00    	je     102c7a <ti_adc108s102_read+0x209>
		return ADC108S102_DONE;
	}

	/* dummy cmd byte */
	adc->cmd_buffer[adc->cmd_buf_len] = 0;
  102ba1:	0f b6 c8             	movzbl %al,%ecx
	adc->cmd_buf_len++;
  102ba4:	40                   	inc    %eax
	adc->seq_table = seq_table;

	/* Sampling */
	while (1) {
		delay = _ti_adc108s102_prepare(dev);
		if (delay == ADC108S102_DONE) {
  102ba5:	83 ff ff             	cmp    $0xffffffff,%edi
	if (adc->cmd_buf_len == 0) {
		return ADC108S102_DONE;
	}

	/* dummy cmd byte */
	adc->cmd_buffer[adc->cmd_buf_len] = 0;
  102ba8:	66 c7 04 4a 00 00    	movw   $0x0,(%edx,%ecx,2)
	adc->cmd_buf_len++;
  102bae:	88 42 4c             	mov    %al,0x4c(%edx)
	adc->seq_table = seq_table;

	/* Sampling */
	while (1) {
		delay = _ti_adc108s102_prepare(dev);
		if (delay == ADC108S102_DONE) {
  102bb1:	0f 84 c3 00 00 00    	je     102c7a <ti_adc108s102_read+0x209>
 * @return N/A
 */
static inline __deprecated void
nano_timer_start(struct nano_timer *timer, int ticks)
{
	k_timer_start(timer, _ticks_to_ms(ticks), 0);
  102bb7:	be e8 03 00 00       	mov    $0x3e8,%esi
  102bbc:	89 f8                	mov    %edi,%eax
  102bbe:	f7 ee                	imul   %esi
  102bc0:	6a 00                	push   $0x0
  102bc2:	6a 00                	push   $0x0
  102bc4:	6a 64                	push   $0x64
  102bc6:	52                   	push   %edx
  102bc7:	50                   	push   %eax
  102bc8:	e8 73 d6 ff ff       	call   100240 <__udivdi3>
  102bcd:	83 c4 10             	add    $0x10,%esp
  102bd0:	50                   	push   %eax
  102bd1:	8d 45 c0             	lea    -0x40(%ebp),%eax
  102bd4:	50                   	push   %eax
  102bd5:	e8 ea 18 00 00       	call   1044c4 <k_timer_start>
  102bda:	83 c4 0c             	add    $0xc,%esp
			break;
		}

		nano_timer_start(&timer, delay);
		nano_task_timer_test(&timer, TICKS_UNLIMITED);
  102bdd:	8d 45 c0             	lea    -0x40(%ebp),%eax
  102be0:	6a ff                	push   $0xffffffff
  102be2:	50                   	push   %eax
  102be3:	e8 a1 0c 00 00       	call   103889 <nano_timer_test>
  102be8:	58                   	pop    %eax
  102be9:	8b 45 08             	mov    0x8(%ebp),%eax
  102bec:	5a                   	pop    %edx
  102bed:	8b 40 08             	mov    0x8(%eax),%eax
			  const void *tx_buf, uint32_t tx_buf_len,
			  void *rx_buf, uint32_t rx_buf_len)
{
	const struct spi_driver_api *api = dev->driver_api;

	return api->transceive(dev, tx_buf, tx_buf_len, rx_buf, rx_buf_len);
  102bf0:	0f b6 50 4d          	movzbl 0x4d(%eax),%edx
	struct ti_adc108s102_data *adc = dev->driver_data;

	SYS_LOG_DBG("Sampling!\n");

	/* SPI deals with uint8_t buffers so multiplying by 2 the length */
	return spi_transceive(adc->spi, adc->cmd_buffer,
  102bf4:	8b 48 24             	mov    0x24(%eax),%ecx
  102bf7:	01 d2                	add    %edx,%edx
  102bf9:	8b 59 04             	mov    0x4(%ecx),%ebx
  102bfc:	52                   	push   %edx
			      adc->cmd_buf_len * 2,
			      adc->sampling_buffer,
  102bfd:	8d 50 12             	lea    0x12(%eax),%edx
  102c00:	52                   	push   %edx
  102c01:	0f b6 50 4c          	movzbl 0x4c(%eax),%edx
  102c05:	01 d2                	add    %edx,%edx
  102c07:	52                   	push   %edx
  102c08:	50                   	push   %eax
  102c09:	51                   	push   %ecx
  102c0a:	ff 53 08             	call   *0x8(%ebx)
  102c0d:	83 c4 14             	add    $0x14,%esp

		nano_timer_start(&timer, delay);
		nano_task_timer_test(&timer, TICKS_UNLIMITED);

		ret = _ti_adc108s102_sampling(dev);
		if (ret != 0) {
  102c10:	85 c0                	test   %eax,%eax
  102c12:	75 63                	jne    102c77 <ti_adc108s102_read+0x206>
  102c14:	8b 45 08             	mov    0x8(%ebp),%eax
  102c17:	8b 58 08             	mov    0x8(%eax),%ebx
	struct adc_seq_entry *entry;
	uint32_t s_i, i;

	SYS_LOG_DBG("_ti_adc108s102_handle_result()");

	for (i = 0, s_i = 1; i < seq_table->num_entries; i++, s_i++) {
  102c1a:	31 c0                	xor    %eax,%eax
}

static inline void _ti_adc108s102_handle_result(struct device *dev)
{
	struct ti_adc108s102_data *adc = dev->driver_data;
	struct adc_seq_table *seq_table = adc->seq_table;
  102c1c:	8b 7b 48             	mov    0x48(%ebx),%edi
	struct adc_seq_entry *entry;
	uint32_t s_i, i;

	SYS_LOG_DBG("_ti_adc108s102_handle_result()");

	for (i = 0, s_i = 1; i < seq_table->num_entries; i++, s_i++) {
  102c1f:	0f b6 57 04          	movzbl 0x4(%edi),%edx
  102c23:	39 d0                	cmp    %edx,%eax
  102c25:	0f 83 13 ff ff ff    	jae    102b3e <ti_adc108s102_read+0xcd>
		entry = &seq_table->entries[i];
  102c2b:	89 c1                	mov    %eax,%ecx
  102c2d:	c1 e1 04             	shl    $0x4,%ecx
  102c30:	03 0f                	add    (%edi),%ecx
  102c32:	0f b6 51 0c          	movzbl 0xc(%ecx),%edx
  102c36:	8d 34 93             	lea    (%ebx,%edx,4),%esi
  102c39:	89 75 a8             	mov    %esi,-0x58(%ebp)
		chan = &adc->chans[entry->channel_id];

		if (entry->buffer_length - chan->buf_idx == 0) {
  102c3c:	8b 56 28             	mov    0x28(%esi),%edx
  102c3f:	39 51 08             	cmp    %edx,0x8(%ecx)
  102c42:	74 1e                	je     102c62 <ti_adc108s102_read+0x1f1>
			continue;
		}

		*((uint16_t *)(entry->buffer+chan->buf_idx)) =
  102c44:	8b 49 04             	mov    0x4(%ecx),%ecx
  102c47:	89 ce                	mov    %ecx,%esi
  102c49:	66 8b 4c 43 14       	mov    0x14(%ebx,%eax,2),%cx
  102c4e:	86 e9                	xchg   %ch,%cl
  102c50:	66 81 e1 ff 0f       	and    $0xfff,%cx
  102c55:	66 89 0c 16          	mov    %cx,(%esi,%edx,1)
				ADC108S102_RESULT(adc->sampling_buffer[s_i]);

		chan->buf_idx += 2;
  102c59:	8b 75 a8             	mov    -0x58(%ebp),%esi
  102c5c:	83 c2 02             	add    $0x2,%edx
  102c5f:	89 56 28             	mov    %edx,0x28(%esi)
	struct adc_seq_entry *entry;
	uint32_t s_i, i;

	SYS_LOG_DBG("_ti_adc108s102_handle_result()");

	for (i = 0, s_i = 1; i < seq_table->num_entries; i++, s_i++) {
  102c62:	40                   	inc    %eax
  102c63:	eb ba                	jmp    102c1f <ti_adc108s102_read+0x1ae>
	spi_conf.max_sys_freq = config->spi_freq;

	nano_timer_init(&timer, data);

	if (spi_configure(adc->spi, &spi_conf)) {
		return -EIO;
  102c65:	c7 45 ac fb ff ff ff 	movl   $0xfffffffb,-0x54(%ebp)
  102c6c:	eb 0c                	jmp    102c7a <ti_adc108s102_read+0x209>

	/* Resetting all internal channel data */
	memset(adc->chans, 0, ADC108S102_CHANNELS_SIZE);

	if (_verify_entries(seq_table) == 0) {
		return -EINVAL;
  102c6e:	c7 45 ac ea ff ff ff 	movl   $0xffffffea,-0x54(%ebp)
  102c75:	eb 03                	jmp    102c7a <ti_adc108s102_read+0x209>
  102c77:	89 45 ac             	mov    %eax,-0x54(%ebp)

		_ti_adc108s102_handle_result(dev);
	}

	return ret;
}
  102c7a:	8b 45 ac             	mov    -0x54(%ebp),%eax
  102c7d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102c80:	5b                   	pop    %ebx
  102c81:	5e                   	pop    %esi
  102c82:	5f                   	pop    %edi
  102c83:	5d                   	pop    %ebp
  102c84:	c3                   	ret    

00102c85 <ti_adc108s102_enable>:
  102c85:	55                   	push   %ebp
  102c86:	89 e5                	mov    %esp,%ebp
  102c88:	5d                   	pop    %ebp
  102c89:	c3                   	ret    

00102c8a <strcmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
  102c8a:	55                   	push   %ebp
	while ((*s1 == *s2) && (*s1 != '\0')) {
  102c8b:	31 c9                	xor    %ecx,%ecx
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
  102c8d:	89 e5                	mov    %esp,%ebp
	while ((*s1 == *s2) && (*s1 != '\0')) {
  102c8f:	8b 45 08             	mov    0x8(%ebp),%eax
  102c92:	8b 55 0c             	mov    0xc(%ebp),%edx
  102c95:	0f be 04 08          	movsbl (%eax,%ecx,1),%eax
  102c99:	0f be 14 0a          	movsbl (%edx,%ecx,1),%edx
  102c9d:	38 d0                	cmp    %dl,%al
  102c9f:	75 08                	jne    102ca9 <strcmp+0x1f>
  102ca1:	41                   	inc    %ecx
  102ca2:	84 c0                	test   %al,%al
  102ca4:	75 e9                	jne    102c8f <strcmp+0x5>
  102ca6:	0f be d0             	movsbl %al,%edx
		s1++;
		s2++;
	}

	return *s1 - *s2;
  102ca9:	29 d0                	sub    %edx,%eax
}
  102cab:	5d                   	pop    %ebp
  102cac:	c3                   	ret    

00102cad <memset>:
 *
 * @return pointer to start of buffer
 */

void *memset(void *buf, int c, size_t n)
{
  102cad:	55                   	push   %ebp
  102cae:	89 e5                	mov    %esp,%ebp
  102cb0:	57                   	push   %edi
  102cb1:	56                   	push   %esi
  102cb2:	53                   	push   %ebx
  102cb3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  102cb6:	8b 55 10             	mov    0x10(%ebp),%edx
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
  102cb9:	88 d8                	mov    %bl,%al

void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
  102cbb:	8b 4d 08             	mov    0x8(%ebp),%ecx
	unsigned char c_byte = (unsigned char)c;

	while (((unsigned int)d_byte) & 0x3) {
  102cbe:	f6 c1 03             	test   $0x3,%cl
  102cc1:	74 0b                	je     102cce <memset+0x21>
		if (n == 0) {
  102cc3:	85 d2                	test   %edx,%edx
  102cc5:	74 42                	je     102d09 <memset+0x5c>
			return buf;
		}
		*(d_byte++) = c_byte;
  102cc7:	41                   	inc    %ecx
		n--;
  102cc8:	4a                   	dec    %edx

	while (((unsigned int)d_byte) & 0x3) {
		if (n == 0) {
			return buf;
		}
		*(d_byte++) = c_byte;
  102cc9:	88 41 ff             	mov    %al,-0x1(%ecx)
  102ccc:	eb f0                	jmp    102cbe <memset+0x11>
	};

	/* do word-sized initialization as long as possible */

	unsigned int *d_word = (unsigned int *)d_byte;
	unsigned int c_word = (unsigned int)(unsigned char)c;
  102cce:	0f b6 db             	movzbl %bl,%ebx

	c_word |= c_word << 8;
  102cd1:	89 de                	mov    %ebx,%esi
  102cd3:	c1 e6 08             	shl    $0x8,%esi
  102cd6:	09 f3                	or     %esi,%ebx
	c_word |= c_word << 16;
  102cd8:	89 de                	mov    %ebx,%esi
  102cda:	c1 e6 10             	shl    $0x10,%esi
  102cdd:	09 de                	or     %ebx,%esi

	while (n >= sizeof(unsigned int)) {
  102cdf:	31 db                	xor    %ebx,%ebx
  102ce1:	89 d7                	mov    %edx,%edi
  102ce3:	29 df                	sub    %ebx,%edi
  102ce5:	83 ff 03             	cmp    $0x3,%edi
  102ce8:	76 08                	jbe    102cf2 <memset+0x45>
		*(d_word++) = c_word;
  102cea:	89 34 19             	mov    %esi,(%ecx,%ebx,1)
  102ced:	83 c3 04             	add    $0x4,%ebx
  102cf0:	eb ef                	jmp    102ce1 <memset+0x34>
  102cf2:	89 d3                	mov    %edx,%ebx
  102cf4:	83 e2 03             	and    $0x3,%edx
  102cf7:	c1 eb 02             	shr    $0x2,%ebx
  102cfa:	8d 1c 99             	lea    (%ecx,%ebx,4),%ebx
	unsigned int c_word = (unsigned int)(unsigned char)c;

	c_word |= c_word << 8;
	c_word |= c_word << 16;

	while (n >= sizeof(unsigned int)) {
  102cfd:	31 c9                	xor    %ecx,%ecx

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
  102cff:	39 ca                	cmp    %ecx,%edx
  102d01:	74 06                	je     102d09 <memset+0x5c>
		*(d_byte++) = c_byte;
  102d03:	88 04 0b             	mov    %al,(%ebx,%ecx,1)
  102d06:	41                   	inc    %ecx
  102d07:	eb f6                	jmp    102cff <memset+0x52>
		n--;
	}

	return buf;
}
  102d09:	5b                   	pop    %ebx
  102d0a:	8b 45 08             	mov    0x8(%ebp),%eax
  102d0d:	5e                   	pop    %esi
  102d0e:	5f                   	pop    %edi
  102d0f:	5d                   	pop    %ebp
  102d10:	c3                   	ret    

00102d11 <_nop_char_out>:
 * @param c Character to swallow
 *
 * @return 0
 */
static int _nop_char_out(int c)
{
  102d11:	55                   	push   %ebp
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
  102d12:	31 c0                	xor    %eax,%eax
 * @param c Character to swallow
 *
 * @return 0
 */
static int _nop_char_out(int c)
{
  102d14:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
  102d16:	5d                   	pop    %ebp
  102d17:	c3                   	ret    

00102d18 <_printk_dec_ulong>:
 *
 * @return N/A
 */
static void _printk_dec_ulong(const unsigned long num, int pad_zero,
			      int min_width)
{
  102d18:	55                   	push   %ebp
  102d19:	89 e5                	mov    %esp,%ebp
  102d1b:	57                   	push   %edi
  102d1c:	56                   	push   %esi
  102d1d:	53                   	push   %ebx
  102d1e:	83 ec 0c             	sub    $0xc,%esp
  102d21:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	unsigned long remainder = num;
	int found_largest_digit = 0;
	int remaining = 10; /* 10 digits max */

	/* make sure we don't skip if value is zero */
	if (min_width <= 0) {
  102d24:	85 c9                	test   %ecx,%ecx
  102d26:	7f 07                	jg     102d2f <_printk_dec_ulong+0x17>
		min_width = 1;
  102d28:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
  102d2f:	83 fa 01             	cmp    $0x1,%edx
  102d32:	89 45 f0             	mov    %eax,-0x10(%ebp)
  102d35:	19 f6                	sbb    %esi,%esi
  102d37:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
  102d3e:	83 e6 f0             	and    $0xfffffff0,%esi
  102d41:	31 ff                	xor    %edi,%edi
  102d43:	83 c6 30             	add    $0x30,%esi
  102d46:	bb ff c9 9a 3b       	mov    $0x3b9ac9ff,%ebx
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
  102d4b:	3b 5d f0             	cmp    -0x10(%ebp),%ebx
  102d4e:	72 04                	jb     102d54 <_printk_dec_ulong+0x3c>
  102d50:	85 ff                	test   %edi,%edi
  102d52:	74 1c                	je     102d70 <_printk_dec_ulong+0x58>
			found_largest_digit = 1;
			_char_out((int)((remainder / (pos + 1)) + 48));
  102d54:	8d 4b 01             	lea    0x1(%ebx),%ecx
  102d57:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102d5a:	31 d2                	xor    %edx,%edx
		min_width = 1;
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
			found_largest_digit = 1;
  102d5c:	bf 01 00 00 00       	mov    $0x1,%edi
			_char_out((int)((remainder / (pos + 1)) + 48));
  102d61:	f7 f1                	div    %ecx
  102d63:	83 c0 30             	add    $0x30,%eax
  102d66:	50                   	push   %eax
  102d67:	ff 15 60 70 10 00    	call   *0x107060
  102d6d:	59                   	pop    %ecx
  102d6e:	eb 12                	jmp    102d82 <_printk_dec_ulong+0x6a>
		} else if (remaining <= min_width) {
  102d70:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102d73:	31 ff                	xor    %edi,%edi
  102d75:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
  102d78:	7c 08                	jl     102d82 <_printk_dec_ulong+0x6a>
			_char_out((int)(pad_zero ? '0' : ' '));
  102d7a:	56                   	push   %esi
  102d7b:	ff 15 60 70 10 00    	call   *0x107060
  102d81:	5a                   	pop    %edx
		}
		remaining--;
		remainder %= (pos + 1);
  102d82:	8d 4b 01             	lea    0x1(%ebx),%ecx
  102d85:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102d88:	31 d2                	xor    %edx,%edx
			found_largest_digit = 1;
			_char_out((int)((remainder / (pos + 1)) + 48));
		} else if (remaining <= min_width) {
			_char_out((int)(pad_zero ? '0' : ' '));
		}
		remaining--;
  102d8a:	ff 4d ec             	decl   -0x14(%ebp)
		remainder %= (pos + 1);
  102d8d:	f7 f1                	div    %ecx
  102d8f:	89 55 f0             	mov    %edx,-0x10(%ebp)
		pos /= 10;
  102d92:	89 d8                	mov    %ebx,%eax
  102d94:	31 d2                	xor    %edx,%edx
  102d96:	b9 0a 00 00 00       	mov    $0xa,%ecx
  102d9b:	f7 f1                	div    %ecx
  102d9d:	89 c3                	mov    %eax,%ebx
	/* make sure we don't skip if value is zero */
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 9) {
  102d9f:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
  102da3:	75 a6                	jne    102d4b <_printk_dec_ulong+0x33>
		}
		remaining--;
		remainder %= (pos + 1);
		pos /= 10;
	}
	_char_out((int)(remainder + 48));
  102da5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102da8:	83 c0 30             	add    $0x30,%eax
  102dab:	50                   	push   %eax
  102dac:	ff 15 60 70 10 00    	call   *0x107060
  102db2:	58                   	pop    %eax
}
  102db3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102db6:	5b                   	pop    %ebx
  102db7:	5e                   	pop    %esi
  102db8:	5f                   	pop    %edi
  102db9:	5d                   	pop    %ebp
  102dba:	c3                   	ret    

00102dbb <__printk_hook_install>:
 * @param fn putc routine to install
 *
 * @return N/A
 */
void __printk_hook_install(int (*fn)(int))
{
  102dbb:	55                   	push   %ebp
  102dbc:	89 e5                	mov    %esp,%ebp
	_char_out = fn;
  102dbe:	8b 45 08             	mov    0x8(%ebp),%eax
}
  102dc1:	5d                   	pop    %ebp
 *
 * @return N/A
 */
void __printk_hook_install(int (*fn)(int))
{
	_char_out = fn;
  102dc2:	a3 60 70 10 00       	mov    %eax,0x107060
}
  102dc7:	c3                   	ret    

00102dc8 <printk>:
 * @param fmt formatted string to output
 *
 * @return N/A
 */
void printk(const char *fmt, ...)
{
  102dc8:	55                   	push   %ebp
  102dc9:	89 e5                	mov    %esp,%ebp
  102dcb:	57                   	push   %edi
  102dcc:	56                   	push   %esi
  102dcd:	53                   	push   %ebx
  102dce:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
  102dd1:	8d 5d 0c             	lea    0xc(%ebp),%ebx
 */
static inline void _vprintk(const char *fmt, va_list ap)
{
	int might_format = 0; /* 1 if encountered a '%' */
	int pad_zero = 0;
	int min_width = -1;
  102dd4:	83 ce ff             	or     $0xffffffff,%esi
 * @return N/A
 */
static inline void _vprintk(const char *fmt, va_list ap)
{
	int might_format = 0; /* 1 if encountered a '%' */
	int pad_zero = 0;
  102dd7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 *
 * @return N/A
 */
static inline void _vprintk(const char *fmt, va_list ap)
{
	int might_format = 0; /* 1 if encountered a '%' */
  102dde:	31 ff                	xor    %edi,%edi
	int pad_zero = 0;
	int min_width = -1;

	/* fmt has already been adjusted if needed */

	while (*fmt) {
  102de0:	8b 45 08             	mov    0x8(%ebp),%eax
  102de3:	0f be 00             	movsbl (%eax),%eax
  102de6:	84 c0                	test   %al,%al
  102de8:	0f 84 0b 02 00 00    	je     102ff9 <printk+0x231>
		if (!might_format) {
  102dee:	85 ff                	test   %edi,%edi
  102df0:	75 15                	jne    102e07 <printk+0x3f>
			if (*fmt != '%') {
  102df2:	3c 25                	cmp    $0x25,%al
  102df4:	0f 84 df 01 00 00    	je     102fd9 <printk+0x211>
				_char_out((int)*fmt);
  102dfa:	50                   	push   %eax
  102dfb:	ff 15 60 70 10 00    	call   *0x107060
  102e01:	58                   	pop    %eax
  102e02:	e9 ea 01 00 00       	jmp    102ff1 <printk+0x229>
				might_format = 1;
				min_width = -1;
				pad_zero = 0;
			}
		} else {
			switch (*fmt) {
  102e07:	3c 68                	cmp    $0x68,%al
  102e09:	0f 84 dd 01 00 00    	je     102fec <printk+0x224>
  102e0f:	7f 32                	jg     102e43 <printk+0x7b>
  102e11:	3c 39                	cmp    $0x39,%al
  102e13:	7f 15                	jg     102e2a <printk+0x62>
  102e15:	3c 31                	cmp    $0x31,%al
  102e17:	7d 7f                	jge    102e98 <printk+0xd0>
  102e19:	3c 25                	cmp    $0x25,%al
  102e1b:	0f 84 98 01 00 00    	je     102fb9 <printk+0x1f1>
  102e21:	3c 30                	cmp    $0x30,%al
  102e23:	74 62                	je     102e87 <printk+0xbf>
  102e25:	e9 93 01 00 00       	jmp    102fbd <printk+0x1f5>
  102e2a:	3c 63                	cmp    $0x63,%al
  102e2c:	0f 84 77 01 00 00    	je     102fa9 <printk+0x1e1>
  102e32:	3c 64                	cmp    $0x64,%al
  102e34:	74 7a                	je     102eb0 <printk+0xe8>
  102e36:	3c 58                	cmp    $0x58,%al
  102e38:	0f 85 7f 01 00 00    	jne    102fbd <printk+0x1f5>
  102e3e:	e9 b5 00 00 00       	jmp    102ef8 <printk+0x130>
  102e43:	3c 73                	cmp    $0x73,%al
  102e45:	0f 84 47 01 00 00    	je     102f92 <printk+0x1ca>
  102e4b:	7f 16                	jg     102e63 <printk+0x9b>
  102e4d:	3c 6c                	cmp    $0x6c,%al
  102e4f:	0f 84 97 01 00 00    	je     102fec <printk+0x224>
  102e55:	3c 70                	cmp    $0x70,%al
  102e57:	74 7d                	je     102ed6 <printk+0x10e>
  102e59:	3c 69                	cmp    $0x69,%al
  102e5b:	0f 85 5c 01 00 00    	jne    102fbd <printk+0x1f5>
  102e61:	eb 4d                	jmp    102eb0 <printk+0xe8>
  102e63:	3c 78                	cmp    $0x78,%al
  102e65:	0f 84 8d 00 00 00    	je     102ef8 <printk+0x130>
  102e6b:	3c 7a                	cmp    $0x7a,%al
  102e6d:	0f 84 79 01 00 00    	je     102fec <printk+0x224>
  102e73:	3c 75                	cmp    $0x75,%al
  102e75:	0f 85 42 01 00 00    	jne    102fbd <printk+0x1f5>
				}
				_printk_dec_ulong(d, pad_zero, min_width);
				break;
			}
			case 'u': {
				unsigned long u = va_arg(
  102e7b:	8d 7b 04             	lea    0x4(%ebx),%edi
					ap, unsigned long);
				_printk_dec_ulong(u, pad_zero, min_width);
  102e7e:	89 f1                	mov    %esi,%ecx
  102e80:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102e83:	8b 03                	mov    (%ebx),%eax
  102e85:	eb 45                	jmp    102ecc <printk+0x104>
				pad_zero = 0;
			}
		} else {
			switch (*fmt) {
			case '0':
				if (min_width < 0 && pad_zero == 0) {
  102e87:	89 f2                	mov    %esi,%edx
  102e89:	c1 ea 1f             	shr    $0x1f,%edx
  102e8c:	74 0a                	je     102e98 <printk+0xd0>
  102e8e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  102e92:	0f 84 4d 01 00 00    	je     102fe5 <printk+0x21d>
					pad_zero = 1;
					goto still_might_format;
				}
				/* Fall through */
			case '1' ... '9':
				if (min_width < 0) {
  102e98:	85 f6                	test   %esi,%esi
  102e9a:	79 08                	jns    102ea4 <printk+0xdc>
					min_width = *fmt - '0';
  102e9c:	8d 70 d0             	lea    -0x30(%eax),%esi
  102e9f:	e9 48 01 00 00       	jmp    102fec <printk+0x224>
				} else {
					min_width = 10 * min_width + *fmt - '0';
  102ea4:	6b f6 0a             	imul   $0xa,%esi,%esi
  102ea7:	8d 74 06 d0          	lea    -0x30(%esi,%eax,1),%esi
  102eab:	e9 3c 01 00 00       	jmp    102fec <printk+0x224>
			case 'h':
				/* FIXME: do nothing for these modifiers */
				goto still_might_format;
			case 'd':
			case 'i': {
				long d = va_arg(ap, long);
  102eb0:	8d 7b 04             	lea    0x4(%ebx),%edi
  102eb3:	8b 1b                	mov    (%ebx),%ebx

				if (d < 0) {
  102eb5:	85 db                	test   %ebx,%ebx
  102eb7:	79 0c                	jns    102ec5 <printk+0xfd>
					_char_out((int)'-');
  102eb9:	6a 2d                	push   $0x2d
					d = -d;
					min_width--;
  102ebb:	4e                   	dec    %esi
			case 'd':
			case 'i': {
				long d = va_arg(ap, long);

				if (d < 0) {
					_char_out((int)'-');
  102ebc:	ff 15 60 70 10 00    	call   *0x107060
  102ec2:	58                   	pop    %eax
					d = -d;
  102ec3:	f7 db                	neg    %ebx
					min_width--;
				}
				_printk_dec_ulong(d, pad_zero, min_width);
  102ec5:	89 f1                	mov    %esi,%ecx
  102ec7:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102eca:	89 d8                	mov    %ebx,%eax
				break;
			}
			case 'u': {
				unsigned long u = va_arg(
					ap, unsigned long);
				_printk_dec_ulong(u, pad_zero, min_width);
  102ecc:	e8 47 fe ff ff       	call   102d18 <_printk_dec_ulong>
  102ed1:	e9 df 00 00 00       	jmp    102fb5 <printk+0x1ed>
				break;
			}
			case 'p':
				  _char_out('0');
  102ed6:	6a 30                	push   $0x30
  102ed8:	ff 15 60 70 10 00    	call   *0x107060
				  _char_out('x');
  102ede:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
				  /* left-pad pointers with zeros */
				  pad_zero = 1;
				  min_width = 8;
  102ee5:	be 08 00 00 00       	mov    $0x8,%esi
				_printk_dec_ulong(u, pad_zero, min_width);
				break;
			}
			case 'p':
				  _char_out('0');
				  _char_out('x');
  102eea:	ff 15 60 70 10 00    	call   *0x107060
  102ef0:	58                   	pop    %eax
				  /* left-pad pointers with zeros */
				  pad_zero = 1;
  102ef1:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
  102ef8:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
				  min_width = 8;
				  /* Fall through */
			case 'x':
			case 'X': {
				unsigned long x = va_arg(
  102efc:	8d 43 04             	lea    0x4(%ebx),%eax
 * @return N/A
 */
static void _printk_hex_ulong(const unsigned long num, int pad_zero,
			      int min_width)
{
	int size = sizeof(num) * 2;
  102eff:	ba 08 00 00 00       	mov    $0x8,%edx
				  pad_zero = 1;
				  min_width = 8;
				  /* Fall through */
			case 'x':
			case 'X': {
				unsigned long x = va_arg(
  102f04:	89 45 e8             	mov    %eax,-0x18(%ebp)
  102f07:	8b 03                	mov    (%ebx),%eax
  102f09:	89 45 e4             	mov    %eax,-0x1c(%ebp)
static void _printk_hex_ulong(const unsigned long num, int pad_zero,
			      int min_width)
{
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
	int remaining = 8; /* 8 digits max */
  102f0c:	bb 08 00 00 00       	mov    $0x8,%ebx
  102f11:	19 c0                	sbb    %eax,%eax
 */
static void _printk_hex_ulong(const unsigned long num, int pad_zero,
			      int min_width)
{
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
  102f13:	31 ff                	xor    %edi,%edi
  102f15:	89 45 ec             	mov    %eax,-0x14(%ebp)
  102f18:	83 65 ec f0          	andl   $0xfffffff0,-0x14(%ebp)
  102f1c:	83 45 ec 30          	addl   $0x30,-0x14(%ebp)
	int remaining = 8; /* 8 digits max */

	for (; size; size--) {
		char nibble = (num >> ((size - 1) << 2) & 0xf);
  102f20:	4a                   	dec    %edx
  102f21:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  102f24:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
  102f2b:	d3 e8                	shr    %cl,%eax
  102f2d:	89 c1                	mov    %eax,%ecx

		if (nibble || found_largest_digit || size == 1) {
  102f2f:	80 e1 0f             	and    $0xf,%cl
  102f32:	75 0c                	jne    102f40 <printk+0x178>
  102f34:	85 ff                	test   %edi,%edi
  102f36:	75 08                	jne    102f40 <printk+0x178>
  102f38:	85 d2                	test   %edx,%edx
  102f3a:	75 2a                	jne    102f66 <printk+0x19e>
			found_largest_digit = 1;
			nibble += nibble > 9 ? 87 : 48;
  102f3c:	b0 30                	mov    $0x30,%al
  102f3e:	eb 0d                	jmp    102f4d <printk+0x185>
  102f40:	80 f9 09             	cmp    $0x9,%cl
  102f43:	0f 9f c0             	setg   %al
  102f46:	48                   	dec    %eax
  102f47:	83 e0 d9             	and    $0xffffffd9,%eax
  102f4a:	83 c0 57             	add    $0x57,%eax
			_char_out((int)nibble);
  102f4d:	01 c8                	add    %ecx,%eax
  102f4f:	89 55 e0             	mov    %edx,-0x20(%ebp)
  102f52:	0f b6 c0             	movzbl %al,%eax
  102f55:	50                   	push   %eax
  102f56:	ff 15 60 70 10 00    	call   *0x107060
  102f5c:	5f                   	pop    %edi
  102f5d:	89 d9                	mov    %ebx,%ecx

	for (; size; size--) {
		char nibble = (num >> ((size - 1) << 2) & 0xf);

		if (nibble || found_largest_digit || size == 1) {
			found_largest_digit = 1;
  102f5f:	bf 01 00 00 00       	mov    $0x1,%edi
  102f64:	eb 1c                	jmp    102f82 <printk+0x1ba>
			nibble += nibble > 9 ? 87 : 48;
			_char_out((int)nibble);
			continue;
		}

		if (remaining-- <= min_width) {
  102f66:	31 ff                	xor    %edi,%edi
  102f68:	8d 4b ff             	lea    -0x1(%ebx),%ecx
  102f6b:	39 de                	cmp    %ebx,%esi
  102f6d:	7c 16                	jl     102f85 <printk+0x1bd>
			_char_out((int)(pad_zero ? '0' : ' '));
  102f6f:	ff 75 ec             	pushl  -0x14(%ebp)
  102f72:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  102f75:	89 55 e0             	mov    %edx,-0x20(%ebp)
  102f78:	ff 15 60 70 10 00    	call   *0x107060
  102f7e:	5b                   	pop    %ebx
  102f7f:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  102f82:	8b 55 e0             	mov    -0x20(%ebp),%edx
{
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
	int remaining = 8; /* 8 digits max */

	for (; size; size--) {
  102f85:	85 d2                	test   %edx,%edx
  102f87:	74 04                	je     102f8d <printk+0x1c5>
  102f89:	89 cb                	mov    %ecx,%ebx
  102f8b:	eb 93                	jmp    102f20 <printk+0x158>
				  pad_zero = 1;
				  min_width = 8;
				  /* Fall through */
			case 'x':
			case 'X': {
				unsigned long x = va_arg(
  102f8d:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  102f90:	eb 43                	jmp    102fd5 <printk+0x20d>
					ap, unsigned long);
				_printk_hex_ulong(x, pad_zero, min_width);
				break;
			}
			case 's': {
				char *s = va_arg(ap, char *);
  102f92:	8d 7b 04             	lea    0x4(%ebx),%edi
  102f95:	8b 1b                	mov    (%ebx),%ebx

				while (*s)
  102f97:	0f be 03             	movsbl (%ebx),%eax
  102f9a:	84 c0                	test   %al,%al
  102f9c:	74 17                	je     102fb5 <printk+0x1ed>
					_char_out((int)(*s++));
  102f9e:	50                   	push   %eax
  102f9f:	43                   	inc    %ebx
  102fa0:	ff 15 60 70 10 00    	call   *0x107060
  102fa6:	59                   	pop    %ecx
  102fa7:	eb ee                	jmp    102f97 <printk+0x1cf>
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);

				_char_out(c);
  102fa9:	ff 33                	pushl  (%ebx)
				while (*s)
					_char_out((int)(*s++));
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);
  102fab:	8d 7b 04             	lea    0x4(%ebx),%edi

				_char_out(c);
  102fae:	ff 15 60 70 10 00    	call   *0x107060
  102fb4:	5a                   	pop    %edx
				while (*s)
					_char_out((int)(*s++));
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);
  102fb5:	89 fb                	mov    %edi,%ebx
  102fb7:	eb 1c                	jmp    102fd5 <printk+0x20d>

				_char_out(c);
				break;
			}
			case '%': {
				_char_out((int)'%');
  102fb9:	6a 25                	push   $0x25
  102fbb:	eb 11                	jmp    102fce <printk+0x206>
				break;
			}
			default:
				_char_out((int)'%');
  102fbd:	6a 25                	push   $0x25
  102fbf:	ff 15 60 70 10 00    	call   *0x107060
				_char_out((int)*fmt);
  102fc5:	8b 45 08             	mov    0x8(%ebp),%eax
  102fc8:	0f be 00             	movsbl (%eax),%eax
  102fcb:	89 04 24             	mov    %eax,(%esp)
  102fce:	ff 15 60 70 10 00    	call   *0x107060
  102fd4:	58                   	pop    %eax
				break;
			}
			might_format = 0;
  102fd5:	31 ff                	xor    %edi,%edi
  102fd7:	eb 18                	jmp    102ff1 <printk+0x229>
		if (!might_format) {
			if (*fmt != '%') {
				_char_out((int)*fmt);
			} else {
				might_format = 1;
				min_width = -1;
  102fd9:	83 ce ff             	or     $0xffffffff,%esi
				pad_zero = 0;
  102fdc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  102fe3:	eb 07                	jmp    102fec <printk+0x224>
			}
		} else {
			switch (*fmt) {
			case '0':
				if (min_width < 0 && pad_zero == 0) {
					pad_zero = 1;
  102fe5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				pad_zero = 0;
			}
		} else {
			switch (*fmt) {
			case '0':
				if (min_width < 0 && pad_zero == 0) {
  102fec:	bf 01 00 00 00       	mov    $0x1,%edi
				break;
			}
			might_format = 0;
		}
still_might_format:
		++fmt;
  102ff1:	ff 45 08             	incl   0x8(%ebp)
  102ff4:	e9 e7 fd ff ff       	jmp    102de0 <printk+0x18>
	va_list ap;

	va_start(ap, fmt);
	_vprintk(fmt, ap);
	va_end(ap);
}
  102ff9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102ffc:	5b                   	pop    %ebx
  102ffd:	5e                   	pop    %esi
  102ffe:	5f                   	pop    %edi
  102fff:	5d                   	pop    %ebp
  103000:	c3                   	ret    

00103001 <_ConfigAbsSyms>:
/* file is auto-generated, do not modify ! */

#include <toolchain.h>

GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
  103001:	55                   	push   %ebp
  103002:	89 e5                	mov    %esp,%ebp
GEN_ABSOLUTE_SYM(CONFIG_MICROKERNEL, 1);
GEN_ABSOLUTE_SYM(CONFIG_MEM_POOL_SPLIT_BEFORE_DEFRAG, 1);
GEN_ABSOLUTE_SYM(CONFIG_ISA_IA32, 1);
GEN_ABSOLUTE_SYM(CONFIG_PINMUX_GALILEO_EXP0_NAME, 1);

GEN_ABS_SYM_END
  103004:	5d                   	pop    %ebp
  103005:	c3                   	ret    

00103006 <gpio_pin_configure>:
 * @param flags Flags for pin configuration. IN/OUT, interrupt ...
 * @return 0 if successful, negative errno code on failure.
 */
static inline int gpio_pin_configure(struct device *port, uint8_t pin,
				     int flags)
{
  103006:	55                   	push   %ebp
  103007:	89 e5                	mov    %esp,%ebp
  103009:	53                   	push   %ebx
	const struct gpio_driver_api *api = port->driver_api;

	return api->config(port, GPIO_ACCESS_BY_PIN, pin, flags);
  10300a:	8b 58 04             	mov    0x4(%eax),%ebx
  10300d:	51                   	push   %ecx
  10300e:	0f b6 d2             	movzbl %dl,%edx
  103011:	52                   	push   %edx
  103012:	6a 00                	push   $0x0
  103014:	50                   	push   %eax
  103015:	ff 13                	call   *(%ebx)
  103017:	83 c4 10             	add    $0x10,%esp
}
  10301a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10301d:	c9                   	leave  
  10301e:	c3                   	ret    

0010301f <gpio_pin_write>:
 * @param value Value set on the pin.
 * @return 0 if successful, negative errno code on failure.
 */
static inline int gpio_pin_write(struct device *port, uint32_t pin,
				 uint32_t value)
{
  10301f:	55                   	push   %ebp
  103020:	89 e5                	mov    %esp,%ebp
  103022:	53                   	push   %ebx
	const struct gpio_driver_api *api = port->driver_api;

	return api->write(port, GPIO_ACCESS_BY_PIN, pin, value);
  103023:	8b 58 04             	mov    0x4(%eax),%ebx
  103026:	51                   	push   %ecx
  103027:	52                   	push   %edx
  103028:	6a 00                	push   $0x0
  10302a:	50                   	push   %eax
  10302b:	ff 53 04             	call   *0x4(%ebx)
  10302e:	83 c4 10             	add    $0x10,%esp
}
  103031:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  103034:	c9                   	leave  
  103035:	c3                   	ret    

00103036 <_galileo_pinmux_set_pin>:
			     { NONE,  0, DONT_CARE, (GPIO_DIR_IN)  },
			     { NONE,  0, DONT_CARE, (GPIO_DIR_IN)  } } },
};

int _galileo_pinmux_set_pin(struct device *port, uint8_t pin, uint32_t func)
{
  103036:	55                   	push   %ebp
  103037:	89 e5                	mov    %esp,%ebp
  103039:	57                   	push   %edi
  10303a:	56                   	push   %esi
  10303b:	53                   	push   %ebx
  10303c:	50                   	push   %eax
	struct galileo_data * const drv_data = port->driver_data;
  10303d:	8b 45 08             	mov    0x8(%ebp),%eax
			     { NONE,  0, DONT_CARE, (GPIO_DIR_IN)  },
			     { NONE,  0, DONT_CARE, (GPIO_DIR_IN)  } } },
};

int _galileo_pinmux_set_pin(struct device *port, uint8_t pin, uint32_t func)
{
  103040:	8b 55 0c             	mov    0xc(%ebp),%edx
  103043:	8b 5d 10             	mov    0x10(%ebp),%ebx
	uint8_t mux_index = 0;
	uint8_t i = 0;
	struct mux_path *enable = NULL;
	struct pin_config *mux_config = drv_data->mux_config;

	if (pin > PINMUX_NUM_PINS) {
  103046:	80 fa 14             	cmp    $0x14,%dl
			     { NONE,  0, DONT_CARE, (GPIO_DIR_IN)  } } },
};

int _galileo_pinmux_set_pin(struct device *port, uint8_t pin, uint32_t func)
{
	struct galileo_data * const drv_data = port->driver_data;
  103049:	8b 70 08             	mov    0x8(%eax),%esi
  10304c:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax

	uint8_t mux_index = 0;
	uint8_t i = 0;
	struct mux_path *enable = NULL;
	struct pin_config *mux_config = drv_data->mux_config;
  103051:	8b 4e 1c             	mov    0x1c(%esi),%ecx

	if (pin > PINMUX_NUM_PINS) {
  103054:	0f 87 10 01 00 00    	ja     10316a <_galileo_pinmux_set_pin+0x134>
		return -ENOTSUP;
	}

	mux_config[pin].mode = func;
  10305a:	0f b6 c2             	movzbl %dl,%eax
	mux_index = NUM_PIN_FUNCS * pin;
	/*
	 * functions are in numeric order, we can just skip to the index
	 * needed
	 */
	mux_index += func;
  10305d:	c6 45 f3 05          	movb   $0x5,-0xd(%ebp)

	if (pin > PINMUX_NUM_PINS) {
		return -ENOTSUP;
	}

	mux_config[pin].mode = func;
  103061:	89 5c c1 04          	mov    %ebx,0x4(%ecx,%eax,8)
  103065:	8d 1c 93             	lea    (%ebx,%edx,4),%ebx
  103068:	0f b6 db             	movzbl %bl,%ebx
  10306b:	6b db 54             	imul   $0x54,%ebx,%ebx
  10306e:	81 c3 20 49 10 00    	add    $0x104920,%ebx
	mux_index += func;

	enable = &_galileo_path[mux_index];

	for (i = 0; i < 5; i++) {
		switch (enable->path[i].mux) {
  103074:	8b 43 04             	mov    0x4(%ebx),%eax
  103077:	48                   	dec    %eax
  103078:	83 f8 06             	cmp    $0x6,%eax
  10307b:	0f 87 db 00 00 00    	ja     10315c <_galileo_pinmux_set_pin+0x126>
  103081:	ff 24 85 e0 48 10 00 	jmp    *0x1048e0(,%eax,4)
		case EXP0:
			gpio_pin_write(drv_data->exp0,
  103088:	0f b6 7b 08          	movzbl 0x8(%ebx),%edi
  10308c:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  10308f:	89 fa                	mov    %edi,%edx
  103091:	8b 06                	mov    (%esi),%eax
  103093:	e8 87 ff ff ff       	call   10301f <gpio_pin_write>
					   enable->path[i].pin,
					   enable->path[i].level);
			gpio_pin_configure(drv_data->exp0,
  103098:	8b 4b 10             	mov    0x10(%ebx),%ecx
  10309b:	89 fa                	mov    %edi,%edx
  10309d:	8b 06                	mov    (%esi),%eax
  10309f:	e9 b3 00 00 00       	jmp    103157 <_galileo_pinmux_set_pin+0x121>
					   enable->path[i].pin,
					   enable->path[i].cfg);
			break;
		case EXP1:
			gpio_pin_write(drv_data->exp1,
  1030a4:	0f b6 7b 08          	movzbl 0x8(%ebx),%edi
  1030a8:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  1030ab:	8b 46 04             	mov    0x4(%esi),%eax
  1030ae:	89 fa                	mov    %edi,%edx
  1030b0:	e8 6a ff ff ff       	call   10301f <gpio_pin_write>
					   enable->path[i].pin,
					   enable->path[i].level);
			gpio_pin_configure(drv_data->exp1,
  1030b5:	8b 4b 10             	mov    0x10(%ebx),%ecx
  1030b8:	8b 46 04             	mov    0x4(%esi),%eax
  1030bb:	e9 95 00 00 00       	jmp    103155 <_galileo_pinmux_set_pin+0x11f>
					   enable->path[i].pin,
					   enable->path[i].cfg);
			break;
		case EXP2:
			gpio_pin_write(drv_data->exp2,
  1030c0:	0f b6 7b 08          	movzbl 0x8(%ebx),%edi
  1030c4:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  1030c7:	8b 46 08             	mov    0x8(%esi),%eax
  1030ca:	89 fa                	mov    %edi,%edx
  1030cc:	e8 4e ff ff ff       	call   10301f <gpio_pin_write>
					   enable->path[i].pin,
					   enable->path[i].level);
			gpio_pin_configure(drv_data->exp2,
  1030d1:	8b 4b 10             	mov    0x10(%ebx),%ecx
  1030d4:	8b 46 08             	mov    0x8(%esi),%eax
  1030d7:	eb 7c                	jmp    103155 <_galileo_pinmux_set_pin+0x11f>
					   enable->path[i].pin,
					   enable->path[i].cfg);
			break;
		case PWM0:
			pwm_pin_configure(drv_data->pwm0,
  1030d9:	8b 46 0c             	mov    0xc(%esi),%eax
static inline int __deprecated pwm_pin_configure(struct device *dev,
						 uint8_t pwm, int flags)
{
	const struct pwm_driver_api *api = dev->driver_api;

	return api->config(dev, PWM_ACCESS_BY_PIN, pwm, flags);
  1030dc:	0f b6 7b 08          	movzbl 0x8(%ebx),%edi
  1030e0:	8b 50 04             	mov    0x4(%eax),%edx
  1030e3:	6a 00                	push   $0x0
  1030e5:	57                   	push   %edi
  1030e6:	6a 00                	push   $0x0
  1030e8:	50                   	push   %eax
  1030e9:	ff 12                	call   *(%edx)
  1030eb:	83 c4 10             	add    $0x10,%esp
				enable->path[i].pin, 0);
			pwm_pin_set_duty_cycle(drv_data->pwm0,
  1030ee:	8b 56 0c             	mov    0xc(%esi),%edx
  1030f1:	83 7b 0c 01          	cmpl   $0x1,0xc(%ebx)
  1030f5:	19 c0                	sbb    %eax,%eax
						      uint32_t pwm,
						      uint8_t duty)
{
	const struct pwm_driver_api *api = dev->driver_api;

	return api->set_duty_cycle(dev, PWM_ACCESS_BY_PIN, pwm, duty);
  1030f7:	8b 4a 04             	mov    0x4(%edx),%ecx
  1030fa:	f7 d0                	not    %eax
  1030fc:	83 e0 64             	and    $0x64,%eax
  1030ff:	50                   	push   %eax
  103100:	57                   	push   %edi
  103101:	6a 00                	push   $0x0
  103103:	52                   	push   %edx
  103104:	ff 51 0c             	call   *0xc(%ecx)
  103107:	83 c4 10             	add    $0x10,%esp
  10310a:	eb 50                	jmp    10315c <_galileo_pinmux_set_pin+0x126>
				enable->path[i].pin,
				enable->path[i].level ? 100 : 0);
			break;
		case G_DW:
			gpio_pin_write(drv_data->gpio_dw,
  10310c:	0f b6 7b 08          	movzbl 0x8(%ebx),%edi
  103110:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  103113:	8b 46 10             	mov    0x10(%esi),%eax
  103116:	89 fa                	mov    %edi,%edx
  103118:	e8 02 ff ff ff       	call   10301f <gpio_pin_write>
					   enable->path[i].pin,
					   enable->path[i].level);
			gpio_pin_configure(drv_data->gpio_dw,
  10311d:	8b 4b 10             	mov    0x10(%ebx),%ecx
  103120:	8b 46 10             	mov    0x10(%esi),%eax
  103123:	eb 30                	jmp    103155 <_galileo_pinmux_set_pin+0x11f>
					   enable->path[i].pin,
					   enable->path[i].cfg);
			break;
		case G_CW:
			gpio_pin_write(drv_data->gpio_core,
  103125:	0f b6 7b 08          	movzbl 0x8(%ebx),%edi
  103129:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  10312c:	8b 46 14             	mov    0x14(%esi),%eax
  10312f:	89 fa                	mov    %edi,%edx
  103131:	e8 e9 fe ff ff       	call   10301f <gpio_pin_write>
					   enable->path[i].pin,
					   enable->path[i].level);
			gpio_pin_configure(drv_data->gpio_core,
  103136:	8b 4b 10             	mov    0x10(%ebx),%ecx
  103139:	8b 46 14             	mov    0x14(%esi),%eax
  10313c:	eb 17                	jmp    103155 <_galileo_pinmux_set_pin+0x11f>
					   enable->path[i].pin,
					   enable->path[i].cfg);
			break;
		case G_RW:
			gpio_pin_write(drv_data->gpio_resume,
  10313e:	0f b6 7b 08          	movzbl 0x8(%ebx),%edi
  103142:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  103145:	8b 46 18             	mov    0x18(%esi),%eax
  103148:	89 fa                	mov    %edi,%edx
  10314a:	e8 d0 fe ff ff       	call   10301f <gpio_pin_write>
					   enable->path[i].pin,
					   enable->path[i].level);
			gpio_pin_configure(drv_data->gpio_resume,
  10314f:	8b 4b 10             	mov    0x10(%ebx),%ecx
  103152:	8b 46 18             	mov    0x18(%esi),%eax
  103155:	89 fa                	mov    %edi,%edx
  103157:	e8 aa fe ff ff       	call   103006 <gpio_pin_configure>
  10315c:	83 c3 10             	add    $0x10,%ebx
	 */
	mux_index += func;

	enable = &_galileo_path[mux_index];

	for (i = 0; i < 5; i++) {
  10315f:	fe 4d f3             	decb   -0xd(%ebp)
  103162:	0f 85 0c ff ff ff    	jne    103074 <_galileo_pinmux_set_pin+0x3e>
			/* no need to do anything */
			break;
		}
	}

	return 0;
  103168:	31 c0                	xor    %eax,%eax
}
  10316a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10316d:	5b                   	pop    %ebx
  10316e:	5e                   	pop    %esi
  10316f:	5f                   	pop    %edi
  103170:	5d                   	pop    %ebp
  103171:	c3                   	ret    

00103172 <pinmux_galileo_initialize>:
	.pwm0 = NULL,
	.mux_config = mux_config,
};

static int pinmux_galileo_initialize(struct device *port)
{
  103172:	55                   	push   %ebp
  103173:	89 e5                	mov    %esp,%ebp
  103175:	56                   	push   %esi
  103176:	53                   	push   %ebx
  103177:	8b 75 08             	mov    0x8(%ebp),%esi
	struct galileo_data *dev = port->driver_data;
  10317a:	8b 5e 08             	mov    0x8(%esi),%ebx
	int i;

	/* Grab the EXP0, EXP1, EXP2, and PWM0 now by name */
	dev->exp0 = device_get_binding(PINMUX_GALILEO_EXP0_NAME);
  10317d:	68 8d 47 10 00       	push   $0x10478d
  103182:	e8 60 05 00 00       	call   1036e7 <device_get_binding>
  103187:	5a                   	pop    %edx
	if (!dev->exp0) {
  103188:	85 c0                	test   %eax,%eax
{
	struct galileo_data *dev = port->driver_data;
	int i;

	/* Grab the EXP0, EXP1, EXP2, and PWM0 now by name */
	dev->exp0 = device_get_binding(PINMUX_GALILEO_EXP0_NAME);
  10318a:	89 03                	mov    %eax,(%ebx)
	if (!dev->exp0) {
  10318c:	75 0a                	jne    103198 <pinmux_galileo_initialize+0x26>
		return -EINVAL;
  10318e:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  103193:	e9 8e 00 00 00       	jmp    103226 <pinmux_galileo_initialize+0xb4>
	}
	dev->exp1 = device_get_binding(PINMUX_GALILEO_EXP1_NAME);
  103198:	68 88 47 10 00       	push   $0x104788
  10319d:	e8 45 05 00 00       	call   1036e7 <device_get_binding>
  1031a2:	59                   	pop    %ecx
	if (!dev->exp1) {
  1031a3:	85 c0                	test   %eax,%eax
	/* Grab the EXP0, EXP1, EXP2, and PWM0 now by name */
	dev->exp0 = device_get_binding(PINMUX_GALILEO_EXP0_NAME);
	if (!dev->exp0) {
		return -EINVAL;
	}
	dev->exp1 = device_get_binding(PINMUX_GALILEO_EXP1_NAME);
  1031a5:	89 43 04             	mov    %eax,0x4(%ebx)
	if (!dev->exp1) {
  1031a8:	74 e4                	je     10318e <pinmux_galileo_initialize+0x1c>
		return -EINVAL;
	}
	dev->exp2 = device_get_binding(PINMUX_GALILEO_EXP2_NAME);
  1031aa:	68 7d 47 10 00       	push   $0x10477d
  1031af:	e8 33 05 00 00       	call   1036e7 <device_get_binding>
  1031b4:	5a                   	pop    %edx
	if (!dev->exp2) {
  1031b5:	85 c0                	test   %eax,%eax
	}
	dev->exp1 = device_get_binding(PINMUX_GALILEO_EXP1_NAME);
	if (!dev->exp1) {
		return -EINVAL;
	}
	dev->exp2 = device_get_binding(PINMUX_GALILEO_EXP2_NAME);
  1031b7:	89 43 08             	mov    %eax,0x8(%ebx)
	if (!dev->exp2) {
  1031ba:	74 d2                	je     10318e <pinmux_galileo_initialize+0x1c>
		return -EINVAL;
	}
	dev->pwm0 = device_get_binding(PINMUX_GALILEO_PWM0_NAME);
  1031bc:	68 a2 47 10 00       	push   $0x1047a2
  1031c1:	e8 21 05 00 00       	call   1036e7 <device_get_binding>
  1031c6:	59                   	pop    %ecx
	if (!dev->pwm0) {
  1031c7:	85 c0                	test   %eax,%eax
	}
	dev->exp2 = device_get_binding(PINMUX_GALILEO_EXP2_NAME);
	if (!dev->exp2) {
		return -EINVAL;
	}
	dev->pwm0 = device_get_binding(PINMUX_GALILEO_PWM0_NAME);
  1031c9:	89 43 0c             	mov    %eax,0xc(%ebx)
	if (!dev->pwm0) {
  1031cc:	74 c0                	je     10318e <pinmux_galileo_initialize+0x1c>
		return -EINVAL;
	}
	dev->gpio_dw = device_get_binding(PINMUX_GALILEO_GPIO_DW_NAME);
  1031ce:	68 76 47 10 00       	push   $0x104776
  1031d3:	e8 0f 05 00 00       	call   1036e7 <device_get_binding>
  1031d8:	5a                   	pop    %edx
	if (!dev->gpio_dw) {
  1031d9:	85 c0                	test   %eax,%eax
	}
	dev->pwm0 = device_get_binding(PINMUX_GALILEO_PWM0_NAME);
	if (!dev->pwm0) {
		return -EINVAL;
	}
	dev->gpio_dw = device_get_binding(PINMUX_GALILEO_GPIO_DW_NAME);
  1031db:	89 43 10             	mov    %eax,0x10(%ebx)
	if (!dev->gpio_dw) {
  1031de:	74 ae                	je     10318e <pinmux_galileo_initialize+0x1c>
		return -EINVAL;
	}
	dev->gpio_core = device_get_binding(
  1031e0:	68 9a 47 10 00       	push   $0x10479a
  1031e5:	e8 fd 04 00 00       	call   1036e7 <device_get_binding>
  1031ea:	59                   	pop    %ecx
			    PINMUX_GALILEO_GPIO_INTEL_CW_NAME);
	if (!dev->gpio_core) {
  1031eb:	85 c0                	test   %eax,%eax
	}
	dev->gpio_dw = device_get_binding(PINMUX_GALILEO_GPIO_DW_NAME);
	if (!dev->gpio_dw) {
		return -EINVAL;
	}
	dev->gpio_core = device_get_binding(
  1031ed:	89 43 14             	mov    %eax,0x14(%ebx)
			    PINMUX_GALILEO_GPIO_INTEL_CW_NAME);
	if (!dev->gpio_core) {
  1031f0:	74 9c                	je     10318e <pinmux_galileo_initialize+0x1c>
		return -EINVAL;
	}
	dev->gpio_resume = device_get_binding(
  1031f2:	68 92 47 10 00       	push   $0x104792
  1031f7:	e8 eb 04 00 00       	call   1036e7 <device_get_binding>
  1031fc:	5a                   	pop    %edx
			    PINMUX_GALILEO_GPIO_INTEL_RW_NAME);
	if (!dev->gpio_resume) {
  1031fd:	85 c0                	test   %eax,%eax
	dev->gpio_core = device_get_binding(
			    PINMUX_GALILEO_GPIO_INTEL_CW_NAME);
	if (!dev->gpio_core) {
		return -EINVAL;
	}
	dev->gpio_resume = device_get_binding(
  1031ff:	89 43 18             	mov    %eax,0x18(%ebx)
			    PINMUX_GALILEO_GPIO_INTEL_RW_NAME);
	if (!dev->gpio_resume) {
  103202:	74 8a                	je     10318e <pinmux_galileo_initialize+0x1c>
  103204:	bb 80 70 10 00       	mov    $0x107080,%ebx
	/*
	 * Now that we have everything, let us start parsing everything
	 * from the above mapping as selected by the end user
	 */
	for (i = 0; i < PINMUX_NUM_PINS; i++) {
		_galileo_pinmux_set_pin(port,
  103209:	ff 73 04             	pushl  0x4(%ebx)
  10320c:	0f b6 03             	movzbl (%ebx),%eax
  10320f:	83 c3 08             	add    $0x8,%ebx
  103212:	50                   	push   %eax
  103213:	56                   	push   %esi
  103214:	e8 1d fe ff ff       	call   103036 <_galileo_pinmux_set_pin>
  103219:	83 c4 0c             	add    $0xc,%esp

	/*
	 * Now that we have everything, let us start parsing everything
	 * from the above mapping as selected by the end user
	 */
	for (i = 0; i < PINMUX_NUM_PINS; i++) {
  10321c:	81 fb 20 71 10 00    	cmp    $0x107120,%ebx
  103222:	75 e5                	jne    103209 <pinmux_galileo_initialize+0x97>
		_galileo_pinmux_set_pin(port,
				 mux_config[i].pin_num,
				 mux_config[i].mode);
	}

	return 0;
  103224:	31 c0                	xor    %eax,%eax
}
  103226:	8d 65 f8             	lea    -0x8(%ebp),%esp
  103229:	5b                   	pop    %ebx
  10322a:	5e                   	pop    %esi
  10322b:	5d                   	pop    %ebp
  10322c:	c3                   	ret    

0010322d <pci_legacy_bridge_irq_config>:
 * - GPIO;
 * - UART0, UART1;
 * - SDIO/eMMC, USB, Ethernet.
 */
static int pci_legacy_bridge_irq_config(struct device *unused)
{
  10322d:	55                   	push   %ebp
	ARG_UNUSED(unused);
	struct pci_dev_info info = {
  10322e:	31 c0                	xor    %eax,%eax
 * - GPIO;
 * - UART0, UART1;
 * - SDIO/eMMC, USB, Ethernet.
 */
static int pci_legacy_bridge_irq_config(struct device *unused)
{
  103230:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(unused);
	struct pci_dev_info info = {
  103232:	b9 05 00 00 00       	mov    $0x5,%ecx
 * - GPIO;
 * - UART0, UART1;
 * - SDIO/eMMC, USB, Ethernet.
 */
static int pci_legacy_bridge_irq_config(struct device *unused)
{
  103237:	57                   	push   %edi
  103238:	53                   	push   %ebx
	ARG_UNUSED(unused);
	struct pci_dev_info info = {
  103239:	8d 7d e4             	lea    -0x1c(%ebp),%edi
 * - GPIO;
 * - UART0, UART1;
 * - SDIO/eMMC, USB, Ethernet.
 */
static int pci_legacy_bridge_irq_config(struct device *unused)
{
  10323c:	83 ec 14             	sub    $0x14,%esp
	ARG_UNUSED(unused);
	struct pci_dev_info info = {
  10323f:	f3 ab                	rep stos %eax,%es:(%edi)
  103241:	c7 45 f0 00 00 01 00 	movl   $0x10000,-0x10(%ebp)
		.function = PCI_FUNCTION_ANY,
		.bar = PCI_BAR_ANY,
	};
	if (pci_legacy_bridge_detect(&info) == 0) {
  103248:	8d 5d e4             	lea    -0x1c(%ebp),%ebx
 * - SDIO/eMMC, USB, Ethernet.
 */
static int pci_legacy_bridge_irq_config(struct device *unused)
{
	ARG_UNUSED(unused);
	struct pci_dev_info info = {
  10324b:	8a 45 f3             	mov    -0xd(%ebp),%al
		.function = PCI_FUNCTION_ANY,
		.bar = PCI_BAR_ANY,
	};
	if (pci_legacy_bridge_detect(&info) == 0) {
  10324e:	53                   	push   %ebx
 * - SDIO/eMMC, USB, Ethernet.
 */
static int pci_legacy_bridge_irq_config(struct device *unused)
{
	ARG_UNUSED(unused);
	struct pci_dev_info info = {
  10324f:	83 e0 e3             	and    $0xffffffe3,%eax
  103252:	83 c8 18             	or     $0x18,%eax
  103255:	88 45 f3             	mov    %al,-0xd(%ebp)
		.function = PCI_FUNCTION_ANY,
		.bar = PCI_BAR_ANY,
	};
	if (pci_legacy_bridge_detect(&info) == 0) {
  103258:	e8 bb de ff ff       	call   101118 <pci_legacy_bridge_detect>
  10325d:	5a                   	pop    %edx
  10325e:	85 c0                	test   %eax,%eax
  103260:	75 78                	jne    1032da <pci_legacy_bridge_irq_config+0xad>
		pci_legacy_bridge_configure(&info, 1, PCI_INTA, 16);
  103262:	6a 10                	push   $0x10
  103264:	6a 01                	push   $0x1
  103266:	6a 01                	push   $0x1
  103268:	53                   	push   %ebx
  103269:	e8 e1 df ff ff       	call   10124f <pci_legacy_bridge_configure>
  10326e:	83 c4 10             	add    $0x10,%esp
		pci_legacy_bridge_configure(&info, 1, PCI_INTB, 17);
  103271:	6a 11                	push   $0x11
  103273:	6a 02                	push   $0x2
  103275:	6a 01                	push   $0x1
  103277:	53                   	push   %ebx
  103278:	e8 d2 df ff ff       	call   10124f <pci_legacy_bridge_configure>
  10327d:	83 c4 10             	add    $0x10,%esp
		pci_legacy_bridge_configure(&info, 1, PCI_INTC, 18);
  103280:	6a 12                	push   $0x12
  103282:	6a 03                	push   $0x3
  103284:	6a 01                	push   $0x1
  103286:	53                   	push   %ebx
  103287:	e8 c3 df ff ff       	call   10124f <pci_legacy_bridge_configure>
  10328c:	83 c4 10             	add    $0x10,%esp
		pci_legacy_bridge_configure(&info, 1, PCI_INTD, 19);
  10328f:	6a 13                	push   $0x13
  103291:	6a 04                	push   $0x4
  103293:	6a 01                	push   $0x1
  103295:	53                   	push   %ebx
  103296:	e8 b4 df ff ff       	call   10124f <pci_legacy_bridge_configure>
  10329b:	83 c4 10             	add    $0x10,%esp
		pci_legacy_bridge_configure(&info, 0, PCI_INTA, 17);
  10329e:	6a 11                	push   $0x11
  1032a0:	6a 01                	push   $0x1
  1032a2:	6a 00                	push   $0x0
  1032a4:	53                   	push   %ebx
  1032a5:	e8 a5 df ff ff       	call   10124f <pci_legacy_bridge_configure>
  1032aa:	83 c4 10             	add    $0x10,%esp
		pci_legacy_bridge_configure(&info, 0, PCI_INTB, 18);
  1032ad:	6a 12                	push   $0x12
  1032af:	6a 02                	push   $0x2
  1032b1:	6a 00                	push   $0x0
  1032b3:	53                   	push   %ebx
  1032b4:	e8 96 df ff ff       	call   10124f <pci_legacy_bridge_configure>
  1032b9:	83 c4 10             	add    $0x10,%esp
		pci_legacy_bridge_configure(&info, 0, PCI_INTC, 19);
  1032bc:	6a 13                	push   $0x13
  1032be:	6a 03                	push   $0x3
  1032c0:	6a 00                	push   $0x0
  1032c2:	53                   	push   %ebx
  1032c3:	e8 87 df ff ff       	call   10124f <pci_legacy_bridge_configure>
  1032c8:	83 c4 10             	add    $0x10,%esp
		pci_legacy_bridge_configure(&info, 0, PCI_INTD, 16);
  1032cb:	6a 10                	push   $0x10
  1032cd:	6a 04                	push   $0x4
  1032cf:	6a 00                	push   $0x0
  1032d1:	53                   	push   %ebx
  1032d2:	e8 78 df ff ff       	call   10124f <pci_legacy_bridge_configure>
  1032d7:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
}
  1032da:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1032dd:	31 c0                	xor    %eax,%eax
  1032df:	5b                   	pop    %ebx
  1032e0:	5f                   	pop    %edi
  1032e1:	5d                   	pop    %ebp
  1032e2:	c3                   	ret    

001032e3 <nano_cpu_idle>:
 * will be issued causing a low-power consumption sleep mode.
 *
 * @return N/A
 */
void nano_cpu_idle(void)
{
  1032e3:	55                   	push   %ebp
  1032e4:	89 e5                	mov    %esp,%ebp
	_sys_k_event_logger_enter_sleep();
#if defined(CONFIG_BOOT_TIME_MEASUREMENT)
	__idle_tsc = _tsc_read();
#endif

	__asm__ volatile (
  1032e6:	fb                   	sti    
  1032e7:	f4                   	hlt    
	    "sti\n\t"
	    "hlt\n\t");
}
  1032e8:	5d                   	pop    %ebp
  1032e9:	c3                   	ret    

001032ea <_SysFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _SysFatalErrorHandler(unsigned int reason,
					 const NANO_ESF *pEsf)
{
  1032ea:	55                   	push   %ebp
  1032eb:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

	if (k_is_in_isr() || _is_thread_essential()) {
  1032ed:	e8 b6 0d 00 00       	call   1040a8 <k_is_in_isr>
  1032f2:	85 c0                	test   %eax,%eax
  1032f4:	74 15                	je     10330b <_SysFatalErrorHandler+0x21>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
  1032f6:	e8 ad 0d 00 00       	call   1040a8 <k_is_in_isr>
{
	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

	if (k_is_in_isr() || _is_thread_essential()) {
		printk("Fatal fault in %s! Spinning...\n",
  1032fb:	ba 60 63 10 00       	mov    $0x106360,%edx
  103300:	85 c0                	test   %eax,%eax
  103302:	75 2e                	jne    103332 <_SysFatalErrorHandler+0x48>
  103304:	ba 64 63 10 00       	mov    $0x106364,%edx
  103309:	eb 27                	jmp    103332 <_SysFatalErrorHandler+0x48>
					 const NANO_ESF *pEsf)
{
	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

	if (k_is_in_isr() || _is_thread_essential()) {
  10330b:	e8 a9 0d 00 00       	call   1040b9 <_is_thread_essential>
  103310:	85 c0                	test   %eax,%eax
  103312:	75 e2                	jne    1032f6 <_SysFatalErrorHandler+0xc>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
		for (;;)
			; /* spin forever */
	}
	printk("Fatal fault in thread %p! Aborting.\n", _current);
  103314:	ff 35 88 7d 10 00    	pushl  0x107d88
  10331a:	68 95 63 10 00       	push   $0x106395
  10331f:	e8 a4 fa ff ff       	call   102dc8 <printk>
  103324:	58                   	pop    %eax
  103325:	5a                   	pop    %edx
	k_thread_abort(_current);
  103326:	ff 35 88 7d 10 00    	pushl  0x107d88
  10332c:	e8 aa 0f 00 00       	call   1042db <k_thread_abort>
  103331:	59                   	pop    %ecx
{
	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

	if (k_is_in_isr() || _is_thread_essential()) {
		printk("Fatal fault in %s! Spinning...\n",
  103332:	52                   	push   %edx
  103333:	68 75 63 10 00       	push   $0x106375
  103338:	e8 8b fa ff ff       	call   102dc8 <printk>
  10333d:	58                   	pop    %eax
  10333e:	5a                   	pop    %edx
  10333f:	eb fe                	jmp    10333f <_SysFatalErrorHandler+0x55>

00103341 <_cache_line_size_get>:
	#define CPUID_CACHE_LINE_MASK (0xff << 8)

	GTEXT(_cache_line_size_get)

SECTION_FUNC(TEXT, _cache_line_size_get)
	pushl %ebx
  103341:	53                   	push   %ebx
	movl $1, %eax
  103342:	b8 01 00 00 00       	mov    $0x1,%eax
	cpuid
  103347:	0f a2                	cpuid  
	movl %ebx, %eax
  103349:	89 d8                	mov    %ebx,%eax
	andl $CPUID_CACHE_LINE_MASK, %eax
  10334b:	25 00 ff 00 00       	and    $0xff00,%eax
	shrl $5,%eax	/* shift right 8 to get value, then multiple by 8
  103350:	c1 e8 05             	shr    $0x5,%eax
					 * to get cache line size */
	popl %ebx
  103353:	5b                   	pop    %ebx
	ret
  103354:	c3                   	ret    

00103355 <init_cache>:
#else
#define init_cache_line_size() do { } while ((0))
#endif

static int init_cache(struct device *unused)
{
  103355:	55                   	push   %ebp
  103356:	89 e5                	mov    %esp,%ebp

#if defined(CONFIG_CACHE_LINE_SIZE_DETECT)
size_t sys_cache_line_size;
static void init_cache_line_size(void)
{
	sys_cache_line_size = _cache_line_size_get();
  103358:	e8 e4 ff ff ff       	call   103341 <_cache_line_size_get>

	init_cache_flush();
	init_cache_line_size();

	return 0;
}
  10335d:	5d                   	pop    %ebp

#if defined(CONFIG_CACHE_LINE_SIZE_DETECT)
size_t sys_cache_line_size;
static void init_cache_line_size(void)
{
	sys_cache_line_size = _cache_line_size_get();
  10335e:	a3 04 7f 10 00       	mov    %eax,0x107f04

	init_cache_flush();
	init_cache_line_size();

	return 0;
}
  103363:	31 c0                	xor    %eax,%eax
  103365:	c3                   	ret    

00103366 <_exception_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * exception exits.
	 */

	cld
  103366:	fc                   	cld    


	/*
	 * Swap ecx and handler function on the current stack;
	 */
	xchgl	%ecx, (%esp)
  103367:	87 0c 24             	xchg   %ecx,(%esp)

	/*
	 * Push the remaining volatile registers on the existing stack.
	 */

	pushl	%eax
  10336a:	50                   	push   %eax
	pushl	%edx
  10336b:	52                   	push   %edx
	/*
	 * Push the cooperative registers on the existing stack as they are
	 * required by debug tools.
	 */

	pushl	%edi
  10336c:	57                   	push   %edi
	pushl	%esi
  10336d:	56                   	push   %esi
	pushl	%ebx
  10336e:	53                   	push   %ebx
	pushl	%ebp
  10336f:	55                   	push   %ebp

	leal	44(%esp), %eax   /* Calculate ESP before interrupt occurred */
  103370:	8d 44 24 2c          	lea    0x2c(%esp),%eax
	pushl	%eax             /* Save calculated ESP */
  103374:	50                   	push   %eax
	 * Test IF bit of saved EFLAGS and re-enable interrupts if IF=1.
	 */

	/* ESP is still pointing to the ESF at this point */

	testl	$0x200, __NANO_ESF_eflags_OFFSET(%esp)
  103375:	f7 44 24 2c 00 02 00 	testl  $0x200,0x2c(%esp)
  10337c:	00 
	je	allDone
  10337d:	74 01                	je     103380 <allDone>
	sti
  10337f:	fb                   	sti    

00103380 <allDone>:

allDone:
#if CONFIG_X86_IAMCU
	movl	%esp, %eax		/* NANO_ESF * parameter */
#else
	pushl	%esp			/* push NANO_ESF * parameter */
  103380:	54                   	push   %esp
#endif
	call	*%ecx			/* call exception handler */
  103381:	ff d1                	call   *%ecx

#ifndef CONFIG_X86_IAMCU
	addl	$0x4, %esp
  103383:	83 c4 04             	add    $0x4,%esp
	 * Pop the non-volatile registers from the stack.
	 * Note that debug tools may have altered the saved register values while
	 * the task was stopped, and we want to pick up the altered values.
	 */

	popl	%ebp		/* Discard saved ESP */
  103386:	5d                   	pop    %ebp
	popl	%ebp
  103387:	5d                   	pop    %ebp
	popl	%ebx
  103388:	5b                   	pop    %ebx
	popl	%esi
  103389:	5e                   	pop    %esi
	popl	%edi
  10338a:	5f                   	pop    %edi

	/* restore edx and ecx which are always saved on the stack */

	popl	%edx
  10338b:	5a                   	pop    %edx
	popl	%eax
  10338c:	58                   	pop    %eax
	popl	%ecx
  10338d:	59                   	pop    %ecx

	addl	$4, %esp	/* "pop" error code */
  10338e:	83 c4 04             	add    $0x4,%esp

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  103391:	cf                   	iret   

00103392 <_interrupt_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * interrupt exits via the IRET instruction.
	 */

	cld
  103392:	fc                   	cld    

	/*
	 * Swap EAX with isr_param and EDX with isr.
	 * Push ECX onto the stack
	 */
	xchgl	%eax, 4(%esp)
  103393:	87 44 24 04          	xchg   %eax,0x4(%esp)
	xchgl	%edx, (%esp)
  103397:	87 14 24             	xchg   %edx,(%esp)
	pushl	%ecx
  10339a:	51                   	push   %ecx

	/* Push EDI as we will use it for scratch space.
	 * Rest of the callee-saved regs get saved by invocation of C
	 * functions (isr handler, _Swap(), etc)
	 */
	pushl	%edi
  10339b:	57                   	push   %edi
	popl	%eax
#endif

	/* load %ecx with &_kernel */

	movl	$_kernel, %ecx
  10339c:	b9 80 7d 10 00       	mov    $0x107d80,%ecx

	/* switch to the interrupt stack for the non-nested case */

	incl	_kernel_offset_to_nested(%ecx)
  1033a1:	ff 01                	incl   (%ecx)

	/* use interrupt stack if not nested */
	cmpl	$1, _kernel_offset_to_nested(%ecx)
  1033a3:	83 39 01             	cmpl   $0x1,(%ecx)
#ifdef CONFIG_DEBUG_INFO
	jne	nested_save_isf
#else
	jne	alreadyOnIntStack
  1033a6:	75 06                	jne    1033ae <alreadyOnIntStack>
	/*
	 * switch to base of the interrupt stack: save esp in edi, then load
	 * irq_stack pointer
	 */

	movl	%esp, %edi
  1033a8:	89 e7                	mov    %esp,%edi
	movl	_kernel_offset_to_irq_stack(%ecx), %esp
  1033aa:	8b 61 04             	mov    0x4(%ecx),%esp


	/* save thread's stack pointer onto base of interrupt stack */

	pushl	%edi			/* Save stack pointer */
  1033ad:	57                   	push   %edi

001033ae <alreadyOnIntStack>:

#ifndef CONFIG_X86_IAMCU
	/* EAX has the interrupt handler argument, needs to go on
	 * stack for sys V calling convention
	 */
	push	%eax
  1033ae:	50                   	push   %eax
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	sti			/* re-enable interrupts */
  1033af:	fb                   	sti    
#endif
	/* Now call the interrupt handler */
	call	*%edx
  1033b0:	ff d2                	call   *%edx
#ifndef CONFIG_X86_IAMCU
	/* Discard ISR argument */
	addl	$0x4, %esp
  1033b2:	83 c4 04             	add    $0x4,%esp
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	cli			/* disable interrupts again */
  1033b5:	fa                   	cli    
#endif

	/* irq_controller.h interface */
	_irq_controller_eoi
  1033b6:	31 c0                	xor    %eax,%eax
  1033b8:	a3 b0 00 e0 fe       	mov    %eax,0xfee000b0
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_start
#endif

	/* determine whether exiting from a nested interrupt */
	movl	$_kernel, %ecx
  1033bd:	b9 80 7d 10 00       	mov    $0x107d80,%ecx
#ifdef CONFIG_DEBUG_INFO
	popl	_kernel_offset_to_isf(%ecx)    /* Restore old ISF */
#endif
	decl	_kernel_offset_to_nested(%ecx)	/* dec interrupt nest count */
  1033c2:	ff 09                	decl   (%ecx)
	jne	nestedInterrupt                 /* 'iret' if nested case */
  1033c4:	75 28                	jne    1033ee <nestedInterrupt>


	movl	_kernel_offset_to_current(%ecx), %edx
  1033c6:	8b 51 08             	mov    0x8(%ecx),%edx
	 * switch.  If the thread is preemptible, scheduler is not locked and
	 * a higher priority thread exists, a _Swap() needs to occur.
	 */

	/* do not reschedule coop threads (negative priority) */
	cmpl	$0, _thread_offset_to_prio(%edx)
  1033c9:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
	jl	noReschedule
  1033cd:	7c 1e                	jl     1033ed <noReschedule>

	/* do not reschedule if scheduler is locked */
	cmpl	$0, _thread_offset_to_sched_locked(%edx)
  1033cf:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
	jg	noReschedule
  1033d3:	7f 18                	jg     1033ed <noReschedule>


	/* reschedule only if the scheduler says that we must do so */
	call	_is_next_thread_current
  1033d5:	e8 8d 07 00 00       	call   103b67 <_is_next_thread_current>
	testl   %eax, %eax
  1033da:	85 c0                	test   %eax,%eax
	jnz     noReschedule
  1033dc:	75 0f                	jne    1033ed <noReschedule>
	 * the existing _Swap() primitive to save the remaining
	 * thread's registers (including floating point) and perform
	 * a switch to the new thread.
	 */

	popl	%esp	/* switch back to outgoing thread's stack */
  1033de:	5c                   	pop    %esp
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif

	pushfl			/* push KERNEL_LOCK_KEY argument */
  1033df:	9c                   	pushf  
#ifdef CONFIG_X86_IAMCU
	/* IAMCU first argument goes into a register, not the stack.
	 */
	popl	%eax
#endif
	call	_Swap
  1033e0:	e8 26 00 00 00       	call   10340b <_Swap>

#ifndef CONFIG_X86_IAMCU
	addl 	$4, %esp	/* pop KERNEL_LOCK_KEY argument */
  1033e5:	83 c4 04             	add    $0x4,%esp

	/* Restore volatile registers and return to the interrupted thread */
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_stop
#endif
	popl	%edi
  1033e8:	5f                   	pop    %edi
	popl	%ecx
  1033e9:	59                   	pop    %ecx
	popl	%edx
  1033ea:	5a                   	pop    %edx
	popl	%eax
  1033eb:	58                   	pop    %eax

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  1033ec:	cf                   	iret   

001033ed <noReschedule>:
	/*
	 * A thread reschedule is not required; switch back to the
	 * interrupted thread's stack and restore volatile registers
	 */

	popl	%esp		/* pop thread stack pointer */
  1033ed:	5c                   	pop    %esp

001033ee <nestedInterrupt>:
	popl	%ebp        /* Discard saved ESP */
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif
	popl	%edi
  1033ee:	5f                   	pop    %edi
	popl	%ecx		/* pop volatile registers in reverse order */
  1033ef:	59                   	pop    %ecx
	popl	%edx
  1033f0:	5a                   	pop    %edx
	popl	%eax
  1033f1:	58                   	pop    %eax
	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  1033f2:	cf                   	iret   

001033f3 <_SpuriousIntNoErrCodeHandler>:
 * thus _SpuriousIntNoErrCodeHandler()/_SpuriousIntHandler() shall be
 * invoked with interrupts disabled.
 */
SECTION_FUNC(TEXT, _SpuriousIntNoErrCodeHandler)

	pushl	$0			/* push dummy err code onto stk */
  1033f3:	6a 00                	push   $0x0

001033f5 <_SpuriousIntHandler>:
	/* fall through to _SpuriousIntHandler */


SECTION_FUNC(TEXT, _SpuriousIntHandler)

	cld				/* Clear direction flag */
  1033f5:	fc                   	cld    

	/* Create the ESF */

	pushl %eax
  1033f6:	50                   	push   %eax
	pushl %ecx
  1033f7:	51                   	push   %ecx
	pushl %edx
  1033f8:	52                   	push   %edx
	pushl %edi
  1033f9:	57                   	push   %edi
	pushl %esi
  1033fa:	56                   	push   %esi
	pushl %ebx
  1033fb:	53                   	push   %ebx
	pushl %ebp
  1033fc:	55                   	push   %ebp

	leal	44(%esp), %ecx   /* Calculate ESP before exception occurred */
  1033fd:	8d 4c 24 2c          	lea    0x2c(%esp),%ecx
	pushl	%ecx             /* Save calculated ESP */
  103401:	51                   	push   %ecx

#ifndef CONFIG_X86_IAMCU
	pushl	%esp			/* push cur stack pointer: pEsf arg */
  103402:	54                   	push   %esp
#else
	mov	%esp, %edx
#endif

	/* re-enable interrupts */
	sti
  103403:	fb                   	sti    

	/* push the 'unsigned int reason' parameter */
#ifndef CONFIG_X86_IAMCU
	pushl	$_NANO_ERR_SPURIOUS_INT
  103404:	6a 00                	push   $0x0
#else
	movl	$_NANO_ERR_SPURIOUS_INT, %eax
#endif
	/* call the fatal error handler */
	call	_NanoFatalErrorHandler
  103406:	e8 99 00 00 00       	call   1034a4 <_NanoFatalErrorHandler>

0010340b <_Swap>:
	 * any of these registers into the k_thread.  Only the 'esp' register
	 * after all the pushes have been performed) will be stored in the
	 * k_thread.
	 */

	pushl	%edi
  10340b:	57                   	push   %edi

	movl	$_kernel, %edi
  10340c:	bf 80 7d 10 00       	mov    $0x107d80,%edi

	pushl	%esi
  103411:	56                   	push   %esi
	pushl	%ebx
  103412:	53                   	push   %ebx
	pushl	%ebp
  103413:	55                   	push   %ebp
	 * -EAGAIN eliminates the need for the timeout code to set it.
	 * If another value is ever needed, it can be modified with
	 * fiberRtnValueSet().
	 */

	pushl   _k_neg_eagain
  103414:	ff 35 a4 65 10 00    	pushl  0x1065a4


	/* save esp into k_thread structure */

	movl	_kernel_offset_to_current(%edi), %ecx
  10341a:	8b 4f 08             	mov    0x8(%edi),%ecx
	movl	%esp, _thread_offset_to_esp(%ecx)
  10341d:	89 61 30             	mov    %esp,0x30(%ecx)

#ifdef CONFIG_KERNEL_EVENT_LOGGER_CONTEXT_SWITCH
	/* Register the context switch */
	call	_sys_k_event_logger_context_switch
#endif
	call	_get_next_ready_thread
  103420:	e8 bf 06 00 00       	call   103ae4 <_get_next_ready_thread>

#endif /* CONFIG_FP_SHARING */

	/* update _kernel.current to reflect incoming thread */

	movl    %eax, _kernel_offset_to_current(%edi)
  103425:	89 47 08             	mov    %eax,0x8(%edi)

	/* recover task/fiber stack pointer from k_thread */

	movl	_thread_offset_to_esp(%eax), %esp
  103428:	8b 60 30             	mov    0x30(%eax),%esp


	/* load return value from a possible fiberRtnValueSet() */

	popl	%eax
  10342b:	58                   	pop    %eax

	/* pop the non-volatile registers from the stack */

	popl	%ebp
  10342c:	5d                   	pop    %ebp
	popl	%ebx
  10342d:	5b                   	pop    %ebx
	popl	%esi
  10342e:	5e                   	pop    %esi
	popl	%edi
  10342f:	5f                   	pop    %edi
	 * - in unified kernel, -EINVAL
	 */

	/* Utilize the 'eflags' parameter to _Swap() */

	pushl	4(%esp)
  103430:	ff 74 24 04          	pushl  0x4(%esp)
	/* restore _Swap's %eax */
	popl	%eax

skipIntLatencyStop:
#endif
	popfl
  103434:	9d                   	popf   
	 * will not do that for us.
	 */
	popl	%edx
	movl	%edx, (%esp)
#endif
	ret
  103435:	c3                   	ret    

00103436 <_new_thread>:
 */
void _new_thread(char *pStackMem, size_t stackSize,
		 _thread_entry_t pEntry,
		 void *parameter1, void *parameter2, void *parameter3,
		 int priority, unsigned options)
{
  103436:	55                   	push   %ebp
  103437:	89 e5                	mov    %esp,%ebp
  103439:	56                   	push   %esi
  10343a:	53                   	push   %ebx
  10343b:	8b 75 08             	mov    0x8(%ebp),%esi
	memset(pStackMem, 0xaa, stackSize);
#endif

	/* carve the thread entry struct from the "base" of the stack */

	pInitialThread =
  10343e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  103441:	01 f3                	add    %esi,%ebx
	 * setup for both threads are equivalent.
	 */

	/* push arguments required by _thread_entry() */

	*--pInitialThread = (unsigned long)parameter3;
  103443:	8b 45 1c             	mov    0x1c(%ebp),%eax
	memset(pStackMem, 0xaa, stackSize);
#endif

	/* carve the thread entry struct from the "base" of the stack */

	pInitialThread =
  103446:	83 e3 fc             	and    $0xfffffffc,%ebx
	 * setup for both threads are equivalent.
	 */

	/* push arguments required by _thread_entry() */

	*--pInitialThread = (unsigned long)parameter3;
  103449:	89 43 fc             	mov    %eax,-0x4(%ebx)
	*--pInitialThread = (unsigned long)parameter2;
  10344c:	8b 45 18             	mov    0x18(%ebp),%eax
  10344f:	89 43 f8             	mov    %eax,-0x8(%ebx)
	*--pInitialThread = (unsigned long)parameter1;
  103452:	8b 45 14             	mov    0x14(%ebp),%eax
  103455:	89 43 f4             	mov    %eax,-0xc(%ebx)
	*--pInitialThread = (unsigned long)pEntry;
  103458:	8b 45 10             	mov    0x10(%ebp),%eax
  10345b:	89 43 f0             	mov    %eax,-0x10(%ebx)
 */
static inline unsigned int EflagsGet(void)
{
	unsigned int eflags; /* EFLAGS register contents */

	__asm__ volatile(
  10345e:	9c                   	pushf  
  10345f:	58                   	pop    %eax

	/* push initial EFLAGS; only modify IF and IOPL bits */

	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
  103460:	80 e4 cd             	and    $0xcd,%ah

	*--pInitialThread = (unsigned long)_thread_entry_wrapper;

#else /* defined(CONFIG_GDB_INFO) || defined(CONFIG_DEBUG_INFO) */

	*--pInitialThread = (unsigned long)_thread_entry;
  103463:	c7 43 e8 cb 40 10 00 	movl   $0x1040cb,-0x18(%ebx)
	*--pInitialThread = (unsigned long)parameter1;
	*--pInitialThread = (unsigned long)pEntry;

	/* push initial EFLAGS; only modify IF and IOPL bits */

	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
  10346a:	80 cc 02             	or     $0x2,%ah
	 *  - eip (so that _Swap() "returns" to the entry point)
	 *  - edi, esi, ebx, ebp,  eax
	 */
	pInitialCtx -= 11;

	thread->callee_saved.esp = (unsigned long)pInitialCtx;
  10346d:	83 eb 2c             	sub    $0x2c,%ebx
	*--pInitialThread = (unsigned long)parameter1;
	*--pInitialThread = (unsigned long)pEntry;

	/* push initial EFLAGS; only modify IF and IOPL bits */

	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
  103470:	89 43 18             	mov    %eax,0x18(%ebx)

#if (defined(CONFIG_FP_SHARING) || defined(CONFIG_GDB_INFO))
	thread->arch.excNestCount = 0;
#endif /* CONFIG_FP_SHARING || CONFIG_GDB_INFO */

	_init_thread_base(&thread->base, priority, K_PRESTART, options);
  103473:	ff 75 24             	pushl  0x24(%ebp)
  103476:	68 00 40 00 00       	push   $0x4000
  10347b:	ff 75 20             	pushl  0x20(%ebp)
  10347e:	56                   	push   %esi
  10347f:	e8 1d 0e 00 00       	call   1042a1 <_init_thread_base>

	/* static threads overwrite it afterwards with real value */
	thread->init_data = NULL;
  103484:	c7 46 34 00 00 00 00 	movl   $0x0,0x34(%esi)
	thread->fn_abort = NULL;
  10348b:	c7 46 38 00 00 00 00 	movl   $0x0,0x38(%esi)
	 *  - eip (so that _Swap() "returns" to the entry point)
	 *  - edi, esi, ebx, ebp,  eax
	 */
	pInitialCtx -= 11;

	thread->callee_saved.esp = (unsigned long)pInitialCtx;
  103492:	89 5e 30             	mov    %ebx,0x30(%esi)

#if (defined(CONFIG_FP_SHARING) || defined(CONFIG_GDB_INFO))
	thread->arch.excNestCount = 0;
#endif /* CONFIG_FP_SHARING || CONFIG_GDB_INFO */

	_init_thread_base(&thread->base, priority, K_PRESTART, options);
  103495:	83 c4 10             	add    $0x10,%esp
	 * The k_thread structure is located at the "low end" of memory set
	 * aside for the thread's stack.
	 */

	_new_thread_internal(pStackMem, stackSize, priority, options);
}
  103498:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10349b:	5b                   	pop    %ebx
  10349c:	5e                   	pop    %esi
  10349d:	5d                   	pop    %ebp
  10349e:	c3                   	ret    

0010349f <_debug_fatal_hook>:
#include <misc/printk.h>
#include <arch/x86/irq_controller.h>
#include <arch/x86/segmentation.h>
#include <exception.h>

__weak void _debug_fatal_hook(const NANO_ESF *esf) { ARG_UNUSED(esf); }
  10349f:	55                   	push   %ebp
  1034a0:	89 e5                	mov    %esp,%ebp
  1034a2:	5d                   	pop    %ebp
  1034a3:	c3                   	ret    

001034a4 <_NanoFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _NanoFatalErrorHandler(unsigned int reason,
					  const NANO_ESF *pEsf)
{
  1034a4:	55                   	push   %ebp
  1034a5:	89 e5                	mov    %esp,%ebp
  1034a7:	57                   	push   %edi
  1034a8:	56                   	push   %esi
  1034a9:	53                   	push   %ebx
  1034aa:	83 ec 28             	sub    $0x28,%esp
  1034ad:	8b 75 08             	mov    0x8(%ebp),%esi
  1034b0:	8b 7d 0c             	mov    0xc(%ebp),%edi
	_debug_fatal_hook(pEsf);
  1034b3:	57                   	push   %edi
  1034b4:	e8 e6 ff ff ff       	call   10349f <_debug_fatal_hook>
  1034b9:	58                   	pop    %eax

#ifdef CONFIG_PRINTK

	/* Display diagnostic information about the error */

	switch (reason) {
  1034ba:	83 fe 03             	cmp    $0x3,%esi
  1034bd:	74 3e                	je     1034fd <_NanoFatalErrorHandler+0x59>
  1034bf:	77 06                	ja     1034c7 <_NanoFatalErrorHandler+0x23>
  1034c1:	85 f6                	test   %esi,%esi
  1034c3:	74 0e                	je     1034d3 <_NanoFatalErrorHandler+0x2f>
  1034c5:	eb 4a                	jmp    103511 <_NanoFatalErrorHandler+0x6d>
  1034c7:	83 fe 05             	cmp    $0x5,%esi
  1034ca:	74 3e                	je     10350a <_NanoFatalErrorHandler+0x66>
  1034cc:	83 fe 06             	cmp    $0x6,%esi
  1034cf:	74 4d                	je     10351e <_NanoFatalErrorHandler+0x7a>
  1034d1:	eb 3e                	jmp    103511 <_NanoFatalErrorHandler+0x6d>
 * @return the vector of the interrupt that is currently being processed, or
 * -1 if this can't be determined
 */
static inline int _irq_controller_isr_vector_get(void)
{
	return __irq_controller_isr_vector_get();
  1034d3:	e8 17 d3 ff ff       	call   1007ef <__irq_controller_isr_vector_get>
		break;

	case _NANO_ERR_SPURIOUS_INT: {
		int vector = _irq_controller_isr_vector_get();

		printk("***** Unhandled interrupt vector ");
  1034d8:	68 ba 63 10 00       	push   $0x1063ba
  1034dd:	89 c3                	mov    %eax,%ebx
  1034df:	e8 e4 f8 ff ff       	call   102dc8 <printk>
  1034e4:	58                   	pop    %eax
		if (vector >= 0) {
  1034e5:	85 db                	test   %ebx,%ebx
  1034e7:	78 0d                	js     1034f6 <_NanoFatalErrorHandler+0x52>
			printk("%d ", vector);
  1034e9:	53                   	push   %ebx
  1034ea:	68 dc 63 10 00       	push   $0x1063dc
  1034ef:	e8 d4 f8 ff ff       	call   102dc8 <printk>
  1034f4:	5b                   	pop    %ebx
  1034f5:	58                   	pop    %eax
		}
		printk("*****\n");
  1034f6:	68 03 64 10 00       	push   $0x106403
  1034fb:	eb 05                	jmp    103502 <_NanoFatalErrorHandler+0x5e>
		break;
	}
	case _NANO_ERR_INVALID_TASK_EXIT:
		printk("***** Invalid Exit Software Error! *****\n");
  1034fd:	68 e0 63 10 00       	push   $0x1063e0
  103502:	e8 c1 f8 ff ff       	call   102dc8 <printk>
  103507:	59                   	pop    %ecx
		break;
  103508:	eb 14                	jmp    10351e <_NanoFatalErrorHandler+0x7a>
		break;
#endif /* CONFIG_STACK_CANARIES */


	case _NANO_ERR_ALLOCATION_FAIL:
		printk("**** Kernel Allocation Failure! ****\n");
  10350a:	68 0a 64 10 00       	push   $0x10640a
  10350f:	eb f1                	jmp    103502 <_NanoFatalErrorHandler+0x5e>
		break;

	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
  103511:	56                   	push   %esi
  103512:	68 30 64 10 00       	push   $0x106430
  103517:	e8 ac f8 ff ff       	call   102dc8 <printk>
  10351c:	58                   	pop    %eax
  10351d:	5a                   	pop    %edx
		break;
	}

	printk("Current thread ID = %p\n"
  10351e:	8b 47 04             	mov    0x4(%edi),%eax
  103521:	8b 4f 2c             	mov    0x2c(%edi),%ecx
  103524:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103527:	8b 47 10             	mov    0x10(%edi),%eax
  10352a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10352d:	8b 47 0c             	mov    0xc(%edi),%eax
  103530:	89 45 e8             	mov    %eax,-0x18(%ebp)
  103533:	8b 47 14             	mov    0x14(%edi),%eax
  103536:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  103539:	8b 47 1c             	mov    0x1c(%edi),%eax
  10353c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10353f:	8b 47 08             	mov    0x8(%edi),%eax
  103542:	89 45 dc             	mov    %eax,-0x24(%ebp)
  103545:	8b 47 18             	mov    0x18(%edi),%eax
  103548:	8b 17                	mov    (%edi),%edx
  10354a:	89 45 d8             	mov    %eax,-0x28(%ebp)
  10354d:	8b 47 24             	mov    0x24(%edi),%eax
  103550:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  103553:	89 55 d0             	mov    %edx,-0x30(%ebp)
  103556:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  103559:	0f b7 5f 28          	movzwl 0x28(%edi),%ebx
  10355d:	e8 73 06 00 00       	call   103bd5 <k_current_get>
  103562:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  103565:	8b 55 d0             	mov    -0x30(%ebp),%edx
  103568:	51                   	push   %ecx
  103569:	52                   	push   %edx
  10356a:	ff 75 f0             	pushl  -0x10(%ebp)
  10356d:	ff 75 ec             	pushl  -0x14(%ebp)
  103570:	ff 75 e8             	pushl  -0x18(%ebp)
  103573:	ff 75 e4             	pushl  -0x1c(%ebp)
  103576:	ff 75 e0             	pushl  -0x20(%ebp)
  103579:	ff 75 dc             	pushl  -0x24(%ebp)
  10357c:	ff 75 d8             	pushl  -0x28(%ebp)
  10357f:	ff 75 d4             	pushl  -0x2c(%ebp)
  103582:	53                   	push   %ebx
  103583:	50                   	push   %eax
  103584:	68 53 64 10 00       	push   $0x106453
  103589:	e8 3a f8 ff ff       	call   102dc8 <printk>
  10358e:	83 c4 34             	add    $0x34,%esp
	/*
	 * Error was fatal to a kernel task or a fiber; invoke the system
	 * fatal error handling policy defined for the platform.
	 */

	_SysFatalErrorHandler(reason, pEsf);
  103591:	57                   	push   %edi
  103592:	56                   	push   %esi
  103593:	e8 52 fd ff ff       	call   1032ea <_SysFatalErrorHandler>

00103598 <generic_exc_handle>:

#if CONFIG_EXCEPTION_DEBUG

static FUNC_NORETURN void generic_exc_handle(unsigned int vector,
					     const NANO_ESF *pEsf)
{
  103598:	55                   	push   %ebp
  103599:	89 e5                	mov    %esp,%ebp
  10359b:	56                   	push   %esi
  10359c:	89 c6                	mov    %eax,%esi
  10359e:	53                   	push   %ebx
  10359f:	89 d3                	mov    %edx,%ebx
	printk("***** CPU exception %d\n", vector);
  1035a1:	50                   	push   %eax
  1035a2:	68 f2 64 10 00       	push   $0x1064f2
  1035a7:	e8 1c f8 ff ff       	call   102dc8 <printk>
  1035ac:	59                   	pop    %ecx
  1035ad:	58                   	pop    %eax
	if ((1 << vector) & _EXC_ERROR_CODE_FAULTS) {
  1035ae:	b8 00 7d 02 00       	mov    $0x27d00,%eax
  1035b3:	0f a3 f0             	bt     %esi,%eax
  1035b6:	73 0f                	jae    1035c7 <generic_exc_handle+0x2f>
		printk("***** Exception code: 0x%x\n", pEsf->errorCode);
  1035b8:	ff 73 20             	pushl  0x20(%ebx)
  1035bb:	68 0a 65 10 00       	push   $0x10650a
  1035c0:	e8 03 f8 ff ff       	call   102dc8 <printk>
  1035c5:	58                   	pop    %eax
  1035c6:	5a                   	pop    %edx
	}
	_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, pEsf);
  1035c7:	53                   	push   %ebx
  1035c8:	6a 06                	push   $0x6
  1035ca:	e8 d5 fe ff ff       	call   1034a4 <_NanoFatalErrorHandler>

001035cf <handle_exc_0>:
	_EXC_FUNC_NOCODE(vector)

#define EXC_FUNC_CODE(vector) \
	_EXC_FUNC_CODE(vector)

EXC_FUNC_NOCODE(IV_DIVIDE_ERROR);
  1035cf:	55                   	push   %ebp
  1035d0:	31 c0                	xor    %eax,%eax
  1035d2:	89 e5                	mov    %esp,%ebp
  1035d4:	8b 55 08             	mov    0x8(%ebp),%edx
  1035d7:	e8 bc ff ff ff       	call   103598 <generic_exc_handle>

001035dc <handle_exc_2>:
EXC_FUNC_NOCODE(IV_NON_MASKABLE_INTERRUPT);
  1035dc:	55                   	push   %ebp
  1035dd:	b8 02 00 00 00       	mov    $0x2,%eax
  1035e2:	89 e5                	mov    %esp,%ebp
  1035e4:	8b 55 08             	mov    0x8(%ebp),%edx
  1035e7:	e8 ac ff ff ff       	call   103598 <generic_exc_handle>

001035ec <handle_exc_4>:
EXC_FUNC_NOCODE(IV_OVERFLOW);
  1035ec:	55                   	push   %ebp
  1035ed:	b8 04 00 00 00       	mov    $0x4,%eax
  1035f2:	89 e5                	mov    %esp,%ebp
  1035f4:	8b 55 08             	mov    0x8(%ebp),%edx
  1035f7:	e8 9c ff ff ff       	call   103598 <generic_exc_handle>

001035fc <handle_exc_5>:
EXC_FUNC_NOCODE(IV_BOUND_RANGE);
  1035fc:	55                   	push   %ebp
  1035fd:	b8 05 00 00 00       	mov    $0x5,%eax
  103602:	89 e5                	mov    %esp,%ebp
  103604:	8b 55 08             	mov    0x8(%ebp),%edx
  103607:	e8 8c ff ff ff       	call   103598 <generic_exc_handle>

0010360c <handle_exc_6>:
EXC_FUNC_NOCODE(IV_INVALID_OPCODE);
  10360c:	55                   	push   %ebp
  10360d:	b8 06 00 00 00       	mov    $0x6,%eax
  103612:	89 e5                	mov    %esp,%ebp
  103614:	8b 55 08             	mov    0x8(%ebp),%edx
  103617:	e8 7c ff ff ff       	call   103598 <generic_exc_handle>

0010361c <handle_exc_7>:
EXC_FUNC_NOCODE(IV_DEVICE_NOT_AVAILABLE);
  10361c:	55                   	push   %ebp
  10361d:	b8 07 00 00 00       	mov    $0x7,%eax
  103622:	89 e5                	mov    %esp,%ebp
  103624:	8b 55 08             	mov    0x8(%ebp),%edx
  103627:	e8 6c ff ff ff       	call   103598 <generic_exc_handle>

0010362c <handle_exc_8>:
EXC_FUNC_CODE(IV_DOUBLE_FAULT);
  10362c:	55                   	push   %ebp
  10362d:	b8 08 00 00 00       	mov    $0x8,%eax
  103632:	89 e5                	mov    %esp,%ebp
  103634:	8b 55 08             	mov    0x8(%ebp),%edx
  103637:	e8 5c ff ff ff       	call   103598 <generic_exc_handle>

0010363c <handle_exc_10>:
EXC_FUNC_CODE(IV_INVALID_TSS);
  10363c:	55                   	push   %ebp
  10363d:	b8 0a 00 00 00       	mov    $0xa,%eax
  103642:	89 e5                	mov    %esp,%ebp
  103644:	8b 55 08             	mov    0x8(%ebp),%edx
  103647:	e8 4c ff ff ff       	call   103598 <generic_exc_handle>

0010364c <handle_exc_11>:
EXC_FUNC_CODE(IV_SEGMENT_NOT_PRESENT);
  10364c:	55                   	push   %ebp
  10364d:	b8 0b 00 00 00       	mov    $0xb,%eax
  103652:	89 e5                	mov    %esp,%ebp
  103654:	8b 55 08             	mov    0x8(%ebp),%edx
  103657:	e8 3c ff ff ff       	call   103598 <generic_exc_handle>

0010365c <handle_exc_12>:
EXC_FUNC_CODE(IV_STACK_FAULT);
  10365c:	55                   	push   %ebp
  10365d:	b8 0c 00 00 00       	mov    $0xc,%eax
  103662:	89 e5                	mov    %esp,%ebp
  103664:	8b 55 08             	mov    0x8(%ebp),%edx
  103667:	e8 2c ff ff ff       	call   103598 <generic_exc_handle>

0010366c <handle_exc_13>:
EXC_FUNC_CODE(IV_GENERAL_PROTECTION);
  10366c:	55                   	push   %ebp
  10366d:	b8 0d 00 00 00       	mov    $0xd,%eax
  103672:	89 e5                	mov    %esp,%ebp
  103674:	8b 55 08             	mov    0x8(%ebp),%edx
  103677:	e8 1c ff ff ff       	call   103598 <generic_exc_handle>

0010367c <handle_exc_14>:
EXC_FUNC_CODE(IV_PAGE_FAULT);
  10367c:	55                   	push   %ebp
  10367d:	b8 0e 00 00 00       	mov    $0xe,%eax
  103682:	89 e5                	mov    %esp,%ebp
  103684:	8b 55 08             	mov    0x8(%ebp),%edx
  103687:	e8 0c ff ff ff       	call   103598 <generic_exc_handle>

0010368c <handle_exc_16>:
EXC_FUNC_NOCODE(IV_X87_FPU_FP_ERROR);
  10368c:	55                   	push   %ebp
  10368d:	b8 10 00 00 00       	mov    $0x10,%eax
  103692:	89 e5                	mov    %esp,%ebp
  103694:	8b 55 08             	mov    0x8(%ebp),%edx
  103697:	e8 fc fe ff ff       	call   103598 <generic_exc_handle>

0010369c <handle_exc_17>:
EXC_FUNC_CODE(IV_ALIGNMENT_CHECK);
  10369c:	55                   	push   %ebp
  10369d:	b8 11 00 00 00       	mov    $0x11,%eax
  1036a2:	89 e5                	mov    %esp,%ebp
  1036a4:	8b 55 08             	mov    0x8(%ebp),%edx
  1036a7:	e8 ec fe ff ff       	call   103598 <generic_exc_handle>

001036ac <handle_exc_18>:
EXC_FUNC_NOCODE(IV_MACHINE_CHECK);
  1036ac:	55                   	push   %ebp
  1036ad:	b8 12 00 00 00       	mov    $0x12,%eax
  1036b2:	89 e5                	mov    %esp,%ebp
  1036b4:	8b 55 08             	mov    0x8(%ebp),%edx
  1036b7:	e8 dc fe ff ff       	call   103598 <generic_exc_handle>

001036bc <_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void _sys_device_do_config_level(int level)
{
  1036bc:	55                   	push   %ebp
  1036bd:	89 e5                	mov    %esp,%ebp
  1036bf:	56                   	push   %esi
  1036c0:	53                   	push   %ebx
  1036c1:	8b 75 08             	mov    0x8(%ebp),%esi
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
  1036c4:	8b 1c b5 80 65 10 00 	mov    0x106580(,%esi,4),%ebx
  1036cb:	3b 1c b5 84 65 10 00 	cmp    0x106584(,%esi,4),%ebx
  1036d2:	73 0c                	jae    1036e0 <_sys_device_do_config_level+0x24>
		struct device_config *device = info->config;

		device->init(info);
  1036d4:	8b 03                	mov    (%ebx),%eax
  1036d6:	53                   	push   %ebx
 */
void _sys_device_do_config_level(int level)
{
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
  1036d7:	83 c3 0c             	add    $0xc,%ebx
		struct device_config *device = info->config;

		device->init(info);
  1036da:	ff 50 04             	call   *0x4(%eax)
  1036dd:	58                   	pop    %eax
  1036de:	eb eb                	jmp    1036cb <_sys_device_do_config_level+0xf>
	}
}
  1036e0:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1036e3:	5b                   	pop    %ebx
  1036e4:	5e                   	pop    %esi
  1036e5:	5d                   	pop    %ebp
  1036e6:	c3                   	ret    

001036e7 <device_get_binding>:

struct device *device_get_binding(const char *name)
{
  1036e7:	55                   	push   %ebp
  1036e8:	89 e5                	mov    %esp,%ebp
  1036ea:	53                   	push   %ebx
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
  1036eb:	bb 50 71 10 00       	mov    $0x107150,%ebx
  1036f0:	81 fb 40 72 10 00    	cmp    $0x107240,%ebx
  1036f6:	74 21                	je     103719 <device_get_binding+0x32>
		if (info->driver_api && !strcmp(name, info->config->name)) {
  1036f8:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  1036fc:	75 05                	jne    103703 <device_get_binding+0x1c>

struct device *device_get_binding(const char *name)
{
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
  1036fe:	83 c3 0c             	add    $0xc,%ebx
  103701:	eb ed                	jmp    1036f0 <device_get_binding+0x9>
		if (info->driver_api && !strcmp(name, info->config->name)) {
  103703:	8b 03                	mov    (%ebx),%eax
  103705:	ff 30                	pushl  (%eax)
  103707:	ff 75 08             	pushl  0x8(%ebp)
  10370a:	e8 7b f5 ff ff       	call   102c8a <strcmp>
  10370f:	5a                   	pop    %edx
  103710:	85 c0                	test   %eax,%eax
  103712:	59                   	pop    %ecx
  103713:	75 e9                	jne    1036fe <device_get_binding+0x17>
  103715:	89 d8                	mov    %ebx,%eax
  103717:	eb 02                	jmp    10371b <device_get_binding+0x34>
			return info;
		}
	}

	return NULL;
  103719:	31 c0                	xor    %eax,%eax
}
  10371b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10371e:	c9                   	leave  
  10371f:	c3                   	ret    

00103720 <device_busy_set>:
  103720:	55                   	push   %ebp
  103721:	89 e5                	mov    %esp,%ebp
  103723:	5d                   	pop    %ebp
  103724:	c3                   	ret    

00103725 <device_busy_clear>:
				 (busy_dev - __device_init_start));
#endif
}

void device_busy_clear(struct device *busy_dev)
{
  103725:	55                   	push   %ebp
  103726:	89 e5                	mov    %esp,%ebp
#ifdef CONFIG_DEVICE_POWER_MANAGEMENT
	atomic_clear_bit((atomic_t *) __device_busy_start,
				 (busy_dev - __device_init_start));
#endif
}
  103728:	5d                   	pop    %ebp
  103729:	c3                   	ret    

0010372a <_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void _main(void *unused1, void *unused2, void *unused3)
{
  10372a:	55                   	push   %ebp
  10372b:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
  10372d:	6a 02                	push   $0x2
  10372f:	e8 88 ff ff ff       	call   1036bc <_sys_device_do_config_level>

	/* These 3 are deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_SECONDARY);
  103734:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  10373b:	e8 7c ff ff ff       	call   1036bc <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_NANOKERNEL);
  103740:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  103747:	e8 70 ff ff ff       	call   1036bc <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_MICROKERNEL);
  10374c:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  103753:	e8 64 ff ff ff       	call   1036bc <_sys_device_do_config_level>

	/* Final init level before app starts */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
  103758:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  10375f:	e8 58 ff ff ff       	call   1036bc <_sys_device_do_config_level>
  103764:	58                   	pop    %eax
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	_init_static_threads();
  103765:	e8 a6 0a 00 00       	call   104210 <_init_static_threads>
	 */
#if defined(MDEF_MAIN_THREAD_PRIORITY) && \
		(MDEF_MAIN_THREAD_PRIORITY != CONFIG_MAIN_THREAD_PRIORITY)
	k_thread_priority_set(_main_thread, MDEF_MAIN_THREAD_PRIORITY);
#endif
	main();
  10376a:	e8 fa cb ff ff       	call   100369 <main>

	/* Terminate thread normally since it has no more work to do */
	_main_thread->base.flags &= ~K_ESSENTIAL;
  10376f:	81 25 40 88 10 00 ff 	andl   $0xfffffdff,0x108840
  103776:	fd ff ff 
}
  103779:	c9                   	leave  
  10377a:	c3                   	ret    

0010377b <_Cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void _Cstart(void)
{
  10377b:	55                   	push   %ebp
  10377c:	89 e5                	mov    %esp,%ebp
  10377e:	83 ec 40             	sub    $0x40,%esp
	 * initialization.  However, don't waste effort initializing the
	 * fields of the dummy thread beyond those needed to identify it as a
	 * dummy thread.
	 */

	_current = dummy_thread;
  103781:	8d 45 c0             	lea    -0x40(%ebp),%eax

	/*
	 * Do not insert dummy execution context in the list of fibers, so
	 * that it does not get scheduled back in once context-switched out.
	 */
	dummy_thread->base.flags = K_ESSENTIAL;
  103784:	c7 45 c8 00 02 00 00 	movl   $0x200,-0x38(%ebp)
	 * initialization.  However, don't waste effort initializing the
	 * fields of the dummy thread beyond those needed to identify it as a
	 * dummy thread.
	 */

	_current = dummy_thread;
  10378b:	a3 88 7d 10 00       	mov    %eax,0x107d88
	/*
	 * Do not insert dummy execution context in the list of fibers, so
	 * that it does not get scheduled back in once context-switched out.
	 */
	dummy_thread->base.flags = K_ESSENTIAL;
	dummy_thread->base.prio = K_PRIO_COOP(0);
  103790:	c7 45 cc f0 ff ff ff 	movl   $0xfffffff0,-0x34(%ebp)
  103797:	b8 9c 7d 10 00       	mov    $0x107d9c,%eax
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  10379c:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
  10379e:	89 40 04             	mov    %eax,0x4(%eax)
  1037a1:	83 c0 08             	add    $0x8,%eax

	_IntLibInit();

	/* ready the init/main and idle threads */

	for (int ii = 0; ii < K_NUM_PRIORITIES; ii++) {
  1037a4:	3d 9c 7e 10 00       	cmp    $0x107e9c,%eax
  1037a9:	75 f1                	jne    10379c <_Cstart+0x21>
		sys_dlist_init(&_ready_q.q[ii]);
	}

	_new_thread(_main_stack, MAIN_STACK_SIZE,
  1037ab:	68 00 02 00 00       	push   $0x200
  1037b0:	6a 00                	push   $0x0
  1037b2:	6a 00                	push   $0x0
  1037b4:	6a 00                	push   $0x0
  1037b6:	6a 00                	push   $0x0
  1037b8:	68 2a 37 10 00       	push   $0x10372a
  1037bd:	68 00 04 00 00       	push   $0x400
  1037c2:	68 38 88 10 00       	push   $0x108838
  1037c7:	e8 6a fc ff ff       	call   103436 <_new_thread>
  1037cc:	83 c4 20             	add    $0x20,%esp
		    _main, NULL, NULL, NULL,
		    CONFIG_MAIN_THREAD_PRIORITY, K_ESSENTIAL);
	_mark_thread_as_started(_main_thread);
	_add_thread_to_ready_q(_main_thread);
  1037cf:	68 38 88 10 00       	push   $0x108838
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.flags &= ~K_PRESTART;
  1037d4:	81 25 40 88 10 00 ff 	andl   $0xffffbfff,0x108840
  1037db:	bf ff ff 
  1037de:	e8 7d 01 00 00       	call   103960 <_add_thread_to_ready_q>

	_new_thread(_idle_stack, IDLE_STACK_SIZE,
  1037e3:	c7 04 24 00 02 00 00 	movl   $0x200,(%esp)
  1037ea:	6a 0f                	push   $0xf
  1037ec:	6a 00                	push   $0x0
  1037ee:	6a 00                	push   $0x0
  1037f0:	6a 00                	push   $0x0
  1037f2:	68 84 45 10 00       	push   $0x104584
  1037f7:	68 00 01 00 00       	push   $0x100
  1037fc:	68 38 87 10 00       	push   $0x108738
  103801:	e8 30 fc ff ff       	call   103436 <_new_thread>
  103806:	83 c4 20             	add    $0x20,%esp
  103809:	81 25 40 87 10 00 ff 	andl   $0xffffbfff,0x108740
  103810:	bf ff ff 
		    idle, NULL, NULL, NULL,
		    K_LOWEST_THREAD_PRIO, K_ESSENTIAL);
	_mark_thread_as_started(_idle_thread);
	_add_thread_to_ready_q(_idle_thread);
  103813:	68 38 87 10 00       	push   $0x108738
  103818:	e8 43 01 00 00       	call   103960 <_add_thread_to_ready_q>
	 */

	prepare_multithreading(dummy_thread);

	/* Deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRIMARY);
  10381d:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  103824:	c7 05 8c 7d 10 00 8c 	movl   $0x107d8c,0x107d8c
  10382b:	7d 10 00 
	list->tail = (sys_dnode_t *)list;
  10382e:	c7 05 90 7d 10 00 8c 	movl   $0x107d8c,0x107d90
  103835:	7d 10 00 
	extern void *_dummy_exception_vector_stub;
	extern char _interrupt_stack[CONFIG_ISR_STACK_SIZE];

	extern void _exception_enter(void);

	_kernel.nested = 0;
  103838:	c7 05 80 7d 10 00 00 	movl   $0x0,0x107d80
  10383f:	00 00 00 

	_kernel.irq_stack = _interrupt_stack + CONFIG_ISR_STACK_SIZE;
  103842:	c7 05 84 7d 10 00 38 	movl   $0x108738,0x107d84
  103849:	87 10 00 
	 * Forces the inclusion of the spurious interrupt handlers. If a
	 * reference isn't made then intconnect.o is never pulled in by the
	 * linker.
	 */

	_dummy_spurious_interrupt = &__isr___SpuriousIntHandler;
  10384c:	c7 05 08 7f 10 00 00 	movl   $0x800,0x107f08
  103853:	08 00 00 
	 * Forces the inclusion of the exception vector stub code. If a
	 * reference isn't made then excstubs.o is never pulled in by the
	 * linker.
	 */

	_dummy_exception_vector_stub = &_exception_enter;
  103856:	c7 05 00 7f 10 00 66 	movl   $0x103366,0x107f00
  10385d:	33 10 00 
  103860:	e8 57 fe ff ff       	call   1036bc <_sys_device_do_config_level>

	/* perform basic hardware initialization */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
  103865:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  10386c:	e8 4b fe ff ff       	call   1036bc <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
  103871:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  103878:	e8 3f fe ff ff       	call   1036bc <_sys_device_do_config_level>

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  10387d:	9c                   	pushf  
  10387e:	fa                   	cli    
  10387f:	58                   	pop    %eax
	 * Context switch to main task (entry function is _main()): the
	 * current fake thread is not on a wait queue or ready queue, so it
	 * will never be rescheduled in.
	 */

	_Swap(irq_lock());
  103880:	89 04 24             	mov    %eax,(%esp)
  103883:	e8 83 fb ff ff       	call   10340b <_Swap>
  103888:	58                   	pop    %eax

00103889 <nano_timer_test>:
}

#endif /* (CONFIG_NUM_DYNAMIC_TIMERS > 0) */

void *nano_timer_test(struct nano_timer *timer, int32_t timeout_in_ticks)
{
  103889:	55                   	push   %ebp
	uint32_t (*test_fn)(struct k_timer *timer);

	if (timeout_in_ticks == TICKS_NONE) {
		test_fn = k_timer_status_get;
	} else {
		test_fn = k_timer_status_sync;
  10388a:	b8 3e 45 10 00       	mov    $0x10453e,%eax
}

#endif /* (CONFIG_NUM_DYNAMIC_TIMERS > 0) */

void *nano_timer_test(struct nano_timer *timer, int32_t timeout_in_ticks)
{
  10388f:	89 e5                	mov    %esp,%ebp
  103891:	53                   	push   %ebx
	uint32_t (*test_fn)(struct k_timer *timer);

	if (timeout_in_ticks == TICKS_NONE) {
  103892:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
}

#endif /* (CONFIG_NUM_DYNAMIC_TIMERS > 0) */

void *nano_timer_test(struct nano_timer *timer, int32_t timeout_in_ticks)
{
  103896:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint32_t (*test_fn)(struct k_timer *timer);

	if (timeout_in_ticks == TICKS_NONE) {
  103899:	75 05                	jne    1038a0 <nano_timer_test+0x17>
  10389b:	b8 23 45 10 00       	mov    $0x104523,%eax
		test_fn = k_timer_status_get;
	} else {
		test_fn = k_timer_status_sync;
	}
	return test_fn(timer) ? timer->_legacy_data : NULL;
  1038a0:	53                   	push   %ebx
  1038a1:	ff d0                	call   *%eax
  1038a3:	5a                   	pop    %edx
  1038a4:	31 d2                	xor    %edx,%edx
  1038a6:	85 c0                	test   %eax,%eax
  1038a8:	74 03                	je     1038ad <nano_timer_test+0x24>
  1038aa:	8b 53 30             	mov    0x30(%ebx),%edx
}
  1038ad:	89 d0                	mov    %edx,%eax
  1038af:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1038b2:	c9                   	leave  
  1038b3:	c3                   	ret    

001038b4 <_get_highest_ready_prio>:
}

/* find out the currently highest priority where a thread is ready to run */
/* interrupts must be locked */
static inline int _get_highest_ready_prio(void)
{
  1038b4:	55                   	push   %ebp
  1038b5:	89 e5                	mov    %esp,%ebp

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
	unsigned int bitpos;

	__asm__ volatile (
  1038b7:	0f bc 05 98 7d 10 00 	bsf    0x107d98,%eax
  1038be:	75 05                	jne    1038c5 <_get_highest_ready_prio+0x11>
  1038c0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	int abs_prio = (find_lsb_set(ready_range) - 1) + (bitmap << 5);

	__ASSERT(abs_prio < K_NUM_PRIORITIES, "prio out-of-range\n");

	return abs_prio - CONFIG_NUM_COOP_PRIORITIES;
  1038c5:	83 e8 10             	sub    $0x10,%eax
}
  1038c8:	5d                   	pop    %ebp
  1038c9:	c3                   	ret    

001038ca <_is_timeout_insert_point>:
 * the timeout of the insert point to update its delta queue value, since the
 * current timeout will be inserted before it.
 */

static int _is_timeout_insert_point(sys_dnode_t *test, void *timeout)
{
  1038ca:	55                   	push   %ebp
  1038cb:	89 e5                	mov    %esp,%ebp
  1038cd:	53                   	push   %ebx
  1038ce:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1038d1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct _timeout *t = (void *)test;
	int32_t *timeout_to_insert = timeout;

	if (*timeout_to_insert > t->delta_ticks_from_prev) {
  1038d4:	8b 41 10             	mov    0x10(%ecx),%eax
  1038d7:	8b 13                	mov    (%ebx),%edx
  1038d9:	39 c2                	cmp    %eax,%edx
  1038db:	7e 08                	jle    1038e5 <_is_timeout_insert_point+0x1b>
		*timeout_to_insert -= t->delta_ticks_from_prev;
  1038dd:	29 c2                	sub    %eax,%edx
		return 0;
  1038df:	31 c0                	xor    %eax,%eax
{
	struct _timeout *t = (void *)test;
	int32_t *timeout_to_insert = timeout;

	if (*timeout_to_insert > t->delta_ticks_from_prev) {
		*timeout_to_insert -= t->delta_ticks_from_prev;
  1038e1:	89 13                	mov    %edx,(%ebx)
		return 0;
  1038e3:	eb 0a                	jmp    1038ef <_is_timeout_insert_point+0x25>
	}

	t->delta_ticks_from_prev -= *timeout_to_insert;
  1038e5:	29 d0                	sub    %edx,%eax
  1038e7:	89 41 10             	mov    %eax,0x10(%ecx)
	return 1;
  1038ea:	b8 01 00 00 00       	mov    $0x1,%eax
}
  1038ef:	5b                   	pop    %ebx
  1038f0:	5d                   	pop    %ebp
  1038f1:	c3                   	ret    

001038f2 <_is_wait_q_insert_point>:
/*
 * Callback for sys_dlist_insert_at() to find the correct insert point in a
 * wait queue (priority-based).
 */
static int _is_wait_q_insert_point(sys_dnode_t *node, void *insert_prio)
{
  1038f2:	55                   	push   %ebp
  1038f3:	89 e5                	mov    %esp,%ebp
		CONTAINER_OF(
			CONTAINER_OF(node, struct _thread_base, k_q_node),
			struct k_thread,
			base);

	return _is_prio_higher((int)insert_prio, waitq_node->base.prio);
  1038f5:	8b 45 08             	mov    0x8(%ebp),%eax
  1038f8:	8b 40 0c             	mov    0xc(%eax),%eax
  1038fb:	39 45 0c             	cmp    %eax,0xc(%ebp)
}
  1038fe:	5d                   	pop    %ebp
		CONTAINER_OF(
			CONTAINER_OF(node, struct _thread_base, k_q_node),
			struct k_thread,
			base);

	return _is_prio_higher((int)insert_prio, waitq_node->base.prio);
  1038ff:	0f 9c c0             	setl   %al
  103902:	0f b6 c0             	movzbl %al,%eax
}
  103905:	c3                   	ret    

00103906 <sys_dlist_insert_at>:
 * @return N/A
 */

static inline void sys_dlist_insert_at(sys_dlist_t *list, sys_dnode_t *node,
	int (*cond)(sys_dnode_t *, void *), void *data)
{
  103906:	55                   	push   %ebp
  103907:	89 e5                	mov    %esp,%ebp
  103909:	57                   	push   %edi
  10390a:	56                   	push   %esi
  10390b:	53                   	push   %ebx
  10390c:	53                   	push   %ebx
  10390d:	89 c6                	mov    %eax,%esi
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  10390f:	8b 38                	mov    (%eax),%edi
 * @return N/A
 */

static inline void sys_dlist_insert_at(sys_dlist_t *list, sys_dnode_t *node,
	int (*cond)(sys_dnode_t *, void *), void *data)
{
  103911:	89 d3                	mov    %edx,%ebx
	if (sys_dlist_is_empty(list)) {
  103913:	39 f8                	cmp    %edi,%eax
  103915:	74 1f                	je     103936 <sys_dlist_insert_at+0x30>
		sys_dlist_append(list, node);
	} else {
		sys_dnode_t *pos = sys_dlist_peek_head(list);

		while (pos && !cond(pos, data)) {
  103917:	85 ff                	test   %edi,%edi
  103919:	74 1b                	je     103936 <sys_dlist_insert_at+0x30>
  10391b:	ff 75 08             	pushl  0x8(%ebp)
  10391e:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  103921:	57                   	push   %edi
  103922:	ff d1                	call   *%ecx
  103924:	5a                   	pop    %edx
  103925:	85 c0                	test   %eax,%eax
  103927:	59                   	pop    %ecx
  103928:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10392b:	75 1b                	jne    103948 <sys_dlist_insert_at+0x42>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (!node || node == list->tail) ? NULL : node->next;
  10392d:	3b 7e 04             	cmp    0x4(%esi),%edi
  103930:	74 04                	je     103936 <sys_dlist_insert_at+0x30>
  103932:	8b 3f                	mov    (%edi),%edi
  103934:	eb e1                	jmp    103917 <sys_dlist_insert_at+0x11>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  103936:	89 33                	mov    %esi,(%ebx)
	node->prev = list->tail;
  103938:	8b 46 04             	mov    0x4(%esi),%eax
  10393b:	89 43 04             	mov    %eax,0x4(%ebx)

	list->tail->next = node;
  10393e:	8b 46 04             	mov    0x4(%esi),%eax
  103941:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
  103943:	89 5e 04             	mov    %ebx,0x4(%esi)
  103946:	eb 10                	jmp    103958 <sys_dlist_insert_at+0x52>
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  103948:	8b 47 04             	mov    0x4(%edi),%eax
		node->next = insert_point;
  10394b:	89 3b                	mov    %edi,(%ebx)
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  10394d:	89 43 04             	mov    %eax,0x4(%ebx)
		node->next = insert_point;
		insert_point->prev->next = node;
  103950:	8b 47 04             	mov    0x4(%edi),%eax
  103953:	89 18                	mov    %ebx,(%eax)
		insert_point->prev = node;
  103955:	89 5f 04             	mov    %ebx,0x4(%edi)
		while (pos && !cond(pos, data)) {
			pos = sys_dlist_peek_next(list, pos);
		}
		sys_dlist_insert_before(list, pos, node);
	}
}
  103958:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10395b:	5b                   	pop    %ebx
  10395c:	5e                   	pop    %esi
  10395d:	5f                   	pop    %edi
  10395e:	5d                   	pop    %ebp
  10395f:	c3                   	ret    

00103960 <_add_thread_to_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _add_thread_to_ready_q(struct k_thread *thread)
{
  103960:	55                   	push   %ebp
  103961:	89 e5                	mov    %esp,%ebp
  103963:	56                   	push   %esi
  103964:	53                   	push   %ebx
static void _set_ready_q_prio_bit(int prio)
{
	int bmap_index = _get_ready_q_prio_bmap_index(prio);
	uint32_t *bmap = &_ready_q.prio_bmap[bmap_index];

	*bmap |= _get_ready_q_prio_bit(prio);
  103965:	bb 01 00 00 00       	mov    $0x1,%ebx
 *
 * Interrupts must be locked when calling this function.
 */

void _add_thread_to_ready_q(struct k_thread *thread)
{
  10396a:	8b 45 08             	mov    0x8(%ebp),%eax
}

/* find out the ready queue array index for a given prio */
static inline int _get_ready_q_q_index(int prio)
{
	return prio + CONFIG_NUM_COOP_PRIORITIES;
  10396d:	8b 50 0c             	mov    0xc(%eax),%edx
  103970:	8d 4a 10             	lea    0x10(%edx),%ecx
	int q_index = _get_ready_q_q_index(thread->base.prio);
	sys_dlist_t *q = &_ready_q.q[q_index];
  103973:	83 c2 12             	add    $0x12,%edx
}

/* find out the prio bitmap index for a given prio */
static inline int _get_ready_q_prio_bmap_index(int prio)
{
	return (prio + CONFIG_NUM_COOP_PRIORITIES) >> 5;
  103976:	89 ce                	mov    %ecx,%esi
  103978:	c1 fe 05             	sar    $0x5,%esi
static void _set_ready_q_prio_bit(int prio)
{
	int bmap_index = _get_ready_q_prio_bmap_index(prio);
	uint32_t *bmap = &_ready_q.prio_bmap[bmap_index];

	*bmap |= _get_ready_q_prio_bit(prio);
  10397b:	d3 e3                	shl    %cl,%ebx
 */

void _add_thread_to_ready_q(struct k_thread *thread)
{
	int q_index = _get_ready_q_q_index(thread->base.prio);
	sys_dlist_t *q = &_ready_q.q[q_index];
  10397d:	8d 0c d5 8c 7d 10 00 	lea    0x107d8c(,%edx,8),%ecx
static void _set_ready_q_prio_bit(int prio)
{
	int bmap_index = _get_ready_q_prio_bmap_index(prio);
	uint32_t *bmap = &_ready_q.prio_bmap[bmap_index];

	*bmap |= _get_ready_q_prio_bit(prio);
  103984:	09 1c b5 98 7d 10 00 	or     %ebx,0x107d98(,%esi,4)
 */

void _add_thread_to_ready_q(struct k_thread *thread)
{
	int q_index = _get_ready_q_q_index(thread->base.prio);
	sys_dlist_t *q = &_ready_q.q[q_index];
  10398b:	89 08                	mov    %ecx,(%eax)
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
	node->prev = list->tail;
  10398d:	8b 0c d5 90 7d 10 00 	mov    0x107d90(,%edx,8),%ecx
  103994:	89 48 04             	mov    %ecx,0x4(%eax)

	list->tail->next = node;
  103997:	8b 0c d5 90 7d 10 00 	mov    0x107d90(,%edx,8),%ecx
  10399e:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
  1039a0:	89 04 d5 90 7d 10 00 	mov    %eax,0x107d90(,%edx,8)
	_set_ready_q_prio_bit(thread->base.prio);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache && _is_prio_higher(thread->base.prio,
  1039a7:	8b 15 94 7d 10 00    	mov    0x107d94,%edx
					   (*cache)->base.prio) ?
		 thread : *cache;
  1039ad:	85 d2                	test   %edx,%edx
  1039af:	74 0a                	je     1039bb <_add_thread_to_ready_q+0x5b>
	_set_ready_q_prio_bit(thread->base.prio);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache && _is_prio_higher(thread->base.prio,
  1039b1:	8b 58 0c             	mov    0xc(%eax),%ebx
  1039b4:	39 5a 0c             	cmp    %ebx,0xc(%edx)
  1039b7:	7e 02                	jle    1039bb <_add_thread_to_ready_q+0x5b>
  1039b9:	89 c2                	mov    %eax,%edx
					   (*cache)->base.prio) ?
		 thread : *cache;
}
  1039bb:	5b                   	pop    %ebx
	_set_ready_q_prio_bit(thread->base.prio);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache && _is_prio_higher(thread->base.prio,
  1039bc:	89 15 94 7d 10 00    	mov    %edx,0x107d94
					   (*cache)->base.prio) ?
		 thread : *cache;
}
  1039c2:	5e                   	pop    %esi
  1039c3:	5d                   	pop    %ebp
  1039c4:	c3                   	ret    

001039c5 <_remove_thread_from_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _remove_thread_from_ready_q(struct k_thread *thread)
{
  1039c5:	55                   	push   %ebp
  1039c6:	89 e5                	mov    %esp,%ebp
  1039c8:	53                   	push   %ebx
  1039c9:	8b 45 08             	mov    0x8(%ebp),%eax
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  1039cc:	8b 48 04             	mov    0x4(%eax),%ecx
  1039cf:	8b 18                	mov    (%eax),%ebx
}

/* find out the ready queue array index for a given prio */
static inline int _get_ready_q_q_index(int prio)
{
	return prio + CONFIG_NUM_COOP_PRIORITIES;
  1039d1:	8b 50 0c             	mov    0xc(%eax),%edx
  1039d4:	89 19                	mov    %ebx,(%ecx)
	node->next->prev = node->prev;
  1039d6:	8b 18                	mov    (%eax),%ebx
  1039d8:	89 4b 04             	mov    %ecx,0x4(%ebx)
	int q_index = _get_ready_q_q_index(thread->base.prio);
	sys_dlist_t *q = &_ready_q.q[q_index];
  1039db:	8d 0c d5 1c 7e 10 00 	lea    0x107e1c(,%edx,8),%ecx

	sys_dlist_remove(&thread->base.k_q_node);
	if (sys_dlist_is_empty(q)) {
  1039e2:	3b 0c d5 1c 7e 10 00 	cmp    0x107e1c(,%edx,8),%ecx
  1039e9:	75 1b                	jne    103a06 <_remove_thread_from_ready_q+0x41>
}

/* find out the prio bitmap index for a given prio */
static inline int _get_ready_q_prio_bmap_index(int prio)
{
	return (prio + CONFIG_NUM_COOP_PRIORITIES) >> 5;
  1039eb:	8b 48 0c             	mov    0xc(%eax),%ecx
static void _clear_ready_q_prio_bit(int prio)
{
	int bmap_index = _get_ready_q_prio_bmap_index(prio);
	uint32_t *bmap = &_ready_q.prio_bmap[bmap_index];

	*bmap &= ~_get_ready_q_prio_bit(prio);
  1039ee:	ba 01 00 00 00       	mov    $0x1,%edx
  1039f3:	83 c1 10             	add    $0x10,%ecx
  1039f6:	89 cb                	mov    %ecx,%ebx
  1039f8:	c1 fb 05             	sar    $0x5,%ebx
  1039fb:	d3 e2                	shl    %cl,%edx
  1039fd:	f7 d2                	not    %edx
  1039ff:	21 14 9d 98 7d 10 00 	and    %edx,0x107d98(,%ebx,4)
		_clear_ready_q_prio_bit(thread->base.prio);
	}

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? NULL : *cache;
  103a06:	8b 15 94 7d 10 00    	mov    0x107d94,%edx
  103a0c:	39 d0                	cmp    %edx,%eax
  103a0e:	75 02                	jne    103a12 <_remove_thread_from_ready_q+0x4d>
  103a10:	31 d2                	xor    %edx,%edx
}
  103a12:	5b                   	pop    %ebx
		_clear_ready_q_prio_bit(thread->base.prio);
	}

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? NULL : *cache;
  103a13:	89 15 94 7d 10 00    	mov    %edx,0x107d94
}
  103a19:	5d                   	pop    %ebp
  103a1a:	c3                   	ret    

00103a1b <_ms_to_ticks>:

#define ceiling(numerator, divider) \
	(((numerator) + ((divider) - 1)) / (divider))

int32_t _ms_to_ticks(int32_t ms)
{
  103a1b:	55                   	push   %ebp
	int64_t ms_ticks_per_sec = (int64_t)ms * sys_clock_ticks_per_sec;

	return (int32_t)ceiling(ms_ticks_per_sec, MSEC_PER_SEC);
  103a1c:	b8 64 00 00 00       	mov    $0x64,%eax

#define ceiling(numerator, divider) \
	(((numerator) + ((divider) - 1)) / (divider))

int32_t _ms_to_ticks(int32_t ms)
{
  103a21:	89 e5                	mov    %esp,%ebp
	int64_t ms_ticks_per_sec = (int64_t)ms * sys_clock_ticks_per_sec;

	return (int32_t)ceiling(ms_ticks_per_sec, MSEC_PER_SEC);
  103a23:	6a 00                	push   $0x0
  103a25:	68 e8 03 00 00       	push   $0x3e8
  103a2a:	f7 6d 08             	imull  0x8(%ebp)
  103a2d:	05 e7 03 00 00       	add    $0x3e7,%eax
  103a32:	83 d2 00             	adc    $0x0,%edx
  103a35:	52                   	push   %edx
  103a36:	50                   	push   %eax
  103a37:	e8 54 c6 ff ff       	call   100090 <__divdi3>
  103a3c:	83 c4 10             	add    $0x10,%esp
}
  103a3f:	c9                   	leave  
  103a40:	c3                   	ret    

00103a41 <_pend_thread>:

/* pend the specified thread: it must *not* be in the ready queue */
/* must be called with interrupts locked */
void _pend_thread(struct k_thread *thread, _wait_q_t *wait_q, int32_t timeout)
{
  103a41:	55                   	push   %ebp
	sys_dlist_t *dlist = (sys_dlist_t *)wait_q;

	sys_dlist_insert_at(dlist, &thread->base.k_q_node,
  103a42:	b9 f2 38 10 00       	mov    $0x1038f2,%ecx
}

/* pend the specified thread: it must *not* be in the ready queue */
/* must be called with interrupts locked */
void _pend_thread(struct k_thread *thread, _wait_q_t *wait_q, int32_t timeout)
{
  103a47:	89 e5                	mov    %esp,%ebp
  103a49:	57                   	push   %edi
  103a4a:	56                   	push   %esi
  103a4b:	53                   	push   %ebx
  103a4c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  103a4f:	8b 75 0c             	mov    0xc(%ebp),%esi
  103a52:	8b 7d 10             	mov    0x10(%ebp),%edi
	sys_dlist_t *dlist = (sys_dlist_t *)wait_q;

	sys_dlist_insert_at(dlist, &thread->base.k_q_node,
  103a55:	89 f0                	mov    %esi,%eax
  103a57:	ff 73 0c             	pushl  0xc(%ebx)
  103a5a:	89 da                	mov    %ebx,%edx
  103a5c:	e8 a5 fe ff ff       	call   103906 <sys_dlist_insert_at>
  103a61:	58                   	pop    %eax
}

/* mark a thread as pending in its TCS */
static inline void _mark_thread_as_pending(struct k_thread *thread)
{
	thread->base.flags |= K_PENDING;
  103a62:	81 4b 08 00 20 00 00 	orl    $0x2000,0x8(%ebx)
			    _is_wait_q_insert_point,
			    (void *)thread->base.prio);

	_mark_thread_as_pending(thread);

	if (timeout != K_FOREVER) {
  103a69:	83 ff ff             	cmp    $0xffffffff,%edi
  103a6c:	74 49                	je     103ab7 <_pend_thread+0x76>

	K_DEBUG("timeout   %p before: next: %p, prev: %p\n",
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
	timeout_obj->delta_ticks_from_prev = timeout;
  103a6e:	b8 64 00 00 00       	mov    $0x64,%eax
		_timeout_q.tail);

	K_DEBUG("timeout   %p before: next: %p, prev: %p\n",
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
  103a73:	89 5b 20             	mov    %ebx,0x20(%ebx)
	timeout_obj->delta_ticks_from_prev = timeout;
  103a76:	f7 ef                	imul   %edi
  103a78:	05 e7 03 00 00       	add    $0x3e7,%eax
  103a7d:	6a 00                	push   $0x0
  103a7f:	83 d2 00             	adc    $0x0,%edx
  103a82:	68 e8 03 00 00       	push   $0x3e8
  103a87:	52                   	push   %edx
  103a88:	50                   	push   %eax
  103a89:	e8 02 c6 ff ff       	call   100090 <__divdi3>
	timeout_obj->wait_q = (sys_dlist_t *)wait_q;
  103a8e:	89 73 24             	mov    %esi,0x24(%ebx)

	K_DEBUG("timeout   %p before: next: %p, prev: %p\n",
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
	timeout_obj->delta_ticks_from_prev = timeout;
  103a91:	40                   	inc    %eax
 */

static inline void _add_thread_timeout(struct k_thread *thread,
				       _wait_q_t *wait_q, int32_t timeout)
{
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout);
  103a92:	8d 53 18             	lea    0x18(%ebx),%edx

	K_DEBUG("timeout   %p before: next: %p, prev: %p\n",
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
	timeout_obj->delta_ticks_from_prev = timeout;
  103a95:	89 43 28             	mov    %eax,0x28(%ebx)
	timeout_obj->wait_q = (sys_dlist_t *)wait_q;
	sys_dlist_insert_at(timeout_q, (void *)timeout_obj,
			    _is_timeout_insert_point,
			    &timeout_obj->delta_ticks_from_prev);
  103a98:	83 c3 28             	add    $0x28,%ebx
  103a9b:	89 5d 08             	mov    %ebx,0x8(%ebp)

	K_DEBUG("timeout   %p before: next: %p, prev: %p\n",
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
	timeout_obj->delta_ticks_from_prev = timeout;
  103a9e:	83 c4 10             	add    $0x10,%esp
		int32_t ticks = _TICK_ALIGN + _ms_to_ticks(timeout);

		_add_thread_timeout(thread, wait_q, ticks);
	}
}
  103aa1:	8d 65 f4             	lea    -0xc(%ebp),%esp
	timeout_obj->wait_q = (sys_dlist_t *)wait_q;
	sys_dlist_insert_at(timeout_q, (void *)timeout_obj,
  103aa4:	b9 ca 38 10 00       	mov    $0x1038ca,%ecx
  103aa9:	b8 8c 7d 10 00       	mov    $0x107d8c,%eax
  103aae:	5b                   	pop    %ebx
  103aaf:	5e                   	pop    %esi
  103ab0:	5f                   	pop    %edi
  103ab1:	5d                   	pop    %ebp
  103ab2:	e9 4f fe ff ff       	jmp    103906 <sys_dlist_insert_at>
  103ab7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103aba:	5b                   	pop    %ebx
  103abb:	5e                   	pop    %esi
  103abc:	5f                   	pop    %edi
  103abd:	5d                   	pop    %ebp
  103abe:	c3                   	ret    

00103abf <_pend_current_thread>:

/* pend the current thread */
/* must be called with interrupts locked */
void _pend_current_thread(_wait_q_t *wait_q, int32_t timeout)
{
  103abf:	55                   	push   %ebp
  103ac0:	89 e5                	mov    %esp,%ebp
	_remove_thread_from_ready_q(_current);
  103ac2:	ff 35 88 7d 10 00    	pushl  0x107d88
  103ac8:	e8 f8 fe ff ff       	call   1039c5 <_remove_thread_from_ready_q>
  103acd:	58                   	pop    %eax
	_pend_thread(_current, wait_q, timeout);
  103ace:	ff 75 0c             	pushl  0xc(%ebp)
  103ad1:	ff 75 08             	pushl  0x8(%ebp)
  103ad4:	ff 35 88 7d 10 00    	pushl  0x107d88
  103ada:	e8 62 ff ff ff       	call   103a41 <_pend_thread>
  103adf:	83 c4 0c             	add    $0xc,%esp
}
  103ae2:	c9                   	leave  
  103ae3:	c3                   	ret    

00103ae4 <_get_next_ready_thread>:

/* find which one is the next thread to run */
/* must be called with interrupts locked */
struct k_thread *_get_next_ready_thread(void)
{
	struct k_thread *cache = _ready_q.cache;
  103ae4:	a1 94 7d 10 00       	mov    0x107d94,%eax

	return cache ? cache : __get_next_ready_thread();
  103ae9:	85 c0                	test   %eax,%eax
  103aeb:	75 15                	jne    103b02 <_get_next_ready_thread+0x1e>
}

/* find which one is the next thread to run */
/* must be called with interrupts locked */
struct k_thread *_get_next_ready_thread(void)
{
  103aed:	55                   	push   %ebp
  103aee:	89 e5                	mov    %esp,%ebp
 * Find the next thread to run when there is no thread in the cache and update
 * the cache.
 */
static struct k_thread *__get_next_ready_thread(void)
{
	int prio = _get_highest_ready_prio();
  103af0:	e8 bf fd ff ff       	call   1038b4 <_get_highest_ready_prio>
struct k_thread *_get_next_ready_thread(void)
{
	struct k_thread *cache = _ready_q.cache;

	return cache ? cache : __get_next_ready_thread();
}
  103af5:	5d                   	pop    %ebp
  103af6:	8b 04 c5 1c 7e 10 00 	mov    0x107e1c(,%eax,8),%eax
		 prio, q_index);

	struct k_thread *thread =
		(struct k_thread *)sys_dlist_peek_head_not_empty(list);

	_ready_q.cache = thread;
  103afd:	a3 94 7d 10 00       	mov    %eax,0x107d94
struct k_thread *_get_next_ready_thread(void)
{
	struct k_thread *cache = _ready_q.cache;

	return cache ? cache : __get_next_ready_thread();
}
  103b02:	c3                   	ret    

00103b03 <__must_switch_threads>:
/*
 * Check if there is a thread of higher prio than the current one. Should only
 * be called if we already know that the current thread is preemptible.
 */
int __must_switch_threads(void)
{
  103b03:	55                   	push   %ebp
		_current->base.prio, _get_highest_ready_prio());

	extern void _dump_ready_q(void);
	_dump_ready_q();

	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
  103b04:	a1 88 7d 10 00       	mov    0x107d88,%eax
/*
 * Check if there is a thread of higher prio than the current one. Should only
 * be called if we already know that the current thread is preemptible.
 */
int __must_switch_threads(void)
{
  103b09:	89 e5                	mov    %esp,%ebp
		_current->base.prio, _get_highest_ready_prio());

	extern void _dump_ready_q(void);
	_dump_ready_q();

	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
  103b0b:	8b 50 0c             	mov    0xc(%eax),%edx
  103b0e:	e8 a1 fd ff ff       	call   1038b4 <_get_highest_ready_prio>
  103b13:	39 c2                	cmp    %eax,%edx
}
  103b15:	5d                   	pop    %ebp
		_current->base.prio, _get_highest_ready_prio());

	extern void _dump_ready_q(void);
	_dump_ready_q();

	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
  103b16:	0f 9f c0             	setg   %al
  103b19:	0f b6 c0             	movzbl %al,%eax
}
  103b1c:	c3                   	ret    

00103b1d <_reschedule_threads>:

/* reschedule threads if the scheduler is not locked */
/* not callable from ISR */
/* must be called with interrupts locked */
void _reschedule_threads(int key)
{
  103b1d:	55                   	push   %ebp
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
  103b1e:	a1 88 7d 10 00       	mov    0x107d88,%eax
  103b23:	89 e5                	mov    %esp,%ebp
}

/* is thread currently preemptible ? */
static inline int _is_preempt(struct k_thread *thread)
{
	return !_is_coop(thread) && !atomic_get(&thread->base.sched_locked);
  103b25:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
  103b29:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103b2c:	78 19                	js     103b47 <_reschedule_threads+0x2a>
 * @return Value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_get(const atomic_t *target)
{
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
  103b2e:	8b 40 10             	mov    0x10(%eax),%eax
  103b31:	85 c0                	test   %eax,%eax
  103b33:	75 12                	jne    103b47 <_reschedule_threads+0x2a>
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
  103b35:	e8 c9 ff ff ff       	call   103b03 <__must_switch_threads>
  103b3a:	85 c0                	test   %eax,%eax
  103b3c:	74 09                	je     103b47 <_reschedule_threads+0x2a>
	K_DEBUG("rescheduling threads\n");

	if (_must_switch_threads()) {
		K_DEBUG("context-switching out %p\n", _current);
		_Swap(key);
  103b3e:	89 4d 08             	mov    %ecx,0x8(%ebp)
	} else {
		irq_unlock(key);
	}
}
  103b41:	5d                   	pop    %ebp
{
	K_DEBUG("rescheduling threads\n");

	if (_must_switch_threads()) {
		K_DEBUG("context-switching out %p\n", _current);
		_Swap(key);
  103b42:	e9 c4 f8 ff ff       	jmp    10340b <_Swap>
  103b47:	80 e5 02             	and    $0x2,%ch
  103b4a:	74 01                	je     103b4d <_reschedule_threads+0x30>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  103b4c:	fb                   	sti    
	} else {
		irq_unlock(key);
	}
}
  103b4d:	5d                   	pop    %ebp
  103b4e:	c3                   	ret    

00103b4f <k_sched_unlock>:
	K_DEBUG("scheduler locked (%p:%d)\n",
		_current, _current->base.sched_locked);
}

void k_sched_unlock(void)
{
  103b4f:	55                   	push   %ebp
  103b50:	89 e5                	mov    %esp,%ebp

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  103b52:	9c                   	pushf  
  103b53:	fa                   	cli    
  103b54:	5a                   	pop    %edx
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
  103b55:	a1 88 7d 10 00       	mov    0x107d88,%eax
  103b5a:	f0 ff 48 10          	lock decl 0x10(%eax)
	atomic_dec(&_current->base.sched_locked);

	K_DEBUG("scheduler unlocked (%p:%d)\n",
		_current, _current->base.sched_locked);

	_reschedule_threads(key);
  103b5e:	52                   	push   %edx
  103b5f:	e8 b9 ff ff ff       	call   103b1d <_reschedule_threads>
  103b64:	58                   	pop    %eax
}
  103b65:	c9                   	leave  
  103b66:	c3                   	ret    

00103b67 <_is_next_thread_current>:

	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
}

int _is_next_thread_current(void)
{
  103b67:	55                   	push   %ebp
  103b68:	89 e5                	mov    %esp,%ebp
	return _get_next_ready_thread() == _current;
  103b6a:	e8 75 ff ff ff       	call   103ae4 <_get_next_ready_thread>
}
  103b6f:	5d                   	pop    %ebp
	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
}

int _is_next_thread_current(void)
{
	return _get_next_ready_thread() == _current;
  103b70:	39 05 88 7d 10 00    	cmp    %eax,0x107d88
  103b76:	0f 94 c0             	sete   %al
  103b79:	0f b6 c0             	movzbl %al,%eax
}
  103b7c:	c3                   	ret    

00103b7d <_move_thread_to_end_of_prio_q>:
 * This function, along with _add_thread_to_ready_q() and
 * _remove_thread_from_ready_q(), are the _only_ places where a thread is
 * taken off or put on the ready queue.
 */
void _move_thread_to_end_of_prio_q(struct k_thread *thread)
{
  103b7d:	55                   	push   %ebp
  103b7e:	89 e5                	mov    %esp,%ebp
  103b80:	56                   	push   %esi
  103b81:	53                   	push   %ebx
  103b82:	8b 45 08             	mov    0x8(%ebp),%eax
	int q_index = _get_ready_q_q_index(thread->base.prio);
	sys_dlist_t *q = &_ready_q.q[q_index];
  103b85:	8b 58 0c             	mov    0xc(%eax),%ebx
  103b88:	8d 53 12             	lea    0x12(%ebx),%edx
  103b8b:	8d 0c d5 8c 7d 10 00 	lea    0x107d8c(,%edx,8),%ecx

	if (sys_dlist_is_tail(q, &thread->base.k_q_node)) {
  103b92:	3b 41 04             	cmp    0x4(%ecx),%eax
  103b95:	74 3a                	je     103bd1 <_move_thread_to_end_of_prio_q+0x54>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  103b97:	8b 58 04             	mov    0x4(%eax),%ebx
  103b9a:	8b 30                	mov    (%eax),%esi
  103b9c:	89 33                	mov    %esi,(%ebx)
	node->next->prev = node->prev;
  103b9e:	8b 30                	mov    (%eax),%esi
  103ba0:	89 5e 04             	mov    %ebx,0x4(%esi)
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  103ba3:	89 08                	mov    %ecx,(%eax)
	node->prev = list->tail;
  103ba5:	8b 0c d5 90 7d 10 00 	mov    0x107d90(,%edx,8),%ecx
  103bac:	89 48 04             	mov    %ecx,0x4(%eax)

	list->tail->next = node;
  103baf:	8b 0c d5 90 7d 10 00 	mov    0x107d90(,%edx,8),%ecx
  103bb6:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
  103bb8:	89 04 d5 90 7d 10 00 	mov    %eax,0x107d90(,%edx,8)
	sys_dlist_remove(&thread->base.k_q_node);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? NULL : *cache;
  103bbf:	8b 15 94 7d 10 00    	mov    0x107d94,%edx
  103bc5:	39 d0                	cmp    %edx,%eax
  103bc7:	75 02                	jne    103bcb <_move_thread_to_end_of_prio_q+0x4e>
  103bc9:	31 d2                	xor    %edx,%edx
  103bcb:	89 15 94 7d 10 00    	mov    %edx,0x107d94
}
  103bd1:	5b                   	pop    %ebx
  103bd2:	5e                   	pop    %esi
  103bd3:	5d                   	pop    %ebp
  103bd4:	c3                   	ret    

00103bd5 <k_current_get>:
		_reschedule_threads(key);
	}
}

k_tid_t k_current_get(void)
{
  103bd5:	55                   	push   %ebp
	return _current;
}
  103bd6:	a1 88 7d 10 00       	mov    0x107d88,%eax
		_reschedule_threads(key);
	}
}

k_tid_t k_current_get(void)
{
  103bdb:	89 e5                	mov    %esp,%ebp
	return _current;
}
  103bdd:	5d                   	pop    %ebp
  103bde:	c3                   	ret    

00103bdf <_abort_timeout>:
}

/* returns 0 in success and -1 if the timer has expired */

static inline int _abort_timeout(struct _timeout *t)
{
  103bdf:	55                   	push   %ebp
  103be0:	89 c2                	mov    %eax,%edx
	sys_dlist_t *timeout_q = &_timeout_q;

	if (-1 == t->delta_ticks_from_prev) {
  103be2:	8b 40 10             	mov    0x10(%eax),%eax
}

/* returns 0 in success and -1 if the timer has expired */

static inline int _abort_timeout(struct _timeout *t)
{
  103be5:	89 e5                	mov    %esp,%ebp
	sys_dlist_t *timeout_q = &_timeout_q;

	if (-1 == t->delta_ticks_from_prev) {
  103be7:	83 f8 ff             	cmp    $0xffffffff,%eax
  103bea:	74 22                	je     103c0e <_abort_timeout+0x2f>
		return -1;
	}

	if (!sys_dlist_is_tail(timeout_q, &t->node)) {
  103bec:	3b 15 90 7d 10 00    	cmp    0x107d90,%edx
  103bf2:	74 05                	je     103bf9 <_abort_timeout+0x1a>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (!node || node == list->tail) ? NULL : node->next;
  103bf4:	8b 0a                	mov    (%edx),%ecx
		struct _timeout *next =
			(struct _timeout *)sys_dlist_peek_next(timeout_q,
								    &t->node);
		next->delta_ticks_from_prev += t->delta_ticks_from_prev;
  103bf6:	01 41 10             	add    %eax,0x10(%ecx)
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  103bf9:	8b 42 04             	mov    0x4(%edx),%eax
  103bfc:	8b 0a                	mov    (%edx),%ecx
  103bfe:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
  103c00:	8b 0a                	mov    (%edx),%ecx
  103c02:	89 41 04             	mov    %eax,0x4(%ecx)
	}
	sys_dlist_remove(&t->node);
	t->delta_ticks_from_prev = -1;
  103c05:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edx)

	return 0;
  103c0c:	31 c0                	xor    %eax,%eax
}
  103c0e:	5d                   	pop    %ebp
  103c0f:	c3                   	ret    

00103c10 <_unpend_first_thread>:
	return (struct k_thread *)sys_dlist_peek_head(wait_q);
}

/* unpend the first thread from a wait queue */
static inline struct k_thread *_unpend_first_thread(_wait_q_t *wait_q)
{
  103c10:	55                   	push   %ebp
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  103c11:	8b 10                	mov    (%eax),%edx
  103c13:	89 e5                	mov    %esp,%ebp

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node;

	if (sys_dlist_is_empty(list)) {
  103c15:	39 d0                	cmp    %edx,%eax
  103c17:	74 15                	je     103c2e <_unpend_first_thread+0x1e>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  103c19:	8b 42 04             	mov    0x4(%edx),%eax
  103c1c:	8b 0a                	mov    (%edx),%ecx
  103c1e:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
  103c20:	8b 0a                	mov    (%edx),%ecx
  103c22:	89 41 04             	mov    %eax,0x4(%ecx)
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.flags &= ~K_PENDING;
  103c25:	81 62 08 ff df ff ff 	andl   $0xffffdfff,0x8(%edx)
  103c2c:	eb 02                	jmp    103c30 <_unpend_first_thread+0x20>
static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node;

	if (sys_dlist_is_empty(list)) {
		return NULL;
  103c2e:	31 d2                	xor    %edx,%edx
	if (thread) {
		_mark_thread_as_not_pending(thread);
	}

	return thread;
}
  103c30:	89 d0                	mov    %edx,%eax
  103c32:	5d                   	pop    %ebp
  103c33:	c3                   	ret    

00103c34 <_ready_thread>:
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.flags &= ~K_PRESTART;
  103c34:	8b 50 08             	mov    0x8(%eax),%edx
  103c37:	89 d1                	mov    %edx,%ecx
  103c39:	80 e5 bf             	and    $0xbf,%ch
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  103c3c:	81 e2 00 a0 03 00    	and    $0x3a000,%edx
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.flags &= ~K_PRESTART;
  103c42:	89 48 08             	mov    %ecx,0x8(%eax)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  103c45:	75 11                	jne    103c58 <_ready_thread+0x24>
  103c47:	83 78 28 ff          	cmpl   $0xffffffff,0x28(%eax)
  103c4b:	75 0b                	jne    103c58 <_ready_thread+0x24>
 * blocked for another reason (eg. suspended).
 *
 * Must be called with interrupts locked.
 */
static inline void _ready_thread(struct k_thread *thread)
{
  103c4d:	55                   	push   %ebp
  103c4e:	89 e5                	mov    %esp,%ebp

	/* needed to handle the start-with-delay case */
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
		_add_thread_to_ready_q(thread);
  103c50:	50                   	push   %eax
  103c51:	e8 0a fd ff ff       	call   103960 <_add_thread_to_ready_q>
  103c56:	58                   	pop    %eax
	}
}
  103c57:	c9                   	leave  
  103c58:	c3                   	ret    

00103c59 <sem_give_common>:
 * @brief Common semaphore give code
 *
 * @return true if _Swap() will need to be invoked; false if not
 */
static bool sem_give_common(struct k_sem *sem)
{
  103c59:	55                   	push   %ebp
  103c5a:	89 e5                	mov    %esp,%ebp
  103c5c:	57                   	push   %edi
  103c5d:	56                   	push   %esi
  103c5e:	89 c6                	mov    %eax,%esi
  103c60:	53                   	push   %ebx
  103c61:	52                   	push   %edx
	struct k_thread *thread;

	thread = _unpend_first_thread(&sem->wait_q);
  103c62:	e8 a9 ff ff ff       	call   103c10 <_unpend_first_thread>
	if (!thread) {
  103c67:	85 c0                	test   %eax,%eax
  103c69:	75 17                	jne    103c82 <sem_give_common+0x29>
		/*
		 * No thread is waiting on the semaphore.
		 * Increment the semaphore's count unless
		 * its limit has already been reached.
		 */
		sem->count += (sem->count != sem->limit);
  103c6b:	8b 46 08             	mov    0x8(%esi),%eax
  103c6e:	31 d2                	xor    %edx,%edx
  103c70:	39 46 0c             	cmp    %eax,0xc(%esi)
  103c73:	0f 95 c2             	setne  %dl
  103c76:	01 d0                	add    %edx,%eax
  103c78:	89 46 08             	mov    %eax,0x8(%esi)
  103c7b:	31 c0                	xor    %eax,%eax
  103c7d:	e9 f5 00 00 00       	jmp    103d77 <sem_give_common+0x11e>
  103c82:	89 c3                	mov    %eax,%ebx

static inline int _abort_thread_timeout(struct k_thread *thread)
{
	return _abort_timeout(&thread->base.timeout);
  103c84:	8d 40 18             	lea    0x18(%eax),%eax
  103c87:	e8 53 ff ff ff       	call   103bdf <_abort_timeout>
	struct _sem_desc *desc = NULL;
	sys_dlist_t  *list;
	sys_dnode_t  *node;
	sys_dnode_t  *next;

	if (!(thread->base.flags & K_DUMMY)) {
  103c8c:	f6 43 0a 02          	testb  $0x2,0xa(%ebx)
  103c90:	0f 84 d1 00 00 00    	je     103d67 <sem_give_common+0x10e>
	/*
	 * The awakened thread is a dummy thread and thus was involved
	 * in a semaphore group operation.
	 */

	list = (sys_dlist_t *)dummy->desc.thread->base.swap_data;
  103c96:	8b 43 38             	mov    0x38(%ebx),%eax
  103c99:	8b 50 14             	mov    0x14(%eax),%edx
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  103c9c:	8b 1a                	mov    (%edx),%ebx
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  103c9e:	39 da                	cmp    %ebx,%edx
  103ca0:	75 45                	jne    103ce7 <sem_give_common+0x8e>
  103ca2:	31 db                	xor    %ebx,%ebx
  103ca4:	eb 41                	jmp    103ce7 <sem_give_common+0x8e>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (!node || node == list->tail) ? NULL : node->next;
  103ca6:	39 5a 04             	cmp    %ebx,0x4(%edx)
  103ca9:	74 02                	je     103cad <sem_give_common+0x54>
  103cab:	8b 3b                	mov    (%ebx),%edi
	do {
		next = sys_dlist_peek_next(list, node);

		desc = (struct _sem_desc *)node;

		if (desc->sem != sem) {
  103cad:	3b 73 0c             	cmp    0xc(%ebx),%esi
  103cb0:	74 2f                	je     103ce1 <sem_give_common+0x88>
  103cb2:	8d 43 e8             	lea    -0x18(%ebx),%eax
  103cb5:	89 55 f0             	mov    %edx,-0x10(%ebp)
  103cb8:	e8 22 ff ff ff       	call   103bdf <_abort_timeout>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  103cbd:	8b 43 d4             	mov    -0x2c(%ebx),%eax
  103cc0:	8b 4b d0             	mov    -0x30(%ebx),%ecx
	node->next->prev = node->prev;
  103cc3:	8b 55 f0             	mov    -0x10(%ebp),%edx
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  103cc6:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
  103cc8:	8b 4b d0             	mov    -0x30(%ebx),%ecx
  103ccb:	89 41 04             	mov    %eax,0x4(%ecx)
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  103cce:	8b 43 04             	mov    0x4(%ebx),%eax
  103cd1:	8b 0b                	mov    (%ebx),%ecx
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.flags &= ~K_PENDING;
  103cd3:	81 63 d8 ff df ff ff 	andl   $0xffffdfff,-0x28(%ebx)
  103cda:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
  103cdc:	8b 0b                	mov    (%ebx),%ecx
  103cde:	89 41 04             	mov    %eax,0x4(%ecx)
			_unpend_thread(dummy_thread);

			sys_dlist_remove(node);
		}
		node = next;
	} while (node != NULL);
  103ce1:	85 ff                	test   %edi,%edi
  103ce3:	74 0a                	je     103cef <sem_give_common+0x96>
  103ce5:	89 fb                	mov    %edi,%ebx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (!node || node == list->tail) ? NULL : node->next;
  103ce7:	31 ff                	xor    %edi,%edi
  103ce9:	85 db                	test   %ebx,%ebx
  103ceb:	75 b9                	jne    103ca6 <sem_give_common+0x4d>
  103ced:	eb be                	jmp    103cad <sem_give_common+0x54>
	 * As this code may be executed several times by a semaphore group give
	 * operation, it is important to ensure that the attempt to ready the
	 * master thread is done only once.
	 */

	if (!_is_thread_ready(desc->thread)) {
  103cef:	8b 43 08             	mov    0x8(%ebx),%eax
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  103cf2:	f7 40 08 00 e0 03 00 	testl  $0x3e000,0x8(%eax)
  103cf9:	75 06                	jne    103d01 <sem_give_common+0xa8>
  103cfb:	83 78 28 ff          	cmpl   $0xffffffff,0x28(%eax)
  103cff:	74 1e                	je     103d1f <sem_give_common+0xc6>
  103d01:	83 c0 18             	add    $0x18,%eax
  103d04:	e8 d6 fe ff ff       	call   103bdf <_abort_timeout>
		_abort_thread_timeout(desc->thread);
		_mark_thread_as_not_pending(desc->thread);
  103d09:	8b 43 08             	mov    0x8(%ebx),%eax
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.flags &= ~K_PENDING;
  103d0c:	8b 50 08             	mov    0x8(%eax),%edx
  103d0f:	89 d1                	mov    %edx,%ecx
  103d11:	80 e5 df             	and    $0xdf,%ch
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  103d14:	81 e2 00 c0 03 00    	and    $0x3c000,%edx
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.flags &= ~K_PENDING;
  103d1a:	89 48 08             	mov    %ecx,0x8(%eax)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  103d1d:	74 39                	je     103d58 <sem_give_common+0xff>
static ALWAYS_INLINE void
_set_thread_return_value(struct k_thread *thread, unsigned int value)
{
	/* write into 'eax' slot created in _Swap() entry */

	*(unsigned int *)(thread->callee_saved.esp) = value;
  103d1f:	8b 43 08             	mov    0x8(%ebx),%eax
  103d22:	8b 40 30             	mov    0x30(%eax),%eax
  103d25:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		/* Handle the non-group case */
		_ready_thread(thread);
		_set_thread_return_value(thread, 0);
	}

	return !_is_in_isr() && _must_switch_threads();
  103d2b:	83 3d 80 7d 10 00 00 	cmpl   $0x0,0x107d80
  103d32:	75 3f                	jne    103d73 <sem_give_common+0x11a>
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
  103d34:	a1 88 7d 10 00       	mov    0x107d88,%eax
}

/* is thread currently preemptible ? */
static inline int _is_preempt(struct k_thread *thread)
{
	return !_is_coop(thread) && !atomic_get(&thread->base.sched_locked);
  103d39:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
  103d3d:	78 34                	js     103d73 <sem_give_common+0x11a>
 * @return Value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_get(const atomic_t *target)
{
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
  103d3f:	8b 40 10             	mov    0x10(%eax),%eax
  103d42:	85 c0                	test   %eax,%eax
  103d44:	75 2d                	jne    103d73 <sem_give_common+0x11a>
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
  103d46:	e8 b8 fd ff ff       	call   103b03 <__must_switch_threads>
  103d4b:	85 c0                	test   %eax,%eax
  103d4d:	0f 95 c0             	setne  %al
  103d50:	0f b6 c0             	movzbl %al,%eax
  103d53:	83 e0 01             	and    $0x1,%eax
  103d56:	eb 1f                	jmp    103d77 <sem_give_common+0x11e>
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  103d58:	83 78 28 ff          	cmpl   $0xffffffff,0x28(%eax)
  103d5c:	75 c1                	jne    103d1f <sem_give_common+0xc6>

	if (!_is_thread_ready(desc->thread)) {
		_abort_thread_timeout(desc->thread);
		_mark_thread_as_not_pending(desc->thread);
		if (_is_thread_ready(desc->thread)) {
			_add_thread_to_ready_q(desc->thread);
  103d5e:	50                   	push   %eax
  103d5f:	e8 fc fb ff ff       	call   103960 <_add_thread_to_ready_q>
  103d64:	58                   	pop    %eax
  103d65:	eb b8                	jmp    103d1f <sem_give_common+0xc6>

	_abort_thread_timeout(thread);

	if (!handle_sem_group(sem, thread)) {
		/* Handle the non-group case */
		_ready_thread(thread);
  103d67:	89 d8                	mov    %ebx,%eax
  103d69:	e8 c6 fe ff ff       	call   103c34 <_ready_thread>
  103d6e:	8b 43 30             	mov    0x30(%ebx),%eax
  103d71:	eb b2                	jmp    103d25 <sem_give_common+0xcc>
		_set_thread_return_value(thread, 0);
	}

	return !_is_in_isr() && _must_switch_threads();
  103d73:	31 c0                	xor    %eax,%eax
  103d75:	eb dc                	jmp    103d53 <sem_give_common+0xfa>
}
  103d77:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103d7a:	5b                   	pop    %ebx
  103d7b:	5e                   	pop    %esi
  103d7c:	5f                   	pop    %edi
  103d7d:	5d                   	pop    %ebp
  103d7e:	c3                   	ret    

00103d7f <k_sem_init>:

#endif /* CONFIG_DEBUG_TRACING_KERNEL_OBJECTS */

void k_sem_init(struct k_sem *sem, unsigned int initial_count,
		unsigned int limit)
{
  103d7f:	55                   	push   %ebp
  103d80:	89 e5                	mov    %esp,%ebp
  103d82:	8b 45 08             	mov    0x8(%ebp),%eax
	__ASSERT(limit != 0, "limit cannot be zero");

	sem->count = initial_count;
  103d85:	8b 55 0c             	mov    0xc(%ebp),%edx
  103d88:	89 50 08             	mov    %edx,0x8(%eax)
	sem->limit = limit;
  103d8b:	8b 55 10             	mov    0x10(%ebp),%edx
  103d8e:	89 50 0c             	mov    %edx,0xc(%eax)
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  103d91:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
  103d93:	89 40 04             	mov    %eax,0x4(%eax)
	sys_dlist_init(&sem->wait_q);
	SYS_TRACING_OBJ_INIT(k_sem, sem);
}
  103d96:	5d                   	pop    %ebp
  103d97:	c3                   	ret    

00103d98 <k_sem_give>:
	irq_unlock(key);
}
#endif

void k_sem_give(struct k_sem *sem)
{
  103d98:	55                   	push   %ebp
  103d99:	89 e5                	mov    %esp,%ebp
  103d9b:	53                   	push   %ebx
  103d9c:	8b 45 08             	mov    0x8(%ebp),%eax
  103d9f:	9c                   	pushf  
  103da0:	fa                   	cli    
  103da1:	5b                   	pop    %ebx
	unsigned int   key;

	key = irq_lock();

	if (sem_give_common(sem)) {
  103da2:	e8 b2 fe ff ff       	call   103c59 <sem_give_common>
  103da7:	84 c0                	test   %al,%al
  103da9:	74 0a                	je     103db5 <k_sem_give+0x1d>
		_Swap(key);
  103dab:	89 5d 08             	mov    %ebx,0x8(%ebp)
	} else {
		irq_unlock(key);
	}
}
  103dae:	5b                   	pop    %ebx
  103daf:	5d                   	pop    %ebp
	unsigned int   key;

	key = irq_lock();

	if (sem_give_common(sem)) {
		_Swap(key);
  103db0:	e9 56 f6 ff ff       	jmp    10340b <_Swap>
  103db5:	80 e7 02             	and    $0x2,%bh
  103db8:	74 01                	je     103dbb <k_sem_give+0x23>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  103dba:	fb                   	sti    
	} else {
		irq_unlock(key);
	}
}
  103dbb:	5b                   	pop    %ebx
  103dbc:	5d                   	pop    %ebp
  103dbd:	c3                   	ret    

00103dbe <k_sem_take>:

int k_sem_take(struct k_sem *sem, int32_t timeout)
{
  103dbe:	55                   	push   %ebp
  103dbf:	89 e5                	mov    %esp,%ebp
  103dc1:	53                   	push   %ebx
  103dc2:	8b 55 08             	mov    0x8(%ebp),%edx
  103dc5:	8b 4d 0c             	mov    0xc(%ebp),%ecx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  103dc8:	9c                   	pushf  
  103dc9:	fa                   	cli    
  103dca:	5b                   	pop    %ebx
	__ASSERT(!_is_in_isr() || timeout == K_NO_WAIT, "");

	unsigned int key = irq_lock();

	if (likely(sem->count > 0)) {
  103dcb:	8b 42 08             	mov    0x8(%edx),%eax
  103dce:	85 c0                	test   %eax,%eax
  103dd0:	74 08                	je     103dda <k_sem_take+0x1c>
		sem->count--;
  103dd2:	48                   	dec    %eax
  103dd3:	89 42 08             	mov    %eax,0x8(%edx)
		irq_unlock(key);
		return 0;
  103dd6:	31 c0                	xor    %eax,%eax
  103dd8:	eb 09                	jmp    103de3 <k_sem_take+0x25>
	}

	if (timeout == K_NO_WAIT) {
  103dda:	85 c9                	test   %ecx,%ecx
  103ddc:	75 0d                	jne    103deb <k_sem_take+0x2d>
		irq_unlock(key);
		return -EBUSY;
  103dde:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  103de3:	80 e7 02             	and    $0x2,%bh
  103de6:	74 18                	je     103e00 <k_sem_take+0x42>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  103de8:	fb                   	sti    
  103de9:	eb 15                	jmp    103e00 <k_sem_take+0x42>
	}

	_pend_current_thread(&sem->wait_q, timeout);
  103deb:	51                   	push   %ecx
  103dec:	52                   	push   %edx
  103ded:	e8 cd fc ff ff       	call   103abf <_pend_current_thread>

	return _Swap(key);
  103df2:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
  103df5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	if (timeout == K_NO_WAIT) {
		irq_unlock(key);
		return -EBUSY;
	}

	_pend_current_thread(&sem->wait_q, timeout);
  103df8:	58                   	pop    %eax
  103df9:	5a                   	pop    %edx

	return _Swap(key);
}
  103dfa:	c9                   	leave  
		return -EBUSY;
	}

	_pend_current_thread(&sem->wait_q, timeout);

	return _Swap(key);
  103dfb:	e9 0b f6 ff ff       	jmp    10340b <_Swap>
}
  103e00:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  103e03:	c9                   	leave  
  103e04:	c3                   	ret    

00103e05 <_nano_sys_clock_tick_announce>:
 * timers that have expired and wake up the fibers pending on them.
 *
 * @return N/A
 */
void _nano_sys_clock_tick_announce(int32_t ticks)
{
  103e05:	55                   	push   %ebp
  103e06:	89 e5                	mov    %esp,%ebp
  103e08:	57                   	push   %edi
  103e09:	56                   	push   %esi
  103e0a:	53                   	push   %ebx
  103e0b:	51                   	push   %ecx
  103e0c:	8b 5d 08             	mov    0x8(%ebp),%ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  103e0f:	9c                   	pushf  
  103e10:	fa                   	cli    
  103e11:	8f 45 f0             	popl   -0x10(%ebp)
	unsigned int  key;

	K_DEBUG("ticks: %d\n", ticks);

	key = irq_lock();
	_sys_clock_tick_count += ticks;
  103e14:	89 d8                	mov    %ebx,%eax
  103e16:	99                   	cltd   
  103e17:	01 1d 18 7f 10 00    	add    %ebx,0x107f18
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  103e1d:	a1 8c 7d 10 00       	mov    0x107d8c,%eax
  103e22:	11 15 1c 7f 10 00    	adc    %edx,0x107f1c
		(struct _timeout *)sys_dlist_peek_head(&_timeout_q);

	K_DEBUG("head: %p, delta: %d\n",
		head, head ? head->delta_ticks_from_prev : -2112);

	if (head) {
  103e28:	3d 8c 7d 10 00       	cmp    $0x107d8c,%eax
  103e2d:	74 04                	je     103e33 <_nano_sys_clock_tick_announce+0x2e>
  103e2f:	85 c0                	test   %eax,%eax
  103e31:	75 13                	jne    103e46 <_nano_sys_clock_tick_announce+0x41>
int32_t _time_slice_duration = CONFIG_TIMESLICE_SIZE;
int  _time_slice_prio_ceiling = CONFIG_TIMESLICE_PRIORITY;

static void handle_time_slicing(int32_t ticks)
{
	if (_time_slice_duration == 0) {
  103e33:	8b 35 a0 7e 10 00    	mov    0x107ea0,%esi
  103e39:	85 f6                	test   %esi,%esi
  103e3b:	0f 85 a0 00 00 00    	jne    103ee1 <_nano_sys_clock_tick_announce+0xdc>
  103e41:	e9 eb 00 00 00       	jmp    103f31 <_nano_sys_clock_tick_announce+0x12c>

	K_DEBUG("head: %p, delta: %d\n",
		head, head ? head->delta_ticks_from_prev : -2112);

	if (head) {
		head->delta_ticks_from_prev -= ticks;
  103e46:	29 58 10             	sub    %ebx,0x10(%eax)
{
	sys_dlist_t *timeout_q = &_timeout_q;
	struct _timeout *next;

	next = (struct _timeout *)sys_dlist_peek_head(timeout_q);
	while (next && next->delta_ticks_from_prev == 0) {
  103e49:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  103e4d:	75 e4                	jne    103e33 <_nano_sys_clock_tick_announce+0x2e>
  103e4f:	8b 15 8c 7d 10 00    	mov    0x107d8c,%edx

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node;

	if (sys_dlist_is_empty(list)) {
  103e55:	81 fa 8c 7d 10 00    	cmp    $0x107d8c,%edx
  103e5b:	0f 84 e7 00 00 00    	je     103f48 <_nano_sys_clock_tick_announce+0x143>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  103e61:	8b 42 04             	mov    0x4(%edx),%eax
  103e64:	8b 0a                	mov    (%edx),%ecx
  103e66:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
  103e68:	8b 0a                	mov    (%edx),%ecx
  103e6a:	89 41 04             	mov    %eax,0x4(%ecx)
	sys_dlist_t *timeout_q)
{
	struct _timeout *t = (void *)sys_dlist_get(timeout_q);
	struct k_thread *thread = t->thread;

	t->delta_ticks_from_prev = -1;
  103e6d:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edx)

static inline struct _timeout *_handle_one_timeout(
	sys_dlist_t *timeout_q)
{
	struct _timeout *t = (void *)sys_dlist_get(timeout_q);
	struct k_thread *thread = t->thread;
  103e74:	8b 42 08             	mov    0x8(%edx),%eax

	t->delta_ticks_from_prev = -1;

	K_DEBUG("timeout %p\n", t);
	if (thread != NULL) {
  103e77:	85 c0                	test   %eax,%eax
  103e79:	74 3e                	je     103eb9 <_nano_sys_clock_tick_announce+0xb4>
/* remove a thread timing out from kernel object's wait queue */

static inline void _unpend_thread_timing_out(struct k_thread *thread,
					     struct _timeout *timeout_obj)
{
	if (timeout_obj->wait_q) {
  103e7b:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
  103e7f:	74 1a                	je     103e9b <_nano_sys_clock_tick_announce+0x96>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  103e81:	8b 50 04             	mov    0x4(%eax),%edx
  103e84:	8b 08                	mov    (%eax),%ecx
  103e86:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  103e88:	8b 08                	mov    (%eax),%ecx
  103e8a:	89 51 04             	mov    %edx,0x4(%ecx)
		_unpend_thread(thread);
		thread->base.timeout.wait_q = NULL;
  103e8d:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.flags &= ~K_PENDING;
  103e94:	81 60 08 ff df ff ff 	andl   $0xffffdfff,0x8(%eax)
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.flags &= ~K_PRESTART;
  103e9b:	8b 50 08             	mov    0x8(%eax),%edx
  103e9e:	89 d1                	mov    %edx,%ecx
  103ea0:	80 e5 bf             	and    $0xbf,%ch
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  103ea3:	81 e2 00 a0 03 00    	and    $0x3a000,%edx
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.flags &= ~K_PRESTART;
  103ea9:	89 48 08             	mov    %ecx,0x8(%eax)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  103eac:	75 16                	jne    103ec4 <_nano_sys_clock_tick_announce+0xbf>
  103eae:	83 78 28 ff          	cmpl   $0xffffffff,0x28(%eax)
  103eb2:	75 10                	jne    103ec4 <_nano_sys_clock_tick_announce+0xbf>
  103eb4:	e9 84 00 00 00       	jmp    103f3d <_nano_sys_clock_tick_announce+0x138>

	K_DEBUG("timeout %p\n", t);
	if (thread != NULL) {
		_unpend_thread_timing_out(thread, t);
		_ready_thread(thread);
	} else if (t->func) {
  103eb9:	8b 42 14             	mov    0x14(%edx),%eax
  103ebc:	85 c0                	test   %eax,%eax
  103ebe:	74 04                	je     103ec4 <_nano_sys_clock_tick_announce+0xbf>
		t->func(t);
  103ec0:	52                   	push   %edx
  103ec1:	ff d0                	call   *%eax
  103ec3:	5a                   	pop    %edx
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  103ec4:	a1 8c 7d 10 00       	mov    0x107d8c,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  103ec9:	3d 8c 7d 10 00       	cmp    $0x107d8c,%eax
  103ece:	0f 84 5f ff ff ff    	je     103e33 <_nano_sys_clock_tick_announce+0x2e>
{
	sys_dlist_t *timeout_q = &_timeout_q;
	struct _timeout *next;

	next = (struct _timeout *)sys_dlist_peek_head(timeout_q);
	while (next && next->delta_ticks_from_prev == 0) {
  103ed4:	85 c0                	test   %eax,%eax
  103ed6:	0f 85 6d ff ff ff    	jne    103e49 <_nano_sys_clock_tick_announce+0x44>
  103edc:	e9 52 ff ff ff       	jmp    103e33 <_nano_sys_clock_tick_announce+0x2e>
{
	if (_time_slice_duration == 0) {
		return;
	}

	if (_is_prio_higher(_current->base.prio, _time_slice_prio_ceiling)) {
  103ee1:	8b 3d 88 7d 10 00    	mov    0x107d88,%edi
  103ee7:	8b 47 0c             	mov    0xc(%edi),%eax
  103eea:	39 05 9c 7e 10 00    	cmp    %eax,0x107e9c
  103ef0:	7f 3f                	jg     103f31 <_nano_sys_clock_tick_announce+0x12c>

#define kpriority_t uint32_t

static inline int32_t _ticks_to_ms(int32_t ticks)
{
	return (ticks == TICKS_UNLIMITED) ? K_FOREVER : __ticks_to_ms(ticks);
  103ef2:	83 c8 ff             	or     $0xffffffff,%eax
  103ef5:	83 fb ff             	cmp    $0xffffffff,%ebx
  103ef8:	74 15                	je     103f0f <_nano_sys_clock_tick_announce+0x10a>
  103efa:	b8 e8 03 00 00       	mov    $0x3e8,%eax
  103eff:	6a 00                	push   $0x0
  103f01:	f7 eb                	imul   %ebx
  103f03:	6a 64                	push   $0x64
  103f05:	52                   	push   %edx
  103f06:	50                   	push   %eax
  103f07:	e8 34 c3 ff ff       	call   100240 <__udivdi3>
  103f0c:	83 c4 10             	add    $0x10,%esp
		return;
	}

	_time_slice_elapsed += _ticks_to_ms(ticks);
  103f0f:	03 05 10 7f 10 00    	add    0x107f10,%eax
	if (_time_slice_elapsed >= _time_slice_duration) {
  103f15:	39 c6                	cmp    %eax,%esi
  103f17:	7e 07                	jle    103f20 <_nano_sys_clock_tick_announce+0x11b>

	if (_is_prio_higher(_current->base.prio, _time_slice_prio_ceiling)) {
		return;
	}

	_time_slice_elapsed += _ticks_to_ms(ticks);
  103f19:	a3 10 7f 10 00       	mov    %eax,0x107f10
  103f1e:	eb 11                	jmp    103f31 <_nano_sys_clock_tick_announce+0x12c>
	if (_time_slice_elapsed >= _time_slice_duration) {
		_time_slice_elapsed = 0;
		_move_thread_to_end_of_prio_q(_current);
  103f20:	57                   	push   %edi
		return;
	}

	_time_slice_elapsed += _ticks_to_ms(ticks);
	if (_time_slice_elapsed >= _time_slice_duration) {
		_time_slice_elapsed = 0;
  103f21:	c7 05 10 7f 10 00 00 	movl   $0x0,0x107f10
  103f28:	00 00 00 
		_move_thread_to_end_of_prio_q(_current);
  103f2b:	e8 4d fc ff ff       	call   103b7d <_move_thread_to_end_of_prio_q>
  103f30:	58                   	pop    %eax
  103f31:	f7 45 f0 00 02 00 00 	testl  $0x200,-0x10(%ebp)
  103f38:	74 15                	je     103f4f <_nano_sys_clock_tick_announce+0x14a>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  103f3a:	fb                   	sti    
	handle_expired_timeouts(ticks);

	handle_time_slicing(ticks);

	irq_unlock(key);
}
  103f3b:	eb 12                	jmp    103f4f <_nano_sys_clock_tick_announce+0x14a>

	/* needed to handle the start-with-delay case */
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
		_add_thread_to_ready_q(thread);
  103f3d:	50                   	push   %eax
  103f3e:	e8 1d fa ff ff       	call   103960 <_add_thread_to_ready_q>
  103f43:	e9 7b ff ff ff       	jmp    103ec3 <_nano_sys_clock_tick_announce+0xbe>

static inline struct _timeout *_handle_one_timeout(
	sys_dlist_t *timeout_q)
{
	struct _timeout *t = (void *)sys_dlist_get(timeout_q);
	struct k_thread *thread = t->thread;
  103f48:	a1 08 00 00 00       	mov    0x8,%eax
  103f4d:	0f 0b                	ud2    
  103f4f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103f52:	5b                   	pop    %ebx
  103f53:	5e                   	pop    %esi
  103f54:	5f                   	pop    %edi
  103f55:	5d                   	pop    %ebp
  103f56:	c3                   	ret    

00103f57 <_is_thread_ready>:

}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
  103f57:	55                   	push   %ebp
  103f58:	89 e5                	mov    %esp,%ebp
	return !(_is_thread_prevented_from_running(thread) ||
  103f5a:	f7 40 08 00 e0 03 00 	testl  $0x3e000,0x8(%eax)
  103f61:	75 0c                	jne    103f6f <_is_thread_ready+0x18>
  103f63:	83 78 28 ff          	cmpl   $0xffffffff,0x28(%eax)
  103f67:	0f 94 c0             	sete   %al
  103f6a:	0f b6 c0             	movzbl %al,%eax
  103f6d:	eb 02                	jmp    103f71 <_is_thread_ready+0x1a>
  103f6f:	31 c0                	xor    %eax,%eax
		 _is_thread_timeout_active(thread));
}
  103f71:	5d                   	pop    %ebp
  103f72:	c3                   	ret    

00103f73 <_k_thread_single_start>:
	_sched_unlock_no_reschedule();
	_Swap(key);
}

void _k_thread_single_start(struct k_thread *thread)
{
  103f73:	55                   	push   %ebp
  103f74:	89 e5                	mov    %esp,%ebp
  103f76:	8b 55 08             	mov    0x8(%ebp),%edx
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
  103f79:	89 d0                	mov    %edx,%eax
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.flags &= ~K_PRESTART;
  103f7b:	81 62 08 ff bf ff ff 	andl   $0xffffbfff,0x8(%edx)
  103f82:	e8 d0 ff ff ff       	call   103f57 <_is_thread_ready>
  103f87:	85 c0                	test   %eax,%eax
  103f89:	74 09                	je     103f94 <_k_thread_single_start+0x21>
		_add_thread_to_ready_q(thread);
  103f8b:	89 55 08             	mov    %edx,0x8(%ebp)
	}
}
  103f8e:	5d                   	pop    %ebp
void _k_thread_single_start(struct k_thread *thread)
{
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
		_add_thread_to_ready_q(thread);
  103f8f:	e9 cc f9 ff ff       	jmp    103960 <_add_thread_to_ready_q>
	}
}
  103f94:	5d                   	pop    %ebp
  103f95:	c3                   	ret    

00103f96 <start_thread>:

	CODE_UNREACHABLE;
}

static void start_thread(struct k_thread *thread)
{
  103f96:	55                   	push   %ebp
  103f97:	89 c2                	mov    %eax,%edx
  103f99:	89 e5                	mov    %esp,%ebp
  103f9b:	53                   	push   %ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  103f9c:	9c                   	pushf  
  103f9d:	fa                   	cli    
  103f9e:	5b                   	pop    %ebx
  103f9f:	81 60 08 ff bf ff ff 	andl   $0xffffbfff,0x8(%eax)
	int key = irq_lock(); /* protect kernel queues */

	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
  103fa6:	e8 ac ff ff ff       	call   103f57 <_is_thread_ready>
  103fab:	85 c0                	test   %eax,%eax
  103fad:	74 2b                	je     103fda <start_thread+0x44>
		_add_thread_to_ready_q(thread);
  103faf:	52                   	push   %edx
  103fb0:	e8 ab f9 ff ff       	call   103960 <_add_thread_to_ready_q>
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
  103fb5:	a1 88 7d 10 00       	mov    0x107d88,%eax
  103fba:	5a                   	pop    %edx
}

/* is thread currently preemptible ? */
static inline int _is_preempt(struct k_thread *thread)
{
	return !_is_coop(thread) && !atomic_get(&thread->base.sched_locked);
  103fbb:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
  103fbf:	78 19                	js     103fda <start_thread+0x44>
  103fc1:	8b 40 10             	mov    0x10(%eax),%eax
  103fc4:	85 c0                	test   %eax,%eax
  103fc6:	75 12                	jne    103fda <start_thread+0x44>
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
  103fc8:	e8 36 fb ff ff       	call   103b03 <__must_switch_threads>
  103fcd:	85 c0                	test   %eax,%eax
  103fcf:	74 09                	je     103fda <start_thread+0x44>
		if (_must_switch_threads()) {
			_Swap(key);
  103fd1:	53                   	push   %ebx
  103fd2:	e8 34 f4 ff ff       	call   10340b <_Swap>
  103fd7:	58                   	pop    %eax
			return;
  103fd8:	eb 06                	jmp    103fe0 <start_thread+0x4a>
  103fda:	80 e7 02             	and    $0x2,%bh
  103fdd:	74 01                	je     103fe0 <start_thread+0x4a>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  103fdf:	fb                   	sti    
		}
	}

	irq_unlock(key);
}
  103fe0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  103fe3:	c9                   	leave  
  103fe4:	c3                   	ret    

00103fe5 <_abort_timeout>:
}

/* returns 0 in success and -1 if the timer has expired */

static inline int _abort_timeout(struct _timeout *t)
{
  103fe5:	55                   	push   %ebp
  103fe6:	89 c2                	mov    %eax,%edx
	sys_dlist_t *timeout_q = &_timeout_q;

	if (-1 == t->delta_ticks_from_prev) {
  103fe8:	8b 40 10             	mov    0x10(%eax),%eax
}

/* returns 0 in success and -1 if the timer has expired */

static inline int _abort_timeout(struct _timeout *t)
{
  103feb:	89 e5                	mov    %esp,%ebp
	sys_dlist_t *timeout_q = &_timeout_q;

	if (-1 == t->delta_ticks_from_prev) {
  103fed:	83 f8 ff             	cmp    $0xffffffff,%eax
  103ff0:	74 22                	je     104014 <_abort_timeout+0x2f>
		return -1;
	}

	if (!sys_dlist_is_tail(timeout_q, &t->node)) {
  103ff2:	3b 15 90 7d 10 00    	cmp    0x107d90,%edx
  103ff8:	74 05                	je     103fff <_abort_timeout+0x1a>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (!node || node == list->tail) ? NULL : node->next;
  103ffa:	8b 0a                	mov    (%edx),%ecx
		struct _timeout *next =
			(struct _timeout *)sys_dlist_peek_next(timeout_q,
								    &t->node);
		next->delta_ticks_from_prev += t->delta_ticks_from_prev;
  103ffc:	01 41 10             	add    %eax,0x10(%ecx)
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  103fff:	8b 42 04             	mov    0x4(%edx),%eax
  104002:	8b 0a                	mov    (%edx),%ecx
  104004:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
  104006:	8b 0a                	mov    (%edx),%ecx
  104008:	89 41 04             	mov    %eax,0x4(%ecx)
	}
	sys_dlist_remove(&t->node);
	t->delta_ticks_from_prev = -1;
  10400b:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edx)

	return 0;
  104012:	31 c0                	xor    %eax,%eax
}
  104014:	5d                   	pop    %ebp
  104015:	c3                   	ret    

00104016 <_sched_lock>:
 * Must be kept in sync until the header files are cleaned-up and the
 * applications have access to the kernel internal deta structures (through
 * APIs of course).
 */
static inline void _sched_lock(void)
{
  104016:	55                   	push   %ebp
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  104017:	a1 88 7d 10 00       	mov    0x107d88,%eax
  10401c:	89 e5                	mov    %esp,%ebp
  10401e:	f0 ff 40 10          	lock incl 0x10(%eax)

	atomic_inc(&_current->base.sched_locked);

	K_DEBUG("scheduler locked (%p:%d)\n",
		_current, _current->base.sched_locked);
}
  104022:	5d                   	pop    %ebp
  104023:	c3                   	ret    

00104024 <schedule_new_thread.part.13>:

static void schedule_new_thread(struct k_thread *thread, int32_t delay)
  104024:	55                   	push   %ebp
  104025:	89 e5                	mov    %esp,%ebp
  104027:	57                   	push   %edi
  104028:	56                   	push   %esi
  104029:	53                   	push   %ebx
  10402a:	89 c3                	mov    %eax,%ebx
{
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (delay == 0) {
		start_thread(thread);
	} else {
		int32_t ticks = _TICK_ALIGN + _ms_to_ticks(delay);
  10402c:	52                   	push   %edx
  10402d:	e8 e9 f9 ff ff       	call   103a1b <_ms_to_ticks>
  104032:	5a                   	pop    %edx

	K_DEBUG("timeout   %p before: next: %p, prev: %p\n",
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
	timeout_obj->delta_ticks_from_prev = timeout;
  104033:	40                   	inc    %eax
 */

static inline void _add_thread_timeout(struct k_thread *thread,
				       _wait_q_t *wait_q, int32_t timeout)
{
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout);
  104034:	8d 53 18             	lea    0x18(%ebx),%edx

	K_DEBUG("timeout   %p before: next: %p, prev: %p\n",
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
	timeout_obj->delta_ticks_from_prev = timeout;
  104037:	89 43 28             	mov    %eax,0x28(%ebx)
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  10403a:	a1 8c 7d 10 00       	mov    0x107d8c,%eax
		_timeout_q.tail);

	K_DEBUG("timeout   %p before: next: %p, prev: %p\n",
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
  10403f:	89 5b 20             	mov    %ebx,0x20(%ebx)
	timeout_obj->delta_ticks_from_prev = timeout;
	timeout_obj->wait_q = (sys_dlist_t *)wait_q;
  104042:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (!node || node == list->tail) ? NULL : node->next;
  104049:	8b 3d 90 7d 10 00    	mov    0x107d90,%edi
 */

static inline void sys_dlist_insert_at(sys_dlist_t *list, sys_dnode_t *node,
	int (*cond)(sys_dnode_t *, void *), void *data)
{
	if (sys_dlist_is_empty(list)) {
  10404f:	3d 8c 7d 10 00       	cmp    $0x107d8c,%eax
  104054:	74 33                	je     104089 <schedule_new_thread.part.13+0x65>
		sys_dlist_append(list, node);
	} else {
		sys_dnode_t *pos = sys_dlist_peek_head(list);

		while (pos && !cond(pos, data)) {
  104056:	85 c0                	test   %eax,%eax
  104058:	74 2f                	je     104089 <schedule_new_thread.part.13+0x65>
static int _is_timeout_insert_point(sys_dnode_t *test, void *timeout)
{
	struct _timeout *t = (void *)test;
	int32_t *timeout_to_insert = timeout;

	if (*timeout_to_insert > t->delta_ticks_from_prev) {
  10405a:	8b 73 28             	mov    0x28(%ebx),%esi
  10405d:	8b 48 10             	mov    0x10(%eax),%ecx
  104060:	39 ce                	cmp    %ecx,%esi
  104062:	7e 0d                	jle    104071 <schedule_new_thread.part.13+0x4d>
		*timeout_to_insert -= t->delta_ticks_from_prev;
  104064:	29 ce                	sub    %ecx,%esi
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (!node || node == list->tail) ? NULL : node->next;
  104066:	39 f8                	cmp    %edi,%eax
  104068:	89 73 28             	mov    %esi,0x28(%ebx)
  10406b:	74 1c                	je     104089 <schedule_new_thread.part.13+0x65>
  10406d:	8b 00                	mov    (%eax),%eax
  10406f:	eb e5                	jmp    104056 <schedule_new_thread.part.13+0x32>
		return 0;
	}

	t->delta_ticks_from_prev -= *timeout_to_insert;
  104071:	29 f1                	sub    %esi,%ecx
  104073:	89 48 10             	mov    %ecx,0x10(%eax)
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  104076:	8b 48 04             	mov    0x4(%eax),%ecx
  104079:	89 4b 1c             	mov    %ecx,0x1c(%ebx)
		node->next = insert_point;
  10407c:	89 43 18             	mov    %eax,0x18(%ebx)
		insert_point->prev->next = node;
  10407f:	8b 48 04             	mov    0x4(%eax),%ecx
  104082:	89 11                	mov    %edx,(%ecx)
		insert_point->prev = node;
  104084:	89 50 04             	mov    %edx,0x4(%eax)
  104087:	eb 17                	jmp    1040a0 <schedule_new_thread.part.13+0x7c>
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
	node->prev = list->tail;
  104089:	a1 90 7d 10 00       	mov    0x107d90,%eax
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  10408e:	c7 43 18 8c 7d 10 00 	movl   $0x107d8c,0x18(%ebx)
	node->prev = list->tail;
  104095:	89 43 1c             	mov    %eax,0x1c(%ebx)

	list->tail->next = node;
  104098:	89 10                	mov    %edx,(%eax)
	list->tail = node;
  10409a:	89 15 90 7d 10 00    	mov    %edx,0x107d90
	}
#else
	ARG_UNUSED(delay);
	start_thread(thread);
#endif
}
  1040a0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1040a3:	5b                   	pop    %ebx
  1040a4:	5e                   	pop    %esi
  1040a5:	5f                   	pop    %edi
  1040a6:	5d                   	pop    %ebp
  1040a7:	c3                   	ret    

001040a8 <k_is_in_isr>:

	return NANO_CTX_TASK;
}

int k_is_in_isr(void)
{
  1040a8:	55                   	push   %ebp
	return _is_in_isr();
  1040a9:	31 c0                	xor    %eax,%eax

	return NANO_CTX_TASK;
}

int k_is_in_isr(void)
{
  1040ab:	89 e5                	mov    %esp,%ebp
	return _is_in_isr();
}
  1040ad:	5d                   	pop    %ebp
	return NANO_CTX_TASK;
}

int k_is_in_isr(void)
{
	return _is_in_isr();
  1040ae:	83 3d 80 7d 10 00 00 	cmpl   $0x0,0x107d80
  1040b5:	0f 95 c0             	setne  %al
}
  1040b8:	c3                   	ret    

001040b9 <_is_thread_essential>:
 *
 * Returns non-zero if current thread is essential, zero if it is not.
 */
int _is_thread_essential(void)
{
	return _current->base.flags & K_ESSENTIAL;
  1040b9:	a1 88 7d 10 00       	mov    0x107d88,%eax
 * This routine indicates if the current thread is an essential system thread.
 *
 * Returns non-zero if current thread is essential, zero if it is not.
 */
int _is_thread_essential(void)
{
  1040be:	55                   	push   %ebp
  1040bf:	89 e5                	mov    %esp,%ebp
	return _current->base.flags & K_ESSENTIAL;
}
  1040c1:	5d                   	pop    %ebp
 *
 * Returns non-zero if current thread is essential, zero if it is not.
 */
int _is_thread_essential(void)
{
	return _current->base.flags & K_ESSENTIAL;
  1040c2:	8b 40 08             	mov    0x8(%eax),%eax
  1040c5:	25 00 02 00 00       	and    $0x200,%eax
}
  1040ca:	c3                   	ret    

001040cb <_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void _thread_entry(void (*entry)(void *, void *, void *),
				 void *p1, void *p2, void *p3)
{
  1040cb:	55                   	push   %ebp
  1040cc:	89 e5                	mov    %esp,%ebp
	entry(p1, p2, p3);
  1040ce:	ff 75 14             	pushl  0x14(%ebp)
  1040d1:	ff 75 10             	pushl  0x10(%ebp)
  1040d4:	ff 75 0c             	pushl  0xc(%ebp)
  1040d7:	ff 55 08             	call   *0x8(%ebp)
  1040da:	83 c4 0c             	add    $0xc,%esp

	if (_is_thread_essential()) {
  1040dd:	e8 d7 ff ff ff       	call   1040b9 <_is_thread_essential>
  1040e2:	85 c0                	test   %eax,%eax
  1040e4:	74 0c                	je     1040f2 <_thread_entry+0x27>
		_NanoFatalErrorHandler(_NANO_ERR_INVALID_TASK_EXIT,
  1040e6:	68 40 65 10 00       	push   $0x106540
  1040eb:	6a 03                	push   $0x3
  1040ed:	e8 b2 f3 ff ff       	call   1034a4 <_NanoFatalErrorHandler>
				       &_default_esf);
	}

	k_thread_abort(_current);
  1040f2:	ff 35 88 7d 10 00    	pushl  0x107d88
  1040f8:	e8 de 01 00 00       	call   1042db <k_thread_abort>
  1040fd:	58                   	pop    %eax

001040fe <k_thread_spawn>:

k_tid_t k_thread_spawn(char *stack, size_t stack_size,
			void (*entry)(void *, void *, void*),
			void *p1, void *p2, void *p3,
			int prio, uint32_t options, int32_t delay)
{
  1040fe:	55                   	push   %ebp
  1040ff:	89 e5                	mov    %esp,%ebp
  104101:	56                   	push   %esi
  104102:	53                   	push   %ebx
	__ASSERT(!_is_in_isr(), "");

	struct k_thread *new_thread = (struct k_thread *)stack;

	_new_thread(stack, stack_size, entry, p1, p2, p3, prio, options);
  104103:	ff 75 24             	pushl  0x24(%ebp)
  104106:	ff 75 20             	pushl  0x20(%ebp)
  104109:	ff 75 1c             	pushl  0x1c(%ebp)
  10410c:	ff 75 18             	pushl  0x18(%ebp)
  10410f:	ff 75 14             	pushl  0x14(%ebp)
  104112:	ff 75 10             	pushl  0x10(%ebp)
  104115:	ff 75 0c             	pushl  0xc(%ebp)

k_tid_t k_thread_spawn(char *stack, size_t stack_size,
			void (*entry)(void *, void *, void*),
			void *p1, void *p2, void *p3,
			int prio, uint32_t options, int32_t delay)
{
  104118:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10411b:	8b 75 28             	mov    0x28(%ebp),%esi
	__ASSERT(!_is_in_isr(), "");

	struct k_thread *new_thread = (struct k_thread *)stack;

	_new_thread(stack, stack_size, entry, p1, p2, p3, prio, options);
  10411e:	53                   	push   %ebx
  10411f:	e8 12 f3 ff ff       	call   103436 <_new_thread>
  104124:	83 c4 20             	add    $0x20,%esp
}

static void schedule_new_thread(struct k_thread *thread, int32_t delay)
{
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (delay == 0) {
  104127:	85 f6                	test   %esi,%esi
  104129:	75 09                	jne    104134 <k_thread_spawn+0x36>
		start_thread(thread);
  10412b:	89 d8                	mov    %ebx,%eax
  10412d:	e8 64 fe ff ff       	call   103f96 <start_thread>
  104132:	eb 09                	jmp    10413d <k_thread_spawn+0x3f>
  104134:	89 f2                	mov    %esi,%edx
  104136:	89 d8                	mov    %ebx,%eax
  104138:	e8 e7 fe ff ff       	call   104024 <schedule_new_thread.part.13>
	_new_thread(stack, stack_size, entry, p1, p2, p3, prio, options);

	schedule_new_thread(new_thread, delay);

	return new_thread;
}
  10413d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  104140:	89 d8                	mov    %ebx,%eax
  104142:	5b                   	pop    %ebx
  104143:	5e                   	pop    %esi
  104144:	5d                   	pop    %ebp
  104145:	c3                   	ret    

00104146 <_k_thread_group_op>:
{
	return !!(thread_data->init_groups & groups);
}

void _k_thread_group_op(uint32_t groups, void (*func)(struct k_thread *))
{
  104146:	55                   	push   %ebp
  104147:	89 e5                	mov    %esp,%ebp
  104149:	57                   	push   %edi
  10414a:	56                   	push   %esi
  10414b:	53                   	push   %ebx
  10414c:	52                   	push   %edx

	_sched_lock();

	/* Invoke func() on each static thread in the specified group set. */

	_FOREACH_STATIC_THREAD(thread_data) {
  10414d:	bf 40 72 10 00       	mov    $0x107240,%edi
{
	return !!(thread_data->init_groups & groups);
}

void _k_thread_group_op(uint32_t groups, void (*func)(struct k_thread *))
{
  104152:	8b 5d 08             	mov    0x8(%ebp),%ebx
  104155:	8b 75 0c             	mov    0xc(%ebp),%esi
	unsigned int  key;

	__ASSERT(!_is_in_isr(), "");

	_sched_lock();
  104158:	e8 b9 fe ff ff       	call   104016 <_sched_lock>

	/* Invoke func() on each static thread in the specified group set. */

	_FOREACH_STATIC_THREAD(thread_data) {
  10415d:	81 ff 40 72 10 00    	cmp    $0x107240,%edi
  104163:	73 1e                	jae    104183 <_k_thread_group_op+0x3d>
		if (is_in_any_group(thread_data, groups)) {
  104165:	85 5f 28             	test   %ebx,0x28(%edi)
  104168:	74 14                	je     10417e <_k_thread_group_op+0x38>

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  10416a:	9c                   	pushf  
  10416b:	fa                   	cli    
  10416c:	8f 45 f0             	popl   -0x10(%ebp)
			key = irq_lock();
			func(thread_data->thread);
  10416f:	ff 37                	pushl  (%edi)
  104171:	ff d6                	call   *%esi
  104173:	58                   	pop    %eax
  104174:	f7 45 f0 00 02 00 00 	testl  $0x200,-0x10(%ebp)
  10417b:	74 01                	je     10417e <_k_thread_group_op+0x38>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  10417d:	fb                   	sti    

	_sched_lock();

	/* Invoke func() on each static thread in the specified group set. */

	_FOREACH_STATIC_THREAD(thread_data) {
  10417e:	83 c7 2c             	add    $0x2c,%edi
  104181:	eb da                	jmp    10415d <_k_thread_group_op+0x17>

	/*
	 * If the current thread is still in a ready state, then let the
	 * "unlock scheduler" code determine if any rescheduling is needed.
	 */
	if (_is_thread_ready(_current)) {
  104183:	a1 88 7d 10 00       	mov    0x107d88,%eax
  104188:	e8 ca fd ff ff       	call   103f57 <_is_thread_ready>
  10418d:	85 c0                	test   %eax,%eax
  10418f:	74 0c                	je     10419d <_k_thread_group_op+0x57>

	/* The current thread is no longer in a ready state--reschedule. */
	key = irq_lock();
	_sched_unlock_no_reschedule();
	_Swap(key);
}
  104191:	8d 65 f4             	lea    -0xc(%ebp),%esp
  104194:	5b                   	pop    %ebx
  104195:	5e                   	pop    %esi
  104196:	5f                   	pop    %edi
  104197:	5d                   	pop    %ebp
	/*
	 * If the current thread is still in a ready state, then let the
	 * "unlock scheduler" code determine if any rescheduling is needed.
	 */
	if (_is_thread_ready(_current)) {
		k_sched_unlock();
  104198:	e9 b2 f9 ff ff       	jmp    103b4f <k_sched_unlock>

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  10419d:	9c                   	pushf  
  10419e:	fa                   	cli    
  10419f:	5a                   	pop    %edx
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
  1041a0:	a1 88 7d 10 00       	mov    0x107d88,%eax
  1041a5:	f0 ff 48 10          	lock decl 0x10(%eax)
	}

	/* The current thread is no longer in a ready state--reschedule. */
	key = irq_lock();
	_sched_unlock_no_reschedule();
	_Swap(key);
  1041a9:	89 55 08             	mov    %edx,0x8(%ebp)
}
  1041ac:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1041af:	5b                   	pop    %ebx
  1041b0:	5e                   	pop    %esi
  1041b1:	5f                   	pop    %edi
  1041b2:	5d                   	pop    %ebp
	}

	/* The current thread is no longer in a ready state--reschedule. */
	key = irq_lock();
	_sched_unlock_no_reschedule();
	_Swap(key);
  1041b3:	e9 53 f2 ff ff       	jmp    10340b <_Swap>

001041b8 <_k_thread_single_abort>:

	_reschedule_threads(key);
}

void _k_thread_single_abort(struct k_thread *thread)
{
  1041b8:	55                   	push   %ebp
  1041b9:	89 e5                	mov    %esp,%ebp
  1041bb:	53                   	push   %ebx
  1041bc:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (thread->fn_abort != NULL) {
  1041bf:	8b 43 38             	mov    0x38(%ebx),%eax
  1041c2:	85 c0                	test   %eax,%eax
  1041c4:	74 02                	je     1041c8 <_k_thread_single_abort+0x10>
		thread->fn_abort();
  1041c6:	ff d0                	call   *%eax
	}

	if (_is_thread_ready(thread)) {
  1041c8:	89 d8                	mov    %ebx,%eax
  1041ca:	e8 88 fd ff ff       	call   103f57 <_is_thread_ready>
  1041cf:	85 c0                	test   %eax,%eax
  1041d1:	74 09                	je     1041dc <_k_thread_single_abort+0x24>
		_remove_thread_from_ready_q(thread);
  1041d3:	53                   	push   %ebx
  1041d4:	e8 ec f7 ff ff       	call   1039c5 <_remove_thread_from_ready_q>
  1041d9:	58                   	pop    %eax
  1041da:	eb 28                	jmp    104204 <_k_thread_single_abort+0x4c>
  1041dc:	8b 43 08             	mov    0x8(%ebx),%eax
	} else {
		if (_is_thread_pending(thread)) {
  1041df:	f6 c4 20             	test   $0x20,%ah
  1041e2:	74 12                	je     1041f6 <_k_thread_single_abort+0x3e>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  1041e4:	8b 53 04             	mov    0x4(%ebx),%edx
  1041e7:	8b 0b                	mov    (%ebx),%ecx
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.flags &= ~K_PENDING;
  1041e9:	80 e4 df             	and    $0xdf,%ah
  1041ec:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  1041ee:	8b 0b                	mov    (%ebx),%ecx
  1041f0:	89 51 04             	mov    %edx,0x4(%ecx)
  1041f3:	89 43 08             	mov    %eax,0x8(%ebx)
			_unpend_thread(thread);
		}
		if (_is_thread_timeout_active(thread)) {
  1041f6:	83 7b 28 ff          	cmpl   $0xffffffff,0x28(%ebx)
  1041fa:	74 08                	je     104204 <_k_thread_single_abort+0x4c>
	return 0;
}

static inline int _abort_thread_timeout(struct k_thread *thread)
{
	return _abort_timeout(&thread->base.timeout);
  1041fc:	8d 43 18             	lea    0x18(%ebx),%eax
  1041ff:	e8 e1 fd ff ff       	call   103fe5 <_abort_timeout>
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_dead(struct k_thread *thread)
{
	thread->base.flags |= K_DEAD;
  104204:	81 4b 08 00 80 00 00 	orl    $0x8000,0x8(%ebx)
			_abort_thread_timeout(thread);
		}
	}
	_mark_thread_as_dead(thread);
}
  10420b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10420e:	c9                   	leave  
  10420f:	c3                   	ret    

00104210 <_init_static_threads>:

void _init_static_threads(void)
{
  104210:	55                   	push   %ebp
  104211:	89 e5                	mov    %esp,%ebp
  104213:	56                   	push   %esi
  104214:	53                   	push   %ebx
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
  104215:	bb 40 72 10 00       	mov    $0x107240,%ebx
  10421a:	81 fb 40 72 10 00    	cmp    $0x107240,%ebx
  104220:	73 29                	jae    10424b <_init_static_threads+0x3b>
		_task_group_adjust(thread_data);
		_new_thread(
  104222:	ff 73 1c             	pushl  0x1c(%ebx)
  104225:	ff 73 18             	pushl  0x18(%ebx)
  104228:	ff 73 14             	pushl  0x14(%ebx)
  10422b:	ff 73 10             	pushl  0x10(%ebx)
  10422e:	ff 73 0c             	pushl  0xc(%ebx)
  104231:	ff 73 08             	pushl  0x8(%ebx)
  104234:	ff 73 04             	pushl  0x4(%ebx)
  104237:	ff 33                	pushl  (%ebx)
  104239:	e8 f8 f1 ff ff       	call   103436 <_new_thread>
			thread_data->init_p2,
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options);

		thread_data->thread->init_data = thread_data;
  10423e:	8b 03                	mov    (%ebx),%eax
{
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
		_task_group_adjust(thread_data);
		_new_thread(
  104240:	83 c4 20             	add    $0x20,%esp
			thread_data->init_p2,
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options);

		thread_data->thread->init_data = thread_data;
  104243:	89 58 34             	mov    %ebx,0x34(%eax)

void _init_static_threads(void)
{
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
  104246:	83 c3 2c             	add    $0x2c,%ebx
  104249:	eb cf                	jmp    10421a <_init_static_threads+0xa>
			thread_data->init_options);

		thread_data->thread->init_data = thread_data;
	}

	_sched_lock();
  10424b:	e8 c6 fd ff ff       	call   104016 <_sched_lock>
	/* Start all (legacy) threads that are part of the EXE task group */
	_k_thread_group_op(K_TASK_GROUP_EXE, _k_thread_single_start);
  104250:	68 73 3f 10 00       	push   $0x103f73
  104255:	6a 01                	push   $0x1
  104257:	e8 ea fe ff ff       	call   104146 <_k_thread_group_op>
  10425c:	58                   	pop    %eax
  10425d:	5a                   	pop    %edx
  10425e:	9c                   	pushf  
  10425f:	fa                   	cli    
  104260:	5e                   	pop    %esi
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
  104261:	bb 40 72 10 00       	mov    $0x107240,%ebx
  104266:	81 fb 40 72 10 00    	cmp    $0x107240,%ebx
  10426c:	73 1f                	jae    10428d <_init_static_threads+0x7d>
		if (thread_data->init_delay != K_FOREVER) {
  10426e:	8b 53 20             	mov    0x20(%ebx),%edx
  104271:	83 fa ff             	cmp    $0xffffffff,%edx
  104274:	74 12                	je     104288 <_init_static_threads+0x78>
			schedule_new_thread(thread_data->thread,
  104276:	8b 03                	mov    (%ebx),%eax
}

static void schedule_new_thread(struct k_thread *thread, int32_t delay)
{
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (delay == 0) {
  104278:	85 d2                	test   %edx,%edx
  10427a:	75 07                	jne    104283 <_init_static_threads+0x73>
		start_thread(thread);
  10427c:	e8 15 fd ff ff       	call   103f96 <start_thread>
  104281:	eb 05                	jmp    104288 <_init_static_threads+0x78>
  104283:	e8 9c fd ff ff       	call   104024 <schedule_new_thread.part.13>
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
  104288:	83 c3 2c             	add    $0x2c,%ebx
  10428b:	eb d9                	jmp    104266 <_init_static_threads+0x56>
  10428d:	81 e6 00 02 00 00    	and    $0x200,%esi
  104293:	74 01                	je     104296 <_init_static_threads+0x86>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  104295:	fb                   	sti    
					    thread_data->init_delay);
		}
	}
	irq_unlock(key);
	k_sched_unlock();
}
  104296:	8d 65 f8             	lea    -0x8(%ebp),%esp
  104299:	5b                   	pop    %ebx
  10429a:	5e                   	pop    %esi
  10429b:	5d                   	pop    %ebp
			schedule_new_thread(thread_data->thread,
					    thread_data->init_delay);
		}
	}
	irq_unlock(key);
	k_sched_unlock();
  10429c:	e9 ae f8 ff ff       	jmp    103b4f <k_sched_unlock>

001042a1 <_init_thread_base>:
}

void _init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
  1042a1:	55                   	push   %ebp
  1042a2:	89 e5                	mov    %esp,%ebp
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->flags = options | initial_state;
  1042a4:	8b 55 14             	mov    0x14(%ebp),%edx
	k_sched_unlock();
}

void _init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
  1042a7:	8b 45 08             	mov    0x8(%ebp),%eax
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->flags = options | initial_state;
  1042aa:	0b 55 10             	or     0x10(%ebp),%edx
  1042ad:	89 50 08             	mov    %edx,0x8(%eax)

	thread_base->prio = priority;
  1042b0:	8b 55 0c             	mov    0xc(%ebp),%edx
  1042b3:	89 50 0c             	mov    %edx,0xc(%eax)

	thread_base->sched_locked = 0;
  1042b6:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	/*
	 * Must be initialized here and when dequeueing a timeout so that code
	 * not dealing with timeouts does not have to handle this, such as when
	 * waiting forever on a semaphore.
	 */
	t->delta_ticks_from_prev = -1;
  1042bd:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)

	/*
	 * Must be initialized here so that the _fiber_wakeup family of APIs can
	 * verify the fiber is not on a wait queue before aborting a timeout.
	 */
	t->wait_q = NULL;
  1042c4:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)

	/*
	 * Must be initialized here, so the _handle_one_timeout()
	 * routine can check if there is a fiber waiting on this timeout
	 */
	t->thread = NULL;
  1042cb:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)

	/*
	 * Function must be initialized before being potentially called.
	 */
	t->func = func;
  1042d2:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)

	/* swap_data does not need to be initialized */

	_init_thread_timeout(thread_base);
}
  1042d9:	5d                   	pop    %ebp
  1042da:	c3                   	ret    

001042db <k_thread_abort>:

extern void _k_thread_single_abort(struct k_thread *thread);

#if !defined(CONFIG_ARCH_HAS_NANO_FIBER_ABORT)
void k_thread_abort(k_tid_t thread)
{
  1042db:	55                   	push   %ebp
  1042dc:	89 e5                	mov    %esp,%ebp
  1042de:	56                   	push   %esi
  1042df:	53                   	push   %ebx
  1042e0:	8b 75 08             	mov    0x8(%ebp),%esi

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1042e3:	9c                   	pushf  
  1042e4:	fa                   	cli    
  1042e5:	5b                   	pop    %ebx
	unsigned int key;

	key = irq_lock();

	_k_thread_single_abort(thread);
  1042e6:	56                   	push   %esi
  1042e7:	e8 cc fe ff ff       	call   1041b8 <_k_thread_single_abort>
  1042ec:	5a                   	pop    %edx
	_thread_monitor_exit(thread);

	if (_current == thread) {
  1042ed:	3b 35 88 7d 10 00    	cmp    0x107d88,%esi
  1042f3:	75 07                	jne    1042fc <k_thread_abort+0x21>
		_Swap(key);
  1042f5:	53                   	push   %ebx
  1042f6:	e8 10 f1 ff ff       	call   10340b <_Swap>
  1042fb:	58                   	pop    %eax
		CODE_UNREACHABLE;
	}

	/* The abort handler might have altered the ready queue. */
	_reschedule_threads(key);
  1042fc:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
  1042ff:	8d 65 f8             	lea    -0x8(%ebp),%esp
  104302:	5b                   	pop    %ebx
  104303:	5e                   	pop    %esi
  104304:	5d                   	pop    %ebp
		_Swap(key);
		CODE_UNREACHABLE;
	}

	/* The abort handler might have altered the ready queue. */
	_reschedule_threads(key);
  104305:	e9 13 f8 ff ff       	jmp    103b1d <_reschedule_threads>

0010430a <_is_timeout_insert_point>:
 * the timeout of the insert point to update its delta queue value, since the
 * current timeout will be inserted before it.
 */

static int _is_timeout_insert_point(sys_dnode_t *test, void *timeout)
{
  10430a:	55                   	push   %ebp
  10430b:	89 e5                	mov    %esp,%ebp
  10430d:	53                   	push   %ebx
  10430e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  104311:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct _timeout *t = (void *)test;
	int32_t *timeout_to_insert = timeout;

	if (*timeout_to_insert > t->delta_ticks_from_prev) {
  104314:	8b 41 10             	mov    0x10(%ecx),%eax
  104317:	8b 13                	mov    (%ebx),%edx
  104319:	39 c2                	cmp    %eax,%edx
  10431b:	7e 08                	jle    104325 <_is_timeout_insert_point+0x1b>
		*timeout_to_insert -= t->delta_ticks_from_prev;
  10431d:	29 c2                	sub    %eax,%edx
		return 0;
  10431f:	31 c0                	xor    %eax,%eax
{
	struct _timeout *t = (void *)test;
	int32_t *timeout_to_insert = timeout;

	if (*timeout_to_insert > t->delta_ticks_from_prev) {
		*timeout_to_insert -= t->delta_ticks_from_prev;
  104321:	89 13                	mov    %edx,(%ebx)
		return 0;
  104323:	eb 0a                	jmp    10432f <_is_timeout_insert_point+0x25>
	}

	t->delta_ticks_from_prev -= *timeout_to_insert;
  104325:	29 d0                	sub    %edx,%eax
  104327:	89 41 10             	mov    %eax,0x10(%ecx)
	return 1;
  10432a:	b8 01 00 00 00       	mov    $0x1,%eax
}
  10432f:	5b                   	pop    %ebx
  104330:	5d                   	pop    %ebp
  104331:	c3                   	ret    

00104332 <_ready_thread>:
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.flags &= ~K_PRESTART;
  104332:	8b 50 08             	mov    0x8(%eax),%edx
  104335:	89 d1                	mov    %edx,%ecx
  104337:	80 e5 bf             	and    $0xbf,%ch
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  10433a:	81 e2 00 a0 03 00    	and    $0x3a000,%edx
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.flags &= ~K_PRESTART;
  104340:	89 48 08             	mov    %ecx,0x8(%eax)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  104343:	75 11                	jne    104356 <_ready_thread+0x24>
  104345:	83 78 28 ff          	cmpl   $0xffffffff,0x28(%eax)
  104349:	75 0b                	jne    104356 <_ready_thread+0x24>
 * blocked for another reason (eg. suspended).
 *
 * Must be called with interrupts locked.
 */
static inline void _ready_thread(struct k_thread *thread)
{
  10434b:	55                   	push   %ebp
  10434c:	89 e5                	mov    %esp,%ebp

	/* needed to handle the start-with-delay case */
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
		_add_thread_to_ready_q(thread);
  10434e:	50                   	push   %eax
  10434f:	e8 0c f6 ff ff       	call   103960 <_add_thread_to_ready_q>
  104354:	58                   	pop    %eax
	}
}
  104355:	c9                   	leave  
  104356:	c3                   	ret    

00104357 <_abort_timeout>:
}

/* returns 0 in success and -1 if the timer has expired */

static inline int _abort_timeout(struct _timeout *t)
{
  104357:	55                   	push   %ebp
  104358:	89 c2                	mov    %eax,%edx
	sys_dlist_t *timeout_q = &_timeout_q;

	if (-1 == t->delta_ticks_from_prev) {
  10435a:	8b 40 10             	mov    0x10(%eax),%eax
}

/* returns 0 in success and -1 if the timer has expired */

static inline int _abort_timeout(struct _timeout *t)
{
  10435d:	89 e5                	mov    %esp,%ebp
	sys_dlist_t *timeout_q = &_timeout_q;

	if (-1 == t->delta_ticks_from_prev) {
  10435f:	83 f8 ff             	cmp    $0xffffffff,%eax
  104362:	74 22                	je     104386 <_abort_timeout+0x2f>
		return -1;
	}

	if (!sys_dlist_is_tail(timeout_q, &t->node)) {
  104364:	3b 15 90 7d 10 00    	cmp    0x107d90,%edx
  10436a:	74 05                	je     104371 <_abort_timeout+0x1a>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (!node || node == list->tail) ? NULL : node->next;
  10436c:	8b 0a                	mov    (%edx),%ecx
		struct _timeout *next =
			(struct _timeout *)sys_dlist_peek_next(timeout_q,
								    &t->node);
		next->delta_ticks_from_prev += t->delta_ticks_from_prev;
  10436e:	01 41 10             	add    %eax,0x10(%ecx)
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  104371:	8b 42 04             	mov    0x4(%edx),%eax
  104374:	8b 0a                	mov    (%edx),%ecx
  104376:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
  104378:	8b 0a                	mov    (%edx),%ecx
  10437a:	89 41 04             	mov    %eax,0x4(%ecx)
	}
	sys_dlist_remove(&t->node);
	t->delta_ticks_from_prev = -1;
  10437d:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edx)

	return 0;
  104384:	31 c0                	xor    %eax,%eax
}
  104386:	5d                   	pop    %ebp
  104387:	c3                   	ret    

00104388 <_unpend_first_thread>:
	return (struct k_thread *)sys_dlist_peek_head(wait_q);
}

/* unpend the first thread from a wait queue */
static inline struct k_thread *_unpend_first_thread(_wait_q_t *wait_q)
{
  104388:	55                   	push   %ebp
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  104389:	8b 10                	mov    (%eax),%edx
  10438b:	89 e5                	mov    %esp,%ebp

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node;

	if (sys_dlist_is_empty(list)) {
  10438d:	39 d0                	cmp    %edx,%eax
  10438f:	74 15                	je     1043a6 <_unpend_first_thread+0x1e>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  104391:	8b 42 04             	mov    0x4(%edx),%eax
  104394:	8b 0a                	mov    (%edx),%ecx
  104396:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
  104398:	8b 0a                	mov    (%edx),%ecx
  10439a:	89 41 04             	mov    %eax,0x4(%ecx)
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.flags &= ~K_PENDING;
  10439d:	81 62 08 ff df ff ff 	andl   $0xffffdfff,0x8(%edx)
  1043a4:	eb 02                	jmp    1043a8 <_unpend_first_thread+0x20>
static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node;

	if (sys_dlist_is_empty(list)) {
		return NULL;
  1043a6:	31 d2                	xor    %edx,%edx
	if (thread) {
		_mark_thread_as_not_pending(thread);
	}

	return thread;
}
  1043a8:	89 d0                	mov    %edx,%eax
  1043aa:	5d                   	pop    %ebp
  1043ab:	c3                   	ret    

001043ac <sys_dlist_insert_at.constprop.7>:
 * @param data parameter to cond()
 *
 * @return N/A
 */

static inline void sys_dlist_insert_at(sys_dlist_t *list, sys_dnode_t *node,
  1043ac:	55                   	push   %ebp
  1043ad:	89 e5                	mov    %esp,%ebp
  1043af:	57                   	push   %edi
  1043b0:	56                   	push   %esi
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  1043b1:	8b 35 8c 7d 10 00    	mov    0x107d8c,%esi
 * @param data parameter to cond()
 *
 * @return N/A
 */

static inline void sys_dlist_insert_at(sys_dlist_t *list, sys_dnode_t *node,
  1043b7:	53                   	push   %ebx
  1043b8:	89 d7                	mov    %edx,%edi
  1043ba:	89 c3                	mov    %eax,%ebx
	int (*cond)(sys_dnode_t *, void *), void *data)
{
	if (sys_dlist_is_empty(list)) {
  1043bc:	81 fe 8c 7d 10 00    	cmp    $0x107d8c,%esi
  1043c2:	74 1d                	je     1043e1 <sys_dlist_insert_at.constprop.7+0x35>
		sys_dlist_append(list, node);
	} else {
		sys_dnode_t *pos = sys_dlist_peek_head(list);

		while (pos && !cond(pos, data)) {
  1043c4:	85 f6                	test   %esi,%esi
  1043c6:	74 19                	je     1043e1 <sys_dlist_insert_at.constprop.7+0x35>
  1043c8:	57                   	push   %edi
  1043c9:	56                   	push   %esi
  1043ca:	e8 3b ff ff ff       	call   10430a <_is_timeout_insert_point>
  1043cf:	5a                   	pop    %edx
  1043d0:	85 c0                	test   %eax,%eax
  1043d2:	59                   	pop    %ecx
  1043d3:	75 29                	jne    1043fe <sys_dlist_insert_at.constprop.7+0x52>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (!node || node == list->tail) ? NULL : node->next;
  1043d5:	3b 35 90 7d 10 00    	cmp    0x107d90,%esi
  1043db:	74 04                	je     1043e1 <sys_dlist_insert_at.constprop.7+0x35>
  1043dd:	8b 36                	mov    (%esi),%esi
  1043df:	eb e3                	jmp    1043c4 <sys_dlist_insert_at.constprop.7+0x18>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  1043e1:	c7 03 8c 7d 10 00    	movl   $0x107d8c,(%ebx)
	node->prev = list->tail;
  1043e7:	a1 90 7d 10 00       	mov    0x107d90,%eax
  1043ec:	89 43 04             	mov    %eax,0x4(%ebx)

	list->tail->next = node;
  1043ef:	a1 90 7d 10 00       	mov    0x107d90,%eax
  1043f4:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
  1043f6:	89 1d 90 7d 10 00    	mov    %ebx,0x107d90
  1043fc:	eb 10                	jmp    10440e <sys_dlist_insert_at.constprop.7+0x62>
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  1043fe:	8b 46 04             	mov    0x4(%esi),%eax
		node->next = insert_point;
  104401:	89 33                	mov    %esi,(%ebx)
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  104403:	89 43 04             	mov    %eax,0x4(%ebx)
		node->next = insert_point;
		insert_point->prev->next = node;
  104406:	8b 46 04             	mov    0x4(%esi),%eax
  104409:	89 18                	mov    %ebx,(%eax)
		insert_point->prev = node;
  10440b:	89 5e 04             	mov    %ebx,0x4(%esi)
		while (pos && !cond(pos, data)) {
			pos = sys_dlist_peek_next(list, pos);
		}
		sys_dlist_insert_before(list, pos, node);
	}
}
  10440e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  104411:	5b                   	pop    %ebx
  104412:	5e                   	pop    %esi
  104413:	5f                   	pop    %edi
  104414:	5d                   	pop    %ebp
  104415:	c3                   	ret    

00104416 <_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void _timer_expiration_handler(struct _timeout *t)
{
  104416:	55                   	push   %ebp
  104417:	89 e5                	mov    %esp,%ebp
  104419:	57                   	push   %edi
  10441a:	56                   	push   %esi
  10441b:	53                   	push   %ebx
  10441c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10441f:	9c                   	pushf  
  104420:	fa                   	cli    
  104421:	5e                   	pop    %esi

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (timer->period > 0) {
  104422:	8b 43 28             	mov    0x28(%ebx),%eax
  104425:	8d 7b 18             	lea    0x18(%ebx),%edi
  104428:	85 c0                	test   %eax,%eax
  10442a:	7e 17                	jle    104443 <_timer_expiration_handler+0x2d>

	K_DEBUG("timeout   %p before: next: %p, prev: %p\n",
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
	timeout_obj->delta_ticks_from_prev = timeout;
  10442c:	89 43 10             	mov    %eax,0x10(%ebx)
		_timeout_q.tail);

	K_DEBUG("timeout   %p before: next: %p, prev: %p\n",
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
  10442f:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		_add_timeout(NULL, &timer->timeout, &timer->wait_q,
  104436:	89 7b 0c             	mov    %edi,0xc(%ebx)
	timeout_obj->delta_ticks_from_prev = timeout;
	timeout_obj->wait_q = (sys_dlist_t *)wait_q;
	sys_dlist_insert_at(timeout_q, (void *)timeout_obj,
			    _is_timeout_insert_point,
			    &timeout_obj->delta_ticks_from_prev);
  104439:	8d 53 10             	lea    0x10(%ebx),%edx
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
	timeout_obj->delta_ticks_from_prev = timeout;
	timeout_obj->wait_q = (sys_dlist_t *)wait_q;
	sys_dlist_insert_at(timeout_q, (void *)timeout_obj,
  10443c:	89 d8                	mov    %ebx,%eax
  10443e:	e8 69 ff ff ff       	call   1043ac <sys_dlist_insert_at.constprop.7>

	/* update timer's status */
	timer->status += 1;

	/* invoke timer expiry function */
	if (timer->expiry_fn) {
  104443:	8b 43 20             	mov    0x20(%ebx),%eax
		_add_timeout(NULL, &timer->timeout, &timer->wait_q,
				timer->period);
	}

	/* update timer's status */
	timer->status += 1;
  104446:	ff 43 2c             	incl   0x2c(%ebx)

	/* invoke timer expiry function */
	if (timer->expiry_fn) {
  104449:	85 c0                	test   %eax,%eax
  10444b:	74 04                	je     104451 <_timer_expiration_handler+0x3b>
		timer->expiry_fn(timer);
  10444d:	53                   	push   %ebx
  10444e:	ff d0                	call   *%eax
  104450:	58                   	pop    %eax
	}
	/*
	 * wake up the (only) thread waiting on the timer, if there is one;
	 * don't invoke _Swap() since the timeout ISR called us, not a thread
	 */
	pending_thread = _unpend_first_thread(&timer->wait_q);
  104451:	89 f8                	mov    %edi,%eax
  104453:	e8 30 ff ff ff       	call   104388 <_unpend_first_thread>
  104458:	89 c3                	mov    %eax,%ebx
	if (pending_thread) {
  10445a:	85 c0                	test   %eax,%eax
  10445c:	74 0e                	je     10446c <_timer_expiration_handler+0x56>
		_ready_thread(pending_thread);
  10445e:	e8 cf fe ff ff       	call   104332 <_ready_thread>
  104463:	8b 43 30             	mov    0x30(%ebx),%eax
  104466:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  10446c:	81 e6 00 02 00 00    	and    $0x200,%esi
  104472:	74 01                	je     104475 <_timer_expiration_handler+0x5f>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  104474:	fb                   	sti    
		_set_thread_return_value(pending_thread, 0);
	}

	irq_unlock(key);
}
  104475:	8d 65 f4             	lea    -0xc(%ebp),%esp
  104478:	5b                   	pop    %ebx
  104479:	5e                   	pop    %esi
  10447a:	5f                   	pop    %edi
  10447b:	5d                   	pop    %ebp
  10447c:	c3                   	ret    

0010447d <k_timer_init>:


void k_timer_init(struct k_timer *timer,
		  void (*expiry_fn)(struct k_timer *),
		  void (*stop_fn)(struct k_timer *))
{
  10447d:	55                   	push   %ebp
  10447e:	89 e5                	mov    %esp,%ebp
  104480:	8b 45 08             	mov    0x8(%ebp),%eax
	timer->expiry_fn = expiry_fn;
  104483:	8b 55 0c             	mov    0xc(%ebp),%edx
  104486:	89 50 20             	mov    %edx,0x20(%eax)
	timer->stop_fn = stop_fn;
  104489:	8b 55 10             	mov    0x10(%ebp),%edx
  10448c:	89 50 24             	mov    %edx,0x24(%eax)
	timer->status = 0;

	sys_dlist_init(&timer->wait_q);
  10448f:	8d 50 18             	lea    0x18(%eax),%edx
		  void (*expiry_fn)(struct k_timer *),
		  void (*stop_fn)(struct k_timer *))
{
	timer->expiry_fn = expiry_fn;
	timer->stop_fn = stop_fn;
	timer->status = 0;
  104492:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  104499:	89 50 18             	mov    %edx,0x18(%eax)
	list->tail = (sys_dnode_t *)list;
  10449c:	89 50 1c             	mov    %edx,0x1c(%eax)
	/*
	 * Must be initialized here and when dequeueing a timeout so that code
	 * not dealing with timeouts does not have to handle this, such as when
	 * waiting forever on a semaphore.
	 */
	t->delta_ticks_from_prev = -1;
  10449f:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)

	/*
	 * Must be initialized here so that the _fiber_wakeup family of APIs can
	 * verify the fiber is not on a wait queue before aborting a timeout.
	 */
	t->wait_q = NULL;
  1044a6:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

	/*
	 * Must be initialized here, so the _handle_one_timeout()
	 * routine can check if there is a fiber waiting on this timeout
	 */
	t->thread = NULL;
  1044ad:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

	/*
	 * Function must be initialized before being potentially called.
	 */
	t->func = func;
  1044b4:	c7 40 14 16 44 10 00 	movl   $0x104416,0x14(%eax)

	sys_dlist_init(&timer->wait_q);
	_init_timeout(&timer->timeout, _timer_expiration_handler);
	SYS_TRACING_OBJ_INIT(k_timer, timer);

	timer->_legacy_data = NULL;
  1044bb:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
}
  1044c2:	5d                   	pop    %ebp
  1044c3:	c3                   	ret    

001044c4 <k_timer_start>:


void k_timer_start(struct k_timer *timer, int32_t duration, int32_t period)
{
  1044c4:	55                   	push   %ebp
  1044c5:	89 e5                	mov    %esp,%ebp
  1044c7:	56                   	push   %esi
  1044c8:	53                   	push   %ebx
  1044c9:	8b 5d 08             	mov    0x8(%ebp),%ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1044cc:	9c                   	pushf  
  1044cd:	fa                   	cli    
  1044ce:	5e                   	pop    %esi
	__ASSERT(duration >= 0 && period >= 0 &&
		 (duration != 0 || period != 0), "invalid parameters\n");

	unsigned int key = irq_lock();

	if (timer->timeout.delta_ticks_from_prev != -1) {
  1044cf:	83 7b 10 ff          	cmpl   $0xffffffff,0x10(%ebx)
  1044d3:	74 07                	je     1044dc <k_timer_start+0x18>
		_abort_timeout(&timer->timeout);
  1044d5:	89 d8                	mov    %ebx,%eax
  1044d7:	e8 7b fe ff ff       	call   104357 <_abort_timeout>
	}

	timer->period = _ms_to_ticks(period);
  1044dc:	ff 75 10             	pushl  0x10(%ebp)
  1044df:	e8 37 f5 ff ff       	call   103a1b <_ms_to_ticks>
  1044e4:	5a                   	pop    %edx
  1044e5:	89 43 28             	mov    %eax,0x28(%ebx)
	_add_timeout(NULL, &timer->timeout, &timer->wait_q,
			_TICK_ALIGN + _ms_to_ticks(duration));
  1044e8:	ff 75 0c             	pushl  0xc(%ebp)
  1044eb:	e8 2b f5 ff ff       	call   103a1b <_ms_to_ticks>
  1044f0:	59                   	pop    %ecx

	K_DEBUG("timeout   %p before: next: %p, prev: %p\n",
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
	timeout_obj->delta_ticks_from_prev = timeout;
  1044f1:	40                   	inc    %eax
		_timeout_q.tail);

	K_DEBUG("timeout   %p before: next: %p, prev: %p\n",
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
  1044f2:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	timeout_obj->delta_ticks_from_prev = timeout;
  1044f9:	89 43 10             	mov    %eax,0x10(%ebx)
	if (timer->timeout.delta_ticks_from_prev != -1) {
		_abort_timeout(&timer->timeout);
	}

	timer->period = _ms_to_ticks(period);
	_add_timeout(NULL, &timer->timeout, &timer->wait_q,
  1044fc:	8d 43 18             	lea    0x18(%ebx),%eax
  1044ff:	89 43 0c             	mov    %eax,0xc(%ebx)
	timeout_obj->wait_q = (sys_dlist_t *)wait_q;
	sys_dlist_insert_at(timeout_q, (void *)timeout_obj,
			    _is_timeout_insert_point,
			    &timeout_obj->delta_ticks_from_prev);
  104502:	8d 53 10             	lea    0x10(%ebx),%edx
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
	timeout_obj->delta_ticks_from_prev = timeout;
	timeout_obj->wait_q = (sys_dlist_t *)wait_q;
	sys_dlist_insert_at(timeout_q, (void *)timeout_obj,
  104505:	89 d8                	mov    %ebx,%eax
  104507:	e8 a0 fe ff ff       	call   1043ac <sys_dlist_insert_at.constprop.7>
			_TICK_ALIGN + _ms_to_ticks(duration));
	timer->status = 0;
  10450c:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  104513:	81 e6 00 02 00 00    	and    $0x200,%esi
  104519:	74 01                	je     10451c <k_timer_start+0x58>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  10451b:	fb                   	sti    
	irq_unlock(key);
}
  10451c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10451f:	5b                   	pop    %ebx
  104520:	5e                   	pop    %esi
  104521:	5d                   	pop    %ebp
  104522:	c3                   	ret    

00104523 <k_timer_status_get>:
	}
}


uint32_t k_timer_status_get(struct k_timer *timer)
{
  104523:	55                   	push   %ebp
  104524:	89 e5                	mov    %esp,%ebp
  104526:	8b 55 08             	mov    0x8(%ebp),%edx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  104529:	9c                   	pushf  
  10452a:	fa                   	cli    
  10452b:	59                   	pop    %ecx
  10452c:	80 e5 02             	and    $0x2,%ch
	unsigned int key = irq_lock();
	uint32_t result = timer->status;
  10452f:	8b 42 2c             	mov    0x2c(%edx),%eax

	timer->status = 0;
  104532:	c7 42 2c 00 00 00 00 	movl   $0x0,0x2c(%edx)
  104539:	74 01                	je     10453c <k_timer_status_get+0x19>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  10453b:	fb                   	sti    
	irq_unlock(key);

	return result;
}
  10453c:	5d                   	pop    %ebp
  10453d:	c3                   	ret    

0010453e <k_timer_status_sync>:


uint32_t k_timer_status_sync(struct k_timer *timer)
{
  10453e:	55                   	push   %ebp
  10453f:	89 e5                	mov    %esp,%ebp
  104541:	56                   	push   %esi
  104542:	53                   	push   %ebx
  104543:	8b 75 08             	mov    0x8(%ebp),%esi

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  104546:	9c                   	pushf  
  104547:	fa                   	cli    
  104548:	5b                   	pop    %ebx
	__ASSERT(!_is_in_isr(), "");

	unsigned int key = irq_lock();
	uint32_t result = timer->status;
  104549:	8b 46 2c             	mov    0x2c(%esi),%eax

	if (result == 0) {
  10454c:	85 c0                	test   %eax,%eax
  10454e:	75 20                	jne    104570 <k_timer_status_sync+0x32>
		if (timer->timeout.delta_ticks_from_prev != -1) {
  104550:	83 7e 10 ff          	cmpl   $0xffffffff,0x10(%esi)
  104554:	74 1a                	je     104570 <k_timer_status_sync+0x32>
			/* wait for timer to expire or stop */
			_pend_current_thread(&timer->wait_q, K_FOREVER);
  104556:	8d 46 18             	lea    0x18(%esi),%eax
  104559:	6a ff                	push   $0xffffffff
  10455b:	50                   	push   %eax
  10455c:	e8 5e f5 ff ff       	call   103abf <_pend_current_thread>
  104561:	58                   	pop    %eax
  104562:	5a                   	pop    %edx
			_Swap(key);
  104563:	53                   	push   %ebx
  104564:	e8 a2 ee ff ff       	call   10340b <_Swap>
  104569:	59                   	pop    %ecx
  10456a:	9c                   	pushf  
  10456b:	fa                   	cli    
  10456c:	5b                   	pop    %ebx

			/* get updated timer status */
			key = irq_lock();
			result = timer->status;
  10456d:	8b 46 2c             	mov    0x2c(%esi),%eax
  104570:	80 e7 02             	and    $0x2,%bh
		}
	} else {
		/* timer has already expired at least once */
	}

	timer->status = 0;
  104573:	c7 46 2c 00 00 00 00 	movl   $0x0,0x2c(%esi)
  10457a:	74 01                	je     10457d <k_timer_status_sync+0x3f>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  10457c:	fb                   	sti    
	irq_unlock(key);

	return result;
}
  10457d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  104580:	5b                   	pop    %ebx
  104581:	5e                   	pop    %esi
  104582:	5d                   	pop    %ebp
  104583:	c3                   	ret    

00104584 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while ((0))
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
  104584:	55                   	push   %ebp
  104585:	89 e5                	mov    %esp,%ebp

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  104587:	9c                   	pushf  
  104588:	fa                   	cli    
  104589:	58                   	pop    %eax
	if (_sys_soc_suspend(ticks) == SYS_PM_NOT_HANDLED) {
		_sys_pm_idle_exit_notify = 0;
		nano_cpu_idle();
	}
#else
	nano_cpu_idle();
  10458a:	e8 54 ed ff ff       	call   1032e3 <nano_cpu_idle>
  10458f:	eb f6                	jmp    104587 <idle+0x3>

00104591 <_OffsetAbsSyms>:
/*
 * The final link step uses the symbol _OffsetAbsSyms to force the linkage of
 * offsets.o into the ELF image.
 */

GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
  104591:	55                   	push   %ebp
  104592:	89 e5                	mov    %esp,%ebp
/* size of the ISR_LIST structure. Used by linker scripts */

GEN_ABSOLUTE_SYM(__ISR_LIST_SIZEOF, sizeof(ISR_LIST));


GEN_ABS_SYM_END
  104594:	5d                   	pop    %ebp
  104595:	c3                   	ret    

00104596 <_handle_exc_0_vector_0_stub>:
  104596:	6a 00                	push   $0x0
  104598:	68 cf 35 10 00       	push   $0x1035cf
  10459d:	e9 c4 ed ff ff       	jmp    103366 <_exception_enter>

001045a2 <_handle_exc_2_vector_2_stub>:
  1045a2:	6a 00                	push   $0x0
  1045a4:	68 dc 35 10 00       	push   $0x1035dc
  1045a9:	e9 b8 ed ff ff       	jmp    103366 <_exception_enter>

001045ae <_handle_exc_4_vector_4_stub>:
  1045ae:	6a 00                	push   $0x0
  1045b0:	68 ec 35 10 00       	push   $0x1035ec
  1045b5:	e9 ac ed ff ff       	jmp    103366 <_exception_enter>

001045ba <_handle_exc_5_vector_5_stub>:
  1045ba:	6a 00                	push   $0x0
  1045bc:	68 fc 35 10 00       	push   $0x1035fc
  1045c1:	e9 a0 ed ff ff       	jmp    103366 <_exception_enter>

001045c6 <_handle_exc_6_vector_6_stub>:
  1045c6:	6a 00                	push   $0x0
  1045c8:	68 0c 36 10 00       	push   $0x10360c
  1045cd:	e9 94 ed ff ff       	jmp    103366 <_exception_enter>

001045d2 <_handle_exc_7_vector_7_stub>:
  1045d2:	6a 00                	push   $0x0
  1045d4:	68 1c 36 10 00       	push   $0x10361c
  1045d9:	e9 88 ed ff ff       	jmp    103366 <_exception_enter>

001045de <_handle_exc_8_vector_8_stub>:
  1045de:	68 2c 36 10 00       	push   $0x10362c
  1045e3:	e9 7e ed ff ff       	jmp    103366 <_exception_enter>

001045e8 <_handle_exc_10_vector_10_stub>:
  1045e8:	68 3c 36 10 00       	push   $0x10363c
  1045ed:	e9 74 ed ff ff       	jmp    103366 <_exception_enter>

001045f2 <_handle_exc_11_vector_11_stub>:
  1045f2:	68 4c 36 10 00       	push   $0x10364c
  1045f7:	e9 6a ed ff ff       	jmp    103366 <_exception_enter>

001045fc <_handle_exc_12_vector_12_stub>:
  1045fc:	68 5c 36 10 00       	push   $0x10365c
  104601:	e9 60 ed ff ff       	jmp    103366 <_exception_enter>

00104606 <_handle_exc_13_vector_13_stub>:
  104606:	68 6c 36 10 00       	push   $0x10366c
  10460b:	e9 56 ed ff ff       	jmp    103366 <_exception_enter>

00104610 <_handle_exc_14_vector_14_stub>:
  104610:	68 7c 36 10 00       	push   $0x10367c
  104615:	e9 4c ed ff ff       	jmp    103366 <_exception_enter>

0010461a <_handle_exc_16_vector_16_stub>:
  10461a:	6a 00                	push   $0x0
  10461c:	68 8c 36 10 00       	push   $0x10368c
  104621:	e9 40 ed ff ff       	jmp    103366 <_exception_enter>

00104626 <_handle_exc_17_vector_17_stub>:
  104626:	68 9c 36 10 00       	push   $0x10369c
  10462b:	e9 36 ed ff ff       	jmp    103366 <_exception_enter>

00104630 <_handle_exc_18_vector_18_stub>:
  104630:	6a 00                	push   $0x0
  104632:	68 ac 36 10 00       	push   $0x1036ac
  104637:	e9 2a ed ff ff       	jmp    103366 <_exception_enter>
