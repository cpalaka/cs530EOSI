
zephyr.elf:     file format elf32-i386


Disassembly of section text:

00100000 <__start>:
        mov  %eax, %esi			/* low  value */
        mov  %edx, %edi			/* high value */
#endif

	/* Enable write-back caching by clearing the NW and CD bits */
	movl	%cr0, %eax
  100000:	0f 20 c0             	mov    %cr0,%eax
	andl	$0x9fffffff, %eax
  100003:	25 ff ff ff 9f       	and    $0x9fffffff,%eax
	movl	%eax, %cr0
  100008:	0f 22 c0             	mov    %eax,%cr0
	/*
	 * Ensure interrupts are disabled.  Interrupts are enabled when
	 * the first context switch occurs.
	 */

	cli
  10000b:	fa                   	cli    
	 * Although the bootloader sets up an Interrupt Descriptor Table (IDT)
	 * and a Global Descriptor Table (GDT), the specification encourages
	 * booted operating systems to setup their own IDT and GDT.
	 */
#if CONFIG_SET_GDT
	lgdt	_gdt_rom		/* load 32-bit operand size GDT */
  10000c:	0f 01 15 70 00 10 00 	lgdtl  0x100070
#endif
	lidt	_Idt		/* load 32-bit operand size IDT */
  100013:	0f 01 1d 57 00 10 00 	lidtl  0x100057
	 *
	 * This is a special case for the ia32 platform, which must work for
	 * multiple platforms (QEMU, generic PC board, etc.). With other
	 * platforms the bootloader is well known so assumptions can be made.
	 */
	movw	$0x10, %ax	/* data segment selector (entry = 3) */
  10001a:	66 b8 10 00          	mov    $0x10,%ax
	movw	%ax, %ds	/* set DS */
  10001e:	8e d8                	mov    %eax,%ds
	movw	%ax, %es	/* set ES */
  100020:	8e c0                	mov    %eax,%es
	movw	%ax, %fs	/* set FS */
  100022:	8e e0                	mov    %eax,%fs
	movw	%ax, %gs	/* set GS */
  100024:	8e e8                	mov    %eax,%gs
	movw	%ax, %ss	/* set SS */
  100026:	8e d0                	mov    %eax,%ss

	ljmp	$0x08, $__csSet	/* set CS = 0x08 */
  100028:	ea 2f 00 10 00 08 00 	ljmp   $0x8,$0x10002f

0010002f <__csSet>:
	/*
	 * Force an #NM exception for floating point instructions
	 * since FP support hasn't been configured
	 */

	movl	%cr0, %eax		/* move CR0 to EAX */
  10002f:	0f 20 c0             	mov    %cr0,%eax
	orl	$0x2e, %eax		/* CR0[NE+TS+EM+MP]=1 */
  100032:	83 c8 2e             	or     $0x2e,%eax
	movl	%eax, %cr0		/* move EAX to CR0 */
  100035:	0f 22 c0             	mov    %eax,%cr0
	stack_size_dwords = (CONFIG_ISR_STACK_SIZE / 4)
	movl $stack_size_dwords, %ecx
	rep  stosl
#endif

	movl	$_interrupt_stack, %esp
  100038:	bc 78 7f 10 00       	mov    $0x107f78,%esp
	addl	$CONFIG_ISR_STACK_SIZE, %esp
  10003d:	81 c4 00 08 00 00    	add    $0x800,%esp

#else /* !CONFIG_SSE */

	/* clear out BSS double words (32-bits at a time) */

	xorl	%eax, %eax		/* fill memory with 0 */
  100043:	31 c0                	xor    %eax,%eax
	movl	$__bss_start, %edi	/* load BSS start address */
  100045:	bf 80 72 10 00       	mov    $0x107280,%edi
	movl	$__bss_num_words, %ecx	/* number of quad bytes */
  10004a:	b9 38 03 00 00       	mov    $0x338,%ecx
	cld
  10004f:	fc                   	cld    
	rep
  100050:	f3 ab                	rep stos %eax,%es:(%edi)
	lgdt	%ds:_gdt
#endif

	/* Jump to C portion of kernel initialization and never return */

	jmp	_Cstart
  100052:	e9 29 37 00 00       	jmp    103780 <_Cstart>

00100057 <_Idt>:
  100057:	ff 07 e8 65 10 00 8d 76 00 02 b0 ad 1b 00 00 00     ...e...v........
  100067:	00 fe 4f 52 e4 8d 74 26 00                          ..OR..t&.

00100070 <_gdt>:
  100070:	17 00 70 00 10 00 00 00 ff ff 00 00 00 9b cf 00     ..p.............
  100080:	ff ff 00 00 00 93 cf 00                             ........

00100088 <_gdt_rom_end>:
  100088:	66 90                	xchg   %ax,%ax
  10008a:	66 90                	xchg   %ax,%ax
  10008c:	66 90                	xchg   %ax,%ax
  10008e:	66 90                	xchg   %ax,%ax

00100090 <__divdi3>:
  100090:	55                   	push   %ebp
  100091:	57                   	push   %edi
  100092:	56                   	push   %esi
  100093:	53                   	push   %ebx
  100094:	83 ec 2c             	sub    $0x2c,%esp
  100097:	8b 5c 24 44          	mov    0x44(%esp),%ebx
  10009b:	8b 54 24 4c          	mov    0x4c(%esp),%edx
  10009f:	8b 4c 24 40          	mov    0x40(%esp),%ecx
  1000a3:	8b 6c 24 48          	mov    0x48(%esp),%ebp
  1000a7:	89 d0                	mov    %edx,%eax
  1000a9:	85 db                	test   %ebx,%ebx
  1000ab:	0f 88 ff 00 00 00    	js     1001b0 <__divdi3+0x120>
  1000b1:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  1000b5:	89 5c 24 14          	mov    %ebx,0x14(%esp)
  1000b9:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  1000c0:	00 
  1000c1:	89 6c 24 08          	mov    %ebp,0x8(%esp)
  1000c5:	89 54 24 0c          	mov    %edx,0xc(%esp)
  1000c9:	85 c0                	test   %eax,%eax
  1000cb:	0f 88 bf 00 00 00    	js     100190 <__divdi3+0x100>
  1000d1:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  1000d5:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  1000d9:	8b 74 24 14          	mov    0x14(%esp),%esi
  1000dd:	8b 54 24 08          	mov    0x8(%esp),%edx
  1000e1:	89 cf                	mov    %ecx,%edi
  1000e3:	89 d8                	mov    %ebx,%eax
  1000e5:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
  1000e9:	89 d5                	mov    %edx,%ebp
  1000eb:	89 f3                	mov    %esi,%ebx
  1000ed:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  1000f1:	89 d6                	mov    %edx,%esi
  1000f3:	85 ff                	test   %edi,%edi
  1000f5:	75 19                	jne    100110 <__divdi3+0x80>
  1000f7:	39 da                	cmp    %ebx,%edx
  1000f9:	76 65                	jbe    100160 <__divdi3+0xd0>
  1000fb:	89 da                	mov    %ebx,%edx
  1000fd:	31 f6                	xor    %esi,%esi
  1000ff:	f7 f5                	div    %ebp
  100101:	89 c1                	mov    %eax,%ecx
  100103:	eb 13                	jmp    100118 <__divdi3+0x88>
  100105:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  100109:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  100110:	39 df                	cmp    %ebx,%edi
  100112:	76 2c                	jbe    100140 <__divdi3+0xb0>
  100114:	31 f6                	xor    %esi,%esi
  100116:	31 c9                	xor    %ecx,%ecx
  100118:	89 c8                	mov    %ecx,%eax
  10011a:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  10011e:	89 f2                	mov    %esi,%edx
  100120:	85 c9                	test   %ecx,%ecx
  100122:	74 07                	je     10012b <__divdi3+0x9b>
  100124:	f7 d8                	neg    %eax
  100126:	83 d2 00             	adc    $0x0,%edx
  100129:	f7 da                	neg    %edx
  10012b:	83 c4 2c             	add    $0x2c,%esp
  10012e:	5b                   	pop    %ebx
  10012f:	5e                   	pop    %esi
  100130:	5f                   	pop    %edi
  100131:	5d                   	pop    %ebp
  100132:	c3                   	ret    
  100133:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  100139:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  100140:	0f bd f7             	bsr    %edi,%esi
  100143:	83 f6 1f             	xor    $0x1f,%esi
  100146:	0f 85 84 00 00 00    	jne    1001d0 <__divdi3+0x140>
  10014c:	39 df                	cmp    %ebx,%edi
  10014e:	72 08                	jb     100158 <__divdi3+0xc8>
  100150:	31 c9                	xor    %ecx,%ecx
  100152:	3b 54 24 1c          	cmp    0x1c(%esp),%edx
  100156:	77 c0                	ja     100118 <__divdi3+0x88>
  100158:	b9 01 00 00 00       	mov    $0x1,%ecx
  10015d:	eb b9                	jmp    100118 <__divdi3+0x88>
  10015f:	90                   	nop
  100160:	85 d2                	test   %edx,%edx
  100162:	75 0b                	jne    10016f <__divdi3+0xdf>
  100164:	b8 01 00 00 00       	mov    $0x1,%eax
  100169:	31 d2                	xor    %edx,%edx
  10016b:	f7 f5                	div    %ebp
  10016d:	89 c6                	mov    %eax,%esi
  10016f:	31 d2                	xor    %edx,%edx
  100171:	89 d8                	mov    %ebx,%eax
  100173:	f7 f6                	div    %esi
  100175:	89 c7                	mov    %eax,%edi
  100177:	89 c8                	mov    %ecx,%eax
  100179:	f7 f6                	div    %esi
  10017b:	89 fe                	mov    %edi,%esi
  10017d:	89 c1                	mov    %eax,%ecx
  10017f:	eb 97                	jmp    100118 <__divdi3+0x88>
  100181:	eb 0d                	jmp    100190 <__divdi3+0x100>
  100183:	90                   	nop
  100184:	90                   	nop
  100185:	90                   	nop
  100186:	90                   	nop
  100187:	90                   	nop
  100188:	90                   	nop
  100189:	90                   	nop
  10018a:	90                   	nop
  10018b:	90                   	nop
  10018c:	90                   	nop
  10018d:	90                   	nop
  10018e:	90                   	nop
  10018f:	90                   	nop
  100190:	f7 5c 24 08          	negl   0x8(%esp)
  100194:	83 54 24 0c 00       	adcl   $0x0,0xc(%esp)
  100199:	f7 54 24 18          	notl   0x18(%esp)
  10019d:	f7 5c 24 0c          	negl   0xc(%esp)
  1001a1:	e9 2b ff ff ff       	jmp    1000d1 <__divdi3+0x41>
  1001a6:	8d 76 00             	lea    0x0(%esi),%esi
  1001a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  1001b0:	f7 d9                	neg    %ecx
  1001b2:	83 d3 00             	adc    $0x0,%ebx
  1001b5:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  1001b9:	f7 db                	neg    %ebx
  1001bb:	89 5c 24 14          	mov    %ebx,0x14(%esp)
  1001bf:	c7 44 24 18 ff ff ff 	movl   $0xffffffff,0x18(%esp)
  1001c6:	ff 
  1001c7:	e9 f5 fe ff ff       	jmp    1000c1 <__divdi3+0x31>
  1001cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  1001d0:	b8 20 00 00 00       	mov    $0x20,%eax
  1001d5:	89 f1                	mov    %esi,%ecx
  1001d7:	29 f0                	sub    %esi,%eax
  1001d9:	d3 e7                	shl    %cl,%edi
  1001db:	88 c1                	mov    %al,%cl
  1001dd:	d3 ea                	shr    %cl,%edx
  1001df:	89 f1                	mov    %esi,%ecx
  1001e1:	09 fa                	or     %edi,%edx
  1001e3:	d3 e5                	shl    %cl,%ebp
  1001e5:	89 df                	mov    %ebx,%edi
  1001e7:	88 c1                	mov    %al,%cl
  1001e9:	d3 ef                	shr    %cl,%edi
  1001eb:	89 f1                	mov    %esi,%ecx
  1001ed:	89 54 24 08          	mov    %edx,0x8(%esp)
  1001f1:	d3 e3                	shl    %cl,%ebx
  1001f3:	8b 54 24 1c          	mov    0x1c(%esp),%edx
  1001f7:	88 c1                	mov    %al,%cl
  1001f9:	d3 ea                	shr    %cl,%edx
  1001fb:	09 d3                	or     %edx,%ebx
  1001fd:	89 fa                	mov    %edi,%edx
  1001ff:	89 d8                	mov    %ebx,%eax
  100201:	f7 74 24 08          	divl   0x8(%esp)
  100205:	89 d7                	mov    %edx,%edi
  100207:	89 c3                	mov    %eax,%ebx
  100209:	f7 e5                	mul    %ebp
  10020b:	39 d7                	cmp    %edx,%edi
  10020d:	72 21                	jb     100230 <__divdi3+0x1a0>
  10020f:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
  100213:	89 f1                	mov    %esi,%ecx
  100215:	d3 e5                	shl    %cl,%ebp
  100217:	39 c5                	cmp    %eax,%ebp
  100219:	73 04                	jae    10021f <__divdi3+0x18f>
  10021b:	39 d7                	cmp    %edx,%edi
  10021d:	74 11                	je     100230 <__divdi3+0x1a0>
  10021f:	89 d9                	mov    %ebx,%ecx
  100221:	31 f6                	xor    %esi,%esi
  100223:	e9 f0 fe ff ff       	jmp    100118 <__divdi3+0x88>
  100228:	90                   	nop
  100229:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  100230:	8d 4b ff             	lea    -0x1(%ebx),%ecx
  100233:	31 f6                	xor    %esi,%esi
  100235:	e9 de fe ff ff       	jmp    100118 <__divdi3+0x88>
  10023a:	66 90                	xchg   %ax,%ax
  10023c:	66 90                	xchg   %ax,%ax
  10023e:	66 90                	xchg   %ax,%ax

00100240 <__udivdi3>:
  100240:	55                   	push   %ebp
  100241:	57                   	push   %edi
  100242:	56                   	push   %esi
  100243:	53                   	push   %ebx
  100244:	83 ec 1c             	sub    $0x1c,%esp
  100247:	8b 5c 24 30          	mov    0x30(%esp),%ebx
  10024b:	8b 4c 24 34          	mov    0x34(%esp),%ecx
  10024f:	8b 7c 24 38          	mov    0x38(%esp),%edi
  100253:	8b 74 24 3c          	mov    0x3c(%esp),%esi
  100257:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  10025b:	89 ca                	mov    %ecx,%edx
  10025d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  100261:	85 f6                	test   %esi,%esi
  100263:	75 3b                	jne    1002a0 <__udivdi3+0x60>
  100265:	39 cf                	cmp    %ecx,%edi
  100267:	0f 87 c3 00 00 00    	ja     100330 <__udivdi3+0xf0>
  10026d:	89 fd                	mov    %edi,%ebp
  10026f:	85 ff                	test   %edi,%edi
  100271:	75 0b                	jne    10027e <__udivdi3+0x3e>
  100273:	b8 01 00 00 00       	mov    $0x1,%eax
  100278:	31 d2                	xor    %edx,%edx
  10027a:	f7 f7                	div    %edi
  10027c:	89 c5                	mov    %eax,%ebp
  10027e:	89 c8                	mov    %ecx,%eax
  100280:	31 d2                	xor    %edx,%edx
  100282:	f7 f5                	div    %ebp
  100284:	89 c1                	mov    %eax,%ecx
  100286:	89 d8                	mov    %ebx,%eax
  100288:	89 cf                	mov    %ecx,%edi
  10028a:	f7 f5                	div    %ebp
  10028c:	89 fa                	mov    %edi,%edx
  10028e:	83 c4 1c             	add    $0x1c,%esp
  100291:	5b                   	pop    %ebx
  100292:	5e                   	pop    %esi
  100293:	5f                   	pop    %edi
  100294:	5d                   	pop    %ebp
  100295:	c3                   	ret    
  100296:	8d 76 00             	lea    0x0(%esi),%esi
  100299:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  1002a0:	39 ce                	cmp    %ecx,%esi
  1002a2:	77 7c                	ja     100320 <__udivdi3+0xe0>
  1002a4:	0f bd fe             	bsr    %esi,%edi
  1002a7:	83 f7 1f             	xor    $0x1f,%edi
  1002aa:	0f 84 90 00 00 00    	je     100340 <__udivdi3+0x100>
  1002b0:	bd 20 00 00 00       	mov    $0x20,%ebp
  1002b5:	89 f9                	mov    %edi,%ecx
  1002b7:	89 eb                	mov    %ebp,%ebx
  1002b9:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
  1002bd:	29 fb                	sub    %edi,%ebx
  1002bf:	89 e8                	mov    %ebp,%eax
  1002c1:	d3 e6                	shl    %cl,%esi
  1002c3:	88 d9                	mov    %bl,%cl
  1002c5:	d3 e8                	shr    %cl,%eax
  1002c7:	89 f9                	mov    %edi,%ecx
  1002c9:	09 f0                	or     %esi,%eax
  1002cb:	d3 e5                	shl    %cl,%ebp
  1002cd:	89 d6                	mov    %edx,%esi
  1002cf:	88 d9                	mov    %bl,%cl
  1002d1:	d3 ee                	shr    %cl,%esi
  1002d3:	89 f9                	mov    %edi,%ecx
  1002d5:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1002d9:	d3 e2                	shl    %cl,%edx
  1002db:	8b 44 24 08          	mov    0x8(%esp),%eax
  1002df:	88 d9                	mov    %bl,%cl
  1002e1:	d3 e8                	shr    %cl,%eax
  1002e3:	09 c2                	or     %eax,%edx
  1002e5:	89 d0                	mov    %edx,%eax
  1002e7:	89 f2                	mov    %esi,%edx
  1002e9:	f7 74 24 0c          	divl   0xc(%esp)
  1002ed:	89 d6                	mov    %edx,%esi
  1002ef:	89 c3                	mov    %eax,%ebx
  1002f1:	f7 e5                	mul    %ebp
  1002f3:	39 d6                	cmp    %edx,%esi
  1002f5:	72 10                	jb     100307 <__udivdi3+0xc7>
  1002f7:	8b 6c 24 08          	mov    0x8(%esp),%ebp
  1002fb:	89 f9                	mov    %edi,%ecx
  1002fd:	d3 e5                	shl    %cl,%ebp
  1002ff:	39 c5                	cmp    %eax,%ebp
  100301:	73 5d                	jae    100360 <__udivdi3+0x120>
  100303:	39 d6                	cmp    %edx,%esi
  100305:	75 59                	jne    100360 <__udivdi3+0x120>
  100307:	8d 43 ff             	lea    -0x1(%ebx),%eax
  10030a:	31 ff                	xor    %edi,%edi
  10030c:	89 fa                	mov    %edi,%edx
  10030e:	83 c4 1c             	add    $0x1c,%esp
  100311:	5b                   	pop    %ebx
  100312:	5e                   	pop    %esi
  100313:	5f                   	pop    %edi
  100314:	5d                   	pop    %ebp
  100315:	c3                   	ret    
  100316:	8d 76 00             	lea    0x0(%esi),%esi
  100319:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  100320:	31 ff                	xor    %edi,%edi
  100322:	31 c0                	xor    %eax,%eax
  100324:	89 fa                	mov    %edi,%edx
  100326:	83 c4 1c             	add    $0x1c,%esp
  100329:	5b                   	pop    %ebx
  10032a:	5e                   	pop    %esi
  10032b:	5f                   	pop    %edi
  10032c:	5d                   	pop    %ebp
  10032d:	c3                   	ret    
  10032e:	66 90                	xchg   %ax,%ax
  100330:	89 d8                	mov    %ebx,%eax
  100332:	f7 f7                	div    %edi
  100334:	31 ff                	xor    %edi,%edi
  100336:	89 fa                	mov    %edi,%edx
  100338:	83 c4 1c             	add    $0x1c,%esp
  10033b:	5b                   	pop    %ebx
  10033c:	5e                   	pop    %esi
  10033d:	5f                   	pop    %edi
  10033e:	5d                   	pop    %ebp
  10033f:	c3                   	ret    
  100340:	39 ce                	cmp    %ecx,%esi
  100342:	72 10                	jb     100354 <__udivdi3+0x114>
  100344:	8b 74 24 08          	mov    0x8(%esp),%esi
  100348:	31 c0                	xor    %eax,%eax
  10034a:	39 74 24 0c          	cmp    %esi,0xc(%esp)
  10034e:	0f 87 38 ff ff ff    	ja     10028c <__udivdi3+0x4c>
  100354:	b8 01 00 00 00       	mov    $0x1,%eax
  100359:	e9 2e ff ff ff       	jmp    10028c <__udivdi3+0x4c>
  10035e:	66 90                	xchg   %ax,%ax
  100360:	89 d8                	mov    %ebx,%eax
  100362:	31 ff                	xor    %edi,%edi
  100364:	e9 23 ff ff ff       	jmp    10028c <__udivdi3+0x4c>

00100369 <main>:
#include <zephyr.h>
#include <errno.h>
#include <kernel.h>
#include "hcsr_driver.h"

void main(void) {
  100369:	55                   	push   %ebp
  10036a:	89 e5                	mov    %esp,%ebp
  10036c:	53                   	push   %ebx
	printk("start of application.\n");
  10036d:	68 40 47 10 00       	push   $0x104740
  100372:	e8 56 2a 00 00       	call   102dcd <printk>
	struct device* hcsr = device_get_binding("HCSR0");
  100377:	c7 04 24 57 47 10 00 	movl   $0x104757,(%esp)
  10037e:	e8 69 33 00 00       	call   1036ec <device_get_binding>
  100383:	89 c3                	mov    %eax,%ebx
	printk("after device get binding.\n");
  100385:	c7 04 24 5d 47 10 00 	movl   $0x10475d,(%esp)
  10038c:	e8 3c 2a 00 00       	call   102dcd <printk>
  100391:	5a                   	pop    %edx

	if(hcsr == NULL) {
  100392:	85 db                	test   %ebx,%ebx
  100394:	75 0b                	jne    1003a1 <main+0x38>
		printk("somethings wrong here lads\n");
  100396:	68 78 47 10 00       	push   $0x104778
  10039b:	e8 2d 2a 00 00       	call   102dcd <printk>
  1003a0:	58                   	pop    %eax
	// 	gpio_pin_write(gpio_0, 5, cnt % 2);
	// 	cnt++;
	// 	k_sleep(1000);
	// }

  1003a1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1003a4:	c9                   	leave  
  1003a5:	c3                   	ret    

001003a6 <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
  1003a6:	55                   	push   %ebp
  1003a7:	89 e5                	mov    %esp,%ebp
  1003a9:	53                   	push   %ebx
  1003aa:	8b 5d 08             	mov    0x8(%ebp),%ebx
		return c;
	}

#endif /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
  1003ad:	83 fb 0a             	cmp    $0xa,%ebx
  1003b0:	75 10                	jne    1003c2 <console_out+0x1c>
		uart_poll_out(uart_console_dev, '\r');
  1003b2:	a1 80 72 10 00       	mov    0x107280,%eax
static inline unsigned char uart_poll_out(struct device *dev,
					  unsigned char out_char)
{
	const struct uart_driver_api *api = dev->driver_api;

	return api->poll_out(dev, out_char);
  1003b7:	8b 50 04             	mov    0x4(%eax),%edx
  1003ba:	6a 0d                	push   $0xd
  1003bc:	50                   	push   %eax
  1003bd:	ff 52 04             	call   *0x4(%edx)
  1003c0:	59                   	pop    %ecx
  1003c1:	58                   	pop    %eax
	}
	uart_poll_out(uart_console_dev, c);
  1003c2:	a1 80 72 10 00       	mov    0x107280,%eax
  1003c7:	0f b6 cb             	movzbl %bl,%ecx
  1003ca:	8b 50 04             	mov    0x4(%eax),%edx
  1003cd:	51                   	push   %ecx
  1003ce:	50                   	push   %eax
  1003cf:	ff 52 04             	call   *0x4(%edx)
  1003d2:	58                   	pop    %eax

	return c;
}
  1003d3:	89 d8                	mov    %ebx,%eax
  1003d5:	5a                   	pop    %edx
  1003d6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1003d9:	c9                   	leave  
  1003da:	c3                   	ret    

001003db <uart_console_hook_install>:
 *
 * @return N/A
 */

void uart_console_hook_install(void)
{
  1003db:	55                   	push   %ebp
  1003dc:	89 e5                	mov    %esp,%ebp
	__stdout_hook_install(console_out);
	__printk_hook_install(console_out);
  1003de:	68 a6 03 10 00       	push   $0x1003a6
  1003e3:	e8 d8 29 00 00       	call   102dc0 <__printk_hook_install>
  1003e8:	58                   	pop    %eax
}
  1003e9:	c9                   	leave  
  1003ea:	c3                   	ret    

001003eb <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
  1003eb:	55                   	push   %ebp
  1003ec:	89 e5                	mov    %esp,%ebp

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
  1003ee:	68 94 47 10 00       	push   $0x104794
  1003f3:	e8 f4 32 00 00       	call   1036ec <device_get_binding>
  1003f8:	5a                   	pop    %edx
  1003f9:	a3 80 72 10 00       	mov    %eax,0x107280
		}
	}
	sys_thread_busy_wait(1000000);
#endif

	uart_console_hook_install();
  1003fe:	e8 d8 ff ff ff       	call   1003db <uart_console_hook_install>

	return 0;
}
  100403:	31 c0                	xor    %eax,%eax
  100405:	c9                   	leave  
  100406:	c3                   	ret    

00100407 <uart_ns16550_poll_in>:
 * @param c Pointer to character
 *
 * @return 0 if a character arrived, -1 if the input buffer if empty.
 */
static int uart_ns16550_poll_in(struct device *dev, unsigned char *c)
{
  100407:	55                   	push   %ebp
  100408:	89 e5                	mov    %esp,%ebp
  10040a:	8b 55 08             	mov    0x8(%ebp),%edx
	if ((INBYTE(LSR(dev)) & LSR_RXRDY) == 0x00)
  10040d:	8b 42 08             	mov    0x8(%edx),%eax
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
			 : "=q"(ret)
			 : "m" (*(volatile uint8_t *) addr)
  100410:	8b 00                	mov    (%eax),%eax
static ALWAYS_INLINE
	uint8_t sys_read8(mm_reg_t addr)
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
  100412:	8a 48 14             	mov    0x14(%eax),%cl
  100415:	80 e1 01             	and    $0x1,%cl
  100418:	74 10                	je     10042a <uart_ns16550_poll_in+0x23>
		return (-1);

	/* got a character */
	*c = INBYTE(RDR(dev));
  10041a:	8b 42 08             	mov    0x8(%edx),%eax
			 : "=q"(ret)
			 : "m" (*(volatile uint8_t *) addr)
  10041d:	8b 00                	mov    (%eax),%eax
static ALWAYS_INLINE
	uint8_t sys_read8(mm_reg_t addr)
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
  10041f:	8a 10                	mov    (%eax),%dl
  100421:	8b 45 0c             	mov    0xc(%ebp),%eax
  100424:	88 10                	mov    %dl,(%eax)

	return 0;
  100426:	31 c0                	xor    %eax,%eax
  100428:	eb 03                	jmp    10042d <uart_ns16550_poll_in+0x26>
  10042a:	83 c8 ff             	or     $0xffffffff,%eax
}
  10042d:	5d                   	pop    %ebp
  10042e:	c3                   	ret    

0010042f <uart_ns16550_poll_out>:
 *
 * @return Sent character
 */
static unsigned char uart_ns16550_poll_out(struct device *dev,
					   unsigned char c)
{
  10042f:	55                   	push   %ebp
  100430:	89 e5                	mov    %esp,%ebp
  100432:	8b 55 08             	mov    0x8(%ebp),%edx
  100435:	8b 45 0c             	mov    0xc(%ebp),%eax
	/* wait for transmitter to ready to accept a character */
	while ((INBYTE(LSR(dev)) & LSR_TEMT) == 0)
  100438:	8b 4a 08             	mov    0x8(%edx),%ecx
			 : "=q"(ret)
			 : "m" (*(volatile uint8_t *) addr)
  10043b:	8b 09                	mov    (%ecx),%ecx
static ALWAYS_INLINE
	uint8_t sys_read8(mm_reg_t addr)
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
  10043d:	8a 49 14             	mov    0x14(%ecx),%cl
  100440:	80 e1 40             	and    $0x40,%cl
  100443:	74 f3                	je     100438 <uart_ns16550_poll_out+0x9>
		;

	OUTBYTE(THR(dev), c);
  100445:	8b 52 08             	mov    0x8(%edx),%edx
static ALWAYS_INLINE
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
  100448:	8b 12                	mov    (%edx),%edx
}

static ALWAYS_INLINE
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
  10044a:	88 02                	mov    %al,(%edx)

	return c;
}
  10044c:	5d                   	pop    %ebp
  10044d:	c3                   	ret    

0010044e <uart_ns16550_err_check>:
 *
 * @return one of UART_ERROR_OVERRUN, UART_ERROR_PARITY, UART_ERROR_FRAMING,
 * UART_ERROR_BREAK if an error was detected, 0 otherwise.
 */
static int uart_ns16550_err_check(struct device *dev)
{
  10044e:	55                   	push   %ebp
  10044f:	89 e5                	mov    %esp,%ebp
	return (INBYTE(LSR(dev)) & LSR_EOB_MASK) >> 1;
  100451:	8b 45 08             	mov    0x8(%ebp),%eax
  100454:	8b 40 08             	mov    0x8(%eax),%eax
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
			 : "=q"(ret)
			 : "m" (*(volatile uint8_t *) addr)
  100457:	8b 00                	mov    (%eax),%eax
static ALWAYS_INLINE
	uint8_t sys_read8(mm_reg_t addr)
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
  100459:	8a 40 14             	mov    0x14(%eax),%al
  10045c:	83 e0 1e             	and    $0x1e,%eax
}
  10045f:	5d                   	pop    %ebp
 * @return one of UART_ERROR_OVERRUN, UART_ERROR_PARITY, UART_ERROR_FRAMING,
 * UART_ERROR_BREAK if an error was detected, 0 otherwise.
 */
static int uart_ns16550_err_check(struct device *dev)
{
	return (INBYTE(LSR(dev)) & LSR_EOB_MASK) >> 1;
  100460:	d1 f8                	sar    %eax
}
  100462:	c3                   	ret    

00100463 <uart_ns16550_init>:
 * @param dev UART device struct
 *
 * @return 0 if successful, failed othersie
 */
static int uart_ns16550_init(struct device *dev)
{
  100463:	55                   	push   %ebp
  100464:	89 e5                	mov    %esp,%ebp
  100466:	57                   	push   %edi
  100467:	56                   	push   %esi
  100468:	53                   	push   %ebx
  100469:	83 ec 10             	sub    $0x10,%esp
  10046c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
  10046f:	8b 73 08             	mov    0x8(%ebx),%esi
#if defined(CONFIG_UART_NS16550_PCI)
static inline int ns16550_pci_uart_scan(struct device *dev)
{
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);

	if (dev_data->pci_dev.vendor_id == 0x0000) {
  100472:	66 83 7e 1c 00       	cmpw   $0x0,0x1c(%esi)
  100477:	74 23                	je     10049c <uart_ns16550_init+0x39>
		return -EINVAL;
	}

	pci_bus_scan_init();

	if (!pci_bus_scan(&dev_data->pci_dev)) {
  100479:	8d 7e 0c             	lea    0xc(%esi),%edi

	if (dev_data->pci_dev.vendor_id == 0x0000) {
		return -EINVAL;
	}

	pci_bus_scan_init();
  10047c:	e8 24 05 00 00       	call   1009a5 <pci_bus_scan_init>

	if (!pci_bus_scan(&dev_data->pci_dev)) {
  100481:	57                   	push   %edi
  100482:	e8 8c 05 00 00       	call   100a13 <pci_bus_scan>
  100487:	5a                   	pop    %edx
  100488:	85 c0                	test   %eax,%eax
  10048a:	0f 84 b6 00 00 00    	je     100546 <uart_ns16550_init+0xe3>
		return 0;
	}

#ifdef CONFIG_PCI_ENUMERATION
	dev_data->port = dev_data->pci_dev.addr;
  100490:	8b 46 0c             	mov    0xc(%esi),%eax
  100493:	89 06                	mov    %eax,(%esi)
#endif

	pci_enable_regs(&dev_data->pci_dev);
  100495:	57                   	push   %edi
  100496:	e8 49 0b 00 00       	call   100fe4 <pci_enable_regs>
  10049b:	58                   	pop    %eax

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  10049c:	9c                   	pushf  
  10049d:	fa                   	cli    
  10049e:	8f 45 e4             	popl   -0x1c(%ebp)
	dev_data->iir_cache = 0;
#endif

	old_level = irq_lock();

	set_baud_rate(dev, dev_data->baud_rate);
  1004a1:	8b 4e 04             	mov    0x4(%esi),%ecx
	const struct uart_ns16550_device_config * const dev_cfg = DEV_CFG(dev);
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
	uint32_t divisor; /* baud rate divisor */
	uint8_t lcr_cache;

	if ((baud_rate != 0) && (dev_cfg->sys_clk_freq != 0)) {
  1004a4:	85 c9                	test   %ecx,%ecx
  1004a6:	74 53                	je     1004fb <uart_ns16550_init+0x98>
}
#endif

static void set_baud_rate(struct device *dev, uint32_t baud_rate)
{
	const struct uart_ns16550_device_config * const dev_cfg = DEV_CFG(dev);
  1004a8:	8b 03                	mov    (%ebx),%eax
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
	uint32_t divisor; /* baud rate divisor */
	uint8_t lcr_cache;

	if ((baud_rate != 0) && (dev_cfg->sys_clk_freq != 0)) {
  1004aa:	8b 40 08             	mov    0x8(%eax),%eax
  1004ad:	8b 00                	mov    (%eax),%eax
  1004af:	85 c0                	test   %eax,%eax
  1004b1:	74 48                	je     1004fb <uart_ns16550_init+0x98>
		/* calculate baud rate divisor */
		divisor = (dev_cfg->sys_clk_freq / baud_rate) >> 4;
  1004b3:	31 d2                	xor    %edx,%edx
#endif

static void set_baud_rate(struct device *dev, uint32_t baud_rate)
{
	const struct uart_ns16550_device_config * const dev_cfg = DEV_CFG(dev);
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
  1004b5:	8b 7b 08             	mov    0x8(%ebx),%edi
	uint32_t divisor; /* baud rate divisor */
	uint8_t lcr_cache;

	if ((baud_rate != 0) && (dev_cfg->sys_clk_freq != 0)) {
		/* calculate baud rate divisor */
		divisor = (dev_cfg->sys_clk_freq / baud_rate) >> 4;
  1004b8:	f7 f1                	div    %ecx
  1004ba:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1004bd:	c1 e8 04             	shr    $0x4,%eax
  1004c0:	89 45 ec             	mov    %eax,-0x14(%ebp)
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
			 : "=q"(ret)
			 : "m" (*(volatile uint8_t *) addr)
  1004c3:	8b 07                	mov    (%edi),%eax
static ALWAYS_INLINE
	uint8_t sys_read8(mm_reg_t addr)
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
  1004c5:	8a 40 0c             	mov    0xc(%eax),%al
  1004c8:	88 45 eb             	mov    %al,-0x15(%ebp)

		/* set the DLAB to access the baud rate divisor registers */
		lcr_cache = INBYTE(LCR(dev));
		OUTBYTE(LCR(dev), LCR_DLAB);
  1004cb:	8b 43 08             	mov    0x8(%ebx),%eax
static ALWAYS_INLINE
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
  1004ce:	8b 10                	mov    (%eax),%edx
}

static ALWAYS_INLINE
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
  1004d0:	b0 80                	mov    $0x80,%al
  1004d2:	88 42 0c             	mov    %al,0xc(%edx)
		OUTBYTE(BRDL(dev), (unsigned char)(divisor & 0xff));
  1004d5:	8b 43 08             	mov    0x8(%ebx),%eax
  1004d8:	8a 55 ec             	mov    -0x14(%ebp),%dl
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
  1004db:	8b 00                	mov    (%eax),%eax
}

static ALWAYS_INLINE
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
  1004dd:	88 10                	mov    %dl,(%eax)
		OUTBYTE(BRDH(dev), (unsigned char)((divisor >> 8) & 0xff));
  1004df:	8b 53 08             	mov    0x8(%ebx),%edx
  1004e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1004e5:	c1 e8 0c             	shr    $0xc,%eax
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
  1004e8:	8b 12                	mov    (%edx),%edx
}

static ALWAYS_INLINE
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
  1004ea:	88 42 04             	mov    %al,0x4(%edx)

		/* restore the DLAB to access the baud rate divisor registers */
		OUTBYTE(LCR(dev), lcr_cache);
  1004ed:	8b 43 08             	mov    0x8(%ebx),%eax
  1004f0:	8a 55 eb             	mov    -0x15(%ebp),%dl
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
  1004f3:	8b 00                	mov    (%eax),%eax
}

static ALWAYS_INLINE
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
  1004f5:	88 50 0c             	mov    %dl,0xc(%eax)

		dev_data->baud_rate = baud_rate;
  1004f8:	89 4f 04             	mov    %ecx,0x4(%edi)
#ifdef CONFIG_UART_NS16550_DLF
	set_dlf(dev, dev_data->dlf);
#endif

	/* 8 data bits, 1 stop bit, no parity, clear DLAB */
	OUTBYTE(LCR(dev), LCR_CS8 | LCR_1_STB | LCR_PDIS);
  1004fb:	8b 43 08             	mov    0x8(%ebx),%eax
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
  1004fe:	8b 10                	mov    (%eax),%edx
}

static ALWAYS_INLINE
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
  100500:	b0 03                	mov    $0x3,%al
  100502:	88 42 0c             	mov    %al,0xc(%edx)

	mdc = MCR_OUT2 | MCR_RTS | MCR_DTR;
	if ((dev_data->options & UART_OPTION_AFCE) == UART_OPTION_AFCE)
  100505:	8a 46 08             	mov    0x8(%esi),%al
		mdc |= MCR_AFCE;

	OUTBYTE(MDC(dev), mdc);
  100508:	8b 53 08             	mov    0x8(%ebx),%edx

	/* 8 data bits, 1 stop bit, no parity, clear DLAB */
	OUTBYTE(LCR(dev), LCR_CS8 | LCR_1_STB | LCR_PDIS);

	mdc = MCR_OUT2 | MCR_RTS | MCR_DTR;
	if ((dev_data->options & UART_OPTION_AFCE) == UART_OPTION_AFCE)
  10050b:	83 e0 01             	and    $0x1,%eax
		mdc |= MCR_AFCE;
  10050e:	3c 01                	cmp    $0x1,%al
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
  100510:	8b 12                	mov    (%edx),%edx
  100512:	19 c0                	sbb    %eax,%eax
  100514:	83 e0 e0             	and    $0xffffffe0,%eax
  100517:	83 c0 2b             	add    $0x2b,%eax
}

static ALWAYS_INLINE
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
  10051a:	88 42 10             	mov    %al,0x10(%edx)
	/*
	 * Program FIFO: enabled, mode 0 (set for compatibility with quark),
	 * generate the interrupt at 8th byte
	 * Clear TX and RX FIFO
	 */
	OUTBYTE(FCR(dev),
  10051d:	8b 43 08             	mov    0x8(%ebx),%eax
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
  100520:	8b 10                	mov    (%eax),%edx
}

static ALWAYS_INLINE
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
  100522:	b0 87                	mov    $0x87,%al
  100524:	88 42 08             	mov    %al,0x8(%edx)
		FCR_FIFO | FCR_MODE0 | FCR_FIFO_8 | FCR_RCVRCLR | FCR_XMITCLR);

	/* clear the port */
	INBYTE(RDR(dev));
  100527:	8b 43 08             	mov    0x8(%ebx),%eax
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
			 : "=q"(ret)
			 : "m" (*(volatile uint8_t *) addr)
  10052a:	8b 00                	mov    (%eax),%eax
static ALWAYS_INLINE
	uint8_t sys_read8(mm_reg_t addr)
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
  10052c:	8a 00                	mov    (%eax),%al

	/* disable interrupts  */
	OUTBYTE(IER(dev), 0x00);
  10052e:	8b 43 08             	mov    0x8(%ebx),%eax
static ALWAYS_INLINE
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
  100531:	8b 10                	mov    (%eax),%edx
}

static ALWAYS_INLINE
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
  100533:	31 c0                	xor    %eax,%eax
  100535:	88 42 04             	mov    %al,0x4(%edx)

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	DEV_CFG(dev)->irq_config_func(dev);
#endif

	return 0;
  100538:	31 c0                	xor    %eax,%eax
 *
 */

static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	if (!(key & 0x200)) {
  10053a:	f7 45 e4 00 02 00 00 	testl  $0x200,-0x1c(%ebp)
  100541:	74 0f                	je     100552 <uart_ns16550_init+0xef>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  100543:	fb                   	sti    
  100544:	eb 0c                	jmp    100552 <uart_ns16550_init+0xef>

	int old_level;     /* old interrupt lock level */
	uint8_t mdc = 0;

	if (!ns16550_pci_uart_scan(dev)) {
		dev->driver_api = NULL;
  100546:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
		return -ENOTSUP;
  10054d:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	DEV_CFG(dev)->irq_config_func(dev);
#endif

	return 0;
}
  100552:	8d 65 f4             	lea    -0xc(%ebp),%esp
  100555:	5b                   	pop    %ebx
  100556:	5e                   	pop    %esi
  100557:	5f                   	pop    %edi
  100558:	5d                   	pop    %ebp
  100559:	c3                   	ret    

0010055a <_timer_int_handler>:
 * is pushed onto the microkernel stack.
 *
 * @return N/A
 */
void _timer_int_handler(void *unused)
{
  10055a:	55                   	push   %ebp
	ARG_UNUSED(unused);

#if defined(CONFIG_HPET_TIMER_LEVEL_LOW) || defined(CONFIG_HPET_TIMER_LEVEL_HIGH)
	/* Acknowledge interrupt */
	*_HPET_GENERAL_INT_STATUS = 1;
  10055b:	c7 05 20 00 d0 fe 01 	movl   $0x1,0xfed00020
  100562:	00 00 00 
 * is pushed onto the microkernel stack.
 *
 * @return N/A
 */
void _timer_int_handler(void *unused)
{
  100565:	89 e5                	mov    %esp,%ebp
	/*
	 * one more tick has occurred -- don't need to do anything special since
	 * timer is already configured to interrupt on the following tick
	 */

	_sys_clock_tick_announce();
  100567:	a1 80 71 10 00       	mov    0x107180,%eax
  10056c:	89 45 08             	mov    %eax,0x8(%ebp)
	programmed_ticks = 1;

	_sys_clock_final_tick_announce();
#endif /* !CONFIG_TICKLESS_IDLE */

}
  10056f:	5d                   	pop    %ebp
	/*
	 * one more tick has occurred -- don't need to do anything special since
	 * timer is already configured to interrupt on the following tick
	 */

	_sys_clock_tick_announce();
  100570:	e9 95 38 00 00       	jmp    103e0a <_nano_sys_clock_tick_announce>

00100575 <_sys_clock_driver_init>:
 *
 * @return 0
 */

int _sys_clock_driver_init(struct device *device)
{
  100575:	55                   	push   %ebp
  100576:	89 e5                	mov    %esp,%ebp
  100578:	57                   	push   %edi
  100579:	56                   	push   %esi
  10057a:	53                   	push   %ebx
	/*
	 * Initial state of HPET is unknown, so put it back in a reset-like
	 * state (i.e. set main counter to 0 and disable interrupts)
	 */

	*_HPET_GENERAL_CONFIG &= ~HPET_ENABLE_CNF;
  10057b:	a1 10 00 d0 fe       	mov    0xfed00010,%eax
  100580:	83 e0 fe             	and    $0xfffffffe,%eax
  100583:	a3 10 00 d0 fe       	mov    %eax,0xfed00010
	*_HPET_MAIN_COUNTER_VALUE = 0;
  100588:	c7 05 f0 00 d0 fe 00 	movl   $0x0,0xfed000f0
  10058f:	00 00 00 
	/*
	 * compute value for the comparator register to achieve
	 * 'sys_clock_us_per_tick' period
	 */

	counter_load_value = (uint32_t)(tickFempto / hpetClockPeriod);
  100592:	b8 00 ca 9a 3b       	mov    $0x3b9aca00,%eax
	 * Initial state of HPET is unknown, so put it back in a reset-like
	 * state (i.e. set main counter to 0 and disable interrupts)
	 */

	*_HPET_GENERAL_CONFIG &= ~HPET_ENABLE_CNF;
	*_HPET_MAIN_COUNTER_VALUE = 0;
  100597:	c7 05 f4 00 d0 fe 00 	movl   $0x0,0xfed000f4
  10059e:	00 00 00 
	/*
	 * compute value for the comparator register to achieve
	 * 'sys_clock_us_per_tick' period
	 */

	counter_load_value = (uint32_t)(tickFempto / hpetClockPeriod);
  1005a1:	f7 2d 8c 71 10 00    	imull  0x10718c
	 * to determine the frequency of clock applied to the HPET device.
	 */

	/* read the clock period: units are fempto (10^-15) seconds */

	hpetClockPeriod = HPET_COUNTER_CLK_PERIOD(*_HPET_GENERAL_CAPS);
  1005a7:	8b 0d 00 00 d0 fe    	mov    0xfed00000,%ecx
  1005ad:	8b 1d 04 00 d0 fe    	mov    0xfed00004,%ebx
	/*
	 * compute value for the comparator register to achieve
	 * 'sys_clock_us_per_tick' period
	 */

	counter_load_value = (uint32_t)(tickFempto / hpetClockPeriod);
  1005b3:	89 d9                	mov    %ebx,%ecx
  1005b5:	31 db                	xor    %ebx,%ebx
  1005b7:	53                   	push   %ebx
  1005b8:	51                   	push   %ecx
  1005b9:	52                   	push   %edx
  1005ba:	50                   	push   %eax
  1005bb:	e8 80 fc ff ff       	call   100240 <__udivdi3>
  1005c0:	31 db                	xor    %ebx,%ebx
	       (uint32_t)(*_HPET_TIMER0_CONFIG_CAPS >> 32));

	/* Initialize sys_clock_hw_cycles_per_tick/sec */

	sys_clock_hw_cycles_per_tick = counter_load_value;
	sys_clock_hw_cycles_per_sec = sys_clock_hw_cycles_per_tick *
  1005c2:	6b d0 64             	imul   $0x64,%eax,%edx
	PRINTK("HPET: timer0: available interrupts mask 0x%x\n",
	       (uint32_t)(*_HPET_TIMER0_CONFIG_CAPS >> 32));

	/* Initialize sys_clock_hw_cycles_per_tick/sec */

	sys_clock_hw_cycles_per_tick = counter_load_value;
  1005c5:	a3 88 71 10 00       	mov    %eax,0x107188
	sys_clock_hw_cycles_per_sec = sys_clock_hw_cycles_per_tick *
  1005ca:	89 15 84 71 10 00    	mov    %edx,0x107184
	 * Setting 32-bit mode during the first load of the comparator
	 * value is required to work around some hardware that otherwise
	 * does not work properly.
	 */

	*_HPET_TIMER0_CONFIG_CAPS |= HPET_Tn_TYPE_CNF | HPET_Tn_32MODE_CNF;
  1005d0:	8b 35 00 01 d0 fe    	mov    0xfed00100,%esi
  1005d6:	8b 3d 04 01 d0 fe    	mov    0xfed00104,%edi
  1005dc:	89 f2                	mov    %esi,%edx
	/*
	 * compute value for the comparator register to achieve
	 * 'sys_clock_us_per_tick' period
	 */

	counter_load_value = (uint32_t)(tickFempto / hpetClockPeriod);
  1005de:	83 c4 10             	add    $0x10,%esp
	 * Setting 32-bit mode during the first load of the comparator
	 * value is required to work around some hardware that otherwise
	 * does not work properly.
	 */

	*_HPET_TIMER0_CONFIG_CAPS |= HPET_Tn_TYPE_CNF | HPET_Tn_32MODE_CNF;
  1005e1:	81 ca 08 01 00 00    	or     $0x108,%edx
  1005e7:	89 15 00 01 d0 fe    	mov    %edx,0xfed00100
  1005ed:	89 3d 04 01 d0 fe    	mov    %edi,0xfed00104

	/*
	 * Set the comparator register for timer0.  The write to the comparator
	 * register is allowed due to setting the HPET_Tn_VAL_SET_CNF bit.
	 */
	*_HPET_TIMER0_CONFIG_CAPS |= HPET_Tn_VAL_SET_CNF;
  1005f3:	8b 35 00 01 d0 fe    	mov    0xfed00100,%esi
  1005f9:	8b 3d 04 01 d0 fe    	mov    0xfed00104,%edi
  1005ff:	89 f2                	mov    %esi,%edx
  100601:	83 ca 40             	or     $0x40,%edx
  100604:	89 15 00 01 d0 fe    	mov    %edx,0xfed00100
  10060a:	89 3d 04 01 d0 fe    	mov    %edi,0xfed00104
	*_HPET_TIMER0_COMPARATOR = counter_load_value;
  100610:	a3 08 01 d0 fe       	mov    %eax,0xfed00108
  100615:	89 1d 0c 01 d0 fe    	mov    %ebx,0xfed0010c
	/*
	 * After the comparator is loaded, 32-bit mode can be safely
	 * switched off
	 */
	*_HPET_TIMER0_CONFIG_CAPS &= ~HPET_Tn_32MODE_CNF;
  10061b:	8b 0d 00 01 d0 fe    	mov    0xfed00100,%ecx
  100621:	8b 1d 04 01 d0 fe    	mov    0xfed00104,%ebx
  100627:	89 cf                	mov    %ecx,%edi
  100629:	81 e7 ff fe ff ff    	and    $0xfffffeff,%edi
  10062f:	89 3d 00 01 d0 fe    	mov    %edi,0xfed00100
  100635:	89 1d 04 01 d0 fe    	mov    %ebx,0xfed00104
	 * this case program leaves the IRQ fields blank.
	 */

	*_HPET_TIMER0_CONFIG_CAPS =
#if CONFIG_HPET_TIMER_IRQ < 32
		(*_HPET_TIMER0_CONFIG_CAPS & ~HPET_Tn_INT_ROUTE_CNF_MASK) |
  10063b:	a1 00 01 d0 fe       	mov    0xfed00100,%eax
  100640:	8b 15 04 01 d0 fe    	mov    0xfed00104,%edx
#else
		(*_HPET_TIMER0_CONFIG_CAPS & ~HPET_Tn_INT_ROUTE_CNF_MASK)
#endif

#if defined(CONFIG_HPET_TIMER_LEVEL_LOW) || defined(CONFIG_HPET_TIMER_LEVEL_HIGH)
		| HPET_Tn_INT_TYPE_CNF;
  100646:	89 c3                	mov    %eax,%ebx
  100648:	81 e3 fd c1 ff ff    	and    $0xffffc1fd,%ebx
  10064e:	81 cb 02 28 00 00    	or     $0x2802,%ebx
	 * HPET timers IRQ field is 5 bits wide, and hence, can support only
	 * IRQ's up to 31. Some platforms, however, use IRQs greater than 31. In
	 * this case program leaves the IRQ fields blank.
	 */

	*_HPET_TIMER0_CONFIG_CAPS =
  100654:	89 1d 00 01 d0 fe    	mov    %ebx,0xfed00100
  10065a:	89 15 04 01 d0 fe    	mov    %edx,0xfed00104
 * @returns: N/A
 */
static inline void _irq_controller_irq_config(unsigned int vector,
					      unsigned int irq, uint32_t flags)
{
	__irq_controller_irq_config(vector, irq, flags);
  100660:	0f b6 05 fc 6d 10 00 	movzbl 0x106dfc,%eax
  100667:	68 00 a0 00 00       	push   $0xa000
  10066c:	6a 14                	push   $0x14
  10066e:	50                   	push   %eax
  10066f:	e8 af 01 00 00       	call   100823 <__irq_controller_irq_config>
  100674:	83 c4 0c             	add    $0xc,%esp
	IRQ_CONNECT(CONFIG_HPET_TIMER_IRQ, CONFIG_HPET_TIMER_IRQ_PRIORITY,
		   _timer_int_handler, 0, HPET_IOAPIC_FLAGS);

	/* enable the IRQ in the interrupt controller */

	irq_enable(CONFIG_HPET_TIMER_IRQ);
  100677:	6a 14                	push   $0x14
  100679:	e8 cb 01 00 00       	call   100849 <_arch_irq_enable>
  10067e:	58                   	pop    %eax

	/* enable the HPET generally, and timer0 specifically */

	*_HPET_GENERAL_CONFIG |= HPET_ENABLE_CNF;
  10067f:	a1 10 00 d0 fe       	mov    0xfed00010,%eax
  100684:	83 c8 01             	or     $0x1,%eax
  100687:	a3 10 00 d0 fe       	mov    %eax,0xfed00010
	*_HPET_TIMER0_CONFIG_CAPS |= HPET_Tn_INT_ENB_CNF;

	return 0;
}
  10068c:	31 c0                	xor    %eax,%eax
	irq_enable(CONFIG_HPET_TIMER_IRQ);

	/* enable the HPET generally, and timer0 specifically */

	*_HPET_GENERAL_CONFIG |= HPET_ENABLE_CNF;
	*_HPET_TIMER0_CONFIG_CAPS |= HPET_Tn_INT_ENB_CNF;
  10068e:	8b 0d 00 01 d0 fe    	mov    0xfed00100,%ecx
  100694:	8b 1d 04 01 d0 fe    	mov    0xfed00104,%ebx
  10069a:	89 cf                	mov    %ecx,%edi
  10069c:	83 cf 04             	or     $0x4,%edi
  10069f:	89 3d 00 01 d0 fe    	mov    %edi,0xfed00100
  1006a5:	89 1d 04 01 d0 fe    	mov    %ebx,0xfed00104

	return 0;
}
  1006ab:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1006ae:	5b                   	pop    %ebx
  1006af:	5e                   	pop    %esi
  1006b0:	5f                   	pop    %edi
  1006b1:	5d                   	pop    %ebp
  1006b2:	c3                   	ret    

001006b3 <_timer_int_handler_irq20_stub>:

	/*
	 * Although the stub has already been "connected", the vector number
	 * still has to be programmed into the interrupt controller.
	 */
	IRQ_CONNECT(CONFIG_HPET_TIMER_IRQ, CONFIG_HPET_TIMER_IRQ_PRIORITY,
  1006b3:	6a 00                	push   $0x0
  1006b5:	68 5a 05 10 00       	push   $0x10055a
  1006ba:	e9 d8 2c 00 00       	jmp    103397 <_interrupt_enter>

001006bf <shared_irq_isr_irq18_stub>:
  1006bf:	68 d8 71 10 00       	push   $0x1071d8
  1006c4:	68 d8 12 10 00       	push   $0x1012d8
  1006c9:	e9 c9 2c 00 00       	jmp    103397 <_interrupt_enter>

001006ce <spi_intel_isr_irq16_stub>:
  1006ce:	68 68 72 10 00       	push   $0x107268
  1006d3:	68 9a 15 10 00       	push   $0x10159a
  1006d8:	e9 ba 2c 00 00       	jmp    103397 <_interrupt_enter>

001006dd <_loapic_init>:
 * @return N/A
 *
 */

static int _loapic_init(struct device *unused)
{
  1006dd:	55                   	push   %ebp
  1006de:	89 e5                	mov    %esp,%ebp
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  1006e0:	a1 f0 00 e0 fe       	mov    0xfee000f0,%eax
	ARG_UNUSED(unused);
	int32_t loApicMaxLvt; /* local APIC Max LVT */

	/* enable the Local APIC */
	sys_write32(sys_read32(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_SVR)
  1006e5:	80 cc 01             	or     $0x1,%ah
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  1006e8:	a3 f0 00 e0 fe       	mov    %eax,0xfee000f0
		    | LOAPIC_ENABLE, CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_SVR);

	loApicMaxLvt = (*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_VER) &
  1006ed:	a1 30 00 e0 fe       	mov    0xfee00030,%eax
			LOAPIC_MAXLVT_MASK) >> 16;

	/* reset the DFR, TPR, TIMER_CONFIG, and TIMER_ICR */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_DFR) =
  1006f2:	c7 05 e0 00 e0 fe ff 	movl   $0xffffffff,0xfee000e0
  1006f9:	ff ff ff 
		(int)0xffffffff;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TPR) = (int)0x0;
  1006fc:	c7 05 80 00 e0 fe 00 	movl   $0x0,0xfee00080
  100703:	00 00 00 
	*(volatile int *) (CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER_CONFIG) =
  100706:	c7 05 e0 03 e0 fe 00 	movl   $0x0,0xfee003e0
  10070d:	00 00 00 
		(int)0x0;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER_ICR) = (int)0x0;
  100710:	c7 05 80 03 e0 fe 00 	movl   $0x0,0xfee00380
  100717:	00 00 00 

	/* enable the Local APIC */
	sys_write32(sys_read32(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_SVR)
		    | LOAPIC_ENABLE, CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_SVR);

	loApicMaxLvt = (*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_VER) &
  10071a:	25 00 00 ff 00       	and    $0xff0000,%eax
  10071f:	c1 f8 10             	sar    $0x10,%eax
	/* program Local Vector Table for the Virtual Wire Mode */

	/* set LINT0: extInt, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) =
		(*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) &
  100722:	8b 15 50 03 e0 fe    	mov    0xfee00350,%edx
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
  100728:	81 e2 ff 58 fe ff    	and    $0xfffe58ff,%edx
  10072e:	80 ce 07             	or     $0x7,%dh

	/* program Local Vector Table for the Virtual Wire Mode */

	/* set LINT0: extInt, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) =
  100731:	89 15 50 03 e0 fe    	mov    %edx,0xfee00350
		(LOAPIC_EXT | LOAPIC_HIGH | LOAPIC_EDGE);

	/* set LINT1: NMI, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) =
		(*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) &
  100737:	8b 15 60 03 e0 fe    	mov    0xfee00360,%edx
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
  10073d:	81 e2 ff 58 fe ff    	and    $0xfffe58ff,%edx
  100743:	80 ce 04             	or     $0x4,%dh
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER) =
		LOAPIC_LVT_MASKED;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ERROR) =
		LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_P6)
  100746:	83 f8 03             	cmp    $0x3,%eax
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
		(LOAPIC_EXT | LOAPIC_HIGH | LOAPIC_EDGE);

	/* set LINT1: NMI, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) =
  100749:	89 15 60 03 e0 fe    	mov    %edx,0xfee00360
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
		(LOAPIC_NMI | LOAPIC_HIGH | LOAPIC_EDGE);

	/* lock the Local APIC interrupts */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER) =
  10074f:	c7 05 20 03 e0 fe 00 	movl   $0x10000,0xfee00320
  100756:	00 01 00 
		LOAPIC_LVT_MASKED;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ERROR) =
  100759:	c7 05 70 03 e0 fe 00 	movl   $0x10000,0xfee00370
  100760:	00 01 00 
		LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_P6)
  100763:	7e 19                	jle    10077e <_loapic_init+0xa1>
		*(volatile int *) (CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_PMC) =
  100765:	c7 05 40 03 e0 fe 00 	movl   $0x10000,0xfee00340
  10076c:	00 01 00 
			LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_PENTIUM4)
  10076f:	83 f8 04             	cmp    $0x4,%eax
  100772:	74 0a                	je     10077e <_loapic_init+0xa1>
		*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_THERMAL) =
  100774:	c7 05 30 03 e0 fe 00 	movl   $0x10000,0xfee00330
  10077b:	00 01 00 

	/* discard a pending interrupt if any */
#if CONFIG_EOI_FORWARDING_BUG
	_lakemont_eoi();
#else
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_EOI) = 0;
  10077e:	c7 05 b0 00 e0 fe 00 	movl   $0x0,0xfee000b0
  100785:	00 00 00 
#endif

	return 0;
}
  100788:	31 c0                	xor    %eax,%eax
  10078a:	5d                   	pop    %ebp
  10078b:	c3                   	ret    

0010078c <_loapic_int_vec_set>:
 */

void _loapic_int_vec_set(unsigned int irq, /* IRQ number of the interrupt */
				  unsigned int vector /* vector to copy into the LVT */
				  )
{
  10078c:	55                   	push   %ebp
  10078d:	89 e5                	mov    %esp,%ebp
	 *   IRQ5 -> LOAPIC_ERROR
	 *
	 * It's assumed that LVTs are spaced by 0x10 bytes
	 */

	pLvt = (volatile int *)
  10078f:	8b 45 08             	mov    0x8(%ebp),%eax
  100792:	05 32 00 ee 0f       	add    $0xfee0032,%eax
  100797:	c1 e0 04             	shl    $0x4,%eax

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  10079a:	9c                   	pushf  
  10079b:	fa                   	cli    
  10079c:	59                   	pop    %ecx
			(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER + (irq * 0x10));

	/* update the 'vector' bits in the LVT */

	oldLevel = irq_lock();
	*pLvt = (*pLvt & ~LOAPIC_VECTOR) | vector;
  10079d:	8b 10                	mov    (%eax),%edx
  10079f:	30 d2                	xor    %dl,%dl
  1007a1:	0b 55 0c             	or     0xc(%ebp),%edx
  1007a4:	80 e5 02             	and    $0x2,%ch
  1007a7:	89 10                	mov    %edx,(%eax)
  1007a9:	74 01                	je     1007ac <_loapic_int_vec_set+0x20>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1007ab:	fb                   	sti    
	irq_unlock(oldLevel);
}
  1007ac:	5d                   	pop    %ebp
  1007ad:	c3                   	ret    

001007ae <_loapic_irq_enable>:
 *
 * @return N/A
 */

void _loapic_irq_enable(unsigned int irq)
{
  1007ae:	55                   	push   %ebp
  1007af:	89 e5                	mov    %esp,%ebp
	/*
	 * See the comments in _LoApicLvtVecSet() regarding IRQ to LVT mappings
	 * and ths assumption concerning LVT spacing.
	 */

	pLvt = (volatile int *)
  1007b1:	8b 45 08             	mov    0x8(%ebp),%eax
  1007b4:	05 32 00 ee 0f       	add    $0xfee0032,%eax
  1007b9:	c1 e0 04             	shl    $0x4,%eax

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1007bc:	9c                   	pushf  
  1007bd:	fa                   	cli    
  1007be:	59                   	pop    %ecx
		(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER + (irq * 0x10));

	/* clear the mask bit in the LVT */

	oldLevel = irq_lock();
	*pLvt = *pLvt & ~LOAPIC_LVT_MASKED;
  1007bf:	8b 10                	mov    (%eax),%edx
  1007c1:	81 e2 ff ff fe ff    	and    $0xfffeffff,%edx
  1007c7:	80 e5 02             	and    $0x2,%ch
  1007ca:	89 10                	mov    %edx,(%eax)
  1007cc:	74 01                	je     1007cf <_loapic_irq_enable+0x21>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1007ce:	fb                   	sti    
	irq_unlock(oldLevel);
}
  1007cf:	5d                   	pop    %ebp
  1007d0:	c3                   	ret    

001007d1 <_loapic_irq_disable>:
 *
 * @return N/A
 */

void _loapic_irq_disable(unsigned int irq)
{
  1007d1:	55                   	push   %ebp
  1007d2:	89 e5                	mov    %esp,%ebp
	/*
	 * See the comments in _LoApicLvtVecSet() regarding IRQ to LVT mappings
	 * and ths assumption concerning LVT spacing.
	 */

	pLvt = (volatile int *)
  1007d4:	8b 45 08             	mov    0x8(%ebp),%eax
  1007d7:	05 32 00 ee 0f       	add    $0xfee0032,%eax
  1007dc:	c1 e0 04             	shl    $0x4,%eax

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1007df:	9c                   	pushf  
  1007e0:	fa                   	cli    
  1007e1:	59                   	pop    %ecx
		(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER + (irq * 0x10));

	/* set the mask bit in the LVT */

	oldLevel = irq_lock();
	*pLvt = *pLvt | LOAPIC_LVT_MASKED;
  1007e2:	8b 10                	mov    (%eax),%edx
  1007e4:	81 ca 00 00 01 00    	or     $0x10000,%edx
  1007ea:	80 e5 02             	and    $0x2,%ch
  1007ed:	89 10                	mov    %edx,(%eax)
  1007ef:	74 01                	je     1007f2 <_loapic_irq_disable+0x21>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1007f1:	fb                   	sti    
	irq_unlock(oldLevel);
}
  1007f2:	5d                   	pop    %ebp
  1007f3:	c3                   	ret    

001007f4 <__irq_controller_isr_vector_get>:
 *
 * @return The vector of the interrupt that is currently being processed, or -1
 * if no IRQ is being serviced.
 */
int __irq_controller_isr_vector_get(void)
{
  1007f4:	55                   	push   %ebp
  1007f5:	b9 70 01 e0 fe       	mov    $0xfee00170,%ecx
  1007fa:	89 e5                	mov    %esp,%ebp
	int pReg, block;

	/* Block 0 bits never lit up as these are all exception or reserved
	 * vectors
	 */
	for (block = 7; likely(block > 0); block--) {
  1007fc:	b8 07 00 00 00       	mov    $0x7,%eax
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  100801:	8b 11                	mov    (%ecx),%edx
		pReg = sys_read32(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ISR +
				  (block * 0x10));
		if (pReg) {
  100803:	85 d2                	test   %edx,%edx
  100805:	74 11                	je     100818 <__irq_controller_isr_vector_get+0x24>

static ALWAYS_INLINE unsigned int find_msb_set(uint32_t op)
{
	unsigned int bitpos;

	__asm__ volatile (
  100807:	0f bd d2             	bsr    %edx,%edx
  10080a:	75 05                	jne    100811 <__irq_controller_isr_vector_get+0x1d>
  10080c:	ba ff ff ff ff       	mov    $0xffffffff,%edx
			return (block * 32) + (find_msb_set(pReg) - 1);
  100811:	c1 e0 05             	shl    $0x5,%eax
  100814:	01 d0                	add    %edx,%eax
  100816:	eb 09                	jmp    100821 <__irq_controller_isr_vector_get+0x2d>
  100818:	83 e9 10             	sub    $0x10,%ecx
	int pReg, block;

	/* Block 0 bits never lit up as these are all exception or reserved
	 * vectors
	 */
	for (block = 7; likely(block > 0); block--) {
  10081b:	48                   	dec    %eax
  10081c:	75 e3                	jne    100801 <__irq_controller_isr_vector_get+0xd>
		if (pReg) {
			return (block * 32) + (find_msb_set(pReg) - 1);
		}

	}
	return -1;
  10081e:	83 c8 ff             	or     $0xffffffff,%eax
}
  100821:	5d                   	pop    %ebp
  100822:	c3                   	ret    

00100823 <__irq_controller_irq_config>:
 * @param flags interrupt flags
 *
 */
void __irq_controller_irq_config(unsigned int vector, unsigned int irq,
				 uint32_t flags)
{
  100823:	55                   	push   %ebp
  100824:	89 e5                	mov    %esp,%ebp
  100826:	8b 45 0c             	mov    0xc(%ebp),%eax
  100829:	8b 55 08             	mov    0x8(%ebp),%edx
	__ASSERT(irq >= 0 && irq <= HARDWARE_IRQ_LIMIT, "invalid irq line");

	if (IS_IOAPIC_IRQ(irq)) {
		_ioapic_irq_set(irq, vector, flags);
  10082c:	89 55 0c             	mov    %edx,0xc(%ebp)
void __irq_controller_irq_config(unsigned int vector, unsigned int irq,
				 uint32_t flags)
{
	__ASSERT(irq >= 0 && irq <= HARDWARE_IRQ_LIMIT, "invalid irq line");

	if (IS_IOAPIC_IRQ(irq)) {
  10082f:	83 f8 17             	cmp    $0x17,%eax
  100832:	77 09                	ja     10083d <__irq_controller_irq_config+0x1a>
		_ioapic_irq_set(irq, vector, flags);
  100834:	89 45 08             	mov    %eax,0x8(%ebp)
	} else {
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
	}
}
  100837:	5d                   	pop    %ebp
				 uint32_t flags)
{
	__ASSERT(irq >= 0 && irq <= HARDWARE_IRQ_LIMIT, "invalid irq line");

	if (IS_IOAPIC_IRQ(irq)) {
		_ioapic_irq_set(irq, vector, flags);
  100838:	e9 e3 00 00 00       	jmp    100920 <_ioapic_irq_set>
	} else {
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
  10083d:	83 e8 18             	sub    $0x18,%eax
  100840:	89 45 08             	mov    %eax,0x8(%ebp)
	}
}
  100843:	5d                   	pop    %ebp
	__ASSERT(irq >= 0 && irq <= HARDWARE_IRQ_LIMIT, "invalid irq line");

	if (IS_IOAPIC_IRQ(irq)) {
		_ioapic_irq_set(irq, vector, flags);
	} else {
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
  100844:	e9 43 ff ff ff       	jmp    10078c <_loapic_int_vec_set>

00100849 <_arch_irq_enable>:
 * virtualization.
 *
 * @return N/A
 */
void _arch_irq_enable(unsigned int irq)
{
  100849:	55                   	push   %ebp
  10084a:	89 e5                	mov    %esp,%ebp
  10084c:	8b 45 08             	mov    0x8(%ebp),%eax
	if (IS_IOAPIC_IRQ(irq)) {
  10084f:	83 f8 17             	cmp    $0x17,%eax
  100852:	77 06                	ja     10085a <_arch_irq_enable+0x11>
		_ioapic_irq_enable(irq);
	} else {
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
	}
}
  100854:	5d                   	pop    %ebp
 * @return N/A
 */
void _arch_irq_enable(unsigned int irq)
{
	if (IS_IOAPIC_IRQ(irq)) {
		_ioapic_irq_enable(irq);
  100855:	e9 9d 00 00 00       	jmp    1008f7 <_ioapic_irq_enable>
	} else {
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
  10085a:	83 e8 18             	sub    $0x18,%eax
  10085d:	89 45 08             	mov    %eax,0x8(%ebp)
	}
}
  100860:	5d                   	pop    %ebp
void _arch_irq_enable(unsigned int irq)
{
	if (IS_IOAPIC_IRQ(irq)) {
		_ioapic_irq_enable(irq);
	} else {
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
  100861:	e9 48 ff ff ff       	jmp    1007ae <_loapic_irq_enable>

00100866 <_arch_irq_disable>:
 * virtualization.
 *
 * @return N/A
 */
void _arch_irq_disable(unsigned int irq)
{
  100866:	55                   	push   %ebp
  100867:	89 e5                	mov    %esp,%ebp
  100869:	8b 45 08             	mov    0x8(%ebp),%eax
	if (IS_IOAPIC_IRQ(irq)) {
  10086c:	83 f8 17             	cmp    $0x17,%eax
  10086f:	77 06                	ja     100877 <_arch_irq_disable+0x11>
		_ioapic_irq_disable(irq);
	} else {
		_loapic_irq_disable(irq - LOAPIC_IRQ_BASE);
	}
}
  100871:	5d                   	pop    %ebp
 * @return N/A
 */
void _arch_irq_disable(unsigned int irq)
{
	if (IS_IOAPIC_IRQ(irq)) {
		_ioapic_irq_disable(irq);
  100872:	e9 93 00 00 00       	jmp    10090a <_ioapic_irq_disable>
	} else {
		_loapic_irq_disable(irq - LOAPIC_IRQ_BASE);
  100877:	83 e8 18             	sub    $0x18,%eax
  10087a:	89 45 08             	mov    %eax,0x8(%ebp)
	}
}
  10087d:	5d                   	pop    %ebp
void _arch_irq_disable(unsigned int irq)
{
	if (IS_IOAPIC_IRQ(irq)) {
		_ioapic_irq_disable(irq);
	} else {
		_loapic_irq_disable(irq - LOAPIC_IRQ_BASE);
  10087e:	e9 4e ff ff ff       	jmp    1007d1 <_loapic_irq_disable>

00100883 <__IoApicSet>:
 * @param offset Register offset (8 bits)
 * @param value Value to set the register
 * @return N/A
 */
static void __IoApicSet(int32_t offset, uint32_t value)
{
  100883:	55                   	push   %ebp
  100884:	89 e5                	mov    %esp,%ebp

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  100886:	9c                   	pushf  
  100887:	fa                   	cli    
  100888:	59                   	pop    %ecx
  100889:	80 e5 02             	and    $0x2,%ch

	/* lock interrupts to ensure indirect addressing works "atomically" */

	key = irq_lock();

	*(volatile char *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_IND) = (char)offset;
  10088c:	a2 00 00 c0 fe       	mov    %al,0xfec00000
	*((volatile uint32_t *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_DATA)) = value;
  100891:	89 15 10 00 c0 fe    	mov    %edx,0xfec00010
  100897:	74 01                	je     10089a <__IoApicSet+0x17>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  100899:	fb                   	sti    

	irq_unlock(key);
}
  10089a:	5d                   	pop    %ebp
  10089b:	c3                   	ret    

0010089c <_IoApicRedUpdateLo>:
 * @return N/A
 */
static void _IoApicRedUpdateLo(unsigned int irq,
				uint32_t value,
				uint32_t mask)
{
  10089c:	55                   	push   %ebp
 * @param irq INTIN number
 * @return 32 low-order bits
 */
static uint32_t ioApicRedGetLo(unsigned int irq)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
  10089d:	8d 44 00 10          	lea    0x10(%eax,%eax,1),%eax
 * @return N/A
 */
static void _IoApicRedUpdateLo(unsigned int irq,
				uint32_t value,
				uint32_t mask)
{
  1008a1:	89 e5                	mov    %esp,%ebp
  1008a3:	56                   	push   %esi
  1008a4:	53                   	push   %ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1008a5:	9c                   	pushf  
  1008a6:	fa                   	cli    
  1008a7:	5e                   	pop    %esi
	/* lock interrupts to ensure indirect addressing works "atomically" */

	key = irq_lock();

	*((volatile char *)
		(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_IND)) = (char)offset;
  1008a8:	a2 00 00 c0 fe       	mov    %al,0xfec00000
  1008ad:	81 e6 00 02 00 00    	and    $0x200,%esi
	value = *((volatile uint32_t *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_DATA));
  1008b3:	8b 1d 10 00 c0 fe    	mov    0xfec00010,%ebx
  1008b9:	74 01                	je     1008bc <_IoApicRedUpdateLo+0x20>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1008bb:	fb                   	sti    
 */
static void ioApicRedSetLo(unsigned int irq, uint32_t lower32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */

	__IoApicSet(offset, lower32);
  1008bc:	31 da                	xor    %ebx,%edx
  1008be:	21 ca                	and    %ecx,%edx
  1008c0:	31 da                	xor    %ebx,%edx
static void _IoApicRedUpdateLo(unsigned int irq,
				uint32_t value,
				uint32_t mask)
{
	ioApicRedSetLo(irq, (ioApicRedGetLo(irq) & ~mask) | (value & mask));
}
  1008c2:	5b                   	pop    %ebx
  1008c3:	5e                   	pop    %esi
  1008c4:	5d                   	pop    %ebp
 */
static void ioApicRedSetLo(unsigned int irq, uint32_t lower32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */

	__IoApicSet(offset, lower32);
  1008c5:	e9 b9 ff ff ff       	jmp    100883 <__IoApicSet>

001008ca <_ioapic_init>:
 * This routine initializes the IO APIC or xAPIC.
 *
 * @return N/A
 */
int _ioapic_init(struct device *unused)
{
  1008ca:	55                   	push   %ebp
  1008cb:	89 e5                	mov    %esp,%ebp
  1008cd:	56                   	push   %esi
  1008ce:	53                   	push   %ebx
	 * ((__IoApicGet(IOAPIC_VERS) & IOAPIC_MRE_MASK) >> 16) + 1
	 */
	rteValue = IOAPIC_EDGE | IOAPIC_HIGH | IOAPIC_FIXED | IOAPIC_INT_MASK |
		   IOAPIC_PHYSICAL | 0 /* dummy vector */;

	for (ix = 0; ix < CONFIG_IOAPIC_NUM_RTES; ix++) {
  1008cf:	31 db                	xor    %ebx,%ebx
 * @param upper32 Value to be written
 * @return N/A
 */
static void ioApicRedSetHi(unsigned int irq, uint32_t upper32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
  1008d1:	8d 34 1b             	lea    (%ebx,%ebx,1),%esi

	__IoApicSet(offset, upper32);
  1008d4:	31 d2                	xor    %edx,%edx
	 * ((__IoApicGet(IOAPIC_VERS) & IOAPIC_MRE_MASK) >> 16) + 1
	 */
	rteValue = IOAPIC_EDGE | IOAPIC_HIGH | IOAPIC_FIXED | IOAPIC_INT_MASK |
		   IOAPIC_PHYSICAL | 0 /* dummy vector */;

	for (ix = 0; ix < CONFIG_IOAPIC_NUM_RTES; ix++) {
  1008d6:	43                   	inc    %ebx
 */
static void ioApicRedSetHi(unsigned int irq, uint32_t upper32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */

	__IoApicSet(offset, upper32);
  1008d7:	8d 46 11             	lea    0x11(%esi),%eax
  1008da:	e8 a4 ff ff ff       	call   100883 <__IoApicSet>
 */
static void ioApicRedSetLo(unsigned int irq, uint32_t lower32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */

	__IoApicSet(offset, lower32);
  1008df:	8d 46 10             	lea    0x10(%esi),%eax
  1008e2:	ba 00 00 01 00       	mov    $0x10000,%edx
  1008e7:	e8 97 ff ff ff       	call   100883 <__IoApicSet>
	 * ((__IoApicGet(IOAPIC_VERS) & IOAPIC_MRE_MASK) >> 16) + 1
	 */
	rteValue = IOAPIC_EDGE | IOAPIC_HIGH | IOAPIC_FIXED | IOAPIC_INT_MASK |
		   IOAPIC_PHYSICAL | 0 /* dummy vector */;

	for (ix = 0; ix < CONFIG_IOAPIC_NUM_RTES; ix++) {
  1008ec:	83 fb 18             	cmp    $0x18,%ebx
  1008ef:	75 e0                	jne    1008d1 <_ioapic_init+0x7>
		ioApicRedSetHi(ix, 0);
		ioApicRedSetLo(ix, rteValue);
	}
#endif
	return 0;
}
  1008f1:	5b                   	pop    %ebx
  1008f2:	31 c0                	xor    %eax,%eax
  1008f4:	5e                   	pop    %esi
  1008f5:	5d                   	pop    %ebp
  1008f6:	c3                   	ret    

001008f7 <_ioapic_irq_enable>:
 * @param irq IRQ number to enable
 *
 * @return N/A
 */
void _ioapic_irq_enable(unsigned int irq)
{
  1008f7:	55                   	push   %ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
  1008f8:	b9 00 00 01 00       	mov    $0x10000,%ecx
 * @param irq IRQ number to enable
 *
 * @return N/A
 */
void _ioapic_irq_enable(unsigned int irq)
{
  1008fd:	89 e5                	mov    %esp,%ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
  1008ff:	31 d2                	xor    %edx,%edx
  100901:	8b 45 08             	mov    0x8(%ebp),%eax
}
  100904:	5d                   	pop    %ebp
 *
 * @return N/A
 */
void _ioapic_irq_enable(unsigned int irq)
{
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
  100905:	e9 92 ff ff ff       	jmp    10089c <_IoApicRedUpdateLo>

0010090a <_ioapic_irq_disable>:
 * @param irq IRQ number to disable
 *
 * @return N/A
 */
void _ioapic_irq_disable(unsigned int irq)
{
  10090a:	55                   	push   %ebp
	_IoApicRedUpdateLo(irq, IOAPIC_INT_MASK, IOAPIC_INT_MASK);
  10090b:	b9 00 00 01 00       	mov    $0x10000,%ecx
 * @param irq IRQ number to disable
 *
 * @return N/A
 */
void _ioapic_irq_disable(unsigned int irq)
{
  100910:	89 e5                	mov    %esp,%ebp
	_IoApicRedUpdateLo(irq, IOAPIC_INT_MASK, IOAPIC_INT_MASK);
  100912:	ba 00 00 01 00       	mov    $0x10000,%edx
  100917:	8b 45 08             	mov    0x8(%ebp),%eax
}
  10091a:	5d                   	pop    %ebp
 *
 * @return N/A
 */
void _ioapic_irq_disable(unsigned int irq)
{
	_IoApicRedUpdateLo(irq, IOAPIC_INT_MASK, IOAPIC_INT_MASK);
  10091b:	e9 7c ff ff ff       	jmp    10089c <_IoApicRedUpdateLo>

00100920 <_ioapic_irq_set>:
 * @param flags Interrupt flags
 *
 * @return N/A
 */
void _ioapic_irq_set(unsigned int irq, unsigned int vector, uint32_t flags)
{
  100920:	55                   	push   %ebp
 */
static void ioApicRedSetHi(unsigned int irq, uint32_t upper32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */

	__IoApicSet(offset, upper32);
  100921:	31 d2                	xor    %edx,%edx
 * @param flags Interrupt flags
 *
 * @return N/A
 */
void _ioapic_irq_set(unsigned int irq, unsigned int vector, uint32_t flags)
{
  100923:	89 e5                	mov    %esp,%ebp
  100925:	56                   	push   %esi
  100926:	53                   	push   %ebx
  100927:	8b 5d 08             	mov    0x8(%ebp),%ebx
 * @param upper32 Value to be written
 * @return N/A
 */
static void ioApicRedSetHi(unsigned int irq, uint32_t upper32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
  10092a:	01 db                	add    %ebx,%ebx
 */
void _ioapic_irq_set(unsigned int irq, unsigned int vector, uint32_t flags)
{
	uint32_t rteValue;   /* value to copy into redirection table entry */

	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
  10092c:	0f b6 75 0c          	movzbl 0xc(%ebp),%esi
 */
static void ioApicRedSetHi(unsigned int irq, uint32_t upper32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */

	__IoApicSet(offset, upper32);
  100930:	8d 43 11             	lea    0x11(%ebx),%eax
 */
void _ioapic_irq_set(unsigned int irq, unsigned int vector, uint32_t flags)
{
	uint32_t rteValue;   /* value to copy into redirection table entry */

	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
  100933:	0b 75 10             	or     0x10(%ebp),%esi
 */
static void ioApicRedSetHi(unsigned int irq, uint32_t upper32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */

	__IoApicSet(offset, upper32);
  100936:	e8 48 ff ff ff       	call   100883 <__IoApicSet>
 */
void _ioapic_irq_set(unsigned int irq, unsigned int vector, uint32_t flags)
{
	uint32_t rteValue;   /* value to copy into redirection table entry */

	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
  10093b:	81 ce 00 00 01 00    	or     $0x10000,%esi
 */
static void ioApicRedSetLo(unsigned int irq, uint32_t lower32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */

	__IoApicSet(offset, lower32);
  100941:	8d 43 10             	lea    0x10(%ebx),%eax
  100944:	89 f2                	mov    %esi,%edx

	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
		   (vector & IOAPIC_VEC_MASK) | flags;
	ioApicRedSetHi(irq, 0);
	ioApicRedSetLo(irq, rteValue);
}
  100946:	5b                   	pop    %ebx
  100947:	5e                   	pop    %esi
  100948:	5d                   	pop    %ebp
 */
static void ioApicRedSetLo(unsigned int irq, uint32_t lower32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */

	__IoApicSet(offset, lower32);
  100949:	e9 35 ff ff ff       	jmp    100883 <__IoApicSet>

0010094e <pci_set_command_bits>:
	return 0;
}
#endif /* CONFIG_PCI_ENUMERATION */

static void pci_set_command_bits(struct pci_dev_info *dev_info, uint32_t bits)
{
  10094e:	55                   	push   %ebp
  10094f:	89 e5                	mov    %esp,%ebp
  100951:	56                   	push   %esi
  100952:	53                   	push   %ebx
  100953:	51                   	push   %ecx
	union pci_addr_reg pci_ctrl_addr;
	uint32_t pci_data;

	pci_ctrl_addr.value = 0;
	pci_ctrl_addr.field.func = dev_info->function;
	pci_ctrl_addr.field.bus = dev_info->bus;
  100954:	0f b6 58 0c          	movzbl 0xc(%eax),%ebx
  100958:	c1 e3 10             	shl    $0x10,%ebx
	return 0;
}
#endif /* CONFIG_PCI_ENUMERATION */

static void pci_set_command_bits(struct pci_dev_info *dev_info, uint32_t bits)
{
  10095b:	89 d6                	mov    %edx,%esi
	union pci_addr_reg pci_ctrl_addr;
	uint32_t pci_data;

	pci_ctrl_addr.value = 0;
	pci_ctrl_addr.field.func = dev_info->function;
  10095d:	8b 50 0c             	mov    0xc(%eax),%edx
	pci_ctrl_addr.field.bus = dev_info->bus;
	pci_ctrl_addr.field.device = dev_info->dev;
  100960:	8a 40 0d             	mov    0xd(%eax),%al
{
	union pci_addr_reg pci_ctrl_addr;
	uint32_t pci_data;

	pci_ctrl_addr.value = 0;
	pci_ctrl_addr.field.func = dev_info->function;
  100963:	c1 ea 05             	shr    $0x5,%edx
	pci_ctrl_addr.field.bus = dev_info->bus;
	pci_ctrl_addr.field.device = dev_info->dev;
  100966:	83 e0 1f             	and    $0x1f,%eax
  100969:	c1 e0 0b             	shl    $0xb,%eax
	union pci_addr_reg pci_ctrl_addr;
	uint32_t pci_data;

	pci_ctrl_addr.value = 0;
	pci_ctrl_addr.field.func = dev_info->function;
	pci_ctrl_addr.field.bus = dev_info->bus;
  10096c:	81 e2 00 07 00 00    	and    $0x700,%edx
	pci_ctrl_addr.field.device = dev_info->dev;
  100972:	09 d3                	or     %edx,%ebx
	pci_ctrl_addr.field.reg = 1;
  100974:	09 c3                	or     %eax,%ebx

#ifdef CONFIG_PCI_DEBUG
	printk("pci_set_command_bits 0x%x\n", pci_ctrl_addr.value);
#endif

	pci_read(DEFAULT_PCI_CONTROLLER,
  100976:	8d 45 f4             	lea    -0xc(%ebp),%eax

	pci_ctrl_addr.value = 0;
	pci_ctrl_addr.field.func = dev_info->function;
	pci_ctrl_addr.field.bus = dev_info->bus;
	pci_ctrl_addr.field.device = dev_info->dev;
	pci_ctrl_addr.field.reg = 1;
  100979:	83 cb 04             	or     $0x4,%ebx

#ifdef CONFIG_PCI_DEBUG
	printk("pci_set_command_bits 0x%x\n", pci_ctrl_addr.value);
#endif

	pci_read(DEFAULT_PCI_CONTROLLER,
  10097c:	50                   	push   %eax
  10097d:	6a 02                	push   $0x2
  10097f:	53                   	push   %ebx
  100980:	6a 00                	push   $0x0
  100982:	e8 6e 06 00 00       	call   100ff5 <pci_read>
  100987:	83 c4 10             	add    $0x10,%esp
			pci_ctrl_addr,
			sizeof(uint16_t),
			&pci_data);

	pci_data = pci_data | bits;
  10098a:	0b 75 f4             	or     -0xc(%ebp),%esi

	pci_write(DEFAULT_PCI_CONTROLLER,
  10098d:	56                   	push   %esi
  10098e:	6a 02                	push   $0x2
  100990:	53                   	push   %ebx
  100991:	6a 00                	push   $0x0
	pci_read(DEFAULT_PCI_CONTROLLER,
			pci_ctrl_addr,
			sizeof(uint16_t),
			&pci_data);

	pci_data = pci_data | bits;
  100993:	89 75 f4             	mov    %esi,-0xc(%ebp)

	pci_write(DEFAULT_PCI_CONTROLLER,
  100996:	e8 ca 06 00 00       	call   101065 <pci_write>
  10099b:	83 c4 10             	add    $0x10,%esp
			pci_ctrl_addr,
			sizeof(uint16_t),
			pci_data);
}
  10099e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1009a1:	5b                   	pop    %ebx
  1009a2:	5e                   	pop    %esi
  1009a3:	5d                   	pop    %ebp
  1009a4:	c3                   	ret    

001009a5 <pci_bus_scan_init>:
	lookup.info.class_type = 0;
	lookup.info.vendor_id = 0;
	lookup.info.device_id = 0;
	lookup.info.function = PCI_FUNCTION_ANY;
	lookup.info.bar = PCI_BAR_ANY;
	lookup.bus = 0;
  1009a5:	66 81 25 74 7f 10 00 	andw   $0xfe00,0x107f74
  1009ac:	00 fe 
	return 0;
}

void pci_bus_scan_init(void)
{
	lookup.info.class_type = 0;
  1009ae:	66 81 25 6e 7f 10 00 	andw   $0xfc03,0x107f6e
  1009b5:	03 fc 
	lookup.info.vendor_id = 0;
	lookup.info.device_id = 0;
	lookup.info.function = PCI_FUNCTION_ANY;
	lookup.info.bar = PCI_BAR_ANY;
	lookup.bus = 0;
	lookup.dev = 0;
  1009b7:	80 25 75 7f 10 00 81 	andb   $0x81,0x107f75
void pci_bus_scan_init(void)
{
	lookup.info.class_type = 0;
	lookup.info.vendor_id = 0;
	lookup.info.device_id = 0;
	lookup.info.function = PCI_FUNCTION_ANY;
  1009be:	a1 6c 7f 10 00       	mov    0x107f6c,%eax

	return 0;
}

void pci_bus_scan_init(void)
{
  1009c3:	55                   	push   %ebp
	lookup.info.device_id = 0;
	lookup.info.function = PCI_FUNCTION_ANY;
	lookup.info.bar = PCI_BAR_ANY;
	lookup.bus = 0;
	lookup.dev = 0;
	lookup.func = 0;
  1009c4:	81 25 74 7f 10 00 ff 	andl   $0xfff87fff,0x107f74
  1009cb:	7f f8 ff 
void pci_bus_scan_init(void)
{
	lookup.info.class_type = 0;
	lookup.info.vendor_id = 0;
	lookup.info.device_id = 0;
	lookup.info.function = PCI_FUNCTION_ANY;
  1009ce:	25 ff 1f fe ff       	and    $0xfffe1fff,%eax

	return 0;
}

void pci_bus_scan_init(void)
{
  1009d3:	89 e5                	mov    %esp,%ebp
	lookup.info.class_type = 0;
	lookup.info.vendor_id = 0;
	lookup.info.device_id = 0;
	lookup.info.function = PCI_FUNCTION_ANY;
  1009d5:	0d 00 00 01 00       	or     $0x10000,%eax
}

void pci_bus_scan_init(void)
{
	lookup.info.class_type = 0;
	lookup.info.vendor_id = 0;
  1009da:	66 c7 05 70 7f 10 00 	movw   $0x0,0x107f70
  1009e1:	00 00 
	lookup.info.device_id = 0;
	lookup.info.function = PCI_FUNCTION_ANY;
  1009e3:	a3 6c 7f 10 00       	mov    %eax,0x107f6c

void pci_bus_scan_init(void)
{
	lookup.info.class_type = 0;
	lookup.info.vendor_id = 0;
	lookup.info.device_id = 0;
  1009e8:	66 c7 05 72 7f 10 00 	movw   $0x0,0x107f72
  1009ef:	00 00 
	lookup.info.function = PCI_FUNCTION_ANY;
	lookup.info.bar = PCI_BAR_ANY;
  1009f1:	a0 6f 7f 10 00       	mov    0x107f6f,%al
	lookup.bus = 0;
	lookup.dev = 0;
	lookup.func = 0;
	lookup.baridx = 0;
	lookup.barofs = 0;
}
  1009f6:	5d                   	pop    %ebp
	lookup.info.function = PCI_FUNCTION_ANY;
	lookup.info.bar = PCI_BAR_ANY;
	lookup.bus = 0;
	lookup.dev = 0;
	lookup.func = 0;
	lookup.baridx = 0;
  1009f7:	80 25 76 7f 10 00 c7 	andb   $0xc7,0x107f76
{
	lookup.info.class_type = 0;
	lookup.info.vendor_id = 0;
	lookup.info.device_id = 0;
	lookup.info.function = PCI_FUNCTION_ANY;
	lookup.info.bar = PCI_BAR_ANY;
  1009fe:	83 e0 e3             	and    $0xffffffe3,%eax
  100a01:	83 c8 18             	or     $0x18,%eax
  100a04:	a2 6f 7f 10 00       	mov    %al,0x107f6f
	lookup.bus = 0;
	lookup.dev = 0;
	lookup.func = 0;
	lookup.baridx = 0;
	lookup.barofs = 0;
  100a09:	66 81 25 76 7f 10 00 	andw   $0xfe3f,0x107f76
  100a10:	3f fe 
}
  100a12:	c3                   	ret    

00100a13 <pci_bus_scan>:
 *
 * @return 1 on success, 0 otherwise. On success, dev_info is filled in with
 * currently found device information
 */
int pci_bus_scan(struct pci_dev_info *dev_info)
{
  100a13:	55                   	push   %ebp
  100a14:	89 e5                	mov    %esp,%ebp
  100a16:	57                   	push   %edi
  100a17:	56                   	push   %esi
  100a18:	53                   	push   %ebx
  100a19:	83 ec 2c             	sub    $0x2c,%esp

	int init_from_dev_info =
		!lookup.info.class_type &&
		!lookup.info.vendor_id &&
		!lookup.info.device_id &&
		lookup.info.bar == PCI_BAR_ANY &&
  100a1c:	66 a1 6e 7f 10 00    	mov    0x107f6e,%ax
 *
 * @return 1 on success, 0 otherwise. On success, dev_info is filled in with
 * currently found device information
 */
int pci_bus_scan(struct pci_dev_info *dev_info)
{
  100a22:	8b 5d 08             	mov    0x8(%ebp),%ebx

	int init_from_dev_info =
		!lookup.info.class_type &&
		!lookup.info.vendor_id &&
		!lookup.info.device_id &&
		lookup.info.bar == PCI_BAR_ANY &&
  100a25:	66 a9 fc 03          	test   $0x3fc,%ax
  100a29:	75 21                	jne    100a4c <pci_bus_scan+0x39>
{
	union pci_addr_reg pci_ctrl_addr;

	int init_from_dev_info =
		!lookup.info.class_type &&
		!lookup.info.vendor_id &&
  100a2b:	83 3d 70 7f 10 00 00 	cmpl   $0x0,0x107f70
  100a32:	75 18                	jne    100a4c <pci_bus_scan+0x39>
		!lookup.info.device_id &&
		lookup.info.bar == PCI_BAR_ANY &&
  100a34:	8b 15 6c 7f 10 00    	mov    0x107f6c,%edx
  100a3a:	81 e2 00 e0 01 1c    	and    $0x1c01e000,%edx
  100a40:	81 fa 00 00 01 18    	cmp    $0x18010000,%edx
  100a46:	0f 84 32 05 00 00    	je     100f7e <pci_bus_scan+0x56b>
	}

	/* initialise the PCI controller address register value */
	pci_ctrl_addr.value = 0;

	if (lookup.info.function != PCI_FUNCTION_ANY) {
  100a4c:	a1 6c 7f 10 00       	mov    0x107f6c,%eax
		lookup.info.function = dev_info->function;
		lookup.info.bar = dev_info->bar;
	}

	/* initialise the PCI controller address register value */
	pci_ctrl_addr.value = 0;
  100a51:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

	if (lookup.info.function != PCI_FUNCTION_ANY) {
  100a58:	89 c2                	mov    %eax,%edx
  100a5a:	81 e2 00 e0 01 00    	and    $0x1e000,%edx
  100a60:	81 fa 00 00 01 00    	cmp    $0x10000,%edx
  100a66:	0f 84 ec 00 00 00    	je     100b58 <pci_bus_scan+0x145>
		lookup.func = lookup.info.function;
  100a6c:	c1 e0 02             	shl    $0x2,%eax
  100a6f:	8b 15 74 7f 10 00    	mov    0x107f74,%edx
  100a75:	25 00 80 07 00       	and    $0x78000,%eax
  100a7a:	81 e2 ff 7f f8 ff    	and    $0xfff87fff,%edx
  100a80:	09 d0                	or     %edx,%eax
  100a82:	a3 74 7f 10 00       	mov    %eax,0x107f74
  100a87:	e9 cc 00 00 00       	jmp    100b58 <pci_bus_scan+0x145>
	}

	/* run through the buses and devices */
	for (; lookup.bus < LSPCI_MAX_BUS; lookup.bus++) {
		for (; (lookup.dev < LSPCI_MAX_DEV); lookup.dev++) {
			pci_ctrl_addr.field.bus = lookup.bus;
  100a8c:	0f b6 15 74 7f 10 00 	movzbl 0x107f74,%edx
  100a93:	8b 4d dc             	mov    -0x24(%ebp),%ecx
			pci_ctrl_addr.field.device = lookup.dev;
  100a96:	83 e0 1f             	and    $0x1f,%eax
	}

	/* run through the buses and devices */
	for (; lookup.bus < LSPCI_MAX_BUS; lookup.bus++) {
		for (; (lookup.dev < LSPCI_MAX_DEV); lookup.dev++) {
			pci_ctrl_addr.field.bus = lookup.bus;
  100a99:	c1 e2 10             	shl    $0x10,%edx
  100a9c:	81 e1 ff 07 00 ff    	and    $0xff0007ff,%ecx
			pci_ctrl_addr.field.device = lookup.dev;
  100aa2:	c1 e0 0b             	shl    $0xb,%eax
  100aa5:	09 ca                	or     %ecx,%edx
  100aa7:	09 c2                	or     %eax,%edx
	int max_bars;

	/* verify first if there is a valid device at this point */
	pci_ctrl_addr.field.func = 0;

	pci_read(DEFAULT_PCI_CONTROLLER,
  100aa9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  100aac:	89 d7                	mov    %edx,%edi
  100aae:	50                   	push   %eax
  100aaf:	81 e7 ff f8 ff ff    	and    $0xfffff8ff,%edi
  100ab5:	6a 04                	push   $0x4
  100ab7:	57                   	push   %edi
  100ab8:	6a 00                	push   $0x0

	/* run through the buses and devices */
	for (; lookup.bus < LSPCI_MAX_BUS; lookup.bus++) {
		for (; (lookup.dev < LSPCI_MAX_DEV); lookup.dev++) {
			pci_ctrl_addr.field.bus = lookup.bus;
			pci_ctrl_addr.field.device = lookup.dev;
  100aba:	89 55 dc             	mov    %edx,-0x24(%ebp)
	int max_bars;

	/* verify first if there is a valid device at this point */
	pci_ctrl_addr.field.func = 0;

	pci_read(DEFAULT_PCI_CONTROLLER,
  100abd:	e8 33 05 00 00       	call   100ff5 <pci_read>
  100ac2:	83 c4 10             	add    $0x10,%esp
			pci_ctrl_addr,
			sizeof(pci_data),
			&pci_data);

	if (pci_data == 0xffffffff) {
  100ac5:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%ebp)
  100ac9:	0f 85 1d 01 00 00    	jne    100bec <pci_bus_scan+0x1d9>

			if (pci_dev_scan(pci_ctrl_addr, dev_info)) {
				return 1;
			}

			if (lookup.info.function != PCI_FUNCTION_ANY) {
  100acf:	8b 15 6c 7f 10 00    	mov    0x107f6c,%edx
  100ad5:	89 d0                	mov    %edx,%eax
  100ad7:	25 00 e0 01 00       	and    $0x1e000,%eax
  100adc:	3d 00 00 01 00       	cmp    $0x10000,%eax
  100ae1:	a1 74 7f 10 00       	mov    0x107f74,%eax
  100ae6:	0f 84 7d 04 00 00    	je     100f69 <pci_bus_scan+0x556>
				lookup.func = lookup.info.function;
  100aec:	c1 e2 02             	shl    $0x2,%edx
  100aef:	25 ff 7f f8 ff       	and    $0xfff87fff,%eax
  100af4:	81 e2 00 80 07 00    	and    $0x78000,%edx
  100afa:	09 d0                	or     %edx,%eax
			} else {
				lookup.func = 0;
  100afc:	a3 74 7f 10 00       	mov    %eax,0x107f74
		lookup.func = lookup.info.function;
	}

	/* run through the buses and devices */
	for (; lookup.bus < LSPCI_MAX_BUS; lookup.bus++) {
		for (; (lookup.dev < LSPCI_MAX_DEV); lookup.dev++) {
  100b01:	a0 75 7f 10 00       	mov    0x107f75,%al
  100b06:	88 c2                	mov    %al,%dl
  100b08:	83 e0 81             	and    $0xffffff81,%eax
  100b0b:	d0 ea                	shr    %dl
  100b0d:	8d 54 12 02          	lea    0x2(%edx,%edx,1),%edx
  100b11:	83 e2 7e             	and    $0x7e,%edx
  100b14:	09 d0                	or     %edx,%eax
  100b16:	a2 75 7f 10 00       	mov    %al,0x107f75
  100b1b:	8a 15 75 7f 10 00    	mov    0x107f75,%dl
  100b21:	88 d0                	mov    %dl,%al
  100b23:	d0 e8                	shr    %al
  100b25:	83 e0 3f             	and    $0x3f,%eax
  100b28:	83 f8 1f             	cmp    $0x1f,%eax
  100b2b:	0f 8e 5b ff ff ff    	jle    100a8c <pci_bus_scan+0x79>
				lookup.func = lookup.info.function;
			} else {
				lookup.func = 0;
			}
		}
		lookup.dev = 0;
  100b31:	88 d0                	mov    %dl,%al
  100b33:	83 e0 81             	and    $0xffffff81,%eax
  100b36:	a2 75 7f 10 00       	mov    %al,0x107f75
	if (lookup.info.function != PCI_FUNCTION_ANY) {
		lookup.func = lookup.info.function;
	}

	/* run through the buses and devices */
	for (; lookup.bus < LSPCI_MAX_BUS; lookup.bus++) {
  100b3b:	8b 0d 74 7f 10 00    	mov    0x107f74,%ecx
  100b41:	8d 41 01             	lea    0x1(%ecx),%eax
  100b44:	66 25 ff 01          	and    $0x1ff,%ax
  100b48:	89 c2                	mov    %eax,%edx
  100b4a:	89 c8                	mov    %ecx,%eax
  100b4c:	66 25 00 fe          	and    $0xfe00,%ax
  100b50:	09 d0                	or     %edx,%eax
  100b52:	66 a3 74 7f 10 00    	mov    %ax,0x107f74
  100b58:	a1 74 7f 10 00       	mov    0x107f74,%eax
  100b5d:	25 ff 01 00 00       	and    $0x1ff,%eax
  100b62:	48                   	dec    %eax
  100b63:	7e b6                	jle    100b1b <pci_bus_scan+0x108>
  100b65:	e9 09 04 00 00       	jmp    100f73 <pci_bus_scan+0x560>
	}

	/* scan all the possible functions for this device */
	for (; lookup.func < LSPCI_MAX_FUNC;
	     lookup.baridx = 0, lookup.barofs = 0, lookup.func++) {
		if (lookup.info.function != PCI_FUNCTION_ANY &&
  100b6a:	8b 15 6c 7f 10 00    	mov    0x107f6c,%edx
  100b70:	89 d6                	mov    %edx,%esi
  100b72:	81 e6 00 e0 01 00    	and    $0x1e000,%esi
  100b78:	81 fe 00 00 01 00    	cmp    $0x10000,%esi
  100b7e:	0f 85 89 00 00 00    	jne    100c0d <pci_bus_scan+0x1fa>
		    lookup.func != lookup.info.function) {
			return 0;
		}

		pci_ctrl_addr.field.func = lookup.func;
  100b84:	83 e0 07             	and    $0x7,%eax

		if (lookup.func != 0) {
  100b87:	81 e1 00 80 07 00    	and    $0x78000,%ecx
		if (lookup.info.function != PCI_FUNCTION_ANY &&
		    lookup.func != lookup.info.function) {
			return 0;
		}

		pci_ctrl_addr.field.func = lookup.func;
  100b8d:	89 c6                	mov    %eax,%esi

		if (lookup.func != 0) {
  100b8f:	0f 84 8b 00 00 00    	je     100c20 <pci_bus_scan+0x20d>
			pci_read(DEFAULT_PCI_CONTROLLER,
  100b95:	89 f0                	mov    %esi,%eax
  100b97:	81 e7 ff f8 ff ff    	and    $0xfffff8ff,%edi
  100b9d:	83 e0 07             	and    $0x7,%eax
  100ba0:	c1 e0 08             	shl    $0x8,%eax
  100ba3:	09 c7                	or     %eax,%edi
  100ba5:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  100ba8:	50                   	push   %eax
  100ba9:	6a 04                	push   $0x4
  100bab:	57                   	push   %edi
  100bac:	6a 00                	push   $0x0
  100bae:	e8 42 04 00 00       	call   100ff5 <pci_read>
  100bb3:	83 c4 10             	add    $0x10,%esp
					pci_ctrl_addr,
					sizeof(pci_data),
					&pci_data);

			if (pci_data == 0xffffffff) {
  100bb6:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%ebp)
  100bba:	75 64                	jne    100c20 <pci_bus_scan+0x20d>
		return 0;
	}

	/* scan all the possible functions for this device */
	for (; lookup.func < LSPCI_MAX_FUNC;
	     lookup.baridx = 0, lookup.barofs = 0, lookup.func++) {
  100bbc:	80 25 76 7f 10 00 c7 	andb   $0xc7,0x107f76
  100bc3:	66 81 25 76 7f 10 00 	andw   $0xfe3f,0x107f76
  100bca:	3f fe 
  100bcc:	8b 15 74 7f 10 00    	mov    0x107f74,%edx
  100bd2:	89 d0                	mov    %edx,%eax
  100bd4:	81 e2 ff 7f f8 ff    	and    $0xfff87fff,%edx
  100bda:	c1 e8 0f             	shr    $0xf,%eax
  100bdd:	40                   	inc    %eax
  100bde:	83 e0 0f             	and    $0xf,%eax
  100be1:	c1 e0 0f             	shl    $0xf,%eax
  100be4:	09 c2                	or     %eax,%edx
  100be6:	89 15 74 7f 10 00    	mov    %edx,0x107f74
	if (pci_data == 0xffffffff) {
		return 0;
	}

	/* scan all the possible functions for this device */
	for (; lookup.func < LSPCI_MAX_FUNC;
  100bec:	8b 0d 74 7f 10 00    	mov    0x107f74,%ecx
  100bf2:	89 ce                	mov    %ecx,%esi
  100bf4:	c1 ee 0f             	shr    $0xf,%esi
  100bf7:	89 f0                	mov    %esi,%eax
  100bf9:	83 e0 0f             	and    $0xf,%eax
  100bfc:	0f b6 d0             	movzbl %al,%edx
  100bff:	83 fa 07             	cmp    $0x7,%edx
  100c02:	0f 8e 62 ff ff ff    	jle    100b6a <pci_bus_scan+0x157>
  100c08:	e9 c2 fe ff ff       	jmp    100acf <pci_bus_scan+0xbc>
	     lookup.baridx = 0, lookup.barofs = 0, lookup.func++) {
		if (lookup.info.function != PCI_FUNCTION_ANY &&
		    lookup.func != lookup.info.function) {
  100c0d:	c1 ea 0d             	shr    $0xd,%edx
  100c10:	83 e2 0f             	and    $0xf,%edx
	}

	/* scan all the possible functions for this device */
	for (; lookup.func < LSPCI_MAX_FUNC;
	     lookup.baridx = 0, lookup.barofs = 0, lookup.func++) {
		if (lookup.info.function != PCI_FUNCTION_ANY &&
  100c13:	38 c2                	cmp    %al,%dl
  100c15:	0f 84 69 ff ff ff    	je     100b84 <pci_bus_scan+0x171>
  100c1b:	e9 af fe ff ff       	jmp    100acf <pci_bus_scan+0xbc>
				continue;
			}
		}

		/* get the PCI header from the device */
		pci_header_get(DEFAULT_PCI_CONTROLLER,
  100c20:	89 f0                	mov    %esi,%eax
  100c22:	81 e7 ff f8 ff ff    	and    $0xfffff8ff,%edi
  100c28:	83 e0 07             	and    $0x7,%eax
  100c2b:	68 a0 72 10 00       	push   $0x1072a0
  100c30:	c1 e0 08             	shl    $0x8,%eax
  100c33:	09 c7                	or     %eax,%edi
  100c35:	57                   	push   %edi
  100c36:	6a 00                	push   $0x0
  100c38:	e8 92 04 00 00       	call   1010cf <pci_header_get>

		/*
		 * Skip a device if its class is specified by the
		 * caller and does not match
		 */
		if (lookup.info.class_type &&
  100c3d:	66 a1 6e 7f 10 00    	mov    0x107f6e,%ax
				continue;
			}
		}

		/* get the PCI header from the device */
		pci_header_get(DEFAULT_PCI_CONTROLLER,
  100c43:	83 c4 0c             	add    $0xc,%esp

		/*
		 * Skip a device if its class is specified by the
		 * caller and does not match
		 */
		if (lookup.info.class_type &&
  100c46:	66 a9 fc 03          	test   $0x3fc,%ax
  100c4a:	74 10                	je     100c5c <pci_bus_scan+0x249>
		    pci_dev_header.field.class != lookup.info.class_type) {
  100c4c:	66 c1 e8 02          	shr    $0x2,%ax

		/*
		 * Skip a device if its class is specified by the
		 * caller and does not match
		 */
		if (lookup.info.class_type &&
  100c50:	38 05 ab 72 10 00    	cmp    %al,0x1072ab
  100c56:	0f 85 60 ff ff ff    	jne    100bbc <pci_bus_scan+0x1a9>
		    pci_dev_header.field.class != lookup.info.class_type) {
			continue;
		}

		if (lookup.info.vendor_id && lookup.info.device_id &&
  100c5c:	66 83 3d 70 7f 10 00 	cmpw   $0x0,0x107f70
  100c63:	00 
  100c64:	74 1b                	je     100c81 <pci_bus_scan+0x26e>
  100c66:	66 83 3d 72 7f 10 00 	cmpw   $0x0,0x107f72
  100c6d:	00 
  100c6e:	74 11                	je     100c81 <pci_bus_scan+0x26e>
  100c70:	a1 a0 72 10 00       	mov    0x1072a0,%eax
  100c75:	39 05 70 7f 10 00    	cmp    %eax,0x107f70
  100c7b:	0f 85 3b ff ff ff    	jne    100bbc <pci_bus_scan+0x1a9>
		    lookup.info.device_id != pci_dev_header.field.device_id)) {
			continue;
		}

		/* Get memory and interrupt information */
		if ((pci_dev_header.field.hdr_type & 0x7f) == 1) {
  100c81:	a0 ae 72 10 00       	mov    0x1072ae,%al
  100c86:	83 e0 7f             	and    $0x7f,%eax
			max_bars = 2;
		} else {
			max_bars = PCI_MAX_BARS;
  100c89:	fe c8                	dec    %al
  100c8b:	0f 95 c0             	setne  %al
  100c8e:	0f b6 c0             	movzbl %al,%eax
  100c91:	8d 04 85 02 00 00 00 	lea    0x2(,%eax,4),%eax
  100c98:	89 45 e0             	mov    %eax,-0x20(%ebp)
  100c9b:	89 f0                	mov    %esi,%eax
  100c9d:	83 e0 07             	and    $0x7,%eax
  100ca0:	89 45 c8             	mov    %eax,-0x38(%ebp)
		}

		for (; lookup.barofs < max_bars;
  100ca3:	66 a1 76 7f 10 00    	mov    0x107f76,%ax
  100ca9:	66 c1 e8 06          	shr    $0x6,%ax
  100cad:	83 e0 07             	and    $0x7,%eax
  100cb0:	0f b6 d0             	movzbl %al,%edx
  100cb3:	3b 55 e0             	cmp    -0x20(%ebp),%edx
  100cb6:	0f 8d 00 ff ff ff    	jge    100bbc <pci_bus_scan+0x1a9>
	uint32_t bar_config;
	uint32_t bar_hival;
	uint32_t addr;
	uint32_t mask;

	pci_ctrl_addr.field.reg = 4 + lookup.barofs;
  100cbc:	83 c0 04             	add    $0x4,%eax
  100cbf:	8b 55 c8             	mov    -0x38(%ebp),%edx
  100cc2:	c1 e2 08             	shl    $0x8,%edx
  100cc5:	81 e7 ff f8 ff ff    	and    $0xfffff8ff,%edi
  100ccb:	88 45 cc             	mov    %al,-0x34(%ebp)
  100cce:	09 d7                	or     %edx,%edi

	pci_read(DEFAULT_PCI_CONTROLLER,
  100cd0:	8b 45 cc             	mov    -0x34(%ebp),%eax
  100cd3:	89 fe                	mov    %edi,%esi
  100cd5:	83 e0 0f             	and    $0xf,%eax
  100cd8:	81 e6 03 f8 ff ff    	and    $0xfffff803,%esi
  100cde:	c1 e0 02             	shl    $0x2,%eax
  100ce1:	09 c6                	or     %eax,%esi
  100ce3:	8d 45 e8             	lea    -0x18(%ebp),%eax
  100ce6:	09 d6                	or     %edx,%esi
  100ce8:	50                   	push   %eax
  100ce9:	6a 04                	push   $0x4
  100ceb:	56                   	push   %esi
  100cec:	6a 00                	push   $0x0
  100cee:	e8 02 03 00 00       	call   100ff5 <pci_read>
  100cf3:	83 c4 10             	add    $0x10,%esp
							uint32_t *config)
{
	uint32_t old_value;

	/* save the current setting */
	pci_read(DEFAULT_PCI_CONTROLLER,
  100cf6:	8d 45 f0             	lea    -0x10(%ebp),%eax
  100cf9:	50                   	push   %eax
  100cfa:	6a 04                	push   $0x4
  100cfc:	56                   	push   %esi
  100cfd:	6a 00                	push   $0x0
  100cff:	e8 f1 02 00 00       	call   100ff5 <pci_read>
  100d04:	83 c4 10             	add    $0x10,%esp
			pci_ctrl_addr,
			sizeof(old_value),
			&old_value);

	/* write to the BAR to see how large it is */
	pci_write(DEFAULT_PCI_CONTROLLER,
  100d07:	6a ff                	push   $0xffffffff
  100d09:	6a 04                	push   $0x4
  100d0b:	56                   	push   %esi
  100d0c:	6a 00                	push   $0x0
  100d0e:	e8 52 03 00 00       	call   101065 <pci_write>
  100d13:	83 c4 10             	add    $0x10,%esp
			pci_ctrl_addr,
			sizeof(uint32_t),
			0xffffffff);

	pci_read(DEFAULT_PCI_CONTROLLER,
  100d16:	8d 45 ec             	lea    -0x14(%ebp),%eax
  100d19:	50                   	push   %eax
  100d1a:	6a 04                	push   $0x4
  100d1c:	56                   	push   %esi
  100d1d:	6a 00                	push   $0x0
  100d1f:	e8 d1 02 00 00       	call   100ff5 <pci_read>
  100d24:	83 c4 10             	add    $0x10,%esp
			pci_ctrl_addr,
			sizeof(*config),
			config);

	/* put back the old configuration */
	pci_write(DEFAULT_PCI_CONTROLLER,
  100d27:	ff 75 f0             	pushl  -0x10(%ebp)
  100d2a:	6a 04                	push   $0x4
  100d2c:	56                   	push   %esi
  100d2d:	6a 00                	push   $0x0
  100d2f:	e8 31 03 00 00       	call   101065 <pci_write>
			pci_ctrl_addr,
			sizeof(old_value),
			old_value);

	/* check if this BAR is implemented */
	if (*config != 0xffffffff && *config != 0) {
  100d34:	8b 55 ec             	mov    -0x14(%ebp),%edx
			pci_ctrl_addr,
			sizeof(*config),
			config);

	/* put back the old configuration */
	pci_write(DEFAULT_PCI_CONTROLLER,
  100d37:	83 c4 10             	add    $0x10,%esp

	pci_read(DEFAULT_PCI_CONTROLLER,
			pci_ctrl_addr,
			sizeof(bar_value),
			&bar_value);
	if (pci_bar_config_get(pci_ctrl_addr, &bar_config) != 0) {
  100d3a:	8d 42 ff             	lea    -0x1(%edx),%eax
  100d3d:	83 f8 fd             	cmp    $0xfffffffd,%eax
  100d40:	0f 87 de 01 00 00    	ja     100f24 <pci_bus_scan+0x511>
		return -1;
	}

	if (BAR_SPACE(bar_config) == BAR_SPACE_MEM) {
  100d46:	f6 c2 01             	test   $0x1,%dl
  100d49:	8a 43 0e             	mov    0xe(%ebx),%al
  100d4c:	75 76                	jne    100dc4 <pci_bus_scan+0x3b1>
		dev_info->mem_type = BAR_SPACE_MEM;
  100d4e:	83 e0 fd             	and    $0xfffffffd,%eax
		mask = ~0xf;
		if (BAR_TYPE(bar_config) == BAR_TYPE_64BIT) {
  100d51:	83 e2 06             	and    $0x6,%edx
	if (pci_bar_config_get(pci_ctrl_addr, &bar_config) != 0) {
		return -1;
	}

	if (BAR_SPACE(bar_config) == BAR_SPACE_MEM) {
		dev_info->mem_type = BAR_SPACE_MEM;
  100d54:	88 43 0e             	mov    %al,0xe(%ebx)
		mask = ~0xf;
		if (BAR_TYPE(bar_config) == BAR_TYPE_64BIT) {
  100d57:	83 fa 04             	cmp    $0x4,%edx
  100d5a:	74 07                	je     100d63 <pci_bus_scan+0x350>
		return -1;
	}

	if (BAR_SPACE(bar_config) == BAR_SPACE_MEM) {
		dev_info->mem_type = BAR_SPACE_MEM;
		mask = ~0xf;
  100d5c:	b9 f0 ff ff ff       	mov    $0xfffffff0,%ecx
  100d61:	eb 6c                	jmp    100dcf <pci_bus_scan+0x3bc>
		if (BAR_TYPE(bar_config) == BAR_TYPE_64BIT) {
			/* Last BAR register cannot be 64-bit */
			if (++lookup.barofs >= max_bars)
  100d63:	66 8b 0d 76 7f 10 00 	mov    0x107f76,%cx
  100d6a:	89 c8                	mov    %ecx,%eax
  100d6c:	66 c1 e8 06          	shr    $0x6,%ax
  100d70:	66 81 e1 3f fe       	and    $0xfe3f,%cx
  100d75:	40                   	inc    %eax
  100d76:	83 e0 07             	and    $0x7,%eax
  100d79:	89 c2                	mov    %eax,%edx
  100d7b:	83 e2 07             	and    $0x7,%edx
  100d7e:	c1 e2 06             	shl    $0x6,%edx
  100d81:	09 ca                	or     %ecx,%edx
  100d83:	0f b6 c0             	movzbl %al,%eax
  100d86:	66 89 15 76 7f 10 00 	mov    %dx,0x107f76
  100d8d:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  100d90:	0f 8e 8e 01 00 00    	jle    100f24 <pci_bus_scan+0x511>
				return 1;

			/* Make sure the address is accessible */
			pci_ctrl_addr.field.reg++;
			pci_read(DEFAULT_PCI_CONTROLLER,
  100d96:	8a 45 cc             	mov    -0x34(%ebp),%al
  100d99:	81 e6 03 ff ff ff    	and    $0xffffff03,%esi
  100d9f:	40                   	inc    %eax
  100da0:	83 e0 1f             	and    $0x1f,%eax
  100da3:	c1 e0 02             	shl    $0x2,%eax
  100da6:	09 c6                	or     %eax,%esi
  100da8:	8d 45 f0             	lea    -0x10(%ebp),%eax
  100dab:	50                   	push   %eax
  100dac:	6a 04                	push   $0x4
  100dae:	56                   	push   %esi
  100daf:	6a 00                	push   $0x0
  100db1:	e8 3f 02 00 00       	call   100ff5 <pci_read>
  100db6:	83 c4 10             	add    $0x10,%esp
				 pci_ctrl_addr,
				 sizeof(bar_hival),
				 &bar_hival);
			if (bar_hival)
  100db9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  100dbd:	74 9d                	je     100d5c <pci_bus_scan+0x349>
  100dbf:	e9 60 01 00 00       	jmp    100f24 <pci_bus_scan+0x511>
				return 1; /* Inaccessible memory */
		}
	} else {
		dev_info->mem_type = BAR_SPACE_IO;
  100dc4:	83 c8 02             	or     $0x2,%eax
		mask = ~0x3;
  100dc7:	b9 fc ff ff ff       	mov    $0xfffffffc,%ecx
				 &bar_hival);
			if (bar_hival)
				return 1; /* Inaccessible memory */
		}
	} else {
		dev_info->mem_type = BAR_SPACE_IO;
  100dcc:	88 43 0e             	mov    %al,0xe(%ebx)
		mask = ~0x3;
	}

	dev_info->addr = bar_value & mask;
  100dcf:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100dd2:	21 c8                	and    %ecx,%eax

	addr = bar_config & mask;
	if (addr != 0) {
  100dd4:	23 4d ec             	and    -0x14(%ebp),%ecx
	} else {
		dev_info->mem_type = BAR_SPACE_IO;
		mask = ~0x3;
	}

	dev_info->addr = bar_value & mask;
  100dd7:	89 03                	mov    %eax,(%ebx)

	addr = bar_config & mask;
	if (addr != 0) {
  100dd9:	74 14                	je     100def <pci_bus_scan+0x3dc>

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
	unsigned int bitpos;

	__asm__ volatile (
  100ddb:	0f bc c9             	bsf    %ecx,%ecx
  100dde:	75 05                	jne    100de5 <pci_bus_scan+0x3d2>
  100de0:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
		/* calculate the size of the BAR memory required */
		dev_info->size = 1 << (find_lsb_set(addr) - 1);
  100de5:	b8 01 00 00 00       	mov    $0x1,%eax
  100dea:	d3 e0                	shl    %cl,%eax
  100dec:	89 43 04             	mov    %eax,0x4(%ebx)
		     lookup.baridx++, lookup.barofs++) {
			/* Ignore BARs with errors */
			if (pci_bar_params_get(pci_ctrl_addr, dev_info,
					       max_bars) != 0) {
				continue;
			} else if (lookup.info.bar != PCI_BAR_ANY &&
  100def:	a0 6f 7f 10 00       	mov    0x107f6f,%al
  100df4:	88 c2                	mov    %al,%dl
  100df6:	83 e2 1c             	and    $0x1c,%edx
  100df9:	80 fa 18             	cmp    $0x18,%dl
  100dfc:	75 63                	jne    100e61 <pci_bus_scan+0x44e>
				   lookup.baridx != lookup.info.bar) {
				continue;
			} else {
				dev_info->bus = lookup.bus;
  100dfe:	a1 74 7f 10 00       	mov    0x107f74,%eax
				dev_info->dev = lookup.dev;
  100e03:	8a 4b 0d             	mov    0xd(%ebx),%cl
				continue;
			} else if (lookup.info.bar != PCI_BAR_ANY &&
				   lookup.baridx != lookup.info.bar) {
				continue;
			} else {
				dev_info->bus = lookup.bus;
  100e06:	66 25 ff 01          	and    $0x1ff,%ax
				dev_info->dev = lookup.dev;
  100e0a:	83 e1 e0             	and    $0xffffffe0,%ecx
				continue;
			} else if (lookup.info.bar != PCI_BAR_ANY &&
				   lookup.baridx != lookup.info.bar) {
				continue;
			} else {
				dev_info->bus = lookup.bus;
  100e0d:	88 c2                	mov    %al,%dl
  100e0f:	88 43 0c             	mov    %al,0xc(%ebx)
				dev_info->dev = lookup.dev;
  100e12:	a0 75 7f 10 00       	mov    0x107f75,%al
 */

static inline int pci_pin2irq(int bus, int dev, int pin)
{
	if (bus < 0 || bus > 1) {
		return -1;
  100e17:	83 ce ff             	or     $0xffffffff,%esi
  100e1a:	d0 e8                	shr    %al
  100e1c:	83 e0 1f             	and    $0x1f,%eax
  100e1f:	09 c8                	or     %ecx,%eax
				dev_info->vendor_id =
					pci_dev_header.field.vendor_id;
				dev_info->device_id =
					pci_dev_header.field.device_id;
				dev_info->class_type =
  100e21:	66 8b 4b 0e          	mov    0xe(%ebx),%cx
  100e25:	66 81 e1 03 fc       	and    $0xfc03,%cx
			} else if (lookup.info.bar != PCI_BAR_ANY &&
				   lookup.baridx != lookup.info.bar) {
				continue;
			} else {
				dev_info->bus = lookup.bus;
				dev_info->dev = lookup.dev;
  100e2a:	88 43 0d             	mov    %al,0xd(%ebx)
				dev_info->vendor_id =
  100e2d:	a1 a0 72 10 00       	mov    0x1072a0,%eax
  100e32:	66 89 43 10          	mov    %ax,0x10(%ebx)
					pci_dev_header.field.vendor_id;
				dev_info->device_id =
  100e36:	66 a1 a2 72 10 00    	mov    0x1072a2,%ax
  100e3c:	66 89 43 12          	mov    %ax,0x12(%ebx)
					pci_dev_header.field.device_id;
				dev_info->class_type =
  100e40:	0f b6 05 ab 72 10 00 	movzbl 0x1072ab,%eax
  100e47:	c1 e0 02             	shl    $0x2,%eax
  100e4a:	09 c8                	or     %ecx,%eax
 *
 */

static inline int pci_pin2irq(int bus, int dev, int pin)
{
	if (bus < 0 || bus > 1) {
  100e4c:	80 fa 01             	cmp    $0x1,%dl
  100e4f:	66 89 43 0e          	mov    %ax,0xe(%ebx)
					pci_dev_header.field.class;
				dev_info->irq = pci_pin2irq(dev_info->bus,
  100e53:	0f b6 05 dd 72 10 00 	movzbl 0x1072dd,%eax
  100e5a:	0f b6 ca             	movzbl %dl,%ecx
  100e5d:	76 1e                	jbe    100e7d <pci_bus_scan+0x46a>
  100e5f:	eb 2d                	jmp    100e8e <pci_bus_scan+0x47b>
			/* Ignore BARs with errors */
			if (pci_bar_params_get(pci_ctrl_addr, dev_info,
					       max_bars) != 0) {
				continue;
			} else if (lookup.info.bar != PCI_BAR_ANY &&
				   lookup.baridx != lookup.info.bar) {
  100e61:	c0 e8 02             	shr    $0x2,%al
  100e64:	8a 15 76 7f 10 00    	mov    0x107f76,%dl
  100e6a:	c0 ea 03             	shr    $0x3,%dl
  100e6d:	83 e0 07             	and    $0x7,%eax
  100e70:	83 e2 07             	and    $0x7,%edx
		     lookup.baridx++, lookup.barofs++) {
			/* Ignore BARs with errors */
			if (pci_bar_params_get(pci_ctrl_addr, dev_info,
					       max_bars) != 0) {
				continue;
			} else if (lookup.info.bar != PCI_BAR_ANY &&
  100e73:	38 c2                	cmp    %al,%dl
  100e75:	0f 85 a9 00 00 00    	jne    100f24 <pci_bus_scan+0x511>
  100e7b:	eb 81                	jmp    100dfe <pci_bus_scan+0x3eb>
		return -1;
	}
	if ((pin < PCI_INTA) || (pin > PCI_INTD)) {
  100e7d:	48                   	dec    %eax
 */

static inline int pci_pin2irq(int bus, int dev, int pin)
{
	if (bus < 0 || bus > 1) {
		return -1;
  100e7e:	83 ce ff             	or     $0xffffffff,%esi
	}
	if ((pin < PCI_INTA) || (pin > PCI_INTD)) {
  100e81:	83 f8 03             	cmp    $0x3,%eax
  100e84:	77 08                	ja     100e8e <pci_bus_scan+0x47b>
		return -1;
	}
	return NUM_STD_IRQS + ((pin - 1 + bus) & 3);
  100e86:	01 c8                	add    %ecx,%eax
  100e88:	83 e0 03             	and    $0x3,%eax
  100e8b:	8d 70 10             	lea    0x10(%eax),%esi
				dev_info->class_type =
					pci_dev_header.field.class;
				dev_info->irq = pci_pin2irq(dev_info->bus,
					dev_info->dev,
					pci_dev_header.field.interrupt_pin);
				dev_info->function = lookup.func;
  100e8e:	a1 74 7f 10 00       	mov    0x107f74,%eax
  100e93:	8b 53 0c             	mov    0xc(%ebx),%edx
  100e96:	c1 e8 02             	shr    $0x2,%eax
  100e99:	81 e2 ff 1f fe ff    	and    $0xfffe1fff,%edx
  100e9f:	25 00 e0 01 00       	and    $0x1e000,%eax
					pci_dev_header.field.vendor_id;
				dev_info->device_id =
					pci_dev_header.field.device_id;
				dev_info->class_type =
					pci_dev_header.field.class;
				dev_info->irq = pci_pin2irq(dev_info->bus,
  100ea4:	89 73 08             	mov    %esi,0x8(%ebx)
					dev_info->dev,
					pci_dev_header.field.interrupt_pin);
				dev_info->function = lookup.func;
  100ea7:	09 d0                	or     %edx,%eax
  100ea9:	89 43 0c             	mov    %eax,0xc(%ebx)
				dev_info->bar = lookup.baridx;
  100eac:	a0 76 7f 10 00       	mov    0x107f76,%al
  100eb1:	8a 4b 0f             	mov    0xf(%ebx),%cl
  100eb4:	c0 e8 03             	shr    $0x3,%al
  100eb7:	83 e1 e3             	and    $0xffffffe3,%ecx
  100eba:	83 e0 07             	and    $0x7,%eax
  100ebd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx

				lookup.baridx++;
  100ec4:	8d 04 c5 08 00 00 00 	lea    0x8(,%eax,8),%eax
					pci_dev_header.field.class;
				dev_info->irq = pci_pin2irq(dev_info->bus,
					dev_info->dev,
					pci_dev_header.field.interrupt_pin);
				dev_info->function = lookup.func;
				dev_info->bar = lookup.baridx;
  100ecb:	09 ca                	or     %ecx,%edx

				lookup.baridx++;
  100ecd:	83 e0 38             	and    $0x38,%eax
					pci_dev_header.field.class;
				dev_info->irq = pci_pin2irq(dev_info->bus,
					dev_info->dev,
					pci_dev_header.field.interrupt_pin);
				dev_info->function = lookup.func;
				dev_info->bar = lookup.baridx;
  100ed0:	88 53 0f             	mov    %dl,0xf(%ebx)

				lookup.baridx++;
  100ed3:	8a 15 76 7f 10 00    	mov    0x107f76,%dl
  100ed9:	83 e2 c7             	and    $0xffffffc7,%edx
  100edc:	09 d0                	or     %edx,%eax
  100ede:	a2 76 7f 10 00       	mov    %al,0x107f76
				lookup.barofs++;
  100ee3:	66 8b 15 76 7f 10 00 	mov    0x107f76,%dx
  100eea:	89 d0                	mov    %edx,%eax
  100eec:	66 c1 e8 06          	shr    $0x6,%ax
  100ef0:	66 81 e2 3f fe       	and    $0xfe3f,%dx
  100ef5:	40                   	inc    %eax
  100ef6:	83 e0 07             	and    $0x7,%eax
  100ef9:	89 c1                	mov    %eax,%ecx
  100efb:	83 e1 07             	and    $0x7,%ecx
  100efe:	c1 e1 06             	shl    $0x6,%ecx
  100f01:	09 ca                	or     %ecx,%edx
				if (lookup.barofs >= max_bars) {
  100f03:	0f b6 c0             	movzbl %al,%eax
					pci_dev_header.field.interrupt_pin);
				dev_info->function = lookup.func;
				dev_info->bar = lookup.baridx;

				lookup.baridx++;
				lookup.barofs++;
  100f06:	66 89 15 76 7f 10 00 	mov    %dx,0x107f76
				if (lookup.barofs >= max_bars) {
  100f0d:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  100f10:	7c 65                	jl     100f77 <pci_bus_scan+0x564>
					lookup.baridx = 0;
  100f12:	80 25 76 7f 10 00 c7 	andb   $0xc7,0x107f76
					lookup.barofs = 0;
  100f19:	66 81 25 76 7f 10 00 	andw   $0xfe3f,0x107f76
  100f20:	3f fe 
  100f22:	eb 53                	jmp    100f77 <pci_bus_scan+0x564>
		} else {
			max_bars = PCI_MAX_BARS;
		}

		for (; lookup.barofs < max_bars;
		     lookup.baridx++, lookup.barofs++) {
  100f24:	8a 15 76 7f 10 00    	mov    0x107f76,%dl
  100f2a:	88 d0                	mov    %dl,%al
  100f2c:	83 e2 c7             	and    $0xffffffc7,%edx
  100f2f:	c0 e8 03             	shr    $0x3,%al
  100f32:	8d 04 c5 08 00 00 00 	lea    0x8(,%eax,8),%eax
  100f39:	83 e0 38             	and    $0x38,%eax
  100f3c:	09 d0                	or     %edx,%eax
  100f3e:	a2 76 7f 10 00       	mov    %al,0x107f76
  100f43:	66 8b 15 76 7f 10 00 	mov    0x107f76,%dx
  100f4a:	89 d0                	mov    %edx,%eax
  100f4c:	66 c1 e8 06          	shr    $0x6,%ax
  100f50:	66 81 e2 3f fe       	and    $0xfe3f,%dx
  100f55:	40                   	inc    %eax
  100f56:	83 e0 07             	and    $0x7,%eax
  100f59:	c1 e0 06             	shl    $0x6,%eax
  100f5c:	09 d0                	or     %edx,%eax
  100f5e:	66 a3 76 7f 10 00    	mov    %ax,0x107f76
  100f64:	e9 3a fd ff ff       	jmp    100ca3 <pci_bus_scan+0x290>
			}

			if (lookup.info.function != PCI_FUNCTION_ANY) {
				lookup.func = lookup.info.function;
			} else {
				lookup.func = 0;
  100f69:	25 ff 7f f8 ff       	and    $0xfff87fff,%eax
  100f6e:	e9 89 fb ff ff       	jmp    100afc <pci_bus_scan+0xe9>
			}
		}
		lookup.dev = 0;
	}

	return 0;
  100f73:	31 c0                	xor    %eax,%eax
  100f75:	eb 65                	jmp    100fdc <pci_bus_scan+0x5c9>
		for (; (lookup.dev < LSPCI_MAX_DEV); lookup.dev++) {
			pci_ctrl_addr.field.bus = lookup.bus;
			pci_ctrl_addr.field.device = lookup.dev;

			if (pci_dev_scan(pci_ctrl_addr, dev_info)) {
				return 1;
  100f77:	b8 01 00 00 00       	mov    $0x1,%eax
  100f7c:	eb 5e                	jmp    100fdc <pci_bus_scan+0x5c9>
		!lookup.info.device_id &&
		lookup.info.bar == PCI_BAR_ANY &&
		lookup.info.function == PCI_FUNCTION_ANY;

	if (init_from_dev_info) {
		lookup.info.class_type = dev_info->class_type;
  100f7e:	66 25 03 fc          	and    $0xfc03,%ax
  100f82:	66 8b 53 0e          	mov    0xe(%ebx),%dx
  100f86:	66 81 e2 fc 03       	and    $0x3fc,%dx
  100f8b:	09 d0                	or     %edx,%eax
  100f8d:	66 a3 6e 7f 10 00    	mov    %ax,0x107f6e
		lookup.info.vendor_id = dev_info->vendor_id;
  100f93:	8b 43 10             	mov    0x10(%ebx),%eax
		lookup.info.device_id = dev_info->device_id;
		lookup.info.function = dev_info->function;
  100f96:	8b 15 6c 7f 10 00    	mov    0x107f6c,%edx
		lookup.info.bar == PCI_BAR_ANY &&
		lookup.info.function == PCI_FUNCTION_ANY;

	if (init_from_dev_info) {
		lookup.info.class_type = dev_info->class_type;
		lookup.info.vendor_id = dev_info->vendor_id;
  100f9c:	66 a3 70 7f 10 00    	mov    %ax,0x107f70
		lookup.info.device_id = dev_info->device_id;
  100fa2:	66 8b 43 12          	mov    0x12(%ebx),%ax
  100fa6:	66 a3 72 7f 10 00    	mov    %ax,0x107f72
		lookup.info.function = dev_info->function;
  100fac:	8b 43 0c             	mov    0xc(%ebx),%eax
  100faf:	81 e2 ff 1f fe ff    	and    $0xfffe1fff,%edx
  100fb5:	25 00 e0 01 00       	and    $0x1e000,%eax
  100fba:	09 d0                	or     %edx,%eax
  100fbc:	a3 6c 7f 10 00       	mov    %eax,0x107f6c
		lookup.info.bar = dev_info->bar;
  100fc1:	8a 43 0f             	mov    0xf(%ebx),%al
  100fc4:	8a 15 6f 7f 10 00    	mov    0x107f6f,%dl
  100fca:	83 e0 1c             	and    $0x1c,%eax
  100fcd:	83 e2 e3             	and    $0xffffffe3,%edx
  100fd0:	09 d0                	or     %edx,%eax
  100fd2:	a2 6f 7f 10 00       	mov    %al,0x107f6f
  100fd7:	e9 70 fa ff ff       	jmp    100a4c <pci_bus_scan+0x39>
		}
		lookup.dev = 0;
	}

	return 0;
}
  100fdc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  100fdf:	5b                   	pop    %ebx
  100fe0:	5e                   	pop    %esi
  100fe1:	5f                   	pop    %edi
  100fe2:	5d                   	pop    %ebp
  100fe3:	c3                   	ret    

00100fe4 <pci_enable_regs>:
			sizeof(uint16_t),
			pci_data);
}

void pci_enable_regs(struct pci_dev_info *dev_info)
{
  100fe4:	55                   	push   %ebp
	pci_set_command_bits(dev_info, PCI_CMD_MEM_ENABLE);
  100fe5:	ba 02 00 00 00       	mov    $0x2,%edx
			sizeof(uint16_t),
			pci_data);
}

void pci_enable_regs(struct pci_dev_info *dev_info)
{
  100fea:	89 e5                	mov    %esp,%ebp
	pci_set_command_bits(dev_info, PCI_CMD_MEM_ENABLE);
  100fec:	8b 45 08             	mov    0x8(%ebp),%eax
}
  100fef:	5d                   	pop    %ebp
			pci_data);
}

void pci_enable_regs(struct pci_dev_info *dev_info)
{
	pci_set_command_bits(dev_info, PCI_CMD_MEM_ENABLE);
  100ff0:	e9 59 f9 ff ff       	jmp    10094e <pci_set_command_bits>

00100ff5 <pci_read>:
 *
 */

void pci_read(uint32_t controller, union pci_addr_reg addr,
	      uint32_t size, uint32_t *data)
{
  100ff5:	55                   	push   %ebp
  100ff6:	89 e5                	mov    %esp,%ebp
  100ff8:	56                   	push   %esi
  100ff9:	53                   	push   %ebx
  100ffa:	8b 55 10             	mov    0x10(%ebp),%edx
  100ffd:	8b 45 0c             	mov    0xc(%ebp),%eax
  101000:	8b 5d 14             	mov    0x14(%ebp),%ebx
	uint32_t access_size;
	uint32_t access_offset;

	/* validate the access size */

	switch (size) {
  101003:	83 fa 01             	cmp    $0x1,%edx
  101006:	74 11                	je     101019 <pci_read+0x24>
  101008:	83 fa 02             	cmp    $0x2,%edx
  10100b:	75 15                	jne    101022 <pci_read+0x2d>
		access_size = SYS_PCI_ACCESS_8BIT;
		access_offset = addr.field.offset;
		break;
	case 2:
		access_size = SYS_PCI_ACCESS_16BIT;
		access_offset = addr.field.offset;
  10100d:	89 c1                	mov    %eax,%ecx
	case 1:
		access_size = SYS_PCI_ACCESS_8BIT;
		access_offset = addr.field.offset;
		break;
	case 2:
		access_size = SYS_PCI_ACCESS_16BIT;
  10100f:	be 01 00 00 00       	mov    $0x1,%esi
		access_offset = addr.field.offset;
  101014:	83 e1 03             	and    $0x3,%ecx
		break;
  101017:	eb 10                	jmp    101029 <pci_read+0x34>
	/* validate the access size */

	switch (size) {
	case 1:
		access_size = SYS_PCI_ACCESS_8BIT;
		access_offset = addr.field.offset;
  101019:	89 c1                	mov    %eax,%ecx

	/* validate the access size */

	switch (size) {
	case 1:
		access_size = SYS_PCI_ACCESS_8BIT;
  10101b:	31 f6                	xor    %esi,%esi
		access_offset = addr.field.offset;
  10101d:	83 e1 03             	and    $0x3,%ecx
		break;
  101020:	eb 07                	jmp    101029 <pci_read+0x34>
		access_offset = addr.field.offset;
		break;
	case 4:
	default:
		access_size = SYS_PCI_ACCESS_32BIT;
		access_offset = 0;
  101022:	31 c9                	xor    %ecx,%ecx
		access_size = SYS_PCI_ACCESS_16BIT;
		access_offset = addr.field.offset;
		break;
	case 4:
	default:
		access_size = SYS_PCI_ACCESS_32BIT;
  101024:	be 03 00 00 00       	mov    $0x3,%esi
		break;
	}

	/* ensure enable has been set */

	addr.field.enable = 1;
  101029:	0d 00 00 00 80       	or     $0x80000000,%eax

	/* clear the offset for the address register */

	addr.field.offset = 0;
  10102e:	83 e0 fc             	and    $0xfffffffc,%eax
static int pci_ctrl_addr_write(uint32_t controller, uint32_t offset,
			       uint32_t data, uint32_t size)
{
	/* we only support one controller */

	if (controller != DEFAULT_PCI_CONTROLLER) {
  101031:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  101035:	75 2a                	jne    101061 <pci_read+0x6c>


static ALWAYS_INLINE
	void sys_out32(uint32_t data, io_port_t port)
{
	__asm__ volatile("outl	%0, %w1;\n\t"
  101037:	ba f8 0c 00 00       	mov    $0xcf8,%edx
  10103c:	ef                   	out    %eax,(%dx)

	if (controller != DEFAULT_PCI_CONTROLLER) {
		return (-1);
	}

	pci_ctrl_read(PCI_CTRL_DATA_REG + offset, data, size);
  10103d:	8d 91 fc 0c 00 00    	lea    0xcfc(%ecx),%edx

static void pci_ctrl_read(uint32_t reg, uint32_t *data, uint32_t size)
{
	/* read based on the size requested */

	switch (size) {
  101043:	83 fe 01             	cmp    $0x1,%esi
  101046:	74 0a                	je     101052 <pci_read+0x5d>
  101048:	72 11                	jb     10105b <pci_read+0x66>
  10104a:	83 fe 03             	cmp    $0x3,%esi
  10104d:	75 12                	jne    101061 <pci_read+0x6c>
static ALWAYS_INLINE
	uint32_t sys_in32(io_port_t port)
{
	uint32_t ret;

	__asm__ volatile("inl	%w1, %0;\n\t"
  10104f:	ed                   	in     (%dx),%eax
  101050:	eb 05                	jmp    101057 <pci_read+0x62>
static ALWAYS_INLINE
	uint16_t sys_in16(io_port_t port)
{
	uint16_t ret;

	__asm__ volatile("inw	%w1, %w0;\n\t"
  101052:	66 ed                	in     (%dx),%ax
	case SYS_PCI_ACCESS_32BIT:
		*data = sys_in32(reg);
		break;
		/* word (16 bits) */
	case SYS_PCI_ACCESS_16BIT:
		*data = sys_in16(reg);
  101054:	0f b7 c0             	movzwl %ax,%eax
  101057:	89 03                	mov    %eax,(%ebx)
  101059:	eb 06                	jmp    101061 <pci_read+0x6c>
static ALWAYS_INLINE
	uint8_t sys_in8(io_port_t port)
{
	uint8_t ret;

	__asm__ volatile("inb	%w1, %b0;\n\t"
  10105b:	ec                   	in     (%dx),%al
		break;
		/* byte (8 bits) */
	case SYS_PCI_ACCESS_8BIT:
		*data = sys_in8(reg);
  10105c:	0f b6 d0             	movzbl %al,%edx
  10105f:	89 13                	mov    %edx,(%ebx)

	pci_ctrl_addr_write(
		controller, PCI_NO_OFFSET, addr.value, SYS_PCI_ACCESS_32BIT);

	pci_ctrl_data_read(controller, access_offset, data, access_size);
}
  101061:	5b                   	pop    %ebx
  101062:	5e                   	pop    %esi
  101063:	5d                   	pop    %ebp
  101064:	c3                   	ret    

00101065 <pci_write>:
 *
 */

void pci_write(uint32_t controller, union pci_addr_reg addr,
	       uint32_t size, uint32_t data)
{
  101065:	55                   	push   %ebp
  101066:	89 e5                	mov    %esp,%ebp
  101068:	53                   	push   %ebx
  101069:	8b 55 10             	mov    0x10(%ebp),%edx
  10106c:	8b 45 0c             	mov    0xc(%ebp),%eax
	uint32_t access_size;
	uint32_t access_offset;

	/* validate the access size */

	switch (size) {
  10106f:	83 fa 01             	cmp    $0x1,%edx
  101072:	74 11                	je     101085 <pci_write+0x20>
  101074:	83 fa 02             	cmp    $0x2,%edx
  101077:	75 15                	jne    10108e <pci_write+0x29>
		access_size = SYS_PCI_ACCESS_8BIT;
		access_offset = addr.field.offset;
		break;
	case 2:
		access_size = SYS_PCI_ACCESS_16BIT;
		access_offset = addr.field.offset;
  101079:	89 c1                	mov    %eax,%ecx
	case 1:
		access_size = SYS_PCI_ACCESS_8BIT;
		access_offset = addr.field.offset;
		break;
	case 2:
		access_size = SYS_PCI_ACCESS_16BIT;
  10107b:	bb 01 00 00 00       	mov    $0x1,%ebx
		access_offset = addr.field.offset;
  101080:	83 e1 03             	and    $0x3,%ecx
		break;
  101083:	eb 10                	jmp    101095 <pci_write+0x30>
	/* validate the access size */

	switch (size) {
	case 1:
		access_size = SYS_PCI_ACCESS_8BIT;
		access_offset = addr.field.offset;
  101085:	89 c1                	mov    %eax,%ecx

	/* validate the access size */

	switch (size) {
	case 1:
		access_size = SYS_PCI_ACCESS_8BIT;
  101087:	31 db                	xor    %ebx,%ebx
		access_offset = addr.field.offset;
  101089:	83 e1 03             	and    $0x3,%ecx
		break;
  10108c:	eb 07                	jmp    101095 <pci_write+0x30>
		access_offset = addr.field.offset;
		break;
	case 4:
	default:
		access_size = SYS_PCI_ACCESS_32BIT;
		access_offset = 0;
  10108e:	31 c9                	xor    %ecx,%ecx
		access_size = SYS_PCI_ACCESS_16BIT;
		access_offset = addr.field.offset;
		break;
	case 4:
	default:
		access_size = SYS_PCI_ACCESS_32BIT;
  101090:	bb 03 00 00 00       	mov    $0x3,%ebx
		break;
	}

	/* ensure enable has been set */

	addr.field.enable = 1;
  101095:	0d 00 00 00 80       	or     $0x80000000,%eax

	/* clear the offset for the address register */

	addr.field.offset = 0;
  10109a:	83 e0 fc             	and    $0xfffffffc,%eax
static int pci_ctrl_addr_write(uint32_t controller, uint32_t offset,
			       uint32_t data, uint32_t size)
{
	/* we only support one controller */

	if (controller != DEFAULT_PCI_CONTROLLER) {
  10109d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1010a1:	75 29                	jne    1010cc <pci_write+0x67>


static ALWAYS_INLINE
	void sys_out32(uint32_t data, io_port_t port)
{
	__asm__ volatile("outl	%0, %w1;\n\t"
  1010a3:	ba f8 0c 00 00       	mov    $0xcf8,%edx
  1010a8:	ef                   	out    %eax,(%dx)

	if (controller != DEFAULT_PCI_CONTROLLER) {
		return (-1);
	}

	pci_ctrl_write(PCI_CTRL_DATA_REG + offset, data, size);
  1010a9:	8d 91 fc 0c 00 00    	lea    0xcfc(%ecx),%edx

static void pci_ctrl_write(uint32_t reg, uint32_t data, uint32_t size)
{
	/* write based on the size requested */

	switch (size) {
  1010af:	83 fb 01             	cmp    $0x1,%ebx
  1010b2:	74 0d                	je     1010c1 <pci_write+0x5c>
  1010b4:	72 12                	jb     1010c8 <pci_write+0x63>
  1010b6:	83 fb 03             	cmp    $0x3,%ebx
  1010b9:	75 11                	jne    1010cc <pci_write+0x67>
  1010bb:	8b 45 14             	mov    0x14(%ebp),%eax
  1010be:	ef                   	out    %eax,(%dx)
  1010bf:	eb 0b                	jmp    1010cc <pci_write+0x67>


static ALWAYS_INLINE
	void sys_out16(uint16_t data, io_port_t port)
{
	__asm__ volatile("outw	%w0, %w1;\n\t"
  1010c1:	8b 45 14             	mov    0x14(%ebp),%eax
  1010c4:	66 ef                	out    %ax,(%dx)
  1010c6:	eb 04                	jmp    1010cc <pci_write+0x67>
/* Implementation of sys_io.h's documented functions */

static ALWAYS_INLINE
void sys_out8(uint8_t data, io_port_t port)
{
	__asm__ volatile("outb	%b0, %w1;\n\t"
  1010c8:	8a 45 14             	mov    0x14(%ebp),%al
  1010cb:	ee                   	out    %al,(%dx)
	/* write the data to the PCI controller */

	pci_ctrl_addr_write(
		controller, PCI_NO_OFFSET, addr.value, SYS_PCI_ACCESS_32BIT);
	pci_ctrl_data_write(controller, access_offset, data, access_size);
}
  1010cc:	5b                   	pop    %ebx
  1010cd:	5d                   	pop    %ebp
  1010ce:	c3                   	ret    

001010cf <pci_header_get>:
 */

void pci_header_get(uint32_t controller,
		    union pci_addr_reg pci_ctrl_addr,
		    union pci_dev *pci_dev_header)
{
  1010cf:	55                   	push   %ebp
  1010d0:	89 e5                	mov    %esp,%ebp
  1010d2:	57                   	push   %edi
  1010d3:	56                   	push   %esi
  1010d4:	53                   	push   %ebx
  1010d5:	8b 5d 10             	mov    0x10(%ebp),%ebx
	uint32_t i;

	/* clear out the header */

	memset(pci_dev_header, 0, sizeof(*pci_dev_header));
  1010d8:	68 00 01 00 00       	push   $0x100
  1010dd:	6a 00                	push   $0x0
  1010df:	53                   	push   %ebx
 */

void pci_header_get(uint32_t controller,
		    union pci_addr_reg pci_ctrl_addr,
		    union pci_dev *pci_dev_header)
{
  1010e0:	8b 75 0c             	mov    0xc(%ebp),%esi

	memset(pci_dev_header, 0, sizeof(*pci_dev_header));

	/* fill in the PCI header from the device */

	for (i = 0; i < PCI_HEADER_WORDS; i++) {
  1010e3:	31 ff                	xor    %edi,%edi
{
	uint32_t i;

	/* clear out the header */

	memset(pci_dev_header, 0, sizeof(*pci_dev_header));
  1010e5:	e8 c8 1b 00 00       	call   102cb2 <memset>
  1010ea:	83 c4 0c             	add    $0xc,%esp

	/* fill in the PCI header from the device */

	for (i = 0; i < PCI_HEADER_WORDS; i++) {
		pci_ctrl_addr.field.reg = i;
  1010ed:	89 f8                	mov    %edi,%eax
  1010ef:	81 e6 03 ff ff ff    	and    $0xffffff03,%esi
  1010f5:	83 e0 3f             	and    $0x3f,%eax
		pci_read(controller,
  1010f8:	53                   	push   %ebx
	memset(pci_dev_header, 0, sizeof(*pci_dev_header));

	/* fill in the PCI header from the device */

	for (i = 0; i < PCI_HEADER_WORDS; i++) {
		pci_ctrl_addr.field.reg = i;
  1010f9:	c1 e0 02             	shl    $0x2,%eax
		pci_read(controller,
  1010fc:	6a 04                	push   $0x4
	memset(pci_dev_header, 0, sizeof(*pci_dev_header));

	/* fill in the PCI header from the device */

	for (i = 0; i < PCI_HEADER_WORDS; i++) {
		pci_ctrl_addr.field.reg = i;
  1010fe:	09 c6                	or     %eax,%esi

	memset(pci_dev_header, 0, sizeof(*pci_dev_header));

	/* fill in the PCI header from the device */

	for (i = 0; i < PCI_HEADER_WORDS; i++) {
  101100:	47                   	inc    %edi
		pci_ctrl_addr.field.reg = i;
		pci_read(controller,
  101101:	56                   	push   %esi
  101102:	83 c3 04             	add    $0x4,%ebx
  101105:	ff 75 08             	pushl  0x8(%ebp)
  101108:	e8 e8 fe ff ff       	call   100ff5 <pci_read>
  10110d:	83 c4 10             	add    $0x10,%esp

	memset(pci_dev_header, 0, sizeof(*pci_dev_header));

	/* fill in the PCI header from the device */

	for (i = 0; i < PCI_HEADER_WORDS; i++) {
  101110:	83 ff 40             	cmp    $0x40,%edi
  101113:	75 d8                	jne    1010ed <pci_header_get+0x1e>
		pci_read(controller,
			pci_ctrl_addr,
			sizeof(uint32_t),
			&pci_dev_header->words.word[i]);
	}
}
  101115:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101118:	5b                   	pop    %ebx
  101119:	5e                   	pop    %esi
  10111a:	5f                   	pop    %edi
  10111b:	5d                   	pop    %ebp
  10111c:	c3                   	ret    

0010111d <pci_legacy_bridge_detect>:
 *
 * @return 0 if legacy bridge is detected and -1 otherwise
 */

int pci_legacy_bridge_detect(struct pci_dev_info *dev_info)
{
  10111d:	55                   	push   %ebp
  10111e:	89 e5                	mov    %esp,%ebp
  101120:	53                   	push   %ebx
  101121:	83 ec 10             	sub    $0x10,%esp
	pci_ctrl_addr.field.device = CONFIG_PCI_LEGACY_BRIDGE_DEV;

	/* verify first if there is a valid device at this point */
	pci_ctrl_addr.field.func = 0;

	pci_read(DEFAULT_PCI_CONTROLLER,
  101124:	8d 45 ec             	lea    -0x14(%ebp),%eax
 *
 * @return 0 if legacy bridge is detected and -1 otherwise
 */

int pci_legacy_bridge_detect(struct pci_dev_info *dev_info)
{
  101127:	8b 5d 08             	mov    0x8(%ebp),%ebx
	pci_ctrl_addr.field.device = CONFIG_PCI_LEGACY_BRIDGE_DEV;

	/* verify first if there is a valid device at this point */
	pci_ctrl_addr.field.func = 0;

	pci_read(DEFAULT_PCI_CONTROLLER,
  10112a:	50                   	push   %eax
  10112b:	6a 04                	push   $0x4
  10112d:	68 00 f8 00 00       	push   $0xf800
  101132:	6a 00                	push   $0x0
  101134:	e8 bc fe ff ff       	call   100ff5 <pci_read>
  101139:	83 c4 10             	add    $0x10,%esp
			pci_ctrl_addr,
			sizeof(pci_data),
			&pci_data);

	if (pci_data == 0xffffffff) {
  10113c:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
  101140:	75 08                	jne    10114a <pci_legacy_bridge_detect+0x2d>
		return -1;
  101142:	83 c8 ff             	or     $0xffffffff,%eax
  101145:	e9 05 01 00 00       	jmp    10124f <pci_legacy_bridge_detect+0x132>
	}

	/* get the PCI header from the device */
	pci_header_get(DEFAULT_PCI_CONTROLLER,
  10114a:	68 a0 73 10 00       	push   $0x1073a0
  10114f:	68 00 f8 00 00       	push   $0xf800
  101154:	6a 00                	push   $0x0
  101156:	e8 74 ff ff ff       	call   1010cf <pci_header_get>
  10115b:	83 c4 0c             	add    $0xc,%esp
		       pci_ctrl_addr,
		       &pci_dev_header);

	if (pci_dev_header.field.vendor_id != CONFIG_PCI_LEGACY_BRIDGE_VENDOR_ID ||
  10115e:	81 3d a0 73 10 00 86 	cmpl   $0x95e8086,0x1073a0
  101165:	80 5e 09 
  101168:	75 d8                	jne    101142 <pci_legacy_bridge_detect+0x25>
	}

	pci_ctrl_addr.field.reg = PCI_LEGACY_BRIDGE_REG;

	/* read RCBA PCI register */
	pci_read(DEFAULT_PCI_CONTROLLER,
  10116a:	8d 45 f0             	lea    -0x10(%ebp),%eax
  10116d:	50                   	push   %eax
  10116e:	6a 04                	push   $0x4
  101170:	68 f0 f8 00 00       	push   $0xf8f0
  101175:	6a 00                	push   $0x0
  101177:	e8 79 fe ff ff       	call   100ff5 <pci_read>
  10117c:	83 c4 10             	add    $0x10,%esp
			     uint32_t *mask)
{
	uint32_t old_value;

	/* save the current setting */
	pci_read(DEFAULT_PCI_CONTROLLER,
  10117f:	8d 45 f8             	lea    -0x8(%ebp),%eax
  101182:	50                   	push   %eax
  101183:	6a 04                	push   $0x4
  101185:	68 f0 f8 00 00       	push   $0xf8f0
  10118a:	6a 00                	push   $0x0
  10118c:	e8 64 fe ff ff       	call   100ff5 <pci_read>
  101191:	83 c4 10             	add    $0x10,%esp
			pci_ctrl_addr,
			sizeof(old_value),
			&old_value);

	/* write to the RCBA to see how large it is */
	pci_write(DEFAULT_PCI_CONTROLLER,
  101194:	6a ff                	push   $0xffffffff
  101196:	6a 04                	push   $0x4
  101198:	68 f0 f8 00 00       	push   $0xf8f0
  10119d:	6a 00                	push   $0x0
  10119f:	e8 c1 fe ff ff       	call   101065 <pci_write>
  1011a4:	83 c4 10             	add    $0x10,%esp
			pci_ctrl_addr,
			sizeof(uint32_t),
			0xffffffff);

	pci_read(DEFAULT_PCI_CONTROLLER,
  1011a7:	8d 45 f4             	lea    -0xc(%ebp),%eax
  1011aa:	50                   	push   %eax
  1011ab:	6a 04                	push   $0x4
  1011ad:	68 f0 f8 00 00       	push   $0xf8f0
  1011b2:	6a 00                	push   $0x0
  1011b4:	e8 3c fe ff ff       	call   100ff5 <pci_read>
  1011b9:	83 c4 10             	add    $0x10,%esp
			pci_ctrl_addr,
			sizeof(*mask),
			mask);

	/* put back the old configuration */
	pci_write(DEFAULT_PCI_CONTROLLER,
  1011bc:	ff 75 f8             	pushl  -0x8(%ebp)
  1011bf:	6a 04                	push   $0x4
  1011c1:	68 f0 f8 00 00       	push   $0xf8f0
  1011c6:	6a 00                	push   $0x0
  1011c8:	e8 98 fe ff ff       	call   101065 <pci_write>
			pci_ctrl_addr,
			sizeof(old_value),
			old_value);

	/* check if this RCBA is implemented */
	if (*mask != 0xffffffff && *mask != 0) {
  1011cd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
			pci_ctrl_addr,
			sizeof(*mask),
			mask);

	/* put back the old configuration */
	pci_write(DEFAULT_PCI_CONTROLLER,
  1011d0:	83 c4 10             	add    $0x10,%esp
			pci_ctrl_addr,
			sizeof(old_value),
			old_value);

	/* check if this RCBA is implemented */
	if (*mask != 0xffffffff && *mask != 0) {
  1011d3:	8d 41 ff             	lea    -0x1(%ecx),%eax
  1011d6:	83 f8 fd             	cmp    $0xfffffffd,%eax
  1011d9:	0f 87 63 ff ff ff    	ja     101142 <pci_legacy_bridge_detect+0x25>
		/* clear the least address unrelated bit */
		*mask &= ~0x01;
  1011df:	83 e1 fe             	and    $0xfffffffe,%ecx

	if (pci_rcba_mask_get(pci_ctrl_addr, &rcba_mask) != 0) {
		return -1;
	}

	dev_info->addr = rcba & rcba_mask;
  1011e2:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1011e5:	21 ca                	and    %ecx,%edx

	/* check if this RCBA is implemented */
	if (*mask != 0xffffffff && *mask != 0) {
		/* clear the least address unrelated bit */
		*mask &= ~0x01;
		return 0;
  1011e7:	31 c0                	xor    %eax,%eax

	if (pci_rcba_mask_get(pci_ctrl_addr, &rcba_mask) != 0) {
		return -1;
	}

	dev_info->addr = rcba & rcba_mask;
  1011e9:	89 13                	mov    %edx,(%ebx)
	if (dev_info->addr != 0) {
  1011eb:	85 d2                	test   %edx,%edx
  1011ed:	74 14                	je     101203 <pci_legacy_bridge_detect+0xe6>

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
	unsigned int bitpos;

	__asm__ volatile (
  1011ef:	0f bc c9             	bsf    %ecx,%ecx
  1011f2:	75 05                	jne    1011f9 <pci_legacy_bridge_detect+0xdc>
  1011f4:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
		/* calculate the size of the root complex memory required */
		dev_info->size = 1 << (find_lsb_set(rcba_mask) - 1);
  1011f9:	ba 01 00 00 00       	mov    $0x1,%edx
  1011fe:	d3 e2                	shl    %cl,%edx
  101200:	89 53 04             	mov    %edx,0x4(%ebx)
	}

	dev_info->irq = -1;
	dev_info->bus = CONFIG_PCI_LEGACY_BRIDGE_BUS;
	dev_info->dev = CONFIG_PCI_LEGACY_BRIDGE_DEV;
  101203:	80 4b 0d 1f          	orb    $0x1f,0xd(%ebx)
		/* calculate the size of the root complex memory required */
		dev_info->size = 1 << (find_lsb_set(rcba_mask) - 1);
	}

	dev_info->irq = -1;
	dev_info->bus = CONFIG_PCI_LEGACY_BRIDGE_BUS;
  101207:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
	if (dev_info->addr != 0) {
		/* calculate the size of the root complex memory required */
		dev_info->size = 1 << (find_lsb_set(rcba_mask) - 1);
	}

	dev_info->irq = -1;
  10120b:	c7 43 08 ff ff ff ff 	movl   $0xffffffff,0x8(%ebx)
	dev_info->bus = CONFIG_PCI_LEGACY_BRIDGE_BUS;
	dev_info->dev = CONFIG_PCI_LEGACY_BRIDGE_DEV;
	dev_info->function = 0;
  101212:	81 63 0c ff 1f fe ff 	andl   $0xfffe1fff,0xc(%ebx)
	dev_info->mem_type = BAR_SPACE_MEM;
  101219:	80 63 0e fd          	andb   $0xfd,0xe(%ebx)
	dev_info->class_type = pci_dev_header.field.class;
  10121d:	0f b6 15 ab 73 10 00 	movzbl 0x1073ab,%edx
  101224:	c1 e2 02             	shl    $0x2,%edx
  101227:	66 8b 4b 0e          	mov    0xe(%ebx),%cx
  10122b:	66 81 e1 03 fc       	and    $0xfc03,%cx
  101230:	09 ca                	or     %ecx,%edx
  101232:	66 89 53 0e          	mov    %dx,0xe(%ebx)
	dev_info->bar = 0;
  101236:	80 63 0f e3          	andb   $0xe3,0xf(%ebx)
	dev_info->vendor_id = pci_dev_header.field.vendor_id;
  10123a:	8b 15 a0 73 10 00    	mov    0x1073a0,%edx
  101240:	66 89 53 10          	mov    %dx,0x10(%ebx)
	dev_info->device_id = pci_dev_header.field.device_id;
  101244:	66 8b 15 a2 73 10 00 	mov    0x1073a2,%dx
  10124b:	66 89 53 12          	mov    %dx,0x12(%ebx)

	return 0;
}
  10124f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  101252:	c9                   	leave  
  101253:	c3                   	ret    

00101254 <pci_legacy_bridge_configure>:
 */
void pci_legacy_bridge_configure(struct pci_dev_info *dev_info,
				 int io_block_num,
				 int pci_interrupt_pin,
				 int irq_number)
{
  101254:	55                   	push   %ebp
  101255:	89 e5                	mov    %esp,%ebp
  101257:	57                   	push   %edi
  101258:	56                   	push   %esi
  101259:	53                   	push   %ebx
	uint32_t addr = (io_block_num == 0) ? PCI_ADDR_IRQAGENT1 :
  10125a:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
	 *            0-7, which corresponds IRQ 16 - IRQ 23
	 * Bits 11:8  indicates which IRQ is used for INTC.
	 * Bits 7:4   indicates which IRQ is used for INTB.
	 * Bits 3:0   indicates which IRQ is used for INTA.
	 */
	int offset = (pci_interrupt_pin - 1) * 4;
  10125e:	8b 55 10             	mov    0x10(%ebp),%edx
 */
void pci_legacy_bridge_configure(struct pci_dev_info *dev_info,
				 int io_block_num,
				 int pci_interrupt_pin,
				 int irq_number)
{
  101261:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint32_t addr = (io_block_num == 0) ? PCI_ADDR_IRQAGENT1 :
  101264:	19 c0                	sbb    %eax,%eax
  101266:	83 e0 fc             	and    $0xfffffffc,%eax
	 *            0-7, which corresponds IRQ 16 - IRQ 23
	 * Bits 11:8  indicates which IRQ is used for INTC.
	 * Bits 7:4   indicates which IRQ is used for INTB.
	 * Bits 3:0   indicates which IRQ is used for INTA.
	 */
	int offset = (pci_interrupt_pin - 1) * 4;
  101269:	8d 0c 95 fc ff ff ff 	lea    -0x4(,%edx,4),%ecx
void pci_legacy_bridge_configure(struct pci_dev_info *dev_info,
				 int io_block_num,
				 int pci_interrupt_pin,
				 int irq_number)
{
	uint32_t addr = (io_block_num == 0) ? PCI_ADDR_IRQAGENT1 :
  101270:	05 46 31 00 00       	add    $0x3146,%eax
{
	uint16_t ret;

	__asm__ volatile("movw	%1, %0;\n\t"
			 : "=r"(ret)
			 : "m" (*(volatile uint16_t *) addr)
  101275:	8b 13                	mov    (%ebx),%edx
  101277:	01 c2                	add    %eax,%edx
static ALWAYS_INLINE
	uint16_t sys_read16(mm_reg_t addr)
{
	uint16_t ret;

	__asm__ volatile("movw	%1, %0;\n\t"
  101279:	66 8b 3a             	mov    (%edx),%di
	 */
	int offset = (pci_interrupt_pin - 1) * 4;
	uint16_t irq_routing = sys_read16(dev_info->addr + addr);

	irq_routing &= ~(0x0f << offset);
	irq_routing |= (irq_number - NUM_STD_IRQS) << offset;
  10127c:	be 0f 00 00 00       	mov    $0xf,%esi
static ALWAYS_INLINE
	void sys_write16(uint16_t data, mm_reg_t addr)
{
	__asm__ volatile("movw	%0, %1;\n\t"
			 :
			 : "r"(data), "m" (*(volatile uint16_t *) addr)
  101281:	03 03                	add    (%ebx),%eax
  101283:	d3 e6                	shl    %cl,%esi
  101285:	f7 d6                	not    %esi
  101287:	21 fe                	and    %edi,%esi
  101289:	8b 7d 14             	mov    0x14(%ebp),%edi
  10128c:	8d 57 f0             	lea    -0x10(%edi),%edx
  10128f:	d3 e2                	shl    %cl,%edx
  101291:	09 f2                	or     %esi,%edx
}

static ALWAYS_INLINE
	void sys_write16(uint16_t data, mm_reg_t addr)
{
	__asm__ volatile("movw	%0, %1;\n\t"
  101293:	66 89 10             	mov    %dx,(%eax)
	sys_write16(irq_routing, dev_info->addr + addr);
}
  101296:	5b                   	pop    %ebx
  101297:	5e                   	pop    %esi
  101298:	5f                   	pop    %edi
  101299:	5d                   	pop    %ebp
  10129a:	c3                   	ret    

0010129b <isr_register>:
 *  @param isr_func Pointer to the ISR function for the device.
 *  @param isr_dev Pointer to the device that will service the interrupt.
 */
static int isr_register(struct device *dev, isr_t isr_func,
				 struct device *isr_dev)
{
  10129b:	55                   	push   %ebp
	struct shared_irq_runtime *clients = dev->driver_data;
	const struct shared_irq_config *config = dev->config->config_info;
	uint32_t i;

	for (i = 0; i < config->client_count; i++) {
  10129c:	31 d2                	xor    %edx,%edx
 *  @param isr_func Pointer to the ISR function for the device.
 *  @param isr_dev Pointer to the device that will service the interrupt.
 */
static int isr_register(struct device *dev, isr_t isr_func,
				 struct device *isr_dev)
{
  10129e:	89 e5                	mov    %esp,%ebp
  1012a0:	53                   	push   %ebx
  1012a1:	8b 45 08             	mov    0x8(%ebp),%eax
	struct shared_irq_runtime *clients = dev->driver_data;
  1012a4:	8b 48 08             	mov    0x8(%eax),%ecx
	const struct shared_irq_config *config = dev->config->config_info;
  1012a7:	8b 00                	mov    (%eax),%eax
	uint32_t i;

	for (i = 0; i < config->client_count; i++) {
  1012a9:	8b 40 08             	mov    0x8(%eax),%eax
  1012ac:	8b 58 08             	mov    0x8(%eax),%ebx
  1012af:	39 da                	cmp    %ebx,%edx
  1012b1:	74 1d                	je     1012d0 <isr_register+0x35>
  1012b3:	6b c2 0c             	imul   $0xc,%edx,%eax
		if (!clients->client[i].isr_dev) {
  1012b6:	83 3c 01 00          	cmpl   $0x0,(%ecx,%eax,1)
  1012ba:	75 11                	jne    1012cd <isr_register+0x32>
  1012bc:	01 c8                	add    %ecx,%eax
			clients->client[i].isr_dev = isr_dev;
  1012be:	8b 55 10             	mov    0x10(%ebp),%edx
  1012c1:	89 10                	mov    %edx,(%eax)
			clients->client[i].isr_func = isr_func;
  1012c3:	8b 55 0c             	mov    0xc(%ebp),%edx
  1012c6:	89 50 04             	mov    %edx,0x4(%eax)
			return 0;
  1012c9:	31 c0                	xor    %eax,%eax
  1012cb:	eb 08                	jmp    1012d5 <isr_register+0x3a>
{
	struct shared_irq_runtime *clients = dev->driver_data;
	const struct shared_irq_config *config = dev->config->config_info;
	uint32_t i;

	for (i = 0; i < config->client_count; i++) {
  1012cd:	42                   	inc    %edx
  1012ce:	eb df                	jmp    1012af <isr_register+0x14>
			clients->client[i].isr_dev = isr_dev;
			clients->client[i].isr_func = isr_func;
			return 0;
		}
	}
	return -EIO;
  1012d0:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  1012d5:	5b                   	pop    %ebx
  1012d6:	5d                   	pop    %ebp
  1012d7:	c3                   	ret    

001012d8 <shared_irq_isr>:
	}
	return -EIO;
}

void shared_irq_isr(struct device *dev)
{
  1012d8:	55                   	push   %ebp
  1012d9:	89 e5                	mov    %esp,%ebp
  1012db:	57                   	push   %edi
  1012dc:	56                   	push   %esi
  1012dd:	53                   	push   %ebx
  1012de:	8b 45 08             	mov    0x8(%ebp),%eax
	struct shared_irq_runtime *clients = dev->driver_data;
	const struct shared_irq_config *config = dev->config->config_info;
	uint32_t i;

	for (i = 0; i < config->client_count; i++) {
  1012e1:	31 f6                	xor    %esi,%esi
}

void shared_irq_isr(struct device *dev)
{
	struct shared_irq_runtime *clients = dev->driver_data;
	const struct shared_irq_config *config = dev->config->config_info;
  1012e3:	8b 10                	mov    (%eax),%edx
  1012e5:	8b 58 08             	mov    0x8(%eax),%ebx
  1012e8:	8b 7a 08             	mov    0x8(%edx),%edi
	uint32_t i;

	for (i = 0; i < config->client_count; i++) {
  1012eb:	3b 77 08             	cmp    0x8(%edi),%esi
  1012ee:	73 11                	jae    101301 <shared_irq_isr+0x29>
		if (clients->client[i].isr_dev) {
  1012f0:	8b 03                	mov    (%ebx),%eax
  1012f2:	85 c0                	test   %eax,%eax
  1012f4:	74 05                	je     1012fb <shared_irq_isr+0x23>
			clients->client[i].isr_func(clients->client[i].isr_dev);
  1012f6:	50                   	push   %eax
  1012f7:	ff 53 04             	call   *0x4(%ebx)
  1012fa:	58                   	pop    %eax
{
	struct shared_irq_runtime *clients = dev->driver_data;
	const struct shared_irq_config *config = dev->config->config_info;
	uint32_t i;

	for (i = 0; i < config->client_count; i++) {
  1012fb:	46                   	inc    %esi
  1012fc:	83 c3 0c             	add    $0xc,%ebx
  1012ff:	eb ea                	jmp    1012eb <shared_irq_isr+0x13>
		if (clients->client[i].isr_dev) {
			clients->client[i].isr_func(clients->client[i].isr_dev);
		}
	}
}
  101301:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101304:	5b                   	pop    %ebx
  101305:	5e                   	pop    %esi
  101306:	5f                   	pop    %edi
  101307:	5d                   	pop    %ebp
  101308:	c3                   	ret    

00101309 <shared_irq_initialize>:
	.disable = disable,
};


int shared_irq_initialize(struct device *dev)
{
  101309:	55                   	push   %ebp
  10130a:	89 e5                	mov    %esp,%ebp
  10130c:	8b 45 08             	mov    0x8(%ebp),%eax
	const struct shared_irq_config *config = dev->config->config_info;
  10130f:	8b 10                	mov    (%eax),%edx
  101311:	8b 52 08             	mov    0x8(%edx),%edx

	dev->driver_api = &api_funcs;
  101314:	c7 40 04 18 48 10 00 	movl   $0x104818,0x4(%eax)
	config->config();
  10131b:	ff 52 04             	call   *0x4(%edx)

	return 0;
}
  10131e:	31 c0                	xor    %eax,%eax
  101320:	5d                   	pop    %ebp
  101321:	c3                   	ret    

00101322 <disable>:
 *  @brief Disable ISR for device
 *  @param dev Pointer to device structure for SHARED_IRQ driver instance.
 *  @param isr_dev Pointer to the device that will service the interrupt.
 */
static inline int disable(struct device *dev, struct device *isr_dev)
{
  101322:	55                   	push   %ebp
  101323:	89 e5                	mov    %esp,%ebp
  101325:	57                   	push   %edi
  101326:	56                   	push   %esi
  101327:	53                   	push   %ebx
  101328:	8b 45 08             	mov    0x8(%ebp),%eax
	struct shared_irq_runtime *clients = dev->driver_data;
  10132b:	8b 50 08             	mov    0x8(%eax),%edx
	const struct shared_irq_config *config = dev->config->config_info;
  10132e:	8b 00                	mov    (%eax),%eax
  101330:	8b 48 08             	mov    0x8(%eax),%ecx
	uint32_t i;

	for (i = 0; i < config->client_count; i++) {
  101333:	31 c0                	xor    %eax,%eax
  101335:	8b 59 08             	mov    0x8(%ecx),%ebx
  101338:	39 d8                	cmp    %ebx,%eax
  10133a:	74 29                	je     101365 <disable+0x43>
		if (clients->client[i].isr_dev == isr_dev) {
  10133c:	6b f0 0c             	imul   $0xc,%eax,%esi
  10133f:	8b 7d 0c             	mov    0xc(%ebp),%edi
  101342:	39 3c 32             	cmp    %edi,(%edx,%esi,1)
  101345:	75 1b                	jne    101362 <disable+0x40>
			clients->client[i].enabled = 0;
  101347:	c7 44 32 08 00 00 00 	movl   $0x0,0x8(%edx,%esi,1)
  10134e:	00 

static int last_enabled_isr(struct shared_irq_runtime *clients, int count)
{
	uint32_t i;

	for (i = 0; i < count; i++) {
  10134f:	31 c0                	xor    %eax,%eax
  101351:	39 c3                	cmp    %eax,%ebx
  101353:	74 17                	je     10136c <disable+0x4a>
		if (clients->client[i].enabled) {
  101355:	6b f0 0c             	imul   $0xc,%eax,%esi
  101358:	83 7c 32 08 00       	cmpl   $0x0,0x8(%edx,%esi,1)
  10135d:	75 15                	jne    101374 <disable+0x52>

static int last_enabled_isr(struct shared_irq_runtime *clients, int count)
{
	uint32_t i;

	for (i = 0; i < count; i++) {
  10135f:	40                   	inc    %eax
  101360:	eb ef                	jmp    101351 <disable+0x2f>
{
	struct shared_irq_runtime *clients = dev->driver_data;
	const struct shared_irq_config *config = dev->config->config_info;
	uint32_t i;

	for (i = 0; i < config->client_count; i++) {
  101362:	40                   	inc    %eax
  101363:	eb d3                	jmp    101338 <disable+0x16>
				irq_disable(config->irq_num);
			}
			return 0;
		}
	}
	return -EIO;
  101365:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  10136a:	eb 0a                	jmp    101376 <disable+0x54>

	for (i = 0; i < config->client_count; i++) {
		if (clients->client[i].isr_dev == isr_dev) {
			clients->client[i].enabled = 0;
			if (last_enabled_isr(clients, config->client_count)) {
				irq_disable(config->irq_num);
  10136c:	ff 31                	pushl  (%ecx)
  10136e:	e8 f3 f4 ff ff       	call   100866 <_arch_irq_disable>
  101373:	58                   	pop    %eax
			}
			return 0;
  101374:	31 c0                	xor    %eax,%eax
		}
	}
	return -EIO;
}
  101376:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101379:	5b                   	pop    %ebx
  10137a:	5e                   	pop    %esi
  10137b:	5f                   	pop    %edi
  10137c:	5d                   	pop    %ebp
  10137d:	c3                   	ret    

0010137e <enable>:
 *  @brief Enable ISR for device
 *  @param dev Pointer to device structure for SHARED_IRQ driver instance.
 *  @param isr_dev Pointer to the device that will service the interrupt.
 */
static inline int enable(struct device *dev, struct device *isr_dev)
{
  10137e:	55                   	push   %ebp
  10137f:	89 e5                	mov    %esp,%ebp
  101381:	57                   	push   %edi
  101382:	56                   	push   %esi
  101383:	53                   	push   %ebx
  101384:	8b 45 08             	mov    0x8(%ebp),%eax
	struct shared_irq_runtime *clients = dev->driver_data;
  101387:	8b 50 08             	mov    0x8(%eax),%edx
	const struct shared_irq_config *config = dev->config->config_info;
  10138a:	8b 00                	mov    (%eax),%eax
  10138c:	8b 48 08             	mov    0x8(%eax),%ecx
	uint32_t i;

	for (i = 0; i < config->client_count; i++) {
  10138f:	31 c0                	xor    %eax,%eax
  101391:	8b 71 08             	mov    0x8(%ecx),%esi
  101394:	39 f0                	cmp    %esi,%eax
  101396:	74 22                	je     1013ba <enable+0x3c>
		if (clients->client[i].isr_dev == isr_dev) {
  101398:	6b d8 0c             	imul   $0xc,%eax,%ebx
  10139b:	8b 7d 0c             	mov    0xc(%ebp),%edi
  10139e:	39 3c 1a             	cmp    %edi,(%edx,%ebx,1)
  1013a1:	75 14                	jne    1013b7 <enable+0x39>
			clients->client[i].enabled = 1;
  1013a3:	c7 44 1a 08 01 00 00 	movl   $0x1,0x8(%edx,%ebx,1)
  1013aa:	00 
			irq_enable(config->irq_num);
  1013ab:	ff 31                	pushl  (%ecx)
  1013ad:	e8 97 f4 ff ff       	call   100849 <_arch_irq_enable>
  1013b2:	58                   	pop    %eax
			return 0;
  1013b3:	31 c0                	xor    %eax,%eax
  1013b5:	eb 08                	jmp    1013bf <enable+0x41>
{
	struct shared_irq_runtime *clients = dev->driver_data;
	const struct shared_irq_config *config = dev->config->config_info;
	uint32_t i;

	for (i = 0; i < config->client_count; i++) {
  1013b7:	40                   	inc    %eax
  1013b8:	eb da                	jmp    101394 <enable+0x16>
			clients->client[i].enabled = 1;
			irq_enable(config->irq_num);
			return 0;
		}
	}
	return -EIO;
  1013ba:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  1013bf:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1013c2:	5b                   	pop    %ebx
  1013c3:	5e                   	pop    %esi
  1013c4:	5f                   	pop    %edi
  1013c5:	5d                   	pop    %ebp
  1013c6:	c3                   	ret    

001013c7 <shared_irq_config_0_irq>:
#else
	#define SHARED_IRQ_0_FLAGS 0
#endif /* CONFIG_IOAPIC */

void shared_irq_config_0_irq(void)
{
  1013c7:	55                   	push   %ebp
  1013c8:	89 e5                	mov    %esp,%ebp
  1013ca:	0f b6 05 fa 6d 10 00 	movzbl 0x106dfa,%eax
  1013d1:	68 00 a0 00 00       	push   $0xa000
  1013d6:	6a 12                	push   $0x12
  1013d8:	50                   	push   %eax
  1013d9:	e8 45 f4 ff ff       	call   100823 <__irq_controller_irq_config>
  1013de:	83 c4 0c             	add    $0xc,%esp
	IRQ_CONNECT(CONFIG_SHARED_IRQ_0_IRQ, CONFIG_SHARED_IRQ_0_PRI,
		    shared_irq_isr, DEVICE_GET(shared_irq_0),
		    SHARED_IRQ_0_FLAGS);
}
  1013e1:	c9                   	leave  
  1013e2:	c3                   	ret    

001013e3 <spi_intel_configure>:
	}
}

static int spi_intel_configure(struct device *dev,
				struct spi_config *config)
{
  1013e3:	55                   	push   %ebp
  1013e4:	89 e5                	mov    %esp,%ebp
  1013e6:	57                   	push   %edi
  1013e7:	56                   	push   %esi
  1013e8:	53                   	push   %ebx
	struct spi_intel_data *spi = dev->driver_data;
  1013e9:	8b 45 08             	mov    0x8(%ebp),%eax
	}
}

static int spi_intel_configure(struct device *dev,
				struct spi_config *config)
{
  1013ec:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	struct spi_intel_data *spi = dev->driver_data;
  1013ef:	8b 50 08             	mov    0x8(%eax),%edx
	uint32_t flags = config->config;
  1013f2:	8b 19                	mov    (%ecx),%ebx
{
	int ret;

	__asm__ volatile("btl	%2, %1;\n\t"
			 "sbb	%0, %0\n\t"
			 : "=r" (ret), "+m" (*(volatile uint32_t *) (addr))
  1013f4:	8b 02                	mov    (%edx),%eax
static ALWAYS_INLINE
	int sys_test_bit(mem_addr_t addr, unsigned int bit)
{
	int ret;

	__asm__ volatile("btl	%2, %1;\n\t"
  1013f6:	0f ba 20 07          	btl    $0x7,(%eax)
  1013fa:	19 f6                	sbb    %esi,%esi

	SYS_LOG_DBG("spi_intel_configure: %p (0x%x), %p", dev, spi->regs,
		    config);

	/* Check status */
	if (test_bit_sscr0_sse(spi->regs) && test_bit_sssr_bsy(spi->regs)) {
  1013fc:	85 f6                	test   %esi,%esi
  1013fe:	75 48                	jne    101448 <spi_intel_configure+0x65>
		SYS_LOG_DBG("spi_intel_configure: Controller is busy");
		return -EBUSY;
	}

	/* Pre-configuring the registers to a clean state*/
	spi->sscr0 = spi->sscr1 = 0;
  101400:	c7 42 34 00 00 00 00 	movl   $0x0,0x34(%edx)
  101407:	c7 42 30 00 00 00 00 	movl   $0x0,0x30(%edx)
static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
			 :
			 : "r"(data), "m" (*(volatile uint32_t *) addr)
  10140e:	8b 32                	mov    (%edx),%esi
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  101410:	31 c0                	xor    %eax,%eax
  101412:	89 06                	mov    %eax,(%esi)
	write_sscr0(spi->sscr0, spi->regs);
	write_sscr1(spi->sscr1, spi->regs);
  101414:	8b 42 34             	mov    0x34(%edx),%eax
			 :
			 : "r"(data), "m" (*(volatile uint32_t *) addr)
  101417:	8b 32                	mov    (%edx),%esi
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  101419:	89 46 04             	mov    %eax,0x4(%esi)
			SPI_WORD_SIZE_GET(flags),
			INTEL_SPI_DSS_RATE(config->max_sys_freq),
			INTEL_SPI_SSCR0_SCR(config->max_sys_freq) >> 8);

	/* Word size and clock rate */
	spi->sscr0 = INTEL_SPI_SSCR0_DSS(SPI_WORD_SIZE_GET(flags)) |
  10141c:	89 d8                	mov    %ebx,%eax
				INTEL_SPI_SSCR0_SCR(config->max_sys_freq);
  10141e:	8b 49 04             	mov    0x4(%ecx),%ecx
			SPI_WORD_SIZE_GET(flags),
			INTEL_SPI_DSS_RATE(config->max_sys_freq),
			INTEL_SPI_SSCR0_SCR(config->max_sys_freq) >> 8);

	/* Word size and clock rate */
	spi->sscr0 = INTEL_SPI_SSCR0_DSS(SPI_WORD_SIZE_GET(flags)) |
  101421:	25 f0 0f 00 00       	and    $0xff0,%eax
  101426:	89 ce                	mov    %ecx,%esi
  101428:	c1 e8 04             	shr    $0x4,%eax
  10142b:	c1 e6 08             	shl    $0x8,%esi
  10142e:	8d 78 ff             	lea    -0x1(%eax),%edi
  101431:	0f b7 c6             	movzwl %si,%eax
  101434:	09 f8                	or     %edi,%eax
  101436:	89 42 30             	mov    %eax,0x30(%edx)
	/* Tx/Rx thresholds
	 * Note: Rx thresholds needs to be 1, it does not seem to be able
	 * to trigger reliably any interrupt with another value though the
	 * rx fifo would be full
	 */
	spi->sscr1 |= INTEL_SPI_SSCR1_TFT(INTEL_SPI_SSCR1_TFT_DFLT) |
  101439:	8b 42 34             	mov    0x34(%edx),%eax
		      INTEL_SPI_SSCR1_RFT(INTEL_SPI_SSCR1_RFT_DFLT);

	/* SPI mode */
	mode = SPI_MODE(flags);
	if (mode & SPI_MODE_CPOL) {
  10143c:	f6 c3 01             	test   $0x1,%bl
  10143f:	75 1b                	jne    10145c <spi_intel_configure+0x79>
	/* Tx/Rx thresholds
	 * Note: Rx thresholds needs to be 1, it does not seem to be able
	 * to trigger reliably any interrupt with another value though the
	 * rx fifo would be full
	 */
	spi->sscr1 |= INTEL_SPI_SSCR1_TFT(INTEL_SPI_SSCR1_TFT_DFLT) |
  101441:	0d c0 01 00 00       	or     $0x1c0,%eax
  101446:	eb 19                	jmp    101461 <spi_intel_configure+0x7e>
{
	int ret;

	__asm__ volatile("btl	%2, %1;\n\t"
			 "sbb	%0, %0\n\t"
			 : "=r" (ret), "+m" (*(volatile uint32_t *) (addr))
  101448:	8b 02                	mov    (%edx),%eax
static ALWAYS_INLINE
	int sys_test_bit(mem_addr_t addr, unsigned int bit)
{
	int ret;

	__asm__ volatile("btl	%2, %1;\n\t"
  10144a:	0f ba 60 08 04       	btl    $0x4,0x8(%eax)
  10144f:	19 f6                	sbb    %esi,%esi
		    config);

	/* Check status */
	if (test_bit_sscr0_sse(spi->regs) && test_bit_sssr_bsy(spi->regs)) {
		SYS_LOG_DBG("spi_intel_configure: Controller is busy");
		return -EBUSY;
  101451:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax

	SYS_LOG_DBG("spi_intel_configure: %p (0x%x), %p", dev, spi->regs,
		    config);

	/* Check status */
	if (test_bit_sscr0_sse(spi->regs) && test_bit_sssr_bsy(spi->regs)) {
  101456:	85 f6                	test   %esi,%esi
  101458:	74 a6                	je     101400 <spi_intel_configure+0x1d>
  10145a:	eb 24                	jmp    101480 <spi_intel_configure+0x9d>
		      INTEL_SPI_SSCR1_RFT(INTEL_SPI_SSCR1_RFT_DFLT);

	/* SPI mode */
	mode = SPI_MODE(flags);
	if (mode & SPI_MODE_CPOL) {
		spi->sscr1 |= INTEL_SPI_SSCR1_SPO;
  10145c:	0d c8 01 00 00       	or     $0x1c8,%eax
  101461:	89 42 34             	mov    %eax,0x34(%edx)
	}

	if (mode & SPI_MODE_CPHA) {
  101464:	f6 c3 02             	test   $0x2,%bl
  101467:	74 04                	je     10146d <spi_intel_configure+0x8a>
		spi->sscr1 |= INTEL_SPI_SSCR1_SPH;
  101469:	83 4a 34 10          	orl    $0x10,0x34(%edx)
	}

	if (mode & SPI_MODE_LOOP) {
  10146d:	80 e3 04             	and    $0x4,%bl
  101470:	74 04                	je     101476 <spi_intel_configure+0x93>
		spi->sscr1 |= INTEL_SPI_SSCR1_LBM;
  101472:	83 4a 34 04          	orl    $0x4,0x34(%edx)
	}

	/* Configuring the rate */
	write_dds_rate(INTEL_SPI_DSS_RATE(config->max_sys_freq), spi->regs);
  101476:	c1 e9 08             	shr    $0x8,%ecx
static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
			 :
			 : "r"(data), "m" (*(volatile uint32_t *) addr)
  101479:	8b 02                	mov    (%edx),%eax
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  10147b:	89 48 28             	mov    %ecx,0x28(%eax)

	return 0;
  10147e:	31 c0                	xor    %eax,%eax
}
  101480:	5b                   	pop    %ebx
  101481:	5e                   	pop    %esi
  101482:	5f                   	pop    %edi
  101483:	5d                   	pop    %ebp
  101484:	c3                   	ret    

00101485 <spi_config_0_irq>:
DEVICE_DEFINE(spi_intel_port_0, CONFIG_SPI_0_NAME, spi_intel_init,
	      spi_intel_device_ctrl, &spi_intel_data_port_0,
	      &spi_intel_config_0, POST_KERNEL, CONFIG_SPI_INIT_PRIORITY, NULL);

void spi_config_0_irq(void)
{
  101485:	55                   	push   %ebp
  101486:	89 e5                	mov    %esp,%ebp
  101488:	0f b6 05 f8 6d 10 00 	movzbl 0x106df8,%eax
  10148f:	6a 00                	push   $0x0
  101491:	6a 10                	push   $0x10
  101493:	50                   	push   %eax
  101494:	e8 8a f3 ff ff       	call   100823 <__irq_controller_irq_config>
  101499:	83 c4 0c             	add    $0xc,%esp
	IRQ_CONNECT(SPI_INTEL_PORT_0_IRQ, CONFIG_SPI_0_IRQ_PRI,
		    spi_intel_isr, DEVICE_GET(spi_intel_port_0),
		    SPI_INTEL_IRQ_FLAGS);
}
  10149c:	c9                   	leave  
  10149d:	c3                   	ret    

0010149e <spi_intel_init>:
#else
#define spi_intel_set_power_state(...)
#endif

int spi_intel_init(struct device *dev)
{
  10149e:	55                   	push   %ebp
  10149f:	89 e5                	mov    %esp,%ebp
  1014a1:	57                   	push   %edi
  1014a2:	56                   	push   %esi
  1014a3:	53                   	push   %ebx
  1014a4:	83 ec 0c             	sub    $0xc,%esp
  1014a7:	8b 7d 08             	mov    0x8(%ebp),%edi
	const struct spi_intel_config *info = dev->config->config_info;
  1014aa:	8b 07                	mov    (%edi),%eax
	struct spi_intel_data *spi = dev->driver_data;
  1014ac:	8b 5f 08             	mov    0x8(%edi),%ebx
#define spi_intel_set_power_state(...)
#endif

int spi_intel_init(struct device *dev)
{
	const struct spi_intel_config *info = dev->config->config_info;
  1014af:	8b 40 08             	mov    0x8(%eax),%eax
{
	struct spi_intel_data *spi = dev->driver_data;

	pci_bus_scan_init();

	if (!pci_bus_scan(&spi->pci_dev)) {
  1014b2:	8d 73 04             	lea    0x4(%ebx),%esi
#define spi_intel_set_power_state(...)
#endif

int spi_intel_init(struct device *dev)
{
	const struct spi_intel_config *info = dev->config->config_info;
  1014b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
#ifdef CONFIG_PCI
static inline int spi_intel_setup(struct device *dev)
{
	struct spi_intel_data *spi = dev->driver_data;

	pci_bus_scan_init();
  1014b8:	e8 e8 f4 ff ff       	call   1009a5 <pci_bus_scan_init>

	if (!pci_bus_scan(&spi->pci_dev)) {
  1014bd:	56                   	push   %esi
  1014be:	e8 50 f5 ff ff       	call   100a13 <pci_bus_scan>
  1014c3:	5a                   	pop    %edx
  1014c4:	83 ca ff             	or     $0xffffffff,%edx
  1014c7:	85 c0                	test   %eax,%eax
  1014c9:	0f 84 91 00 00 00    	je     101560 <spi_intel_init+0xc2>
		SYS_LOG_DBG("Could not find device");
		return 0;
	}

#ifdef CONFIG_PCI_ENUMERATION
	spi->regs = spi->pci_dev.addr;
  1014cf:	8b 43 04             	mov    0x4(%ebx),%eax
  1014d2:	89 03                	mov    %eax,(%ebx)
#endif

	pci_enable_regs(&spi->pci_dev);
  1014d4:	56                   	push   %esi
  1014d5:	e8 0a fb ff ff       	call   100fe4 <pci_enable_regs>

	if (!spi_intel_setup(dev)) {
		return -EPERM;
	}

	info->config_func();
  1014da:	8b 45 f0             	mov    -0x10(%ebp),%eax

#ifdef CONFIG_PCI_ENUMERATION
	spi->regs = spi->pci_dev.addr;
#endif

	pci_enable_regs(&spi->pci_dev);
  1014dd:	5a                   	pop    %edx

	if (!spi_intel_setup(dev)) {
		return -EPERM;
	}

	info->config_func();
  1014de:	ff 50 04             	call   *0x4(%eax)

#include <gpio.h>

static inline void _spi_config_cs(struct device *dev)
{
	const struct spi_intel_config *info = dev->config->config_info;
  1014e1:	8b 07                	mov    (%edi),%eax
  1014e3:	8b 50 08             	mov    0x8(%eax),%edx
	struct spi_intel_data *spi = dev->driver_data;
  1014e6:	8b 47 08             	mov    0x8(%edi),%eax
	struct device *gpio;

	gpio = device_get_binding(info->cs_gpio_name);
  1014e9:	89 55 e8             	mov    %edx,-0x18(%ebp)
#include <gpio.h>

static inline void _spi_config_cs(struct device *dev)
{
	const struct spi_intel_config *info = dev->config->config_info;
	struct spi_intel_data *spi = dev->driver_data;
  1014ec:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct device *gpio;

	gpio = device_get_binding(info->cs_gpio_name);
  1014ef:	ff 72 08             	pushl  0x8(%edx)
  1014f2:	e8 f5 21 00 00       	call   1036ec <device_get_binding>
  1014f7:	59                   	pop    %ecx
  1014f8:	89 c6                	mov    %eax,%esi
	if (!gpio) {
  1014fa:	85 c0                	test   %eax,%eax
  1014fc:	8b 55 e8             	mov    -0x18(%ebp),%edx
  1014ff:	75 0c                	jne    10150d <spi_intel_init+0x6f>
		spi->cs_gpio_port = NULL;
  101501:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101504:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  10150b:	eb 2f                	jmp    10153c <spi_intel_init+0x9e>
static inline int gpio_pin_configure(struct device *port, uint8_t pin,
				     int flags)
{
	const struct gpio_driver_api *api = port->driver_api;

	return api->config(port, GPIO_ACCESS_BY_PIN, pin, flags);
  10150d:	8b 40 04             	mov    0x4(%eax),%eax
  101510:	6a 01                	push   $0x1
  101512:	0f b6 4a 0c          	movzbl 0xc(%edx),%ecx
  101516:	51                   	push   %ecx
  101517:	6a 00                	push   $0x0
  101519:	56                   	push   %esi
  10151a:	89 55 e8             	mov    %edx,-0x18(%ebp)
  10151d:	ff 10                	call   *(%eax)
  10151f:	83 c4 10             	add    $0x10,%esp
static inline int gpio_pin_write(struct device *port, uint32_t pin,
				 uint32_t value)
{
	const struct gpio_driver_api *api = port->driver_api;

	return api->write(port, GPIO_ACCESS_BY_PIN, pin, value);
  101522:	8b 55 e8             	mov    -0x18(%ebp),%edx
  101525:	8b 46 04             	mov    0x4(%esi),%eax
  101528:	6a 01                	push   $0x1
  10152a:	ff 72 0c             	pushl  0xc(%edx)
  10152d:	6a 00                	push   $0x0
  10152f:	56                   	push   %esi
  101530:	ff 50 04             	call   *0x4(%eax)

	gpio_pin_configure(gpio, info->cs_gpio_pin, GPIO_DIR_OUT);
	/* Default CS line to high (idling) */
	gpio_pin_write(gpio, info->cs_gpio_pin, 1);

	spi->cs_gpio_port = gpio;
  101533:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101536:	83 c4 10             	add    $0x10,%esp
  101539:	89 70 2c             	mov    %esi,0x2c(%eax)
 *
 * @param sync A pointer to a valid device_sync_call_t
 */
static inline void device_sync_call_init(device_sync_call_t *sync)
{
	k_sem_init(&sync->f_sem, 0, UINT_MAX);
  10153c:	83 c3 18             	add    $0x18,%ebx
  10153f:	6a ff                	push   $0xffffffff
  101541:	6a 00                	push   $0x0
  101543:	53                   	push   %ebx
  101544:	e8 3b 28 00 00       	call   103d84 <k_sem_init>

	device_sync_call_init(&spi->sync);

	spi_intel_set_power_state(dev, DEVICE_PM_ACTIVE_STATE);

	irq_enable(info->irq);
  101549:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10154c:	83 c4 0c             	add    $0xc,%esp
  10154f:	ff 30                	pushl  (%eax)
  101551:	e8 f3 f2 ff ff       	call   100849 <_arch_irq_enable>
  101556:	58                   	pop    %eax

	SYS_LOG_DBG("SPI Intel Driver initialized on device: %p", dev);

	dev->driver_api = &intel_spi_api;

	return 0;
  101557:	31 d2                	xor    %edx,%edx

	irq_enable(info->irq);

	SYS_LOG_DBG("SPI Intel Driver initialized on device: %p", dev);

	dev->driver_api = &intel_spi_api;
  101559:	c7 47 04 50 48 10 00 	movl   $0x104850,0x4(%edi)

	return 0;
}
  101560:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101563:	89 d0                	mov    %edx,%eax
  101565:	5b                   	pop    %ebx
  101566:	5e                   	pop    %esi
  101567:	5f                   	pop    %edi
  101568:	5d                   	pop    %ebp
  101569:	c3                   	ret    

0010156a <_spi_control_cs>:
static inline void _spi_control_cs(struct device *dev, int on)
{
	const struct spi_intel_config *info = dev->config->config_info;
	struct spi_intel_data *spi = dev->driver_data;

	if (!spi->cs_gpio_port) {
  10156a:	8b 48 08             	mov    0x8(%eax),%ecx
  10156d:	8b 49 2c             	mov    0x2c(%ecx),%ecx
  101570:	85 c9                	test   %ecx,%ecx
  101572:	74 25                	je     101599 <_spi_control_cs+0x2f>

	spi->cs_gpio_port = gpio;
}

static inline void _spi_control_cs(struct device *dev, int on)
{
  101574:	55                   	push   %ebp
  101575:	85 d2                	test   %edx,%edx
  101577:	0f 94 c2             	sete   %dl
  10157a:	89 e5                	mov    %esp,%ebp
  10157c:	53                   	push   %ebx
  10157d:	0f b6 d2             	movzbl %dl,%edx
  101580:	8b 59 04             	mov    0x4(%ecx),%ebx
  101583:	52                   	push   %edx
	const struct spi_intel_config *info = dev->config->config_info;
  101584:	8b 00                	mov    (%eax),%eax

	if (!spi->cs_gpio_port) {
		return;
	}

	gpio_pin_write(spi->cs_gpio_port, info->cs_gpio_pin, !on);
  101586:	8b 40 08             	mov    0x8(%eax),%eax
  101589:	ff 70 0c             	pushl  0xc(%eax)
  10158c:	6a 00                	push   $0x0
  10158e:	51                   	push   %ecx
  10158f:	ff 53 04             	call   *0x4(%ebx)
  101592:	83 c4 10             	add    $0x10,%esp
}
  101595:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  101598:	c9                   	leave  
  101599:	c3                   	ret    

0010159a <spi_intel_isr>:

	return 0;
}

void spi_intel_isr(void *arg)
{
  10159a:	55                   	push   %ebp
  10159b:	89 e5                	mov    %esp,%ebp
  10159d:	57                   	push   %edi
  10159e:	56                   	push   %esi
  10159f:	53                   	push   %ebx
  1015a0:	51                   	push   %ecx
  1015a1:	8b 45 08             	mov    0x8(%ebp),%eax
	struct device *dev = arg;
	struct spi_intel_data *spi = dev->driver_data;
  1015a4:	8b 58 08             	mov    0x8(%eax),%ebx
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
			 : "=r"(ret)
			 : "m" (*(volatile uint32_t *) addr)
  1015a7:	8b 13                	mov    (%ebx),%edx
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  1015a9:	8b 72 08             	mov    0x8(%edx),%esi
  1015ac:	89 75 f0             	mov    %esi,-0x10(%ebp)

	SYS_LOG_DBG("spi_intel_isr: %p", dev);

	status = read_sssr(spi->regs);

	if (status & INTEL_SPI_SSSR_ROR) {
  1015af:	81 e6 80 00 00 00    	and    $0x80,%esi
  1015b5:	74 11                	je     1015c8 <spi_intel_isr+0x2e>

static ALWAYS_INLINE
	void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btrl	%1, %0;\n\t"
			 : "+m" (*(volatile uint32_t *) (addr))
  1015b7:	8b 13                	mov    (%ebx),%edx
}

static ALWAYS_INLINE
	void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btrl	%1, %0;\n\t"
  1015b9:	0f ba 72 08 07       	btrl   $0x7,0x8(%edx)
		/* Unrecoverable error, ack it */
		clear_bit_sssr_ror(spi->regs);
		error = 1;
  1015be:	ba 01 00 00 00       	mov    $0x1,%edx
  1015c3:	e9 90 00 00 00       	jmp    101658 <spi_intel_isr+0xbe>
		goto out;
	}

	if (status & INTEL_SPI_SSSR_RFS) {
  1015c8:	f6 45 f0 40          	testb  $0x40,-0x10(%ebp)
  1015cc:	75 0f                	jne    1015dd <spi_intel_isr+0x43>
{
	int ret;

	__asm__ volatile("btl	%2, %1;\n\t"
			 "sbb	%0, %0\n\t"
			 : "=r" (ret), "+m" (*(volatile uint32_t *) (addr))
  1015ce:	8b 13                	mov    (%ebx),%edx
static ALWAYS_INLINE
	int sys_test_bit(mem_addr_t addr, unsigned int bit)
{
	int ret;

	__asm__ volatile("btl	%2, %1;\n\t"
  1015d0:	0f ba 62 04 01       	btl    $0x1,0x4(%edx)
  1015d5:	19 db                	sbb    %ebx,%ebx
		pull_data(dev);
	}

	if (test_bit_sscr1_tie(spi->regs)) {
  1015d7:	85 db                	test   %ebx,%ebx
  1015d9:	75 2e                	jne    101609 <spi_intel_isr+0x6f>
  1015db:	eb 79                	jmp    101656 <spi_intel_isr+0xbc>
  1015dd:	8b 50 08             	mov    0x8(%eax),%edx
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
			 : "=r"(ret)
			 : "m" (*(volatile uint32_t *) addr)
  1015e0:	8b 32                	mov    (%edx),%esi
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  1015e2:	8b 76 08             	mov    0x8(%esi),%esi
{
	struct spi_intel_data *spi = dev->driver_data;
	uint32_t cnt = 0;
	uint8_t data = 0;

	while (read_sssr(spi->regs) & INTEL_SPI_SSSR_RNE) {
  1015e5:	83 e6 08             	and    $0x8,%esi
  1015e8:	74 e4                	je     1015ce <spi_intel_isr+0x34>
			 : "=r"(ret)
			 : "m" (*(volatile uint32_t *) addr)
  1015ea:	8b 32                	mov    (%edx),%esi
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  1015ec:	8b 7e 10             	mov    0x10(%esi),%edi
		data = (uint8_t) read_ssdr(spi->regs);
		cnt++;
		spi->received++;
  1015ef:	8b 72 4c             	mov    0x4c(%edx),%esi
  1015f2:	89 f9                	mov    %edi,%ecx

		if ((spi->received - 1) < spi->r_buf_len) {
  1015f4:	3b 72 44             	cmp    0x44(%edx),%esi
	uint8_t data = 0;

	while (read_sssr(spi->regs) & INTEL_SPI_SSSR_RNE) {
		data = (uint8_t) read_ssdr(spi->regs);
		cnt++;
		spi->received++;
  1015f7:	8d 7e 01             	lea    0x1(%esi),%edi
  1015fa:	89 7a 4c             	mov    %edi,0x4c(%edx)

		if ((spi->received - 1) < spi->r_buf_len) {
  1015fd:	73 e1                	jae    1015e0 <spi_intel_isr+0x46>
			*(uint8_t *)(spi->rx_buf) = data;
  1015ff:	8b 72 3c             	mov    0x3c(%edx),%esi
  101602:	88 0e                	mov    %cl,(%esi)
			spi->rx_buf++;
  101604:	ff 42 3c             	incl   0x3c(%edx)
  101607:	eb d7                	jmp    1015e0 <spi_intel_isr+0x46>
	if (status & INTEL_SPI_SSSR_RFS) {
		pull_data(dev);
	}

	if (test_bit_sscr1_tie(spi->regs)) {
		if (status & INTEL_SPI_SSSR_TFS) {
  101609:	f6 45 f0 20          	testb  $0x20,-0x10(%ebp)
  10160d:	74 47                	je     101656 <spi_intel_isr+0xbc>
  10160f:	8b 50 08             	mov    0x8(%eax),%edx
			 : "=r"(ret)
			 : "m" (*(volatile uint32_t *) addr)
  101612:	8b 0a                	mov    (%edx),%ecx
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  101614:	8b 49 08             	mov    0x8(%ecx),%ecx
	struct spi_intel_data *spi = dev->driver_data;
	uint32_t cnt = 0;
	uint8_t data;
	uint32_t status;

	while ((status = read_sssr(spi->regs)) & INTEL_SPI_SSSR_TNF) {
  101617:	f6 c1 04             	test   $0x4,%cl
  10161a:	8b 5a 48             	mov    0x48(%edx),%ebx
  10161d:	74 2b                	je     10164a <spi_intel_isr+0xb0>
		if (status & INTEL_SPI_SSSR_RFS) {
  10161f:	80 e1 40             	and    $0x40,%cl
  101622:	75 26                	jne    10164a <spi_intel_isr+0xb0>
			break;
		}
		if (spi->tx_buf && (spi->transmitted < spi->t_buf_len)) {
  101624:	8b 4a 38             	mov    0x38(%edx),%ecx
  101627:	85 c9                	test   %ecx,%ecx
  101629:	74 0e                	je     101639 <spi_intel_isr+0x9f>
  10162b:	3b 5a 40             	cmp    0x40(%edx),%ebx
  10162e:	73 09                	jae    101639 <spi_intel_isr+0x9f>
			data = *(uint8_t *)(spi->tx_buf);
  101630:	0f b6 19             	movzbl (%ecx),%ebx
			spi->tx_buf++;
  101633:	41                   	inc    %ecx
  101634:	89 4a 38             	mov    %ecx,0x38(%edx)
  101637:	eb 07                	jmp    101640 <spi_intel_isr+0xa6>
		} else if (spi->transmitted < spi->trans_len) {
  101639:	3b 5a 50             	cmp    0x50(%edx),%ebx
  10163c:	73 0c                	jae    10164a <spi_intel_isr+0xb0>
			data = 0;
  10163e:	31 db                	xor    %ebx,%ebx
static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
			 :
			 : "r"(data), "m" (*(volatile uint32_t *) addr)
  101640:	8b 0a                	mov    (%edx),%ecx
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  101642:	89 59 10             	mov    %ebx,0x10(%ecx)
		}

		cnt++;
		SYS_LOG_DBG("Pushing 1 byte (total: %d)", cnt);
		write_ssdr(data, spi->regs);
		spi->transmitted++;
  101645:	ff 42 48             	incl   0x48(%edx)
  101648:	eb c8                	jmp    101612 <spi_intel_isr+0x78>
	}

	SYS_LOG_DBG("Pushed: %d (total: %d)", cnt, spi->transmitted);

	if (spi->transmitted == spi->trans_len) {
  10164a:	3b 5a 50             	cmp    0x50(%edx),%ebx
  10164d:	75 07                	jne    101656 <spi_intel_isr+0xbc>

static ALWAYS_INLINE
	void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btrl	%1, %0;\n\t"
			 : "+m" (*(volatile uint32_t *) (addr))
  10164f:	8b 12                	mov    (%edx),%edx
}

static ALWAYS_INLINE
	void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btrl	%1, %0;\n\t"
  101651:	0f ba 72 04 01       	btrl   $0x1,0x4(%edx)

void spi_intel_isr(void *arg)
{
	struct device *dev = arg;
	struct spi_intel_data *spi = dev->driver_data;
	uint32_t error = 0;
  101656:	31 d2                	xor    %edx,%edx
#define _spi_config_cs(...) { ; }
#endif /* CONFIG_SPI_CS_GPIO */

static void completed(struct device *dev, uint32_t error)
{
	struct spi_intel_data *spi = dev->driver_data;
  101658:	8b 58 08             	mov    0x8(%eax),%ebx

	/* if received == trans_len, then transmitted == trans_len */
	if (!(spi->received == spi->trans_len) && !error) {
  10165b:	8b 7b 50             	mov    0x50(%ebx),%edi
  10165e:	39 7b 4c             	cmp    %edi,0x4c(%ebx)
  101661:	74 04                	je     101667 <spi_intel_isr+0xcd>
  101663:	85 d2                	test   %edx,%edx
  101665:	74 28                	je     10168f <spi_intel_isr+0xf5>
		return;
	}

	spi->error = error;
  101667:	88 53 28             	mov    %dl,0x28(%ebx)

	_spi_control_cs(dev, 0);
  10166a:	31 d2                	xor    %edx,%edx
  10166c:	e8 f9 fe ff ff       	call   10156a <_spi_control_cs>

	write_sscr1(spi->sscr1, spi->regs);
  101671:	8b 43 34             	mov    0x34(%ebx),%eax
static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
			 :
			 : "r"(data), "m" (*(volatile uint32_t *) addr)
  101674:	8b 13                	mov    (%ebx),%edx
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  101676:	89 42 04             	mov    %eax,0x4(%edx)

static ALWAYS_INLINE
	void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btrl	%1, %0;\n\t"
			 : "+m" (*(volatile uint32_t *) (addr))
  101679:	8b 03                	mov    (%ebx),%eax
}

static ALWAYS_INLINE
	void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btrl	%1, %0;\n\t"
  10167b:	0f ba 30 07          	btrl   $0x7,(%eax)
 *
 * @param sync A pointer to a valid device_sync_call_t
 */
static inline void device_sync_call_complete(device_sync_call_t *sync)
{
	k_sem_give(&sync->f_sem);
  10167f:	83 c3 18             	add    $0x18,%ebx
  101682:	89 5d 08             	mov    %ebx,0x8(%ebp)
			push_data(dev);
		}
	}
out:
	completed(dev, error);
}
  101685:	5a                   	pop    %edx
  101686:	5b                   	pop    %ebx
  101687:	5e                   	pop    %esi
  101688:	5f                   	pop    %edi
  101689:	5d                   	pop    %ebp
  10168a:	e9 0e 27 00 00       	jmp    103d9d <k_sem_give>
  10168f:	58                   	pop    %eax
  101690:	5b                   	pop    %ebx
  101691:	5e                   	pop    %esi
  101692:	5f                   	pop    %edi
  101693:	5d                   	pop    %ebp
  101694:	c3                   	ret    

00101695 <spi_intel_transceive>:
}

static int spi_intel_transceive(struct device *dev,
				const void *tx_buf, uint32_t tx_buf_len,
				void *rx_buf, uint32_t rx_buf_len)
{
  101695:	55                   	push   %ebp
  101696:	89 e5                	mov    %esp,%ebp
  101698:	57                   	push   %edi
  101699:	56                   	push   %esi
  10169a:	53                   	push   %ebx
  10169b:	8b 45 08             	mov    0x8(%ebp),%eax
  10169e:	8b 55 10             	mov    0x10(%ebp),%edx
  1016a1:	8b 75 18             	mov    0x18(%ebp),%esi
	struct spi_intel_data *spi = dev->driver_data;
  1016a4:	8b 58 08             	mov    0x8(%eax),%ebx
{
	int ret;

	__asm__ volatile("btl	%2, %1;\n\t"
			 "sbb	%0, %0\n\t"
			 : "=r" (ret), "+m" (*(volatile uint32_t *) (addr))
  1016a7:	8b 0b                	mov    (%ebx),%ecx
static ALWAYS_INLINE
	int sys_test_bit(mem_addr_t addr, unsigned int bit)
{
	int ret;

	__asm__ volatile("btl	%2, %1;\n\t"
  1016a9:	0f ba 21 07          	btl    $0x7,(%ecx)
  1016ad:	19 ff                	sbb    %edi,%edi

	SYS_LOG_DBG("spi_dw_transceive: %p, %p, %u, %p, %u",
			dev, tx_buf, tx_buf_len, rx_buf, rx_buf_len);

	/* Check status */
	if (test_bit_sscr0_sse(spi->regs) && test_bit_sssr_bsy(spi->regs)) {
  1016af:	85 ff                	test   %edi,%edi
  1016b1:	75 67                	jne    10171a <spi_intel_transceive+0x85>
		SYS_LOG_DBG("spi_intel_transceive: Controller is busy");
		return -EBUSY;
	}

	/* Set buffers info */
	spi->tx_buf = tx_buf;
  1016b3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	spi->rx_buf = rx_buf;
	spi->t_buf_len = tx_buf_len;
  1016b6:	89 53 40             	mov    %edx,0x40(%ebx)
		SYS_LOG_DBG("spi_intel_transceive: Controller is busy");
		return -EBUSY;
	}

	/* Set buffers info */
	spi->tx_buf = tx_buf;
  1016b9:	89 4b 38             	mov    %ecx,0x38(%ebx)
	spi->rx_buf = rx_buf;
  1016bc:	8b 4d 14             	mov    0x14(%ebp),%ecx
  1016bf:	89 4b 3c             	mov    %ecx,0x3c(%ebx)
	spi->t_buf_len = tx_buf_len;
	spi->r_buf_len = rx_buf_len;
  1016c2:	89 73 44             	mov    %esi,0x44(%ebx)
	spi->transmitted = 0;
  1016c5:	c7 43 48 00 00 00 00 	movl   $0x0,0x48(%ebx)
	spi->received = 0;
  1016cc:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
	spi->trans_len = max(tx_buf_len, rx_buf_len);
  1016d3:	39 f2                	cmp    %esi,%edx
  1016d5:	73 02                	jae    1016d9 <spi_intel_transceive+0x44>
  1016d7:	89 f2                	mov    %esi,%edx
  1016d9:	89 53 50             	mov    %edx,0x50(%ebx)

	_spi_control_cs(dev, 1);
  1016dc:	ba 01 00 00 00       	mov    $0x1,%edx
  1016e1:	e8 84 fe ff ff       	call   10156a <_spi_control_cs>

	/* Enabling the controller */
	write_sscr0(spi->sscr0 | INTEL_SPI_SSCR0_SSE, spi->regs);
  1016e6:	8b 43 30             	mov    0x30(%ebx),%eax
  1016e9:	0c 80                	or     $0x80,%al
static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
			 :
			 : "r"(data), "m" (*(volatile uint32_t *) addr)
  1016eb:	8b 13                	mov    (%ebx),%edx
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  1016ed:	89 02                	mov    %eax,(%edx)

	/* Installing the registers */
	write_sscr1(spi->sscr1 | INTEL_SPI_SSCR1_RIE |
  1016ef:	8b 43 34             	mov    0x34(%ebx),%eax
			 :
			 : "r"(data), "m" (*(volatile uint32_t *) addr)
  1016f2:	8b 13                	mov    (%ebx),%edx
  1016f4:	83 c8 03             	or     $0x3,%eax
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  1016f7:	89 42 04             	mov    %eax,0x4(%edx)
 *
 * @param sync A pointer to a valid device_sync_call_t
 */
static inline void device_sync_call_wait(device_sync_call_t *sync)
{
	k_sem_take(&sync->f_sem, K_FOREVER);
  1016fa:	8d 43 18             	lea    0x18(%ebx),%eax
  1016fd:	6a ff                	push   $0xffffffff
  1016ff:	50                   	push   %eax
  101700:	e8 be 26 00 00       	call   103dc3 <k_sem_take>
  101705:	58                   	pop    %eax
	if (spi->error) {
		spi->error = 0;
		return -EIO;
	}

	return 0;
  101706:	31 c9                	xor    %ecx,%ecx
  101708:	5a                   	pop    %edx
	write_sscr1(spi->sscr1 | INTEL_SPI_SSCR1_RIE |
				INTEL_SPI_SSCR1_TIE, spi->regs);

	device_sync_call_wait(&spi->sync);

	if (spi->error) {
  101709:	80 7b 28 00          	cmpb   $0x0,0x28(%ebx)
  10170d:	74 1d                	je     10172c <spi_intel_transceive+0x97>
		spi->error = 0;
  10170f:	c6 43 28 00          	movb   $0x0,0x28(%ebx)
		return -EIO;
  101713:	b9 fb ff ff ff       	mov    $0xfffffffb,%ecx
  101718:	eb 12                	jmp    10172c <spi_intel_transceive+0x97>
{
	int ret;

	__asm__ volatile("btl	%2, %1;\n\t"
			 "sbb	%0, %0\n\t"
			 : "=r" (ret), "+m" (*(volatile uint32_t *) (addr))
  10171a:	8b 0b                	mov    (%ebx),%ecx
static ALWAYS_INLINE
	int sys_test_bit(mem_addr_t addr, unsigned int bit)
{
	int ret;

	__asm__ volatile("btl	%2, %1;\n\t"
  10171c:	0f ba 61 08 04       	btl    $0x4,0x8(%ecx)
  101721:	19 ff                	sbb    %edi,%edi
			dev, tx_buf, tx_buf_len, rx_buf, rx_buf_len);

	/* Check status */
	if (test_bit_sscr0_sse(spi->regs) && test_bit_sssr_bsy(spi->regs)) {
		SYS_LOG_DBG("spi_intel_transceive: Controller is busy");
		return -EBUSY;
  101723:	b9 f0 ff ff ff       	mov    $0xfffffff0,%ecx

	SYS_LOG_DBG("spi_dw_transceive: %p, %p, %u, %p, %u",
			dev, tx_buf, tx_buf_len, rx_buf, rx_buf_len);

	/* Check status */
	if (test_bit_sscr0_sse(spi->regs) && test_bit_sssr_bsy(spi->regs)) {
  101728:	85 ff                	test   %edi,%edi
  10172a:	74 87                	je     1016b3 <spi_intel_transceive+0x1e>
		spi->error = 0;
		return -EIO;
	}

	return 0;
}
  10172c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10172f:	89 c8                	mov    %ecx,%eax
  101731:	5b                   	pop    %ebx
  101732:	5e                   	pop    %esi
  101733:	5f                   	pop    %edi
  101734:	5d                   	pop    %ebp
  101735:	c3                   	ret    

00101736 <dw_set_bit>:
	sys_write32(val, base_addr + offset);
}

static void dw_set_bit(uint32_t base_addr, uint32_t offset,
		       uint32_t bit, uint8_t value)
{
  101736:	55                   	push   %ebp
  101737:	8d 04 10             	lea    (%eax,%edx,1),%eax
  10173a:	89 e5                	mov    %esp,%ebp
	if (!value) {
  10173c:	80 7d 08 00          	cmpb   $0x0,0x8(%ebp)
  101740:	75 05                	jne    101747 <dw_set_bit+0x11>
}

static ALWAYS_INLINE
	void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btrl	%1, %0;\n\t"
  101742:	0f b3 08             	btr    %ecx,(%eax)
  101745:	eb 03                	jmp    10174a <dw_set_bit+0x14>


static ALWAYS_INLINE
	void sys_set_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btsl	%1, %0;\n\t"
  101747:	0f ab 08             	bts    %ecx,(%eax)
		sys_clear_bit(base_addr + offset, bit);
	} else {
		sys_set_bit(base_addr + offset, bit);
	}
}
  10174a:	5d                   	pop    %ebp
  10174b:	c3                   	ret    

0010174c <gpio_dw_write>:
	return 0;
}

static inline int gpio_dw_write(struct device *port, int access_op,
				uint32_t pin, uint32_t value)
{
  10174c:	55                   	push   %ebp
  10174d:	89 e5                	mov    %esp,%ebp
	struct gpio_dw_runtime *context = port->driver_data;
	uint32_t base_addr = context->base_addr;
  10174f:	8b 45 08             	mov    0x8(%ebp),%eax
	return 0;
}

static inline int gpio_dw_write(struct device *port, int access_op,
				uint32_t pin, uint32_t value)
{
  101752:	8b 55 14             	mov    0x14(%ebp),%edx
	struct gpio_dw_runtime *context = port->driver_data;
	uint32_t base_addr = context->base_addr;

	if (GPIO_ACCESS_BY_PIN == access_op) {
  101755:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)

static inline int gpio_dw_write(struct device *port, int access_op,
				uint32_t pin, uint32_t value)
{
	struct gpio_dw_runtime *context = port->driver_data;
	uint32_t base_addr = context->base_addr;
  101759:	8b 40 08             	mov    0x8(%eax),%eax
  10175c:	8b 00                	mov    (%eax),%eax

	if (GPIO_ACCESS_BY_PIN == access_op) {
  10175e:	75 11                	jne    101771 <gpio_dw_write+0x25>
		dw_set_bit(base_addr, SWPORTA_DR, pin, value);
  101760:	0f b6 d2             	movzbl %dl,%edx
  101763:	52                   	push   %edx
  101764:	8b 4d 10             	mov    0x10(%ebp),%ecx
  101767:	31 d2                	xor    %edx,%edx
  101769:	e8 c8 ff ff ff       	call   101736 <dw_set_bit>
  10176e:	58                   	pop    %eax
  10176f:	eb 02                	jmp    101773 <gpio_dw_write+0x27>
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  101771:	89 10                	mov    %edx,(%eax)
	} else {
		dw_write(base_addr, SWPORTA_DR, value);
	}

	return 0;
}
  101773:	31 c0                	xor    %eax,%eax
  101775:	c9                   	leave  
  101776:	c3                   	ret    

00101777 <gpio_dw_read>:

static inline int gpio_dw_read(struct device *port, int access_op,
			       uint32_t pin, uint32_t *value)
{
  101777:	55                   	push   %ebp
  101778:	b9 0c 00 00 00       	mov    $0xc,%ecx
  10177d:	89 e5                	mov    %esp,%ebp
  10177f:	56                   	push   %esi
  101780:	53                   	push   %ebx
  101781:	31 d2                	xor    %edx,%edx
	struct gpio_dw_runtime *context = port->driver_data;
	uint32_t base_addr = context->base_addr;
  101783:	8b 45 08             	mov    0x8(%ebp),%eax
	return 0;
}

static inline int gpio_dw_read(struct device *port, int access_op,
			       uint32_t pin, uint32_t *value)
{
  101786:	8b 5d 14             	mov    0x14(%ebp),%ebx
	struct gpio_dw_runtime *context = port->driver_data;
	uint32_t base_addr = context->base_addr;
  101789:	8b 40 08             	mov    0x8(%eax),%eax
  10178c:	8b 30                	mov    (%eax),%esi
  10178e:	89 f0                	mov    %esi,%eax
  101790:	83 e0 3f             	and    $0x3f,%eax
  101793:	f7 f1                	div    %ecx
  101795:	b9 50 00 00 00       	mov    $0x50,%ecx
  10179a:	8d 50 ff             	lea    -0x1(%eax),%edx
  10179d:	83 fa 02             	cmp    $0x2,%edx
  1017a0:	77 07                	ja     1017a9 <gpio_dw_read+0x32>
  1017a2:	0f b6 88 5b 48 10 00 	movzbl 0x10485b(%eax),%ecx
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
			 : "=r"(ret)
			 : "m" (*(volatile uint32_t *) addr)
  1017a9:	83 e6 c0             	and    $0xffffffc0,%esi
  1017ac:	01 f1                	add    %esi,%ecx
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  1017ae:	8b 01                	mov    (%ecx),%eax
		break;
	}
	*value = dw_read(dw_base_to_block_base(base_addr), ext_port);
#endif

	if (GPIO_ACCESS_BY_PIN == access_op) {
  1017b0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  1017b4:	75 08                	jne    1017be <gpio_dw_read+0x47>
		*value = !!(*value & BIT(pin));
  1017b6:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1017b9:	d3 e8                	shr    %cl,%eax
  1017bb:	83 e0 01             	and    $0x1,%eax
  1017be:	89 03                	mov    %eax,(%ebx)
	}
	return 0;
}
  1017c0:	31 c0                	xor    %eax,%eax
  1017c2:	5b                   	pop    %ebx
  1017c3:	5e                   	pop    %esi
  1017c4:	5d                   	pop    %ebp
  1017c5:	c3                   	ret    

001017c6 <gpio_dw_manage_callback>:

static inline int gpio_dw_manage_callback(struct device *port,
					  struct gpio_callback *callback,
					  bool set)
{
  1017c6:	55                   	push   %ebp
  1017c7:	89 e5                	mov    %esp,%ebp
  1017c9:	53                   	push   %ebx
 * @param node A pointer on the node to remove from the list
 */
static inline void sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node)
{
	sys_snode_t *prev = NULL;
  1017ca:	31 db                	xor    %ebx,%ebx
	struct gpio_dw_runtime *context = port->driver_data;
  1017cc:	8b 45 08             	mov    0x8(%ebp),%eax
}

static inline int gpio_dw_manage_callback(struct device *port,
					  struct gpio_callback *callback,
					  bool set)
{
  1017cf:	8b 55 0c             	mov    0xc(%ebp),%edx
					 bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (set) {
  1017d2:	80 7d 10 00          	cmpb   $0x0,0x10(%ebp)
	struct gpio_dw_runtime *context = port->driver_data;
  1017d6:	8b 40 08             	mov    0x8(%eax),%eax
 * @param node A pointer on the node to prepend
 */
static inline void sys_slist_prepend(sys_slist_t *list,
				     sys_snode_t *node)
{
	node->next = list->head;
  1017d9:	8b 48 18             	mov    0x18(%eax),%ecx
  1017dc:	74 18                	je     1017f6 <gpio_dw_manage_callback+0x30>
  1017de:	89 0a                	mov    %ecx,(%edx)
	list->head = node;
  1017e0:	89 50 18             	mov    %edx,0x18(%eax)

	if (!list->tail) {
  1017e3:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
  1017e7:	75 36                	jne    10181f <gpio_dw_manage_callback+0x59>
		list->tail = list->head;
  1017e9:	89 50 1c             	mov    %edx,0x1c(%eax)
  1017ec:	eb 31                	jmp    10181f <gpio_dw_manage_callback+0x59>
{
	sys_snode_t *prev = NULL;
	sys_snode_t *test;

	SYS_SLIST_FOR_EACH_NODE(list, test) {
		if (test == node) {
  1017ee:	39 ca                	cmp    %ecx,%edx
  1017f0:	74 0a                	je     1017fc <gpio_dw_manage_callback+0x36>
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node)
{
	return !node ? NULL : node->next;
  1017f2:	89 cb                	mov    %ecx,%ebx
  1017f4:	8b 09                	mov    (%ecx),%ecx
					     sys_snode_t *node)
{
	sys_snode_t *prev = NULL;
	sys_snode_t *test;

	SYS_SLIST_FOR_EACH_NODE(list, test) {
  1017f6:	85 c9                	test   %ecx,%ecx
  1017f8:	75 f4                	jne    1017ee <gpio_dw_manage_callback+0x28>
  1017fa:	eb 23                	jmp    10181f <gpio_dw_manage_callback+0x59>
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node)
{
	if (!prev_node) {
  1017fc:	85 db                	test   %ebx,%ebx
  1017fe:	8b 0a                	mov    (%edx),%ecx
  101800:	75 0d                	jne    10180f <gpio_dw_manage_callback+0x49>
		list->head = node->next;
  101802:	89 48 18             	mov    %ecx,0x18(%eax)

		/* Was node also the tail? */
		if (list->tail == node) {
  101805:	3b 50 1c             	cmp    0x1c(%eax),%edx
  101808:	75 0f                	jne    101819 <gpio_dw_manage_callback+0x53>
			list->tail = list->head;
  10180a:	89 48 1c             	mov    %ecx,0x1c(%eax)
  10180d:	eb 0a                	jmp    101819 <gpio_dw_manage_callback+0x53>
		}
	} else {
		prev_node->next = node->next;
  10180f:	89 0b                	mov    %ecx,(%ebx)

		/* Was node the tail? */
		if (list->tail == node) {
  101811:	3b 50 1c             	cmp    0x1c(%eax),%edx
  101814:	75 03                	jne    101819 <gpio_dw_manage_callback+0x53>
			list->tail = prev_node;
  101816:	89 58 1c             	mov    %ebx,0x1c(%eax)
		}
	}

	node->next = NULL;
  101819:	c7 02 00 00 00 00    	movl   $0x0,(%edx)

	_gpio_manage_callback(&context->callbacks, callback, set);

	return 0;
}
  10181f:	31 c0                	xor    %eax,%eax
  101821:	5b                   	pop    %ebx
  101822:	5d                   	pop    %ebp
  101823:	c3                   	ret    

00101824 <gpio_dw_enable_callback>:

static inline int gpio_dw_enable_callback(struct device *port, int access_op,
					  uint32_t pin)
{
  101824:	55                   	push   %ebp
  101825:	89 e5                	mov    %esp,%ebp
  101827:	8b 55 08             	mov    0x8(%ebp),%edx
  10182a:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const struct gpio_dw_config *config = port->config->config_info;
	struct gpio_dw_runtime *context = port->driver_data;
	uint32_t base_addr = dw_base_to_block_base(context->base_addr);
  10182d:	8b 42 08             	mov    0x8(%edx),%eax
  101830:	8b 00                	mov    (%eax),%eax
  101832:	83 e0 c0             	and    $0xffffffc0,%eax

	if (GPIO_ACCESS_BY_PIN == access_op) {
  101835:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  101839:	75 19                	jne    101854 <gpio_dw_enable_callback+0x30>
		dw_write(base_addr, PORTA_EOI, BIT(pin));
  10183b:	ba 01 00 00 00       	mov    $0x1,%edx
  101840:	d3 e2                	shl    %cl,%edx
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  101842:	89 50 4c             	mov    %edx,0x4c(%eax)
		dw_set_bit(base_addr, INTMASK, pin, 0);
  101845:	ba 34 00 00 00       	mov    $0x34,%edx
  10184a:	6a 00                	push   $0x0
  10184c:	e8 e5 fe ff ff       	call   101736 <dw_set_bit>
  101851:	58                   	pop    %eax
  101852:	eb 17                	jmp    10186b <gpio_dw_enable_callback+0x47>
}

static inline int gpio_dw_enable_callback(struct device *port, int access_op,
					  uint32_t pin)
{
	const struct gpio_dw_config *config = port->config->config_info;
  101854:	8b 12                	mov    (%edx),%edx

	if (GPIO_ACCESS_BY_PIN == access_op) {
		dw_write(base_addr, PORTA_EOI, BIT(pin));
		dw_set_bit(base_addr, INTMASK, pin, 0);
	} else {
		dw_write(base_addr, PORTA_EOI, BIT_MASK(config->bits));
  101856:	8b 52 08             	mov    0x8(%edx),%edx
  101859:	8b 0a                	mov    (%edx),%ecx
  10185b:	ba 01 00 00 00       	mov    $0x1,%edx
  101860:	d3 e2                	shl    %cl,%edx
  101862:	4a                   	dec    %edx
  101863:	89 50 4c             	mov    %edx,0x4c(%eax)
  101866:	31 d2                	xor    %edx,%edx
  101868:	89 50 34             	mov    %edx,0x34(%eax)
		dw_write(base_addr, INTMASK, 0);
	}

	return 0;
}
  10186b:	31 c0                	xor    %eax,%eax
  10186d:	c9                   	leave  
  10186e:	c3                   	ret    

0010186f <gpio_dw_disable_callback>:

static inline int gpio_dw_disable_callback(struct device *port, int access_op,
					   uint32_t pin)
{
  10186f:	55                   	push   %ebp
  101870:	89 e5                	mov    %esp,%ebp
  101872:	8b 55 08             	mov    0x8(%ebp),%edx
	const struct gpio_dw_config *config = port->config->config_info;
	struct gpio_dw_runtime *context = port->driver_data;
	uint32_t base_addr = dw_base_to_block_base(context->base_addr);
  101875:	8b 42 08             	mov    0x8(%edx),%eax
  101878:	8b 00                	mov    (%eax),%eax
  10187a:	83 e0 c0             	and    $0xffffffc0,%eax

	if (GPIO_ACCESS_BY_PIN == access_op) {
  10187d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  101881:	75 12                	jne    101895 <gpio_dw_disable_callback+0x26>
		dw_set_bit(base_addr, INTMASK, pin, 1);
  101883:	8b 4d 10             	mov    0x10(%ebp),%ecx
  101886:	ba 34 00 00 00       	mov    $0x34,%edx
  10188b:	6a 01                	push   $0x1
  10188d:	e8 a4 fe ff ff       	call   101736 <dw_set_bit>
  101892:	58                   	pop    %eax
  101893:	eb 12                	jmp    1018a7 <gpio_dw_disable_callback+0x38>
}

static inline int gpio_dw_disable_callback(struct device *port, int access_op,
					   uint32_t pin)
{
	const struct gpio_dw_config *config = port->config->config_info;
  101895:	8b 12                	mov    (%edx),%edx
	uint32_t base_addr = dw_base_to_block_base(context->base_addr);

	if (GPIO_ACCESS_BY_PIN == access_op) {
		dw_set_bit(base_addr, INTMASK, pin, 1);
	} else {
		dw_write(base_addr, INTMASK, BIT_MASK(config->bits));
  101897:	8b 52 08             	mov    0x8(%edx),%edx
  10189a:	8b 0a                	mov    (%edx),%ecx
  10189c:	ba 01 00 00 00       	mov    $0x1,%edx
  1018a1:	d3 e2                	shl    %cl,%edx
  1018a3:	4a                   	dec    %edx
  1018a4:	89 50 34             	mov    %edx,0x34(%eax)
	}

	return 0;
}
  1018a7:	31 c0                	xor    %eax,%eax
  1018a9:	c9                   	leave  
  1018aa:	c3                   	ret    

001018ab <gpio_dw_isr>:
#else
#define gpio_dw_unmask_int(...)
#endif

static void gpio_dw_isr(void *arg)
{
  1018ab:	55                   	push   %ebp
  1018ac:	89 e5                	mov    %esp,%ebp
  1018ae:	57                   	push   %edi
  1018af:	56                   	push   %esi
  1018b0:	53                   	push   %ebx
  1018b1:	8b 7d 08             	mov    0x8(%ebp),%edi
	struct device *port = (struct device *)arg;
	struct gpio_dw_runtime *context = port->driver_data;
  1018b4:	8b 57 08             	mov    0x8(%edi),%edx
	uint32_t base_addr = dw_base_to_block_base(context->base_addr);
  1018b7:	8b 02                	mov    (%edx),%eax
  1018b9:	83 e0 c0             	and    $0xffffffc0,%eax
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  1018bc:	8b 70 40             	mov    0x40(%eax),%esi
#ifdef CONFIG_SHARED_IRQ
	/* If using with shared IRQ, this function will be called
	 * by the shared IRQ driver. So check here if the interrupt
	 * is coming from the GPIO controller (or somewhere else).
	 */
	if (!int_status) {
  1018bf:	85 f6                	test   %esi,%esi
  1018c1:	74 1c                	je     1018df <gpio_dw_isr+0x34>
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  1018c3:	89 70 4c             	mov    %esi,0x4c(%eax)
  1018c6:	8b 5a 18             	mov    0x18(%edx),%ebx
					uint32_t pins)
{
	struct gpio_callback *cb;
	sys_snode_t *node;

	SYS_SLIST_FOR_EACH_NODE(list, node) {
  1018c9:	85 db                	test   %ebx,%ebx
  1018cb:	74 12                	je     1018df <gpio_dw_isr+0x34>
		cb = (struct gpio_callback *)node;

		if (cb->pin_mask & pins) {
  1018cd:	85 73 08             	test   %esi,0x8(%ebx)
  1018d0:	74 09                	je     1018db <gpio_dw_isr+0x30>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, pins);
  1018d2:	56                   	push   %esi
  1018d3:	53                   	push   %ebx
  1018d4:	57                   	push   %edi
  1018d5:	ff 53 04             	call   *0x4(%ebx)
  1018d8:	83 c4 0c             	add    $0xc,%esp
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node)
{
	return !node ? NULL : node->next;
  1018db:	8b 1b                	mov    (%ebx),%ebx
  1018dd:	eb ea                	jmp    1018c9 <gpio_dw_isr+0x1e>
#endif

	dw_write(base_addr, PORTA_EOI, int_status);

	_gpio_fire_callbacks(&context->callbacks, port, int_status);
}
  1018df:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1018e2:	5b                   	pop    %ebx
  1018e3:	5e                   	pop    %esi
  1018e4:	5f                   	pop    %edi
  1018e5:	5d                   	pop    %ebp
  1018e6:	c3                   	ret    

001018e7 <dw_pin_config>:
	}
}

static inline void dw_pin_config(struct device *port,
				 uint32_t pin, int flags)
{
  1018e7:	55                   	push   %ebp
  1018e8:	89 e5                	mov    %esp,%ebp
  1018ea:	57                   	push   %edi
  1018eb:	56                   	push   %esi
  1018ec:	53                   	push   %ebx
  1018ed:	83 ec 08             	sub    $0x8,%esp
  1018f0:	89 c6                	mov    %eax,%esi
	struct gpio_dw_runtime *context = port->driver_data;
	const struct gpio_dw_config *config = port->config->config_info;
	uint32_t base_addr = dw_base_to_block_base(context->base_addr);
  1018f2:	8b 40 08             	mov    0x8(%eax),%eax
	}
}

static inline void dw_pin_config(struct device *port,
				 uint32_t pin, int flags)
{
  1018f5:	89 d7                	mov    %edx,%edi
  1018f7:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	struct gpio_dw_runtime *context = port->driver_data;
	const struct gpio_dw_config *config = port->config->config_info;
	uint32_t base_addr = dw_base_to_block_base(context->base_addr);
  1018fa:	8b 00                	mov    (%eax),%eax
  1018fc:	89 45 ec             	mov    %eax,-0x14(%ebp)

static inline void dw_pin_config(struct device *port,
				 uint32_t pin, int flags)
{
	struct gpio_dw_runtime *context = port->driver_data;
	const struct gpio_dw_config *config = port->config->config_info;
  1018ff:	8b 06                	mov    (%esi),%eax
  101901:	8b 40 08             	mov    0x8(%eax),%eax
	uint32_t port = (base_addr & 0x3f) / 12;
	return port;
}
static inline int dw_interrupt_support(const struct gpio_dw_config *config)
{
	return ((int)(config->irq_num) > 0);
  101904:	8b 58 04             	mov    0x4(%eax),%ebx
	const struct gpio_dw_config *config = port->config->config_info;
	uint32_t base_addr = dw_base_to_block_base(context->base_addr);
	uint32_t port_base_addr = context->base_addr;
	int interrupt_support = dw_interrupt_support(config);

	if (interrupt_support) {
  101907:	85 db                	test   %ebx,%ebx
  101909:	7e 15                	jle    101920 <dw_pin_config+0x39>
		/* clear interrupt enable */
		dw_set_bit(base_addr, INTEN, pin, 0);
  10190b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10190e:	89 d1                	mov    %edx,%ecx
  101910:	83 e0 c0             	and    $0xffffffc0,%eax
  101913:	ba 30 00 00 00       	mov    $0x30,%edx
  101918:	6a 00                	push   $0x0
  10191a:	e8 17 fe ff ff       	call   101736 <dw_set_bit>
  10191f:	58                   	pop    %eax
	}

	/* set direction */
	dw_set_bit(port_base_addr, SWPORTA_DDR, pin, (flags & GPIO_DIR_MASK));
  101920:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101923:	89 f9                	mov    %edi,%ecx
  101925:	83 e0 01             	and    $0x1,%eax
  101928:	ba 04 00 00 00       	mov    $0x4,%edx
  10192d:	50                   	push   %eax
  10192e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101931:	e8 00 fe ff ff       	call   101736 <dw_set_bit>
  101936:	58                   	pop    %eax

	if (interrupt_support && (flags & GPIO_INT)) {
  101937:	85 db                	test   %ebx,%ebx
  101939:	0f 8e c0 00 00 00    	jle    1019ff <dw_pin_config+0x118>
  10193f:	f6 45 f0 02          	testb  $0x2,-0x10(%ebp)
  101943:	0f 84 b6 00 00 00    	je     1019ff <dw_pin_config+0x118>

static inline void dw_interrupt_config(struct device *port, int access_op,
				       uint32_t pin, int flags)
{
	struct gpio_dw_runtime *context = port->driver_data;
	const struct gpio_dw_config *config = port->config->config_info;
  101949:	8b 06                	mov    (%esi),%eax
	uint32_t base_addr = dw_base_to_block_base(context->base_addr);
	uint8_t flag_is_set;

	/* set as an input pin */
	dw_set_bit(context->base_addr, SWPORTA_DDR, pin, 0);
  10194b:	89 f9                	mov    %edi,%ecx
  10194d:	ba 04 00 00 00       	mov    $0x4,%edx

static inline void dw_interrupt_config(struct device *port, int access_op,
				       uint32_t pin, int flags)
{
	struct gpio_dw_runtime *context = port->driver_data;
	const struct gpio_dw_config *config = port->config->config_info;
  101952:	8b 58 08             	mov    0x8(%eax),%ebx
	uint32_t base_addr = dw_base_to_block_base(context->base_addr);
  101955:	8b 46 08             	mov    0x8(%esi),%eax
  101958:	8b 30                	mov    (%eax),%esi
	uint8_t flag_is_set;

	/* set as an input pin */
	dw_set_bit(context->base_addr, SWPORTA_DDR, pin, 0);
  10195a:	6a 00                	push   $0x0
  10195c:	89 f0                	mov    %esi,%eax
  10195e:	e8 d3 fd ff ff       	call   101736 <dw_set_bit>
  101963:	58                   	pop    %eax

	if (dw_interrupt_support(config)) {
  101964:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  101968:	0f 8e 91 00 00 00    	jle    1019ff <dw_pin_config+0x118>

		/* level or edge */
		flag_is_set = (flags & GPIO_INT_EDGE);
		dw_set_bit(base_addr, INTTYPE_LEVEL, pin, flag_is_set);
  10196e:	8a 45 f0             	mov    -0x10(%ebp),%al
static inline void dw_interrupt_config(struct device *port, int access_op,
				       uint32_t pin, int flags)
{
	struct gpio_dw_runtime *context = port->driver_data;
	const struct gpio_dw_config *config = port->config->config_info;
	uint32_t base_addr = dw_base_to_block_base(context->base_addr);
  101971:	83 e6 c0             	and    $0xffffffc0,%esi

	if (dw_interrupt_support(config)) {

		/* level or edge */
		flag_is_set = (flags & GPIO_INT_EDGE);
		dw_set_bit(base_addr, INTTYPE_LEVEL, pin, flag_is_set);
  101974:	83 e0 20             	and    $0x20,%eax
  101977:	89 f9                	mov    %edi,%ecx
  101979:	0f b6 c0             	movzbl %al,%eax
  10197c:	50                   	push   %eax
  10197d:	ba 38 00 00 00       	mov    $0x38,%edx
  101982:	89 f0                	mov    %esi,%eax
  101984:	e8 ad fd ff ff       	call   101736 <dw_set_bit>

		/* Active low/high */
		flag_is_set = (flags & GPIO_INT_ACTIVE_HIGH);
		dw_set_bit(base_addr, INT_POLARITY, pin, flag_is_set);
  101989:	8a 45 f0             	mov    -0x10(%ebp),%al
  10198c:	83 e0 04             	and    $0x4,%eax
  10198f:	89 f9                	mov    %edi,%ecx
  101991:	0f b6 c0             	movzbl %al,%eax
  101994:	89 04 24             	mov    %eax,(%esp)
  101997:	ba 3c 00 00 00       	mov    $0x3c,%edx
  10199c:	89 f0                	mov    %esi,%eax
  10199e:	e8 93 fd ff ff       	call   101736 <dw_set_bit>

		/* both edges */
		flag_is_set = (flags & GPIO_INT_DOUBLE_EDGE);
		if (flag_is_set) {
  1019a3:	8a 5d f0             	mov    -0x10(%ebp),%bl
  1019a6:	80 e3 40             	and    $0x40,%bl
		flag_is_set = (flags & GPIO_INT_EDGE);
		dw_set_bit(base_addr, INTTYPE_LEVEL, pin, flag_is_set);

		/* Active low/high */
		flag_is_set = (flags & GPIO_INT_ACTIVE_HIGH);
		dw_set_bit(base_addr, INT_POLARITY, pin, flag_is_set);
  1019a9:	59                   	pop    %ecx

		/* both edges */
		flag_is_set = (flags & GPIO_INT_DOUBLE_EDGE);
		if (flag_is_set) {
  1019aa:	74 25                	je     1019d1 <dw_pin_config+0xea>
	return 1;
}
#else
static inline void dw_set_both_edges(uint32_t base_addr, uint32_t pin)
{
	dw_set_bit(base_addr, INT_BOTHEDGE, pin, 1);
  1019ac:	89 f9                	mov    %edi,%ecx
  1019ae:	ba 68 00 00 00       	mov    $0x68,%edx
  1019b3:	89 f0                	mov    %esi,%eax
  1019b5:	6a 01                	push   $0x1

		/* both edges */
		flag_is_set = (flags & GPIO_INT_DOUBLE_EDGE);
		if (flag_is_set) {
			dw_set_both_edges(base_addr, pin);
			dw_set_bit(base_addr, INTTYPE_LEVEL, pin, flag_is_set);
  1019b7:	0f b6 db             	movzbl %bl,%ebx
	return 1;
}
#else
static inline void dw_set_both_edges(uint32_t base_addr, uint32_t pin)
{
	dw_set_bit(base_addr, INT_BOTHEDGE, pin, 1);
  1019ba:	e8 77 fd ff ff       	call   101736 <dw_set_bit>

		/* both edges */
		flag_is_set = (flags & GPIO_INT_DOUBLE_EDGE);
		if (flag_is_set) {
			dw_set_both_edges(base_addr, pin);
			dw_set_bit(base_addr, INTTYPE_LEVEL, pin, flag_is_set);
  1019bf:	ba 38 00 00 00       	mov    $0x38,%edx
  1019c4:	89 f9                	mov    %edi,%ecx
  1019c6:	89 f0                	mov    %esi,%eax
  1019c8:	89 1c 24             	mov    %ebx,(%esp)
  1019cb:	e8 66 fd ff ff       	call   101736 <dw_set_bit>
  1019d0:	5a                   	pop    %edx
		}

		/* use built-in debounce  */
		flag_is_set = (flags & GPIO_INT_DEBOUNCE);
		dw_set_bit(base_addr, PORTA_DEBOUNCE, pin, flag_is_set);
  1019d1:	8a 45 f0             	mov    -0x10(%ebp),%al
  1019d4:	89 f9                	mov    %edi,%ecx
  1019d6:	83 e0 10             	and    $0x10,%eax
  1019d9:	ba 48 00 00 00       	mov    $0x48,%edx
  1019de:	0f b6 c0             	movzbl %al,%eax
  1019e1:	50                   	push   %eax
  1019e2:	89 f0                	mov    %esi,%eax
  1019e4:	e8 4d fd ff ff       	call   101736 <dw_set_bit>

		/* Finally enabling interrupt */
		dw_set_bit(base_addr, INTEN, pin, 1);
  1019e9:	89 f0                	mov    %esi,%eax
  1019eb:	89 f9                	mov    %edi,%ecx
  1019ed:	ba 30 00 00 00       	mov    $0x30,%edx
  1019f2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1019f9:	e8 38 fd ff ff       	call   101736 <dw_set_bit>
  1019fe:	58                   	pop    %eax
	dw_set_bit(port_base_addr, SWPORTA_DDR, pin, (flags & GPIO_DIR_MASK));

	if (interrupt_support && (flags & GPIO_INT)) {
		dw_interrupt_config(port, GPIO_ACCESS_BY_PIN, pin, flags);
	}
}
  1019ff:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101a02:	5b                   	pop    %ebx
  101a03:	5e                   	pop    %esi
  101a04:	5f                   	pop    %edi
  101a05:	5d                   	pop    %ebp
  101a06:	c3                   	ret    

00101a07 <gpio_dw_config>:
	}
}

static inline int gpio_dw_config(struct device *port, int access_op,
				 uint32_t pin, int flags)
{
  101a07:	55                   	push   %ebp
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
		return -1;
  101a08:	83 c8 ff             	or     $0xffffffff,%eax
	}
}

static inline int gpio_dw_config(struct device *port, int access_op,
				 uint32_t pin, int flags)
{
  101a0b:	89 e5                	mov    %esp,%ebp
  101a0d:	57                   	push   %edi
  101a0e:	56                   	push   %esi
  101a0f:	53                   	push   %ebx
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
  101a10:	8b 55 14             	mov    0x14(%ebp),%edx
	}
}

static inline int gpio_dw_config(struct device *port, int access_op,
				 uint32_t pin, int flags)
{
  101a13:	8b 75 08             	mov    0x8(%ebp),%esi
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
  101a16:	83 e2 03             	and    $0x3,%edx
  101a19:	83 fa 03             	cmp    $0x3,%edx
  101a1c:	74 31                	je     101a4f <gpio_dw_config+0x48>
		return -1;
	}

	if (GPIO_ACCESS_BY_PIN == access_op) {
  101a1e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  101a22:	75 0f                	jne    101a33 <gpio_dw_config+0x2c>
		dw_pin_config(port, pin, flags);
  101a24:	8b 4d 14             	mov    0x14(%ebp),%ecx
  101a27:	8b 55 10             	mov    0x10(%ebp),%edx
  101a2a:	89 f0                	mov    %esi,%eax
  101a2c:	e8 b6 fe ff ff       	call   1018e7 <dw_pin_config>
  101a31:	eb 1a                	jmp    101a4d <gpio_dw_config+0x46>
	}
}

static inline void dw_port_config(struct device *port, int flags)
{
	const struct gpio_dw_config *config = port->config->config_info;
  101a33:	8b 06                	mov    (%esi),%eax
	int i;

	for (i = 0; i < config->bits; i++) {
  101a35:	31 db                	xor    %ebx,%ebx
	}
}

static inline void dw_port_config(struct device *port, int flags)
{
	const struct gpio_dw_config *config = port->config->config_info;
  101a37:	8b 78 08             	mov    0x8(%eax),%edi
	int i;

	for (i = 0; i < config->bits; i++) {
  101a3a:	3b 1f                	cmp    (%edi),%ebx
  101a3c:	73 0f                	jae    101a4d <gpio_dw_config+0x46>
		dw_pin_config(port, i, flags);
  101a3e:	89 da                	mov    %ebx,%edx
  101a40:	8b 4d 14             	mov    0x14(%ebp),%ecx
  101a43:	89 f0                	mov    %esi,%eax
static inline void dw_port_config(struct device *port, int flags)
{
	const struct gpio_dw_config *config = port->config->config_info;
	int i;

	for (i = 0; i < config->bits; i++) {
  101a45:	43                   	inc    %ebx
		dw_pin_config(port, i, flags);
  101a46:	e8 9c fe ff ff       	call   1018e7 <dw_pin_config>
  101a4b:	eb ed                	jmp    101a3a <gpio_dw_config+0x33>
	if (GPIO_ACCESS_BY_PIN == access_op) {
		dw_pin_config(port, pin, flags);
	} else {
		dw_port_config(port, flags);
	}
	return 0;
  101a4d:	31 c0                	xor    %eax,%eax
}
  101a4f:	5b                   	pop    %ebx
  101a50:	5e                   	pop    %esi
  101a51:	5f                   	pop    %edi
  101a52:	5d                   	pop    %ebp
  101a53:	c3                   	ret    

00101a54 <gpio_dw_initialize>:
#define gpio_dw_setup(_unused_) (1)
#endif /* CONFIG_PCI */


static int gpio_dw_initialize(struct device *port)
{
  101a54:	55                   	push   %ebp
  101a55:	89 e5                	mov    %esp,%ebp
  101a57:	57                   	push   %edi
  101a58:	56                   	push   %esi
  101a59:	53                   	push   %ebx
  101a5a:	51                   	push   %ecx
  101a5b:	8b 75 08             	mov    0x8(%ebp),%esi
	struct gpio_dw_runtime *context = port->driver_data;
	const struct gpio_dw_config *config = port->config->config_info;
  101a5e:	8b 06                	mov    (%esi),%eax
#endif /* CONFIG_PCI */


static int gpio_dw_initialize(struct device *port)
{
	struct gpio_dw_runtime *context = port->driver_data;
  101a60:	8b 5e 08             	mov    0x8(%esi),%ebx
	const struct gpio_dw_config *config = port->config->config_info;
  101a63:	8b 78 08             	mov    0x8(%eax),%edi
#ifdef CONFIG_PCI
static inline int gpio_dw_setup(struct device *dev)
{
	struct gpio_dw_runtime *context = dev->driver_data;

	pci_bus_scan_init();
  101a66:	e8 3a ef ff ff       	call   1009a5 <pci_bus_scan_init>

	if (!pci_bus_scan(&context->pci_dev)) {
  101a6b:	8d 53 04             	lea    0x4(%ebx),%edx
  101a6e:	52                   	push   %edx
  101a6f:	89 55 f0             	mov    %edx,-0x10(%ebp)
  101a72:	e8 9c ef ff ff       	call   100a13 <pci_bus_scan>
  101a77:	5a                   	pop    %edx
  101a78:	85 c0                	test   %eax,%eax
  101a7a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  101a7d:	74 42                	je     101ac1 <gpio_dw_initialize+0x6d>
		return 0;
	}

#ifdef CONFIG_PCI_ENUMERATION
	context->base_addr = context->pci_dev.addr;
  101a7f:	8b 43 04             	mov    0x4(%ebx),%eax
  101a82:	89 03                	mov    %eax,(%ebx)
#endif
	pci_enable_regs(&context->pci_dev);
  101a84:	52                   	push   %edx
  101a85:	e8 5a f5 ff ff       	call   100fe4 <pci_enable_regs>
		config->config_func(port);
	}

	gpio_dw_set_power_state(port, DEVICE_PM_ACTIVE_STATE);

	return 0;
  101a8a:	31 c0                	xor    %eax,%eax
	}

#ifdef CONFIG_PCI_ENUMERATION
	context->base_addr = context->pci_dev.addr;
#endif
	pci_enable_regs(&context->pci_dev);
  101a8c:	5a                   	pop    %edx
	if (!gpio_dw_setup(port)) {
		port->driver_api = NULL;
		return -EPERM;
	}

	if (dw_interrupt_support(config)) {
  101a8d:	83 7f 04 00          	cmpl   $0x0,0x4(%edi)
  101a91:	7e 38                	jle    101acb <gpio_dw_initialize+0x77>

		base_addr = dw_base_to_block_base(context->base_addr);
  101a93:	8b 1b                	mov    (%ebx),%ebx
		/* Need to enable clock for GPIO controller */
		dw_set_bit(base_addr, INT_CLOCK_SYNC, CLK_ENA_POS, 1);
#endif /* CONFIG_SOC_QUARK_SE_C1000_SS */

		/* interrupts in sync with system clock */
		dw_set_bit(base_addr, INT_CLOCK_SYNC, LS_SYNC_POS, 1);
  101a95:	31 c9                	xor    %ecx,%ecx
		return -EPERM;
	}

	if (dw_interrupt_support(config)) {

		base_addr = dw_base_to_block_base(context->base_addr);
  101a97:	83 e3 c0             	and    $0xffffffc0,%ebx
		/* Need to enable clock for GPIO controller */
		dw_set_bit(base_addr, INT_CLOCK_SYNC, CLK_ENA_POS, 1);
#endif /* CONFIG_SOC_QUARK_SE_C1000_SS */

		/* interrupts in sync with system clock */
		dw_set_bit(base_addr, INT_CLOCK_SYNC, LS_SYNC_POS, 1);
  101a9a:	ba 60 00 00 00       	mov    $0x60,%edx
  101a9f:	89 d8                	mov    %ebx,%eax
  101aa1:	6a 01                	push   $0x1
  101aa3:	e8 8e fc ff ff       	call   101736 <dw_set_bit>
  101aa8:	83 c8 ff             	or     $0xffffffff,%eax
  101aab:	89 43 34             	mov    %eax,0x34(%ebx)
  101aae:	31 d2                	xor    %edx,%edx
  101ab0:	89 53 30             	mov    %edx,0x30(%ebx)
  101ab3:	89 43 4c             	mov    %eax,0x4c(%ebx)
		/* mask and disable interrupts */
		dw_write(base_addr, INTMASK, ~(0));
		dw_write(base_addr, INTEN, 0);
		dw_write(base_addr, PORTA_EOI, ~(0));

		config->config_func(port);
  101ab6:	89 34 24             	mov    %esi,(%esp)
  101ab9:	ff 57 08             	call   *0x8(%edi)
  101abc:	58                   	pop    %eax
	}

	gpio_dw_set_power_state(port, DEVICE_PM_ACTIVE_STATE);

	return 0;
  101abd:	31 c0                	xor    %eax,%eax
  101abf:	eb 0a                	jmp    101acb <gpio_dw_initialize+0x77>
	struct gpio_dw_runtime *context = port->driver_data;
	const struct gpio_dw_config *config = port->config->config_info;
	uint32_t base_addr;

	if (!gpio_dw_setup(port)) {
		port->driver_api = NULL;
  101ac1:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
		return -EPERM;
  101ac8:	83 c8 ff             	or     $0xffffffff,%eax
	}

	gpio_dw_set_power_state(port, DEVICE_PM_ACTIVE_STATE);

	return 0;
}
  101acb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101ace:	5b                   	pop    %ebx
  101acf:	5e                   	pop    %esi
  101ad0:	5f                   	pop    %edi
  101ad1:	5d                   	pop    %ebp
  101ad2:	c3                   	ret    

00101ad3 <gpio_config_0_irq>:
		    POST_KERNEL, CONFIG_GPIO_DW_INIT_PRIORITY,
		    &api_funcs);
#endif

static void gpio_config_0_irq(struct device *port)
{
  101ad3:	55                   	push   %ebp
  101ad4:	89 e5                	mov    %esp,%ebp
  101ad6:	56                   	push   %esi
  101ad7:	53                   	push   %ebx
  101ad8:	8b 75 08             	mov    0x8(%ebp),%esi
#if (GPIO_DW_0_IRQ > 0)
	const struct gpio_dw_config *config = port->config->config_info;
  101adb:	8b 06                	mov    (%esi),%eax
		    DEVICE_GET(gpio_dw_0), GPIO_DW_0_IRQ_FLAGS);
	irq_enable(config->irq_num);
#elif defined(CONFIG_GPIO_DW_0_IRQ_SHARED)
	struct device *shared_irq_dev;

	shared_irq_dev = device_get_binding(config->shared_irq_dev_name);
  101add:	8b 40 08             	mov    0x8(%eax),%eax
  101ae0:	ff 70 0c             	pushl  0xc(%eax)
  101ae3:	e8 04 1c 00 00       	call   1036ec <device_get_binding>
  101ae8:	89 c3                	mov    %eax,%ebx
static inline int shared_irq_isr_register(struct device *dev, isr_t isr_func,
				 struct device *isr_dev)
{
	const struct shared_irq_driver_api *api = dev->driver_api;

	return api->isr_register(dev, isr_func, isr_dev);
  101aea:	8b 40 04             	mov    0x4(%eax),%eax
  101aed:	89 34 24             	mov    %esi,(%esp)
  101af0:	68 ab 18 10 00       	push   $0x1018ab
  101af5:	53                   	push   %ebx
  101af6:	ff 10                	call   *(%eax)
  101af8:	83 c4 0c             	add    $0xc,%esp
 */
static inline int shared_irq_enable(struct device *dev, struct device *isr_dev)
{
	const struct shared_irq_driver_api *api = dev->driver_api;

	return api->enable(dev, isr_dev);
  101afb:	8b 43 04             	mov    0x4(%ebx),%eax
  101afe:	56                   	push   %esi
  101aff:	53                   	push   %ebx
  101b00:	ff 50 04             	call   *0x4(%eax)
  101b03:	58                   	pop    %eax
  101b04:	5a                   	pop    %edx
	shared_irq_isr_register(shared_irq_dev, (isr_t)gpio_dw_isr, port);
	shared_irq_enable(shared_irq_dev, port);
#endif
	gpio_dw_unmask_int(GPIO_DW_PORT_0_INT_MASK);
#endif
}
  101b05:	8d 65 f8             	lea    -0x8(%ebp),%esp
  101b08:	5b                   	pop    %ebx
  101b09:	5e                   	pop    %esi
  101b0a:	5d                   	pop    %ebp
  101b0b:	c3                   	ret    

00101b0c <gpio_pcal9535a_manage_callback>:
}

static int gpio_pcal9535a_manage_callback(struct device *dev,
					  struct gpio_callback *callback,
					  bool set)
{
  101b0c:	55                   	push   %ebp
	ARG_UNUSED(dev);
	ARG_UNUSED(callback);
	ARG_UNUSED(set);

	return -ENOTSUP;
}
  101b0d:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
}

static int gpio_pcal9535a_manage_callback(struct device *dev,
					  struct gpio_callback *callback,
					  bool set)
{
  101b12:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(dev);
	ARG_UNUSED(callback);
	ARG_UNUSED(set);

	return -ENOTSUP;
}
  101b14:	5d                   	pop    %ebp
  101b15:	c3                   	ret    

00101b16 <gpio_pcal9535a_disable_callback>:
	return -ENOTSUP;
}

static int gpio_pcal9535a_disable_callback(struct device *dev,
					   int access_op, uint32_t pin)
{
  101b16:	55                   	push   %ebp
	ARG_UNUSED(dev);
	ARG_UNUSED(access_op);
	ARG_UNUSED(pin);

	return -ENOTSUP;
}
  101b17:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
	return -ENOTSUP;
}

static int gpio_pcal9535a_disable_callback(struct device *dev,
					   int access_op, uint32_t pin)
{
  101b1c:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(dev);
	ARG_UNUSED(access_op);
	ARG_UNUSED(pin);

	return -ENOTSUP;
}
  101b1e:	5d                   	pop    %ebp
  101b1f:	c3                   	ret    

00101b20 <gpio_pcal9535a_read>:
 *
 * @return 0 if successful, failed otherwise
 */
static int gpio_pcal9535a_read(struct device *dev, int access_op,
			       uint32_t pin, uint32_t *value)
{
  101b20:	55                   	push   %ebp
  101b21:	89 e5                	mov    %esp,%ebp
  101b23:	57                   	push   %edi
  101b24:	56                   	push   %esi
  101b25:	53                   	push   %ebx
  101b26:	83 ec 1c             	sub    $0x1c,%esp
  101b29:	8b 55 08             	mov    0x8(%ebp),%edx
  101b2c:	8b 75 0c             	mov    0xc(%ebp),%esi
  101b2f:	8b 5d 14             	mov    0x14(%ebp),%ebx
 */
static inline int _has_i2c_master(struct device *dev)
{
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	struct device * const i2c_master = drv_data->i2c_master;
  101b32:	8b 42 08             	mov    0x8(%edx),%eax
  101b35:	8b 00                	mov    (%eax),%eax

	if (i2c_master)
  101b37:	85 c0                	test   %eax,%eax
  101b39:	75 07                	jne    101b42 <gpio_pcal9535a_read+0x22>
{
	union gpio_pcal9535a_port_data buf;
	int ret;

	if (!_has_i2c_master(dev)) {
		return -EINVAL;
  101b3b:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  101b40:	eb 66                	jmp    101ba8 <gpio_pcal9535a_read+0x88>
 * @return 0 if successful, failed otherwise.
 */
static int _read_port_regs(struct device *dev, uint8_t reg,
			   union gpio_pcal9535a_port_data *buf)
{
	const struct gpio_pcal9535a_config * const config =
  101b42:	8b 12                	mov    (%edx),%edx
				 uint8_t num_bytes)
{
	const struct i2c_driver_api *api = dev->driver_api;
	struct i2c_msg msg[2];

	msg[0].buf = &start_addr;
  101b44:	8d 7d d9             	lea    -0x27(%ebp),%edi
 */
static inline int i2c_burst_read(struct device *dev, uint16_t dev_addr,
				 uint8_t start_addr, uint8_t *buf,
				 uint8_t num_bytes)
{
	const struct i2c_driver_api *api = dev->driver_api;
  101b47:	8b 48 04             	mov    0x4(%eax),%ecx
	struct i2c_msg msg[2];

	msg[0].buf = &start_addr;
  101b4a:	89 7d dc             	mov    %edi,-0x24(%ebp)
		dev->config->config_info;
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	struct device * const i2c_master = drv_data->i2c_master;
	uint16_t i2c_addr = config->i2c_slave_addr;
  101b4d:	8b 52 08             	mov    0x8(%edx),%edx
	msg[0].len = 1;
	msg[0].flags = I2C_MSG_WRITE;

	msg[1].buf = buf;
  101b50:	8d 7d da             	lea    -0x26(%ebp),%edi
  101b53:	c6 45 d9 00          	movb   $0x0,-0x27(%ebp)
  101b57:	0f b7 52 04          	movzwl 0x4(%edx),%edx
{
	const struct i2c_driver_api *api = dev->driver_api;
	struct i2c_msg msg[2];

	msg[0].buf = &start_addr;
	msg[0].len = 1;
  101b5b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	msg[1].buf = buf;
	msg[1].len = num_bytes;
	msg[1].flags = I2C_MSG_RESTART | I2C_MSG_READ | I2C_MSG_STOP;

	return api->transfer(dev, msg, 2, dev_addr);
  101b62:	52                   	push   %edx
	const struct i2c_driver_api *api = dev->driver_api;
	struct i2c_msg msg[2];

	msg[0].buf = &start_addr;
	msg[0].len = 1;
	msg[0].flags = I2C_MSG_WRITE;
  101b63:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)

	msg[1].buf = buf;
	msg[1].len = num_bytes;
	msg[1].flags = I2C_MSG_RESTART | I2C_MSG_READ | I2C_MSG_STOP;

	return api->transfer(dev, msg, 2, dev_addr);
  101b67:	8d 55 dc             	lea    -0x24(%ebp),%edx

	msg[0].buf = &start_addr;
	msg[0].len = 1;
	msg[0].flags = I2C_MSG_WRITE;

	msg[1].buf = buf;
  101b6a:	89 7d e8             	mov    %edi,-0x18(%ebp)
	msg[1].len = num_bytes;
  101b6d:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)
	msg[1].flags = I2C_MSG_RESTART | I2C_MSG_READ | I2C_MSG_STOP;
  101b74:	c6 45 f0 07          	movb   $0x7,-0x10(%ebp)

	return api->transfer(dev, msg, 2, dev_addr);
  101b78:	6a 02                	push   $0x2
  101b7a:	52                   	push   %edx
  101b7b:	50                   	push   %eax
  101b7c:	ff 51 04             	call   *0x4(%ecx)
  101b7f:	83 c4 10             	add    $0x10,%esp
	if (!_has_i2c_master(dev)) {
		return -EINVAL;
	}

	ret = _read_port_regs(dev, REG_INPUT_PORT0, &buf);
	if (ret != 0) {
  101b82:	85 c0                	test   %eax,%eax
  101b84:	75 22                	jne    101ba8 <gpio_pcal9535a_read+0x88>
		goto done;
	}

	switch (access_op) {
  101b86:	85 f6                	test   %esi,%esi
  101b88:	74 09                	je     101b93 <gpio_pcal9535a_read+0x73>
  101b8a:	4e                   	dec    %esi
  101b8b:	75 16                	jne    101ba3 <gpio_pcal9535a_read+0x83>
	case GPIO_ACCESS_BY_PIN:
		*value = (buf.all >> pin) & 0x01;
		break;
	case GPIO_ACCESS_BY_PORT:
		*value = buf.all;
  101b8d:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
  101b91:	eb 0c                	jmp    101b9f <gpio_pcal9535a_read+0x7f>
		goto done;
	}

	switch (access_op) {
	case GPIO_ACCESS_BY_PIN:
		*value = (buf.all >> pin) & 0x01;
  101b93:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
  101b97:	8b 4d 10             	mov    0x10(%ebp),%ecx
  101b9a:	d3 fa                	sar    %cl,%edx
  101b9c:	83 e2 01             	and    $0x1,%edx
		break;
	case GPIO_ACCESS_BY_PORT:
		*value = buf.all;
  101b9f:	89 13                	mov    %edx,(%ebx)
		break;
  101ba1:	eb 05                	jmp    101ba8 <gpio_pcal9535a_read+0x88>
	default:
		ret = -ENOTSUP;
  101ba3:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
		break;
	}

done:
	return ret;
}
  101ba8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101bab:	5b                   	pop    %ebx
  101bac:	5e                   	pop    %esi
  101bad:	5f                   	pop    %edi
  101bae:	5d                   	pop    %ebp
  101baf:	c3                   	ret    

00101bb0 <gpio_pcal9535a_init>:
 *
 * @param dev Device struct
 * @return 0 if successful, failed otherwise.
 */
static int gpio_pcal9535a_init(struct device *dev)
{
  101bb0:	55                   	push   %ebp
  101bb1:	89 e5                	mov    %esp,%ebp
  101bb3:	56                   	push   %esi
  101bb4:	53                   	push   %ebx
  101bb5:	8b 5d 08             	mov    0x8(%ebp),%ebx
	const struct gpio_pcal9535a_config * const config =
  101bb8:	8b 03                	mov    (%ebx),%eax
		dev->config->config_info;
	struct gpio_pcal9535a_drv_data * const drv_data =
  101bba:	8b 73 08             	mov    0x8(%ebx),%esi
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	struct device *i2c_master;

	/* Find out the device struct of the I2C master */
	i2c_master = device_get_binding((char *)config->i2c_master_dev_name);
  101bbd:	8b 40 08             	mov    0x8(%eax),%eax
  101bc0:	ff 30                	pushl  (%eax)
  101bc2:	e8 25 1b 00 00       	call   1036ec <device_get_binding>
  101bc7:	5a                   	pop    %edx
	if (!i2c_master) {
  101bc8:	85 c0                	test   %eax,%eax
  101bca:	ba ea ff ff ff       	mov    $0xffffffea,%edx
  101bcf:	74 22                	je     101bf3 <gpio_pcal9535a_init+0x43>
		return -EINVAL;
	}
	drv_data->i2c_master = i2c_master;
  101bd1:	89 06                	mov    %eax,(%esi)

	nano_timer_init(&drv_data->timer, (void *) 0);
  101bd3:	8d 46 08             	lea    0x8(%esi),%eax
 * @return N/A
 */
static inline __deprecated void
nano_timer_init(struct k_timer *timer, void *data)
{
	k_timer_init(timer, NULL, NULL);
  101bd6:	6a 00                	push   $0x0
  101bd8:	6a 00                	push   $0x0
  101bda:	50                   	push   %eax
  101bdb:	e8 a2 28 00 00       	call   104482 <k_timer_init>
	timer->_legacy_data = data;
  101be0:	c7 46 38 00 00 00 00 	movl   $0x0,0x38(%esi)
 * @return N/A
 */
static inline __deprecated void
nano_timer_init(struct k_timer *timer, void *data)
{
	k_timer_init(timer, NULL, NULL);
  101be7:	83 c4 0c             	add    $0xc,%esp

	dev->driver_api = &gpio_pcal9535a_drv_api_funcs;
  101bea:	c7 43 04 88 48 10 00 	movl   $0x104888,0x4(%ebx)

	return 0;
  101bf1:	31 d2                	xor    %edx,%edx
}
  101bf3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  101bf6:	89 d0                	mov    %edx,%eax
  101bf8:	5b                   	pop    %ebx
  101bf9:	5e                   	pop    %esi
  101bfa:	5d                   	pop    %ebp
  101bfb:	c3                   	ret    

00101bfc <_write_port_regs>:
 *
 * @return 0 if successful, failed otherwise.
 */
static int _write_port_regs(struct device *dev, uint8_t reg,
			    union gpio_pcal9535a_port_data *buf)
{
  101bfc:	55                   	push   %ebp
  101bfd:	89 e5                	mov    %esp,%ebp
  101bff:	56                   	push   %esi
  101c00:	53                   	push   %ebx
  101c01:	83 ec 1c             	sub    $0x1c,%esp
				  uint8_t num_bytes)
{
	const struct i2c_driver_api *api = dev->driver_api;
	struct i2c_msg msg[2];

	msg[0].buf = &start_addr;
  101c04:	8d 75 df             	lea    -0x21(%ebp),%esi
	const struct gpio_pcal9535a_config * const config =
		dev->config->config_info;
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	struct device * const i2c_master = drv_data->i2c_master;
  101c07:	8b 58 08             	mov    0x8(%eax),%ebx
 * @return 0 if successful, failed otherwise.
 */
static int _write_port_regs(struct device *dev, uint8_t reg,
			    union gpio_pcal9535a_port_data *buf)
{
	const struct gpio_pcal9535a_config * const config =
  101c0a:	8b 00                	mov    (%eax),%eax
		dev->config->config_info;
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	struct device * const i2c_master = drv_data->i2c_master;
	uint16_t i2c_addr = config->i2c_slave_addr;
  101c0c:	8b 40 08             	mov    0x8(%eax),%eax
{
	const struct gpio_pcal9535a_config * const config =
		dev->config->config_info;
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	struct device * const i2c_master = drv_data->i2c_master;
  101c0f:	8b 1b                	mov    (%ebx),%ebx
  101c11:	88 55 df             	mov    %dl,-0x21(%ebp)
  101c14:	89 75 e0             	mov    %esi,-0x20(%ebp)
	uint16_t i2c_addr = config->i2c_slave_addr;
  101c17:	0f b7 40 04          	movzwl 0x4(%eax),%eax
 */
static inline int i2c_burst_write(struct device *dev, uint16_t dev_addr,
				  uint8_t start_addr, uint8_t *buf,
				  uint8_t num_bytes)
{
	const struct i2c_driver_api *api = dev->driver_api;
  101c1b:	8b 53 04             	mov    0x4(%ebx),%edx

	msg[1].buf = buf;
	msg[1].len = num_bytes;
	msg[1].flags = I2C_MSG_WRITE | I2C_MSG_STOP;

	return api->transfer(dev, msg, 2, dev_addr);
  101c1e:	50                   	push   %eax
  101c1f:	8d 45 e0             	lea    -0x20(%ebp),%eax
  101c22:	6a 02                	push   $0x2
{
	const struct i2c_driver_api *api = dev->driver_api;
	struct i2c_msg msg[2];

	msg[0].buf = &start_addr;
	msg[0].len = 1;
  101c24:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

	msg[1].buf = buf;
	msg[1].len = num_bytes;
	msg[1].flags = I2C_MSG_WRITE | I2C_MSG_STOP;

	return api->transfer(dev, msg, 2, dev_addr);
  101c2b:	50                   	push   %eax
	const struct i2c_driver_api *api = dev->driver_api;
	struct i2c_msg msg[2];

	msg[0].buf = &start_addr;
	msg[0].len = 1;
	msg[0].flags = I2C_MSG_WRITE;
  101c2c:	c6 45 e8 00          	movb   $0x0,-0x18(%ebp)

	msg[1].buf = buf;
	msg[1].len = num_bytes;
	msg[1].flags = I2C_MSG_WRITE | I2C_MSG_STOP;

	return api->transfer(dev, msg, 2, dev_addr);
  101c30:	53                   	push   %ebx

	msg[0].buf = &start_addr;
	msg[0].len = 1;
	msg[0].flags = I2C_MSG_WRITE;

	msg[1].buf = buf;
  101c31:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	msg[1].len = num_bytes;
  101c34:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
	msg[1].flags = I2C_MSG_WRITE | I2C_MSG_STOP;
  101c3b:	c6 45 f4 02          	movb   $0x2,-0xc(%ebp)

	return api->transfer(dev, msg, 2, dev_addr);
  101c3f:	ff 52 04             	call   *0x4(%edx)
  101c42:	83 c4 10             	add    $0x10,%esp
		SYS_LOG_ERR("PCAL9535A[0x%X]: error writing from register 0x%X "
			    "(%d)", i2c_addr, reg, ret);
	}

	return ret;
}
  101c45:	8d 65 f8             	lea    -0x8(%ebp),%esp
  101c48:	5b                   	pop    %ebx
  101c49:	5e                   	pop    %esi
  101c4a:	5d                   	pop    %ebp
  101c4b:	c3                   	ret    

00101c4c <gpio_pcal9535a_config>:
 *
 * @return 0 if successful, failed otherwise
 */
static int gpio_pcal9535a_config(struct device *dev, int access_op,
				 uint32_t pin, int flags)
{
  101c4c:	55                   	push   %ebp
  101c4d:	89 e5                	mov    %esp,%ebp
  101c4f:	57                   	push   %edi
  101c50:	56                   	push   %esi
  101c51:	53                   	push   %ebx
  101c52:	83 ec 08             	sub    $0x8,%esp
  101c55:	8b 7d 08             	mov    0x8(%ebp),%edi
  101c58:	8b 45 10             	mov    0x10(%ebp),%eax
  101c5b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  101c5e:	8b 45 14             	mov    0x14(%ebp),%eax
  101c61:	8b 57 08             	mov    0x8(%edi),%edx
  101c64:	89 45 ec             	mov    %eax,-0x14(%ebp)
  101c67:	8b 75 0c             	mov    0xc(%ebp),%esi
		dev->config->config_info;
	uint16_t i2c_addr = config->i2c_slave_addr;
#endif

	if (!_has_i2c_master(dev)) {
		return -EINVAL;
  101c6a:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
{
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	struct device * const i2c_master = drv_data->i2c_master;

	if (i2c_master)
  101c6f:	83 3a 00             	cmpl   $0x0,(%edx)
  101c72:	0f 84 67 01 00 00    	je     101ddf <gpio_pcal9535a_config+0x193>
	union gpio_pcal9535a_port_data *port = &drv_data->reg_cache.dir;
	uint16_t bit_mask;
	uint16_t new_value = 0;
	int ret;

	switch (access_op) {
  101c78:	85 f6                	test   %esi,%esi
  101c7a:	75 1e                	jne    101c9a <gpio_pcal9535a_config+0x4e>
	case GPIO_ACCESS_BY_PIN:
		bit_mask = 1 << pin;
  101c7c:	8a 4d f0             	mov    -0x10(%ebp),%cl
  101c7f:	b8 01 00 00 00       	mov    $0x1,%eax
  101c84:	d3 e0                	shl    %cl,%eax
{
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	union gpio_pcal9535a_port_data *port = &drv_data->reg_cache.dir;
	uint16_t bit_mask;
	uint16_t new_value = 0;
  101c86:	31 c9                	xor    %ecx,%ecx
	switch (access_op) {
	case GPIO_ACCESS_BY_PIN:
		bit_mask = 1 << pin;

		/* Config 0 == output, 1 == input */
		if ((flags & GPIO_DIR_MASK) == GPIO_DIR_IN) {
  101c88:	f6 45 ec 01          	testb  $0x1,-0x14(%ebp)
  101c8c:	75 02                	jne    101c90 <gpio_pcal9535a_config+0x44>
			new_value = 1 << pin;
  101c8e:	89 c1                	mov    %eax,%ecx
		}

		port->all &= ~bit_mask;
		port->all |= new_value;
  101c90:	f7 d0                	not    %eax
  101c92:	66 23 42 40          	and    0x40(%edx),%ax
  101c96:	09 c8                	or     %ecx,%eax
  101c98:	eb 10                	jmp    101caa <gpio_pcal9535a_config+0x5e>
	union gpio_pcal9535a_port_data *port = &drv_data->reg_cache.dir;
	uint16_t bit_mask;
	uint16_t new_value = 0;
	int ret;

	switch (access_op) {
  101c9a:	83 fe 01             	cmp    $0x1,%esi
  101c9d:	0f 85 dc 00 00 00    	jne    101d7f <gpio_pcal9535a_config+0x133>

		break;
	case GPIO_ACCESS_BY_PORT:
		/* Config 0 == output, 1 == input */
		if ((flags & GPIO_DIR_MASK) == GPIO_DIR_IN) {
			port->all = 0xFFFF;
  101ca3:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101ca6:	83 e0 01             	and    $0x1,%eax
  101ca9:	48                   	dec    %eax
  101caa:	66 89 42 40          	mov    %ax,0x40(%edx)
static int _setup_pin_dir(struct device *dev, int access_op,
			  uint32_t pin, int flags)
{
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	union gpio_pcal9535a_port_data *port = &drv_data->reg_cache.dir;
  101cae:	8d 4a 40             	lea    0x40(%edx),%ecx
	default:
		ret = -ENOTSUP;
		goto done;
	}

	ret = _write_port_regs(dev, REG_CONF_PORT0, port);
  101cb1:	89 f8                	mov    %edi,%eax
  101cb3:	ba 06 00 00 00       	mov    $0x6,%edx
  101cb8:	e8 3f ff ff ff       	call   101bfc <_write_port_regs>
	if (!_has_i2c_master(dev)) {
		return -EINVAL;
	}

	ret = _setup_pin_dir(dev, access_op, pin, flags);
	if (ret) {
  101cbd:	85 c0                	test   %eax,%eax
  101cbf:	0f 85 1a 01 00 00    	jne    101ddf <gpio_pcal9535a_config+0x193>
 * @return 0 if successful, failed otherwise
 */
static int _setup_pin_polarity(struct device *dev, int access_op,
			       uint32_t pin, int flags)
{
	struct gpio_pcal9535a_drv_data * const drv_data =
  101cc5:	8b 5f 08             	mov    0x8(%edi),%ebx
	union gpio_pcal9535a_port_data *port = &drv_data->reg_cache.pol_inv;
	uint16_t bit_mask;
	uint16_t new_value = 0;
	int ret;

	switch (access_op) {
  101cc8:	85 f6                	test   %esi,%esi
  101cca:	74 15                	je     101ce1 <gpio_pcal9535a_config+0x95>
  101ccc:	83 fe 01             	cmp    $0x1,%esi
  101ccf:	0f 85 aa 00 00 00    	jne    101d7f <gpio_pcal9535a_config+0x133>

		break;
	case GPIO_ACCESS_BY_PORT:
		/* normal == 0, invert == 1 */
		if ((flags & GPIO_POL_MASK) == GPIO_POL_INV) {
			port->all = 0xFFFF;
  101cd5:	31 c0                	xor    %eax,%eax
  101cd7:	f6 45 ec 80          	testb  $0x80,-0x14(%ebp)
  101cdb:	0f 94 c0             	sete   %al
  101cde:	48                   	dec    %eax
  101cdf:	eb 1c                	jmp    101cfd <gpio_pcal9535a_config+0xb1>
	uint16_t new_value = 0;
	int ret;

	switch (access_op) {
	case GPIO_ACCESS_BY_PIN:
		bit_mask = BIT(pin);
  101ce1:	b8 01 00 00 00       	mov    $0x1,%eax
  101ce6:	8a 4d f0             	mov    -0x10(%ebp),%cl
  101ce9:	d3 e0                	shl    %cl,%eax
{
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	union gpio_pcal9535a_port_data *port = &drv_data->reg_cache.pol_inv;
	uint16_t bit_mask;
	uint16_t new_value = 0;
  101ceb:	31 d2                	xor    %edx,%edx
	switch (access_op) {
	case GPIO_ACCESS_BY_PIN:
		bit_mask = BIT(pin);

		/* normal == 0, invert == 1 */
		if ((flags & GPIO_POL_MASK) == GPIO_POL_INV) {
  101ced:	f6 45 ec 80          	testb  $0x80,-0x14(%ebp)
  101cf1:	74 02                	je     101cf5 <gpio_pcal9535a_config+0xa9>
			new_value = BIT(pin);
  101cf3:	89 c2                	mov    %eax,%edx
		}

		port->all &= ~bit_mask;
		port->all |= new_value;
  101cf5:	f7 d0                	not    %eax
  101cf7:	66 23 43 3e          	and    0x3e(%ebx),%ax
  101cfb:	09 d0                	or     %edx,%eax

		break;
	case GPIO_ACCESS_BY_PORT:
		/* normal == 0, invert == 1 */
		if ((flags & GPIO_POL_MASK) == GPIO_POL_INV) {
			port->all = 0xFFFF;
  101cfd:	66 89 43 3e          	mov    %ax,0x3e(%ebx)
static int _setup_pin_polarity(struct device *dev, int access_op,
			       uint32_t pin, int flags)
{
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	union gpio_pcal9535a_port_data *port = &drv_data->reg_cache.pol_inv;
  101d01:	8d 4b 3e             	lea    0x3e(%ebx),%ecx
	default:
		ret = -ENOTSUP;
		goto done;
	}

	ret = _write_port_regs(dev, REG_POL_INV_PORT0, port);
  101d04:	ba 04 00 00 00       	mov    $0x4,%edx
  101d09:	89 f8                	mov    %edi,%eax
  101d0b:	e8 ec fe ff ff       	call   101bfc <_write_port_regs>
	if (!ret) {
  101d10:	85 c0                	test   %eax,%eax
  101d12:	0f 85 c7 00 00 00    	jne    101ddf <gpio_pcal9535a_config+0x193>
		drv_data->out_pol_inv = port->all;
  101d18:	0f b7 43 3e          	movzwl 0x3e(%ebx),%eax
	int ret;

	/* If disabling pull up/down, there is no need to set the selection
	 * register. Just go straight to disabling.
	 */
	if ((flags & GPIO_PUD_MASK) == GPIO_PUD_NORMAL) {
  101d1c:	8b 55 ec             	mov    -0x14(%ebp),%edx
		goto done;
	}

	ret = _write_port_regs(dev, REG_POL_INV_PORT0, port);
	if (!ret) {
		drv_data->out_pol_inv = port->all;
  101d1f:	89 43 04             	mov    %eax,0x4(%ebx)
	int ret;

	/* If disabling pull up/down, there is no need to set the selection
	 * register. Just go straight to disabling.
	 */
	if ((flags & GPIO_PUD_MASK) == GPIO_PUD_NORMAL) {
  101d22:	81 e2 00 03 00 00    	and    $0x300,%edx
 * @return 0 if successful, failed otherwise
 */
static int _setup_pin_pullupdown(struct device *dev, int access_op,
				 uint32_t pin, int flags)
{
	struct gpio_pcal9535a_drv_data * const drv_data =
  101d28:	8b 5f 08             	mov    0x8(%edi),%ebx
	int ret;

	/* If disabling pull up/down, there is no need to set the selection
	 * register. Just go straight to disabling.
	 */
	if ((flags & GPIO_PUD_MASK) == GPIO_PUD_NORMAL) {
  101d2b:	0f 84 91 00 00 00    	je     101dc2 <gpio_pcal9535a_config+0x176>
		goto en_dis;
	}

	/* Setup pin pull up or pull down */
	port = &drv_data->reg_cache.pud_sel;
	switch (access_op) {
  101d31:	85 f6                	test   %esi,%esi
  101d33:	74 13                	je     101d48 <gpio_pcal9535a_config+0xfc>
  101d35:	83 fe 01             	cmp    $0x1,%esi
  101d38:	75 45                	jne    101d7f <gpio_pcal9535a_config+0x133>

		break;
	case GPIO_ACCESS_BY_PORT:
		/* pull down == 0, pull up == 1*/
		if ((flags & GPIO_PUD_MASK) == GPIO_PUD_PULL_UP) {
			port->all = 0xFFFF;
  101d3a:	31 c0                	xor    %eax,%eax
  101d3c:	81 fa 00 01 00 00    	cmp    $0x100,%edx
  101d42:	0f 95 c0             	setne  %al
  101d45:	48                   	dec    %eax
  101d46:	eb 1e                	jmp    101d66 <gpio_pcal9535a_config+0x11a>

	/* Setup pin pull up or pull down */
	port = &drv_data->reg_cache.pud_sel;
	switch (access_op) {
	case GPIO_ACCESS_BY_PIN:
		bit_mask = 1 << pin;
  101d48:	8a 4d f0             	mov    -0x10(%ebp),%cl
  101d4b:	b8 01 00 00 00       	mov    $0x1,%eax
  101d50:	d3 e0                	shl    %cl,%eax
{
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	union gpio_pcal9535a_port_data *port;
	uint16_t bit_mask;
	uint16_t new_value = 0;
  101d52:	31 c9                	xor    %ecx,%ecx
	switch (access_op) {
	case GPIO_ACCESS_BY_PIN:
		bit_mask = 1 << pin;

		/* pull down == 0, pull up == 1*/
		if ((flags & GPIO_PUD_MASK) == GPIO_PUD_PULL_UP) {
  101d54:	81 fa 00 01 00 00    	cmp    $0x100,%edx
  101d5a:	75 02                	jne    101d5e <gpio_pcal9535a_config+0x112>
			new_value = 1 << pin;
  101d5c:	89 c1                	mov    %eax,%ecx
		}

		port->all &= ~bit_mask;
		port->all |= new_value;
  101d5e:	f7 d0                	not    %eax
  101d60:	66 23 43 44          	and    0x44(%ebx),%ax
  101d64:	09 c8                	or     %ecx,%eax

		break;
	case GPIO_ACCESS_BY_PORT:
		/* pull down == 0, pull up == 1*/
		if ((flags & GPIO_PUD_MASK) == GPIO_PUD_PULL_UP) {
			port->all = 0xFFFF;
  101d66:	66 89 43 44          	mov    %ax,0x44(%ebx)
	if ((flags & GPIO_PUD_MASK) == GPIO_PUD_NORMAL) {
		goto en_dis;
	}

	/* Setup pin pull up or pull down */
	port = &drv_data->reg_cache.pud_sel;
  101d6a:	8d 4b 44             	lea    0x44(%ebx),%ecx
	default:
		ret = -ENOTSUP;
		goto done;
	}

	ret = _write_port_regs(dev, REG_PUD_SEL_PORT0, port);
  101d6d:	ba 48 00 00 00       	mov    $0x48,%edx
  101d72:	89 f8                	mov    %edi,%eax
  101d74:	e8 83 fe ff ff       	call   101bfc <_write_port_regs>
	if (ret) {
  101d79:	85 c0                	test   %eax,%eax
  101d7b:	74 09                	je     101d86 <gpio_pcal9535a_config+0x13a>
  101d7d:	eb 60                	jmp    101ddf <gpio_pcal9535a_config+0x193>
		} else {
			port->all = 0x0;
		}
		break;
	default:
		ret = -ENOTSUP;
  101d7f:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
  101d84:	eb 59                	jmp    101ddf <gpio_pcal9535a_config+0x193>
	}

en_dis:
	/* enable/disable pull up/down */
	port = &drv_data->reg_cache.pud_en;
	switch (access_op) {
  101d86:	85 f6                	test   %esi,%esi
  101d88:	75 2d                	jne    101db7 <gpio_pcal9535a_config+0x16b>
	case GPIO_ACCESS_BY_PIN:
		bit_mask = 1 << pin;
  101d8a:	b8 01 00 00 00       	mov    $0x1,%eax
  101d8f:	8a 4d f0             	mov    -0x10(%ebp),%cl
  101d92:	d3 e0                	shl    %cl,%eax

		if ((flags & GPIO_PUD_MASK) != GPIO_PUD_NORMAL) {
			new_value = 1 << pin;
  101d94:	89 c2                	mov    %eax,%edx
		}

		port->all &= ~bit_mask;
		port->all |= new_value;
  101d96:	f7 d0                	not    %eax
  101d98:	66 23 43 42          	and    0x42(%ebx),%ax
  101d9c:	09 d0                	or     %edx,%eax
  101d9e:	66 89 43 42          	mov    %ax,0x42(%ebx)
		goto done;
	}

en_dis:
	/* enable/disable pull up/down */
	port = &drv_data->reg_cache.pud_en;
  101da2:	8d 4b 42             	lea    0x42(%ebx),%ecx
	default:
		ret = -ENOTSUP;
		goto done;
	}

	ret = _write_port_regs(dev, REG_PUD_EN_PORT0, port);
  101da5:	89 f8                	mov    %edi,%eax
  101da7:	ba 46 00 00 00       	mov    $0x46,%edx
		goto done;
	}

done:
	return ret;
}
  101dac:	5b                   	pop    %ebx
  101dad:	5e                   	pop    %esi
  101dae:	5b                   	pop    %ebx
  101daf:	5e                   	pop    %esi
  101db0:	5f                   	pop    %edi
  101db1:	5d                   	pop    %ebp
	default:
		ret = -ENOTSUP;
		goto done;
	}

	ret = _write_port_regs(dev, REG_PUD_EN_PORT0, port);
  101db2:	e9 45 fe ff ff       	jmp    101bfc <_write_port_regs>
	}

en_dis:
	/* enable/disable pull up/down */
	port = &drv_data->reg_cache.pud_en;
	switch (access_op) {
  101db7:	4e                   	dec    %esi
  101db8:	75 c5                	jne    101d7f <gpio_pcal9535a_config+0x133>
		port->all |= new_value;

		break;
	case GPIO_ACCESS_BY_PORT:
		if ((flags & GPIO_PUD_MASK) != GPIO_PUD_NORMAL) {
			port->all = 0xFFFF;
  101dba:	66 c7 43 42 ff ff    	movw   $0xffff,0x42(%ebx)
  101dc0:	eb e0                	jmp    101da2 <gpio_pcal9535a_config+0x156>
	}

en_dis:
	/* enable/disable pull up/down */
	port = &drv_data->reg_cache.pud_en;
	switch (access_op) {
  101dc2:	85 f6                	test   %esi,%esi
  101dc4:	75 0e                	jne    101dd4 <gpio_pcal9535a_config+0x188>
	case GPIO_ACCESS_BY_PIN:
		bit_mask = 1 << pin;
  101dc6:	b8 01 00 00 00       	mov    $0x1,%eax
  101dcb:	8a 4d f0             	mov    -0x10(%ebp),%cl
  101dce:	d3 e0                	shl    %cl,%eax
{
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	union gpio_pcal9535a_port_data *port;
	uint16_t bit_mask;
	uint16_t new_value = 0;
  101dd0:	31 d2                	xor    %edx,%edx
  101dd2:	eb c2                	jmp    101d96 <gpio_pcal9535a_config+0x14a>
	}

en_dis:
	/* enable/disable pull up/down */
	port = &drv_data->reg_cache.pud_en;
	switch (access_op) {
  101dd4:	4e                   	dec    %esi
  101dd5:	75 a8                	jne    101d7f <gpio_pcal9535a_config+0x133>
		break;
	case GPIO_ACCESS_BY_PORT:
		if ((flags & GPIO_PUD_MASK) != GPIO_PUD_NORMAL) {
			port->all = 0xFFFF;
		} else {
			port->all = 0x0;
  101dd7:	66 c7 43 42 00 00    	movw   $0x0,0x42(%ebx)
  101ddd:	eb c3                	jmp    101da2 <gpio_pcal9535a_config+0x156>
		goto done;
	}

done:
	return ret;
}
  101ddf:	5a                   	pop    %edx
  101de0:	59                   	pop    %ecx
  101de1:	5b                   	pop    %ebx
  101de2:	5e                   	pop    %esi
  101de3:	5f                   	pop    %edi
  101de4:	5d                   	pop    %ebp
  101de5:	c3                   	ret    

00101de6 <gpio_pcal9535a_write>:
 *
 * @return 0 if successful, failed otherwise
 */
static int gpio_pcal9535a_write(struct device *dev, int access_op,
				uint32_t pin, uint32_t value)
{
  101de6:	55                   	push   %ebp
  101de7:	89 e5                	mov    %esp,%ebp
  101de9:	57                   	push   %edi
  101dea:	56                   	push   %esi
  101deb:	53                   	push   %ebx
  101dec:	8b 45 08             	mov    0x8(%ebp),%eax
  101def:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  101df2:	8b 4d 10             	mov    0x10(%ebp),%ecx
  101df5:	8b 75 14             	mov    0x14(%ebp),%esi
	struct gpio_pcal9535a_drv_data * const drv_data =
  101df8:	8b 50 08             	mov    0x8(%eax),%edx
{
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	struct device * const i2c_master = drv_data->i2c_master;

	if (i2c_master)
  101dfb:	83 3a 00             	cmpl   $0x0,(%edx)
  101dfe:	75 07                	jne    101e07 <gpio_pcal9535a_write+0x21>
	uint16_t bit_mask;
	uint16_t new_value;
	int ret;

	if (!_has_i2c_master(dev)) {
		return -EINVAL;
  101e00:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  101e05:	eb 4e                	jmp    101e55 <gpio_pcal9535a_write+0x6f>
	}

	/* Invert input value for pins configurated as active low. */
	switch (access_op) {
  101e07:	85 db                	test   %ebx,%ebx
  101e09:	75 1a                	jne    101e25 <gpio_pcal9535a_write+0x3f>
	case GPIO_ACCESS_BY_PIN:
		bit_mask = BIT(pin);
  101e0b:	bb 01 00 00 00       	mov    $0x1,%ebx
  101e10:	d3 e3                	shl    %cl,%ebx

		new_value = (value << pin) & bit_mask;
  101e12:	d3 e6                	shl    %cl,%esi
		new_value ^= (drv_data->out_pol_inv & bit_mask);
		new_value &= bit_mask;

		port->all &= ~bit_mask;
		port->all |= new_value;
  101e14:	89 d9                	mov    %ebx,%ecx
	switch (access_op) {
	case GPIO_ACCESS_BY_PIN:
		bit_mask = BIT(pin);

		new_value = (value << pin) & bit_mask;
		new_value ^= (drv_data->out_pol_inv & bit_mask);
  101e16:	33 72 04             	xor    0x4(%edx),%esi
		new_value &= bit_mask;

		port->all &= ~bit_mask;
		port->all |= new_value;
  101e19:	f7 d1                	not    %ecx
  101e1b:	66 23 4a 3c          	and    0x3c(%edx),%cx
  101e1f:	21 f3                	and    %esi,%ebx
  101e21:	09 cb                	or     %ecx,%ebx
  101e23:	eb 16                	jmp    101e3b <gpio_pcal9535a_write+0x55>
	if (!_has_i2c_master(dev)) {
		return -EINVAL;
	}

	/* Invert input value for pins configurated as active low. */
	switch (access_op) {
  101e25:	4b                   	dec    %ebx
  101e26:	75 28                	jne    101e50 <gpio_pcal9535a_write+0x6a>
		port->all |= new_value;

		break;
	case GPIO_ACCESS_BY_PORT:
		port->all = value;
		bit_mask = drv_data->out_pol_inv;
  101e28:	8b 4a 04             	mov    0x4(%edx),%ecx

		new_value = value & bit_mask;
		new_value ^= drv_data->out_pol_inv;
  101e2b:	89 f7                	mov    %esi,%edi
		new_value &= bit_mask;

		port->all &= ~bit_mask;
		port->all |= new_value;
  101e2d:	89 cb                	mov    %ecx,%ebx
  101e2f:	f7 d3                	not    %ebx
	case GPIO_ACCESS_BY_PORT:
		port->all = value;
		bit_mask = drv_data->out_pol_inv;

		new_value = value & bit_mask;
		new_value ^= drv_data->out_pol_inv;
  101e31:	f7 d7                	not    %edi
		new_value &= bit_mask;

		port->all &= ~bit_mask;
		port->all |= new_value;
  101e33:	21 de                	and    %ebx,%esi
  101e35:	21 f9                	and    %edi,%ecx
  101e37:	09 ce                	or     %ecx,%esi
  101e39:	89 f3                	mov    %esi,%ebx
  101e3b:	66 89 5a 3c          	mov    %bx,0x3c(%edx)
static int gpio_pcal9535a_write(struct device *dev, int access_op,
				uint32_t pin, uint32_t value)
{
	struct gpio_pcal9535a_drv_data * const drv_data =
		(struct gpio_pcal9535a_drv_data * const)dev->driver_data;
	union gpio_pcal9535a_port_data *port = &drv_data->reg_cache.output;
  101e3f:	8d 4a 3c             	lea    0x3c(%edx),%ecx
	default:
		ret = -ENOTSUP;
		goto done;
	}

	ret = _write_port_regs(dev, REG_OUTPUT_PORT0, port);
  101e42:	ba 02 00 00 00       	mov    $0x2,%edx

done:
	return ret;
}
  101e47:	5b                   	pop    %ebx
  101e48:	5e                   	pop    %esi
  101e49:	5f                   	pop    %edi
  101e4a:	5d                   	pop    %ebp
	default:
		ret = -ENOTSUP;
		goto done;
	}

	ret = _write_port_regs(dev, REG_OUTPUT_PORT0, port);
  101e4b:	e9 ac fd ff ff       	jmp    101bfc <_write_port_regs>
		port->all &= ~bit_mask;
		port->all |= new_value;

		break;
	default:
		ret = -ENOTSUP;
  101e50:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax

	ret = _write_port_regs(dev, REG_OUTPUT_PORT0, port);

done:
	return ret;
}
  101e55:	5b                   	pop    %ebx
  101e56:	5e                   	pop    %esi
  101e57:	5f                   	pop    %edi
  101e58:	5d                   	pop    %ebp
  101e59:	c3                   	ret    

00101e5a <gpio_pcal9535a_enable_callback>:
  101e5a:	55                   	push   %ebp
  101e5b:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
  101e60:	89 e5                	mov    %esp,%ebp
  101e62:	5d                   	pop    %ebp
  101e63:	c3                   	ret    

00101e64 <gpio_sch_read>:
	return 0;
}

static int gpio_sch_read(struct device *dev,
			 int access_op, uint32_t pin, uint32_t *value)
{
  101e64:	55                   	push   %ebp
  101e65:	89 e5                	mov    %esp,%ebp
  101e67:	56                   	push   %esi
  101e68:	53                   	push   %ebx
	const struct gpio_sch_config *info = dev->config->config_info;
  101e69:	8b 45 08             	mov    0x8(%ebp),%eax
	return 0;
}

static int gpio_sch_read(struct device *dev,
			 int access_op, uint32_t pin, uint32_t *value)
{
  101e6c:	8b 4d 10             	mov    0x10(%ebp),%ecx
  101e6f:	8b 5d 14             	mov    0x14(%ebp),%ebx
	const struct gpio_sch_config *info = dev->config->config_info;
  101e72:	8b 00                	mov    (%eax),%eax
  101e74:	8b 70 08             	mov    0x8(%eax),%esi
static ALWAYS_INLINE
	uint32_t sys_in32(io_port_t port)
{
	uint32_t ret;

	__asm__ volatile("inl	%w1, %0;\n\t"
  101e77:	8b 06                	mov    (%esi),%eax
  101e79:	8d 50 08             	lea    0x8(%eax),%edx
  101e7c:	ed                   	in     (%dx),%eax
  101e7d:	89 c2                	mov    %eax,%edx

	*value = _read_glvl(info->regs);
  101e7f:	89 03                	mov    %eax,(%ebx)
		}

		*value = !!(*value & BIT(pin));
	}

	return 0;
  101e81:	31 c0                	xor    %eax,%eax
{
	const struct gpio_sch_config *info = dev->config->config_info;

	*value = _read_glvl(info->regs);

	if (access_op == GPIO_ACCESS_BY_PIN) {
  101e83:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  101e87:	75 16                	jne    101e9f <gpio_sch_read+0x3b>
		if (pin >= info->bits) {
  101e89:	0f b6 76 04          	movzbl 0x4(%esi),%esi
  101e8d:	39 ce                	cmp    %ecx,%esi
  101e8f:	76 09                	jbe    101e9a <gpio_sch_read+0x36>
			return -ENOTSUP;
		}

		*value = !!(*value & BIT(pin));
  101e91:	d3 ea                	shr    %cl,%edx
  101e93:	83 e2 01             	and    $0x1,%edx
  101e96:	89 13                	mov    %edx,(%ebx)
  101e98:	eb 05                	jmp    101e9f <gpio_sch_read+0x3b>

	*value = _read_glvl(info->regs);

	if (access_op == GPIO_ACCESS_BY_PIN) {
		if (pin >= info->bits) {
			return -ENOTSUP;
  101e9a:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax

		*value = !!(*value & BIT(pin));
	}

	return 0;
}
  101e9f:	5b                   	pop    %ebx
  101ea0:	5e                   	pop    %esi
  101ea1:	5d                   	pop    %ebp
  101ea2:	c3                   	ret    

00101ea3 <gpio_sch_init>:
	.enable_callback = gpio_sch_enable_callback,
	.disable_callback = gpio_sch_disable_callback,
};

static int gpio_sch_init(struct device *dev)
{
  101ea3:	55                   	push   %ebp
  101ea4:	89 e5                	mov    %esp,%ebp
  101ea6:	8b 55 08             	mov    0x8(%ebp),%edx
	struct gpio_sch_data *gpio = dev->driver_data;
  101ea9:	8b 42 08             	mov    0x8(%edx),%eax

	dev->driver_api = &gpio_sch_api;
  101eac:	c7 42 04 b4 48 10 00 	movl   $0x1048b4,0x4(%edx)

	k_timer_init(&gpio->poll_timer, NULL, NULL);
  101eb3:	05 08 04 00 00       	add    $0x408,%eax
  101eb8:	6a 00                	push   $0x0
  101eba:	6a 00                	push   $0x0
  101ebc:	50                   	push   %eax
  101ebd:	e8 c0 25 00 00       	call   104482 <k_timer_init>
  101ec2:	83 c4 0c             	add    $0xc,%esp

	SYS_LOG_DBG("SCH GPIO Intel Driver initialized on device: %p", dev);

	return 0;
}
  101ec5:	31 c0                	xor    %eax,%eax
  101ec7:	c9                   	leave  
  101ec8:	c3                   	ret    

00101ec9 <_gpio_sch_manage_callback>:
	}
}

static void _gpio_sch_manage_callback(struct device *dev)
{
	struct gpio_sch_data *gpio = dev->driver_data;
  101ec9:	8b 50 08             	mov    0x8(%eax),%edx

	/* Start the fiber only when relevant */
	if (!sys_slist_is_empty(&gpio->callbacks) && gpio->cb_enabled) {
  101ecc:	83 ba 00 04 00 00 00 	cmpl   $0x0,0x400(%edx)
  101ed3:	74 3d                	je     101f12 <_gpio_sch_manage_callback+0x49>
  101ed5:	83 ba 44 04 00 00 00 	cmpl   $0x0,0x444(%edx)
  101edc:	74 34                	je     101f12 <_gpio_sch_manage_callback+0x49>
		if (!gpio->poll) {
  101ede:	80 ba 48 04 00 00 00 	cmpb   $0x0,0x448(%edx)
  101ee5:	75 33                	jne    101f1a <_gpio_sch_manage_callback+0x51>
		k_timer_status_sync(&gpio->poll_timer);
	}
}

static void _gpio_sch_manage_callback(struct device *dev)
{
  101ee7:	55                   	push   %ebp

	/* Start the fiber only when relevant */
	if (!sys_slist_is_empty(&gpio->callbacks) && gpio->cb_enabled) {
		if (!gpio->poll) {
			SYS_LOG_DBG("Starting SCH GPIO polling fiber");
			gpio->poll = 1;
  101ee8:	c6 82 48 04 00 00 01 	movb   $0x1,0x448(%edx)
		k_timer_status_sync(&gpio->poll_timer);
	}
}

static void _gpio_sch_manage_callback(struct device *dev)
{
  101eef:	89 e5                	mov    %esp,%ebp
	/* Start the fiber only when relevant */
	if (!sys_slist_is_empty(&gpio->callbacks) && gpio->cb_enabled) {
		if (!gpio->poll) {
			SYS_LOG_DBG("Starting SCH GPIO polling fiber");
			gpio->poll = 1;
			k_thread_spawn(gpio->polling_stack,
  101ef1:	6a 00                	push   $0x0
  101ef3:	6a 00                	push   $0x0
  101ef5:	6a f1                	push   $0xfffffff1
  101ef7:	6a 00                	push   $0x0
  101ef9:	6a 00                	push   $0x0
  101efb:	50                   	push   %eax
  101efc:	68 a7 20 10 00       	push   $0x1020a7
  101f01:	68 00 04 00 00       	push   $0x400
  101f06:	52                   	push   %edx
  101f07:	e8 f7 21 00 00       	call   104103 <k_thread_spawn>
  101f0c:	83 c4 24             	add    $0x24,%esp
				       K_PRIO_COOP(1), 0, 0);
		}
	} else {
		gpio->poll = 0;
	}
}
  101f0f:	c9                   	leave  
  101f10:	eb 08                	jmp    101f1a <_gpio_sch_manage_callback+0x51>
				       (k_thread_entry_t)_gpio_sch_poll_status,
				       dev, NULL, NULL,
				       K_PRIO_COOP(1), 0, 0);
		}
	} else {
		gpio->poll = 0;
  101f12:	c6 82 48 04 00 00 00 	movb   $0x0,0x448(%edx)
	}
}
  101f19:	c3                   	ret    
  101f1a:	c3                   	ret    

00101f1b <gpio_sch_manage_callback>:

static int gpio_sch_manage_callback(struct device *dev,
				    struct gpio_callback *callback, bool set)
{
  101f1b:	55                   	push   %ebp
  101f1c:	89 e5                	mov    %esp,%ebp
  101f1e:	56                   	push   %esi
  101f1f:	53                   	push   %ebx
 * @param node A pointer on the node to remove from the list
 */
static inline void sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node)
{
	sys_snode_t *prev = NULL;
  101f20:	31 f6                	xor    %esi,%esi
  101f22:	8b 45 08             	mov    0x8(%ebp),%eax
  101f25:	8b 4d 0c             	mov    0xc(%ebp),%ecx
					 bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (set) {
  101f28:	80 7d 10 00          	cmpb   $0x0,0x10(%ebp)
	struct gpio_sch_data *gpio = dev->driver_data;
  101f2c:	8b 50 08             	mov    0x8(%eax),%edx
 * @param node A pointer on the node to prepend
 */
static inline void sys_slist_prepend(sys_slist_t *list,
				     sys_snode_t *node)
{
	node->next = list->head;
  101f2f:	8b 9a 00 04 00 00    	mov    0x400(%edx),%ebx
  101f35:	74 21                	je     101f58 <gpio_sch_manage_callback+0x3d>
  101f37:	89 19                	mov    %ebx,(%ecx)
	list->head = node;
  101f39:	89 8a 00 04 00 00    	mov    %ecx,0x400(%edx)

	if (!list->tail) {
  101f3f:	83 ba 04 04 00 00 00 	cmpl   $0x0,0x404(%edx)
  101f46:	75 48                	jne    101f90 <gpio_sch_manage_callback+0x75>
		list->tail = list->head;
  101f48:	89 8a 04 04 00 00    	mov    %ecx,0x404(%edx)
  101f4e:	eb 40                	jmp    101f90 <gpio_sch_manage_callback+0x75>
{
	sys_snode_t *prev = NULL;
	sys_snode_t *test;

	SYS_SLIST_FOR_EACH_NODE(list, test) {
		if (test == node) {
  101f50:	39 d9                	cmp    %ebx,%ecx
  101f52:	74 0a                	je     101f5e <gpio_sch_manage_callback+0x43>
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node)
{
	return !node ? NULL : node->next;
  101f54:	89 de                	mov    %ebx,%esi
  101f56:	8b 1b                	mov    (%ebx),%ebx
					     sys_snode_t *node)
{
	sys_snode_t *prev = NULL;
	sys_snode_t *test;

	SYS_SLIST_FOR_EACH_NODE(list, test) {
  101f58:	85 db                	test   %ebx,%ebx
  101f5a:	75 f4                	jne    101f50 <gpio_sch_manage_callback+0x35>
  101f5c:	eb 32                	jmp    101f90 <gpio_sch_manage_callback+0x75>
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node)
{
	if (!prev_node) {
  101f5e:	85 f6                	test   %esi,%esi
  101f60:	8b 19                	mov    (%ecx),%ebx
  101f62:	75 16                	jne    101f7a <gpio_sch_manage_callback+0x5f>
		list->head = node->next;
  101f64:	89 9a 00 04 00 00    	mov    %ebx,0x400(%edx)

		/* Was node also the tail? */
		if (list->tail == node) {
  101f6a:	3b 8a 04 04 00 00    	cmp    0x404(%edx),%ecx
  101f70:	75 18                	jne    101f8a <gpio_sch_manage_callback+0x6f>
			list->tail = list->head;
  101f72:	89 9a 04 04 00 00    	mov    %ebx,0x404(%edx)
  101f78:	eb 10                	jmp    101f8a <gpio_sch_manage_callback+0x6f>
		}
	} else {
		prev_node->next = node->next;
  101f7a:	89 1e                	mov    %ebx,(%esi)

		/* Was node the tail? */
		if (list->tail == node) {
  101f7c:	3b 8a 04 04 00 00    	cmp    0x404(%edx),%ecx
  101f82:	75 06                	jne    101f8a <gpio_sch_manage_callback+0x6f>
			list->tail = prev_node;
  101f84:	89 b2 04 04 00 00    	mov    %esi,0x404(%edx)
		}
	}

	node->next = NULL;
  101f8a:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)

	_gpio_manage_callback(&gpio->callbacks, callback, set);

	_gpio_sch_manage_callback(dev);
  101f90:	e8 34 ff ff ff       	call   101ec9 <_gpio_sch_manage_callback>

	return 0;
}
  101f95:	5b                   	pop    %ebx
  101f96:	31 c0                	xor    %eax,%eax
  101f98:	5e                   	pop    %esi
  101f99:	5d                   	pop    %ebp
  101f9a:	c3                   	ret    

00101f9b <_set_bit>:
DEFINE_MM_REG_READ(gts, GPIO_SCH_REG_GTS)
DEFINE_MM_REG_WRITE(gts, GPIO_SCH_REG_GTS)

static void _set_bit(uint32_t base_addr,
		     uint32_t bit, uint8_t set)
{
  101f9b:	55                   	push   %ebp
  101f9c:	89 e5                	mov    %esp,%ebp
  101f9e:	56                   	push   %esi
  101f9f:	53                   	push   %ebx
  101fa0:	89 c3                	mov    %eax,%ebx
  101fa2:	89 d6                	mov    %edx,%esi
static ALWAYS_INLINE
	void sys_io_clear_bit(io_port_t port, unsigned int bit)
{
	uint32_t reg = 0;

	__asm__ volatile("inl	%w1, %0;\n\t"
  101fa4:	31 c0                	xor    %eax,%eax
  101fa6:	89 da                	mov    %ebx,%edx
	if (!set) {
  101fa8:	84 c9                	test   %cl,%cl
  101faa:	75 07                	jne    101fb3 <_set_bit+0x18>
  101fac:	ed                   	in     (%dx),%eax
  101fad:	0f b3 f0             	btr    %esi,%eax
  101fb0:	ef                   	out    %eax,(%dx)
  101fb1:	eb 05                	jmp    101fb8 <_set_bit+0x1d>
static ALWAYS_INLINE
	void sys_io_set_bit(io_port_t port, unsigned int bit)
{
	uint32_t reg = 0;

	__asm__ volatile("inl	%w1, %0;\n\t"
  101fb3:	ed                   	in     (%dx),%eax
  101fb4:	0f ab f0             	bts    %esi,%eax
  101fb7:	ef                   	out    %eax,(%dx)
		_REG_CLEAR_BIT(base_addr, bit);
	} else {
		_REG_SET_BIT(base_addr, bit);
	}
}
  101fb8:	5b                   	pop    %ebx
  101fb9:	5e                   	pop    %esi
  101fba:	5d                   	pop    %ebp
  101fbb:	c3                   	ret    

00101fbc <gpio_sch_write>:
	return 0;
}

static int gpio_sch_write(struct device *dev,
			  int access_op, uint32_t pin, uint32_t value)
{
  101fbc:	55                   	push   %ebp
  101fbd:	89 e5                	mov    %esp,%ebp
  101fbf:	56                   	push   %esi
  101fc0:	53                   	push   %ebx
	const struct gpio_sch_config *info = dev->config->config_info;
  101fc1:	8b 45 08             	mov    0x8(%ebp),%eax
	return 0;
}

static int gpio_sch_write(struct device *dev,
			  int access_op, uint32_t pin, uint32_t value)
{
  101fc4:	8b 55 10             	mov    0x10(%ebp),%edx
  101fc7:	8b 4d 14             	mov    0x14(%ebp),%ecx
	const struct gpio_sch_config *info = dev->config->config_info;
  101fca:	8b 00                	mov    (%eax),%eax

	if (access_op == GPIO_ACCESS_BY_PIN) {
  101fcc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
}

static int gpio_sch_write(struct device *dev,
			  int access_op, uint32_t pin, uint32_t value)
{
	const struct gpio_sch_config *info = dev->config->config_info;
  101fd0:	8b 58 08             	mov    0x8(%eax),%ebx

	if (access_op == GPIO_ACCESS_BY_PIN) {
  101fd3:	75 1c                	jne    101ff1 <gpio_sch_write+0x35>
		if (pin >= info->bits) {
  101fd5:	0f b6 73 04          	movzbl 0x4(%ebx),%esi
			return -ENOTSUP;
  101fd9:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
			  int access_op, uint32_t pin, uint32_t value)
{
	const struct gpio_sch_config *info = dev->config->config_info;

	if (access_op == GPIO_ACCESS_BY_PIN) {
		if (pin >= info->bits) {
  101fde:	39 d6                	cmp    %edx,%esi
  101fe0:	76 17                	jbe    101ff9 <gpio_sch_write+0x3d>
		_set_bit(addr + __off, bit, set);                       \
	}

DEFINE_MM_REG_SET_BIT(gen, GPIO_SCH_REG_GEN)
DEFINE_MM_REG_SET_BIT(gio, GPIO_SCH_REG_GIO)
DEFINE_MM_REG_SET_BIT(glvl, GPIO_SCH_REG_GLVL)
  101fe2:	8b 03                	mov    (%ebx),%eax
  101fe4:	0f b6 c9             	movzbl %cl,%ecx
  101fe7:	83 c0 08             	add    $0x8,%eax
  101fea:	e8 ac ff ff ff       	call   101f9b <_set_bit>
  101fef:	eb 06                	jmp    101ff7 <gpio_sch_write+0x3b>


static ALWAYS_INLINE
	void sys_out32(uint32_t data, io_port_t port)
{
	__asm__ volatile("outl	%0, %w1;\n\t"
  101ff1:	8b 03                	mov    (%ebx),%eax
  101ff3:	8d 51 08             	lea    0x8(%ecx),%edx
  101ff6:	ef                   	out    %eax,(%dx)
		_set_bit_glvl(info->regs, pin, value);
	} else {
		_write_glvl(info->regs, value);
	}

	return 0;
  101ff7:	31 c0                	xor    %eax,%eax
}
  101ff9:	5b                   	pop    %ebx
  101ffa:	5e                   	pop    %esi
  101ffb:	5d                   	pop    %ebp
  101ffc:	c3                   	ret    

00101ffd <gpio_sch_enable_callback>:
	return 0;
}

static int gpio_sch_enable_callback(struct device *dev,
				    int access_op, uint32_t pin)
{
  101ffd:	55                   	push   %ebp
  101ffe:	89 e5                	mov    %esp,%ebp
  102000:	57                   	push   %edi
  102001:	56                   	push   %esi
  102002:	53                   	push   %ebx
  102003:	51                   	push   %ecx
	const struct gpio_sch_config *info = dev->config->config_info;
  102004:	8b 45 08             	mov    0x8(%ebp),%eax
	struct gpio_sch_data *gpio = dev->driver_data;

	if (access_op == GPIO_ACCESS_BY_PIN) {
  102007:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
}

static int gpio_sch_enable_callback(struct device *dev,
				    int access_op, uint32_t pin)
{
	const struct gpio_sch_config *info = dev->config->config_info;
  10200b:	8b 00                	mov    (%eax),%eax
  10200d:	8b 70 08             	mov    0x8(%eax),%esi
	struct gpio_sch_data *gpio = dev->driver_data;
  102010:	8b 45 08             	mov    0x8(%ebp),%eax
  102013:	8b 58 08             	mov    0x8(%eax),%ebx
  102016:	0f b6 46 04          	movzbl 0x4(%esi),%eax
  10201a:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (access_op == GPIO_ACCESS_BY_PIN) {
  10201d:	75 51                	jne    102070 <gpio_sch_enable_callback+0x73>
		uint32_t bits = BIT(pin);
  10201f:	b8 01 00 00 00       	mov    $0x1,%eax
  102024:	8a 4d 10             	mov    0x10(%ebp),%cl
  102027:	d3 e0                	shl    %cl,%eax

		if (pin >= info->bits) {
  102029:	8b 55 f0             	mov    -0x10(%ebp),%edx
{
	const struct gpio_sch_config *info = dev->config->config_info;
	struct gpio_sch_data *gpio = dev->driver_data;

	if (access_op == GPIO_ACCESS_BY_PIN) {
		uint32_t bits = BIT(pin);
  10202c:	89 c7                	mov    %eax,%edi

		if (pin >= info->bits) {
  10202e:	39 55 10             	cmp    %edx,0x10(%ebp)
			return -ENOTSUP;
  102031:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
	struct gpio_sch_data *gpio = dev->driver_data;

	if (access_op == GPIO_ACCESS_BY_PIN) {
		uint32_t bits = BIT(pin);

		if (pin >= info->bits) {
  102036:	73 69                	jae    1020a1 <gpio_sch_enable_callback+0xa4>
	}

DEFINE_MM_REG_SET_BIT(gen, GPIO_SCH_REG_GEN)
DEFINE_MM_REG_SET_BIT(gio, GPIO_SCH_REG_GIO)
DEFINE_MM_REG_SET_BIT(glvl, GPIO_SCH_REG_GLVL)
DEFINE_MM_REG_SET_BIT(gtpe, GPIO_SCH_REG_GTPE)
  102038:	31 c9                	xor    %ecx,%ecx
  10203a:	8b 06                	mov    (%esi),%eax
  10203c:	85 bb 3c 04 00 00    	test   %edi,0x43c(%ebx)
  102042:	8b 55 10             	mov    0x10(%ebp),%edx
  102045:	0f 95 c1             	setne  %cl
  102048:	83 c0 0c             	add    $0xc,%eax
  10204b:	e8 4b ff ff ff       	call   101f9b <_set_bit>
DEFINE_MM_REG_SET_BIT(gtne, GPIO_SCH_REG_GTNE)
  102050:	31 c9                	xor    %ecx,%ecx
  102052:	8b 06                	mov    (%esi),%eax
  102054:	85 bb 40 04 00 00    	test   %edi,0x440(%ebx)
  10205a:	8b 55 10             	mov    0x10(%ebp),%edx
  10205d:	0f 95 c1             	setne  %cl
  102060:	83 c0 10             	add    $0x10,%eax
  102063:	e8 33 ff ff ff       	call   101f9b <_set_bit>
		}

		_set_bit_gtpe(info->regs, pin, !!(bits & gpio->int_regs.gtpe));
		_set_bit_gtne(info->regs, pin, !!(bits & gpio->int_regs.gtne));

		gpio->cb_enabled |= bits;
  102068:	09 bb 44 04 00 00    	or     %edi,0x444(%ebx)
  10206e:	eb 27                	jmp    102097 <gpio_sch_enable_callback+0x9a>
	} else {
		_write_gtpe(gpio->int_regs.gtpe, info->regs);
  102070:	8b 0e                	mov    (%esi),%ecx
  102072:	8b 83 3c 04 00 00    	mov    0x43c(%ebx),%eax
  102078:	8d 51 0c             	lea    0xc(%ecx),%edx
  10207b:	ef                   	out    %eax,(%dx)
  10207c:	8b 83 40 04 00 00    	mov    0x440(%ebx),%eax
  102082:	8d 51 10             	lea    0x10(%ecx),%edx
  102085:	ef                   	out    %eax,(%dx)
		_write_gtne(gpio->int_regs.gtne, info->regs);

		gpio->cb_enabled = BIT_MASK(info->bits);
  102086:	b8 01 00 00 00       	mov    $0x1,%eax
  10208b:	8a 4d f0             	mov    -0x10(%ebp),%cl
  10208e:	d3 e0                	shl    %cl,%eax
  102090:	48                   	dec    %eax
  102091:	89 83 44 04 00 00    	mov    %eax,0x444(%ebx)
	}

	_gpio_sch_manage_callback(dev);
  102097:	8b 45 08             	mov    0x8(%ebp),%eax
  10209a:	e8 2a fe ff ff       	call   101ec9 <_gpio_sch_manage_callback>

	return 0;
  10209f:	31 c0                	xor    %eax,%eax
}
  1020a1:	5a                   	pop    %edx
  1020a2:	5b                   	pop    %ebx
  1020a3:	5e                   	pop    %esi
  1020a4:	5f                   	pop    %edi
  1020a5:	5d                   	pop    %ebp
  1020a6:	c3                   	ret    

001020a7 <_gpio_sch_poll_status>:

	return 0;
}

static void _gpio_sch_poll_status(void *arg1, void *unused1, void *unused2)
{
  1020a7:	55                   	push   %ebp
  1020a8:	89 e5                	mov    %esp,%ebp
  1020aa:	57                   	push   %edi
  1020ab:	56                   	push   %esi
  1020ac:	53                   	push   %ebx
  1020ad:	83 ec 08             	sub    $0x8,%esp
	struct device *dev = (struct device *)arg1;
	const struct gpio_sch_config *info = dev->config->config_info;
  1020b0:	8b 45 08             	mov    0x8(%ebp),%eax
  1020b3:	8b 00                	mov    (%eax),%eax
  1020b5:	8b 70 08             	mov    0x8(%eax),%esi
	struct gpio_sch_data *gpio = dev->driver_data;
  1020b8:	8b 45 08             	mov    0x8(%ebp),%eax
  1020bb:	8b 58 08             	mov    0x8(%eax),%ebx

DEFINE_MM_REG_READ(glvl, GPIO_SCH_REG_GLVL)
DEFINE_MM_REG_WRITE(glvl, GPIO_SCH_REG_GLVL)
DEFINE_MM_REG_WRITE(gtpe, GPIO_SCH_REG_GTPE)
DEFINE_MM_REG_WRITE(gtne, GPIO_SCH_REG_GTNE)
DEFINE_MM_REG_READ(gts, GPIO_SCH_REG_GTS)
  1020be:	8b 06                	mov    (%esi),%eax
  1020c0:	8d 50 1c             	lea    0x1c(%eax),%edx
static ALWAYS_INLINE
	uint32_t sys_in32(io_port_t port)
{
	uint32_t ret;

	__asm__ volatile("inl	%w1, %0;\n\t"
  1020c3:	ed                   	in     (%dx),%eax


static ALWAYS_INLINE
	void sys_out32(uint32_t data, io_port_t port)
{
	__asm__ volatile("outl	%0, %w1;\n\t"
  1020c4:	ef                   	out    %eax,(%dx)
		/* It's not documented but writing the same status value
		 * into GTS tells to the controller it got handled.
		 */
		_write_gts(status, info->regs);
loop:
		k_timer_start(&gpio->poll_timer, GPIO_SCH_POLLING_MSEC, 0);
  1020c5:	8d bb 08 04 00 00    	lea    0x408(%ebx),%edi
	ARG_UNUSED(unused2);

	/* Cleaning up GTS first */
	_write_gts(_read_gts(info->regs), info->regs);

	while (gpio->poll) {
  1020cb:	80 bb 48 04 00 00 00 	cmpb   $0x0,0x448(%ebx)
  1020d2:	74 53                	je     102127 <_gpio_sch_poll_status+0x80>
static ALWAYS_INLINE
	uint32_t sys_in32(io_port_t port)
{
	uint32_t ret;

	__asm__ volatile("inl	%w1, %0;\n\t"
  1020d4:	8b 06                	mov    (%esi),%eax
  1020d6:	8d 50 1c             	lea    0x1c(%eax),%edx
  1020d9:	ed                   	in     (%dx),%eax
		uint32_t status;

		status = _read_gts(info->regs);
		if (!status) {
  1020da:	85 c0                	test   %eax,%eax
  1020dc:	74 30                	je     10210e <_gpio_sch_poll_status+0x67>
  1020de:	8b 93 00 04 00 00    	mov    0x400(%ebx),%edx
					uint32_t pins)
{
	struct gpio_callback *cb;
	sys_snode_t *node;

	SYS_SLIST_FOR_EACH_NODE(list, node) {
  1020e4:	85 d2                	test   %edx,%edx
  1020e6:	74 20                	je     102108 <_gpio_sch_poll_status+0x61>
		cb = (struct gpio_callback *)node;

		if (cb->pin_mask & pins) {
  1020e8:	85 42 08             	test   %eax,0x8(%edx)
  1020eb:	74 17                	je     102104 <_gpio_sch_poll_status+0x5d>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, pins);
  1020ed:	50                   	push   %eax
  1020ee:	52                   	push   %edx
  1020ef:	ff 75 08             	pushl  0x8(%ebp)
  1020f2:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1020f5:	89 55 f0             	mov    %edx,-0x10(%ebp)
  1020f8:	ff 52 04             	call   *0x4(%edx)
  1020fb:	83 c4 0c             	add    $0xc,%esp
  1020fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102101:	8b 55 f0             	mov    -0x10(%ebp),%edx
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node)
{
	return !node ? NULL : node->next;
  102104:	8b 12                	mov    (%edx),%edx
  102106:	eb dc                	jmp    1020e4 <_gpio_sch_poll_status+0x3d>


static ALWAYS_INLINE
	void sys_out32(uint32_t data, io_port_t port)
{
	__asm__ volatile("outl	%0, %w1;\n\t"
  102108:	8b 0e                	mov    (%esi),%ecx
  10210a:	8d 51 1c             	lea    0x1c(%ecx),%edx
  10210d:	ef                   	out    %eax,(%dx)
		/* It's not documented but writing the same status value
		 * into GTS tells to the controller it got handled.
		 */
		_write_gts(status, info->regs);
loop:
		k_timer_start(&gpio->poll_timer, GPIO_SCH_POLLING_MSEC, 0);
  10210e:	6a 00                	push   $0x0
  102110:	68 c8 00 00 00       	push   $0xc8
  102115:	57                   	push   %edi
  102116:	e8 ae 23 00 00       	call   1044c9 <k_timer_start>
  10211b:	83 c4 0c             	add    $0xc,%esp
		k_timer_status_sync(&gpio->poll_timer);
  10211e:	57                   	push   %edi
  10211f:	e8 1f 24 00 00       	call   104543 <k_timer_status_sync>
  102124:	58                   	pop    %eax
  102125:	eb a4                	jmp    1020cb <_gpio_sch_poll_status+0x24>
	}
}
  102127:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10212a:	5b                   	pop    %ebx
  10212b:	5e                   	pop    %esi
  10212c:	5f                   	pop    %edi
  10212d:	5d                   	pop    %ebp
  10212e:	c3                   	ret    

0010212f <_gpio_pin_config>:
	*reg &= ~(BIT(pin));
	*reg |= (set << pin) & BIT(pin);
}

static void _gpio_pin_config(struct device *dev, uint32_t pin, int flags)
{
  10212f:	55                   	push   %ebp
  102130:	89 e5                	mov    %esp,%ebp
  102132:	57                   	push   %edi
  102133:	56                   	push   %esi
  102134:	53                   	push   %ebx
  102135:	53                   	push   %ebx
  102136:	89 55 f0             	mov    %edx,-0x10(%ebp)
	const struct gpio_sch_config *info = dev->config->config_info;
  102139:	8b 10                	mov    (%eax),%edx
	*reg &= ~(BIT(pin));
	*reg |= (set << pin) & BIT(pin);
}

static void _gpio_pin_config(struct device *dev, uint32_t pin, int flags)
{
  10213b:	89 cb                	mov    %ecx,%ebx
	const struct gpio_sch_config *info = dev->config->config_info;
	struct gpio_sch_data *gpio = dev->driver_data;
  10213d:	8b 70 08             	mov    0x8(%eax),%esi
					    uint32_t bit, uint8_t set)  \
	{                                                               \
		_set_bit(addr + __off, bit, set);                       \
	}

DEFINE_MM_REG_SET_BIT(gen, GPIO_SCH_REG_GEN)
  102140:	b9 01 00 00 00       	mov    $0x1,%ecx
	*reg |= (set << pin) & BIT(pin);
}

static void _gpio_pin_config(struct device *dev, uint32_t pin, int flags)
{
	const struct gpio_sch_config *info = dev->config->config_info;
  102145:	8b 7a 08             	mov    0x8(%edx),%edi
					    uint32_t bit, uint8_t set)  \
	{                                                               \
		_set_bit(addr + __off, bit, set);                       \
	}

DEFINE_MM_REG_SET_BIT(gen, GPIO_SCH_REG_GEN)
  102148:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10214b:	8b 07                	mov    (%edi),%eax
  10214d:	e8 49 fe ff ff       	call   101f9b <_set_bit>
  102152:	89 d9                	mov    %ebx,%ecx
  102154:	83 e1 01             	and    $0x1,%ecx
DEFINE_MM_REG_SET_BIT(gio, GPIO_SCH_REG_GIO)
  102157:	8b 07                	mov    (%edi),%eax
  102159:	83 f1 01             	xor    $0x1,%ecx
  10215c:	83 c0 04             	add    $0x4,%eax
  10215f:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102162:	e8 34 fe ff ff       	call   101f9b <_set_bit>
	uint8_t active_low = 0;

	_set_bit_gen(info->regs, pin, 1);
	_set_bit_gio(info->regs, pin, !(flags & GPIO_DIR_MASK));

	if (flags & GPIO_INT) {
  102167:	f6 c3 02             	test   $0x2,%bl
  10216a:	74 0e                	je     10217a <_gpio_pin_config+0x4b>
		if (flags & GPIO_INT_ACTIVE_HIGH) {
  10216c:	83 e3 04             	and    $0x4,%ebx
			active_high = 1;
		} else {
			active_low = 1;
  10216f:	83 fb 01             	cmp    $0x1,%ebx
  102172:	0f 92 c2             	setb   %dl
  102175:	19 c0                	sbb    %eax,%eax
  102177:	40                   	inc    %eax
  102178:	eb 04                	jmp    10217e <_gpio_pin_config+0x4f>
static void _gpio_pin_config(struct device *dev, uint32_t pin, int flags)
{
	const struct gpio_sch_config *info = dev->config->config_info;
	struct gpio_sch_data *gpio = dev->driver_data;
	uint8_t active_high = 0;
	uint8_t active_low = 0;
  10217a:	31 d2                	xor    %edx,%edx

static void _gpio_pin_config(struct device *dev, uint32_t pin, int flags)
{
	const struct gpio_sch_config *info = dev->config->config_info;
	struct gpio_sch_data *gpio = dev->driver_data;
	uint8_t active_high = 0;
  10217c:	31 c0                	xor    %eax,%eax
DEFINE_MM_REG_SET_BIT(gtpe, GPIO_SCH_REG_GTPE)
DEFINE_MM_REG_SET_BIT(gtne, GPIO_SCH_REG_GTNE)

static inline void _set_data_reg(uint32_t *reg, uint8_t pin, uint8_t set)
{
	*reg &= ~(BIT(pin));
  10217e:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
	*reg |= (set << pin) & BIT(pin);
  102182:	0f b6 c0             	movzbl %al,%eax
DEFINE_MM_REG_SET_BIT(gtpe, GPIO_SCH_REG_GTPE)
DEFINE_MM_REG_SET_BIT(gtne, GPIO_SCH_REG_GTNE)

static inline void _set_data_reg(uint32_t *reg, uint8_t pin, uint8_t set)
{
	*reg &= ~(BIT(pin));
  102185:	8b 9e 3c 04 00 00    	mov    0x43c(%esi),%ebx
  10218b:	bf 01 00 00 00       	mov    $0x1,%edi
	*reg |= (set << pin) & BIT(pin);
  102190:	d3 e0                	shl    %cl,%eax
DEFINE_MM_REG_SET_BIT(gtpe, GPIO_SCH_REG_GTPE)
DEFINE_MM_REG_SET_BIT(gtne, GPIO_SCH_REG_GTNE)

static inline void _set_data_reg(uint32_t *reg, uint8_t pin, uint8_t set)
{
	*reg &= ~(BIT(pin));
  102192:	d3 e7                	shl    %cl,%edi
	*reg |= (set << pin) & BIT(pin);
  102194:	31 d8                	xor    %ebx,%eax
  102196:	21 f8                	and    %edi,%eax
  102198:	0f b6 d2             	movzbl %dl,%edx
  10219b:	31 c3                	xor    %eax,%ebx
DEFINE_MM_REG_SET_BIT(gtpe, GPIO_SCH_REG_GTPE)
DEFINE_MM_REG_SET_BIT(gtne, GPIO_SCH_REG_GTNE)

static inline void _set_data_reg(uint32_t *reg, uint8_t pin, uint8_t set)
{
	*reg &= ~(BIT(pin));
  10219d:	8b 86 40 04 00 00    	mov    0x440(%esi),%eax
	*reg |= (set << pin) & BIT(pin);
  1021a3:	d3 e2                	shl    %cl,%edx
  1021a5:	31 c2                	xor    %eax,%edx
  1021a7:	89 9e 3c 04 00 00    	mov    %ebx,0x43c(%esi)
  1021ad:	21 fa                	and    %edi,%edx
  1021af:	31 d0                	xor    %edx,%eax
  1021b1:	89 86 40 04 00 00    	mov    %eax,0x440(%esi)
	/* We store the gtpe/gtne settings. These will be used once
	 * we enable the callback for the pin, or the whole port
	 */
	_set_data_reg(&gpio->int_regs.gtpe, pin, active_high);
	_set_data_reg(&gpio->int_regs.gtne, pin, active_low);
}
  1021b7:	58                   	pop    %eax
  1021b8:	5b                   	pop    %ebx
  1021b9:	5e                   	pop    %esi
  1021ba:	5f                   	pop    %edi
  1021bb:	5d                   	pop    %ebp
  1021bc:	c3                   	ret    

001021bd <gpio_sch_config>:
	}
}

static int gpio_sch_config(struct device *dev,
			   int access_op, uint32_t pin, int flags)
{
  1021bd:	55                   	push   %ebp
  1021be:	89 e5                	mov    %esp,%ebp
  1021c0:	57                   	push   %edi
  1021c1:	56                   	push   %esi
  1021c2:	53                   	push   %ebx
  1021c3:	8b 75 08             	mov    0x8(%ebp),%esi
  1021c6:	31 db                	xor    %ebx,%ebx
  1021c8:	8b 55 10             	mov    0x10(%ebp),%edx
	const struct gpio_sch_config *info = dev->config->config_info;
  1021cb:	8b 06                	mov    (%esi),%eax

	if (access_op == GPIO_ACCESS_BY_PIN) {
  1021cd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
}

static int gpio_sch_config(struct device *dev,
			   int access_op, uint32_t pin, int flags)
{
	const struct gpio_sch_config *info = dev->config->config_info;
  1021d1:	8b 78 08             	mov    0x8(%eax),%edi

	if (access_op == GPIO_ACCESS_BY_PIN) {
  1021d4:	75 19                	jne    1021ef <gpio_sch_config+0x32>
		if (pin >= info->bits) {
  1021d6:	0f b6 4f 04          	movzbl 0x4(%edi),%ecx
			return -EINVAL;
  1021da:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
			   int access_op, uint32_t pin, int flags)
{
	const struct gpio_sch_config *info = dev->config->config_info;

	if (access_op == GPIO_ACCESS_BY_PIN) {
		if (pin >= info->bits) {
  1021df:	39 d1                	cmp    %edx,%ecx
  1021e1:	76 25                	jbe    102208 <gpio_sch_config+0x4b>
			return -EINVAL;
		}

		_gpio_pin_config(dev, pin, flags);
  1021e3:	8b 4d 14             	mov    0x14(%ebp),%ecx
  1021e6:	89 f0                	mov    %esi,%eax
  1021e8:	e8 42 ff ff ff       	call   10212f <_gpio_pin_config>
  1021ed:	eb 17                	jmp    102206 <gpio_sch_config+0x49>
static inline void _gpio_port_config(struct device *dev, int flags)
{
	const struct gpio_sch_config *info = dev->config->config_info;
	int pin;

	for (pin = 0; pin < info->bits; pin++) {
  1021ef:	0f b6 47 04          	movzbl 0x4(%edi),%eax
  1021f3:	39 c3                	cmp    %eax,%ebx
  1021f5:	7d 0f                	jge    102206 <gpio_sch_config+0x49>
		_gpio_pin_config(dev, pin, flags);
  1021f7:	89 da                	mov    %ebx,%edx
  1021f9:	8b 4d 14             	mov    0x14(%ebp),%ecx
  1021fc:	89 f0                	mov    %esi,%eax
static inline void _gpio_port_config(struct device *dev, int flags)
{
	const struct gpio_sch_config *info = dev->config->config_info;
	int pin;

	for (pin = 0; pin < info->bits; pin++) {
  1021fe:	43                   	inc    %ebx
		_gpio_pin_config(dev, pin, flags);
  1021ff:	e8 2b ff ff ff       	call   10212f <_gpio_pin_config>
  102204:	eb e9                	jmp    1021ef <gpio_sch_config+0x32>
		_gpio_pin_config(dev, pin, flags);
	} else {
		_gpio_port_config(dev, flags);
	}

	return 0;
  102206:	31 c0                	xor    %eax,%eax
}
  102208:	5b                   	pop    %ebx
  102209:	5e                   	pop    %esi
  10220a:	5f                   	pop    %edi
  10220b:	5d                   	pop    %ebp
  10220c:	c3                   	ret    

0010220d <gpio_sch_disable_callback>:
	return 0;
}

static int gpio_sch_disable_callback(struct device *dev,
				     int access_op, uint32_t pin)
{
  10220d:	55                   	push   %ebp
  10220e:	89 e5                	mov    %esp,%ebp
  102210:	57                   	push   %edi
  102211:	56                   	push   %esi
  102212:	53                   	push   %ebx
  102213:	8b 75 08             	mov    0x8(%ebp),%esi
	const struct gpio_sch_config *info = dev->config->config_info;
	struct gpio_sch_data *gpio = dev->driver_data;

	if (access_op == GPIO_ACCESS_BY_PIN) {
  102216:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
}

static int gpio_sch_disable_callback(struct device *dev,
				     int access_op, uint32_t pin)
{
	const struct gpio_sch_config *info = dev->config->config_info;
  10221a:	8b 06                	mov    (%esi),%eax
	struct gpio_sch_data *gpio = dev->driver_data;
  10221c:	8b 7e 08             	mov    0x8(%esi),%edi
}

static int gpio_sch_disable_callback(struct device *dev,
				     int access_op, uint32_t pin)
{
	const struct gpio_sch_config *info = dev->config->config_info;
  10221f:	8b 58 08             	mov    0x8(%eax),%ebx
	struct gpio_sch_data *gpio = dev->driver_data;

	if (access_op == GPIO_ACCESS_BY_PIN) {
  102222:	75 3e                	jne    102262 <gpio_sch_disable_callback+0x55>
		if (pin >= info->bits) {
  102224:	0f b6 53 04          	movzbl 0x4(%ebx),%edx
			return -ENOTSUP;
  102228:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
{
	const struct gpio_sch_config *info = dev->config->config_info;
	struct gpio_sch_data *gpio = dev->driver_data;

	if (access_op == GPIO_ACCESS_BY_PIN) {
		if (pin >= info->bits) {
  10222d:	3b 55 10             	cmp    0x10(%ebp),%edx
  102230:	76 4f                	jbe    102281 <gpio_sch_disable_callback+0x74>
	}

DEFINE_MM_REG_SET_BIT(gen, GPIO_SCH_REG_GEN)
DEFINE_MM_REG_SET_BIT(gio, GPIO_SCH_REG_GIO)
DEFINE_MM_REG_SET_BIT(glvl, GPIO_SCH_REG_GLVL)
DEFINE_MM_REG_SET_BIT(gtpe, GPIO_SCH_REG_GTPE)
  102232:	8b 03                	mov    (%ebx),%eax
  102234:	31 c9                	xor    %ecx,%ecx
  102236:	83 c0 0c             	add    $0xc,%eax
  102239:	8b 55 10             	mov    0x10(%ebp),%edx
  10223c:	e8 5a fd ff ff       	call   101f9b <_set_bit>
DEFINE_MM_REG_SET_BIT(gtne, GPIO_SCH_REG_GTNE)
  102241:	8b 03                	mov    (%ebx),%eax
  102243:	83 c0 10             	add    $0x10,%eax
  102246:	31 c9                	xor    %ecx,%ecx
  102248:	8b 55 10             	mov    0x10(%ebp),%edx
  10224b:	e8 4b fd ff ff       	call   101f9b <_set_bit>
		}

		_set_bit_gtpe(info->regs, pin, 0);
		_set_bit_gtne(info->regs, pin, 0);

		gpio->cb_enabled &= ~BIT(pin);
  102250:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  102255:	8a 4d 10             	mov    0x10(%ebp),%cl
  102258:	d3 c0                	rol    %cl,%eax
  10225a:	21 87 44 04 00 00    	and    %eax,0x444(%edi)
  102260:	eb 16                	jmp    102278 <gpio_sch_disable_callback+0x6b>
	} else {
		_write_gtpe(0, info->regs);
  102262:	8b 0b                	mov    (%ebx),%ecx
  102264:	31 c0                	xor    %eax,%eax
  102266:	8d 51 0c             	lea    0xc(%ecx),%edx
  102269:	ef                   	out    %eax,(%dx)
  10226a:	8d 51 10             	lea    0x10(%ecx),%edx
  10226d:	ef                   	out    %eax,(%dx)
		_write_gtne(0, info->regs);

		gpio->cb_enabled = 0;
  10226e:	c7 87 44 04 00 00 00 	movl   $0x0,0x444(%edi)
  102275:	00 00 00 
	}

	_gpio_sch_manage_callback(dev);
  102278:	89 f0                	mov    %esi,%eax
  10227a:	e8 4a fc ff ff       	call   101ec9 <_gpio_sch_manage_callback>

	return 0;
  10227f:	31 c0                	xor    %eax,%eax
}
  102281:	5b                   	pop    %ebx
  102282:	5e                   	pop    %esi
  102283:	5f                   	pop    %edi
  102284:	5d                   	pop    %ebp
  102285:	c3                   	ret    

00102286 <i2c_dw_runtime_configure>:

	return ret;
}

static int i2c_dw_runtime_configure(struct device *dev, uint32_t config)
{
  102286:	55                   	push   %ebp
  102287:	89 e5                	mov    %esp,%ebp
  102289:	53                   	push   %ebx
	struct i2c_dw_dev_config * const dw = dev->driver_data;
  10228a:	8b 55 08             	mov    0x8(%ebp),%edx

	return ret;
}

static int i2c_dw_runtime_configure(struct device *dev, uint32_t config)
{
  10228d:	8b 45 0c             	mov    0xc(%ebp),%eax
	struct i2c_dw_dev_config * const dw = dev->driver_data;
  102290:	8b 4a 08             	mov    0x8(%edx),%ecx
	uint32_t	rc = 0;

	volatile struct i2c_dw_registers * const regs =
		(struct i2c_dw_registers *)dw->base_address;

	dw->app_config.raw = config;
  102293:	89 41 14             	mov    %eax,0x14(%ecx)
{
	struct i2c_dw_dev_config * const dw = dev->driver_data;
	uint32_t	value = 0;
	uint32_t	rc = 0;

	volatile struct i2c_dw_registers * const regs =
  102296:	8b 11                	mov    (%ecx),%edx

	dw->app_config.raw = config;

	/* Make sure we have a supported speed for the DesignWare model */
	/* and have setup the clock frequency and speed mode */
	switch (dw->app_config.bits.speed) {
  102298:	d0 e8                	shr    %al
  10229a:	83 e0 07             	and    $0x7,%eax
  10229d:	3c 03                	cmp    $0x3,%al
  10229f:	77 0d                	ja     1022ae <i2c_dw_runtime_configure+0x28>
  1022a1:	3c 02                	cmp    $0x2,%al
  1022a3:	73 45                	jae    1022ea <i2c_dw_runtime_configure+0x64>
  1022a5:	fe c8                	dec    %al
  1022a7:	74 0e                	je     1022b7 <i2c_dw_runtime_configure+0x31>
  1022a9:	e9 c6 00 00 00       	jmp    102374 <i2c_dw_runtime_configure+0xee>
  1022ae:	3c 04                	cmp    $0x4,%al
  1022b0:	74 73                	je     102325 <i2c_dw_runtime_configure+0x9f>
  1022b2:	e9 bd 00 00 00       	jmp    102374 <i2c_dw_runtime_configure+0xee>
	case I2C_SPEED_STANDARD:
		/* Following the directions on DW spec page 59, IC_SS_SCL_LCNT
		 * must have register values larger than IC_FS_SPKLEN + 7
		 */
		if (I2C_STD_LCNT <= (regs->ic_fs_spklen + 7)) {
  1022b7:	8b 9a a0 00 00 00    	mov    0xa0(%edx),%ebx
			value = regs->ic_fs_spklen + 8;
		} else {
			value = I2C_STD_LCNT;
  1022bd:	b8 7d 00 00 00       	mov    $0x7d,%eax
	switch (dw->app_config.bits.speed) {
	case I2C_SPEED_STANDARD:
		/* Following the directions on DW spec page 59, IC_SS_SCL_LCNT
		 * must have register values larger than IC_FS_SPKLEN + 7
		 */
		if (I2C_STD_LCNT <= (regs->ic_fs_spklen + 7)) {
  1022c2:	83 c3 07             	add    $0x7,%ebx
  1022c5:	83 fb 7c             	cmp    $0x7c,%ebx
  1022c8:	76 09                	jbe    1022d3 <i2c_dw_runtime_configure+0x4d>
			value = regs->ic_fs_spklen + 8;
  1022ca:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
  1022d0:	83 c0 08             	add    $0x8,%eax
		dw->lcnt = value;

		/* Following the directions on DW spec page 59, IC_SS_SCL_HCNT
		 * must have register values larger than IC_FS_SPKLEN + 5
		 */
		if (I2C_STD_HCNT <= (regs->ic_fs_spklen + 5)) {
  1022d3:	8b 9a a0 00 00 00    	mov    0xa0(%edx),%ebx
			value = regs->ic_fs_spklen + 8;
		} else {
			value = I2C_STD_LCNT;
		}

		dw->lcnt = value;
  1022d9:	66 89 41 26          	mov    %ax,0x26(%ecx)

		/* Following the directions on DW spec page 59, IC_SS_SCL_HCNT
		 * must have register values larger than IC_FS_SPKLEN + 5
		 */
		if (I2C_STD_HCNT <= (regs->ic_fs_spklen + 5)) {
  1022dd:	83 c3 05             	add    $0x5,%ebx
			value = regs->ic_fs_spklen + 6;
		} else {
			value = I2C_STD_HCNT;
  1022e0:	b8 64 00 00 00       	mov    $0x64,%eax
		dw->lcnt = value;

		/* Following the directions on DW spec page 59, IC_SS_SCL_HCNT
		 * must have register values larger than IC_FS_SPKLEN + 5
		 */
		if (I2C_STD_HCNT <= (regs->ic_fs_spklen + 5)) {
  1022e5:	83 fb 63             	cmp    $0x63,%ebx
  1022e8:	eb 31                	jmp    10231b <i2c_dw_runtime_configure+0x95>
	case I2C_SPEED_FAST_PLUS:
		/*
		 * Following the directions on DW spec page 59, IC_FS_SCL_LCNT
		 * must have register values larger than IC_FS_SPKLEN + 7
		 */
		if (I2C_FS_LCNT <= (regs->ic_fs_spklen + 7)) {
  1022ea:	8b 9a a0 00 00 00    	mov    0xa0(%edx),%ebx
			value = regs->ic_fs_spklen + 8;
		} else {
			value = I2C_FS_LCNT;
  1022f0:	b8 15 00 00 00       	mov    $0x15,%eax
	case I2C_SPEED_FAST_PLUS:
		/*
		 * Following the directions on DW spec page 59, IC_FS_SCL_LCNT
		 * must have register values larger than IC_FS_SPKLEN + 7
		 */
		if (I2C_FS_LCNT <= (regs->ic_fs_spklen + 7)) {
  1022f5:	83 c3 07             	add    $0x7,%ebx
  1022f8:	83 fb 14             	cmp    $0x14,%ebx
  1022fb:	76 09                	jbe    102306 <i2c_dw_runtime_configure+0x80>
			value = regs->ic_fs_spklen + 8;
  1022fd:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
  102303:	83 c0 08             	add    $0x8,%eax

		/*
		 * Following the directions on DW spec page 59, IC_FS_SCL_HCNT
		 * must have register values larger than IC_FS_SPKLEN + 5
		 */
		if (I2C_FS_HCNT <= (regs->ic_fs_spklen + 5)) {
  102306:	8b 9a a0 00 00 00    	mov    0xa0(%edx),%ebx
			value = regs->ic_fs_spklen + 8;
		} else {
			value = I2C_FS_LCNT;
		}

		dw->lcnt = value;
  10230c:	66 89 41 26          	mov    %ax,0x26(%ecx)

		/*
		 * Following the directions on DW spec page 59, IC_FS_SCL_HCNT
		 * must have register values larger than IC_FS_SPKLEN + 5
		 */
		if (I2C_FS_HCNT <= (regs->ic_fs_spklen + 5)) {
  102310:	83 c3 05             	add    $0x5,%ebx
			value = regs->ic_fs_spklen + 6;
		} else {
			value = I2C_FS_HCNT;
  102313:	b8 12 00 00 00       	mov    $0x12,%eax

		/*
		 * Following the directions on DW spec page 59, IC_FS_SCL_HCNT
		 * must have register values larger than IC_FS_SPKLEN + 5
		 */
		if (I2C_FS_HCNT <= (regs->ic_fs_spklen + 5)) {
  102318:	83 fb 11             	cmp    $0x11,%ebx
  10231b:	76 4f                	jbe    10236c <i2c_dw_runtime_configure+0xe6>
			value = regs->ic_fs_spklen + 6;
  10231d:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
  102323:	eb 44                	jmp    102369 <i2c_dw_runtime_configure+0xe3>
				value = I2C_HS_HCNT;
			}

			dw->hcnt = value;
		} else {
			rc = -EINVAL;
  102325:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
		}

		dw->hcnt = value;
		break;
	case I2C_SPEED_HIGH:
		if (dw->support_hs_mode) {
  10232a:	80 79 2b 00          	cmpb   $0x0,0x2b(%ecx)
  10232e:	74 49                	je     102379 <i2c_dw_runtime_configure+0xf3>
			if (I2C_HS_LCNT <= (regs->ic_hs_spklen + 7)) {
  102330:	8b 9a a4 00 00 00    	mov    0xa4(%edx),%ebx
				value = regs->ic_hs_spklen + 8;
			} else {
				value = I2C_HS_LCNT;
  102336:	b8 15 00 00 00       	mov    $0x15,%eax

		dw->hcnt = value;
		break;
	case I2C_SPEED_HIGH:
		if (dw->support_hs_mode) {
			if (I2C_HS_LCNT <= (regs->ic_hs_spklen + 7)) {
  10233b:	83 c3 07             	add    $0x7,%ebx
  10233e:	83 fb 14             	cmp    $0x14,%ebx
  102341:	76 09                	jbe    10234c <i2c_dw_runtime_configure+0xc6>
				value = regs->ic_hs_spklen + 8;
  102343:	8b 82 a4 00 00 00    	mov    0xa4(%edx),%eax
  102349:	83 c0 08             	add    $0x8,%eax
				value = I2C_HS_LCNT;
			}

			dw->lcnt = value;

			if (I2C_HS_HCNT <= (regs->ic_hs_spklen + 5)) {
  10234c:	8b 9a a4 00 00 00    	mov    0xa4(%edx),%ebx
				value = regs->ic_hs_spklen + 8;
			} else {
				value = I2C_HS_LCNT;
			}

			dw->lcnt = value;
  102352:	66 89 41 26          	mov    %ax,0x26(%ecx)

			if (I2C_HS_HCNT <= (regs->ic_hs_spklen + 5)) {
  102356:	83 c3 05             	add    $0x5,%ebx
				value = regs->ic_hs_spklen + 6;
			} else {
				value = I2C_HS_HCNT;
  102359:	b8 12 00 00 00       	mov    $0x12,%eax
				value = I2C_HS_LCNT;
			}

			dw->lcnt = value;

			if (I2C_HS_HCNT <= (regs->ic_hs_spklen + 5)) {
  10235e:	83 fb 11             	cmp    $0x11,%ebx
  102361:	76 09                	jbe    10236c <i2c_dw_runtime_configure+0xe6>
				value = regs->ic_hs_spklen + 6;
  102363:	8b 82 a4 00 00 00    	mov    0xa4(%edx),%eax
  102369:	83 c0 06             	add    $0x6,%eax
			} else {
				value = I2C_HS_HCNT;
			}

			dw->hcnt = value;
  10236c:	66 89 41 24          	mov    %ax,0x24(%ecx)

static int i2c_dw_runtime_configure(struct device *dev, uint32_t config)
{
	struct i2c_dw_dev_config * const dw = dev->driver_data;
	uint32_t	value = 0;
	uint32_t	rc = 0;
  102370:	31 c0                	xor    %eax,%eax
  102372:	eb 05                	jmp    102379 <i2c_dw_runtime_configure+0xf3>
			rc = -EINVAL;
		}
		break;
	default:
		/* TODO change */
		rc = -EINVAL;
  102374:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	}

	/*
	 * Clear any interrupts currently waiting in the controller
	 */
	value = regs->ic_clr_intr;
  102379:	66 8b 52 40          	mov    0x40(%edx),%dx
	/*
	 * TEMPORARY HACK - The I2C does not work in any mode other than Master
	 * currently.  This "hack" forces us to always be configured for master
	 * mode, until we can verify that Slave mode works correctly.
	 */
	dw->app_config.bits.is_master_device = 1;
  10237d:	80 49 14 10          	orb    $0x10,0x14(%ecx)

	return rc;
}
  102381:	5b                   	pop    %ebx
  102382:	5d                   	pop    %ebp
  102383:	c3                   	ret    

00102384 <i2c_dw_transfer>:
}

static int i2c_dw_transfer(struct device *dev,
			   struct i2c_msg *msgs, uint8_t num_msgs,
			   uint16_t slave_address)
{
  102384:	55                   	push   %ebp
  102385:	89 e5                	mov    %esp,%ebp
  102387:	57                   	push   %edi
  102388:	56                   	push   %esi
  102389:	53                   	push   %ebx
  10238a:	83 ec 08             	sub    $0x8,%esp
	struct i2c_dw_dev_config * const dw = dev->driver_data;
  10238d:	8b 7d 08             	mov    0x8(%ebp),%edi
}

static int i2c_dw_transfer(struct device *dev,
			   struct i2c_msg *msgs, uint8_t num_msgs,
			   uint16_t slave_address)
{
  102390:	8b 75 14             	mov    0x14(%ebp),%esi
  102393:	8b 45 10             	mov    0x10(%ebp),%eax
  102396:	89 75 ec             	mov    %esi,-0x14(%ebp)
	struct i2c_dw_dev_config * const dw = dev->driver_data;
  102399:	8b 5f 08             	mov    0x8(%edi),%ebx
}

static int i2c_dw_transfer(struct device *dev,
			   struct i2c_msg *msgs, uint8_t num_msgs,
			   uint16_t slave_address)
{
  10239c:	88 45 f3             	mov    %al,-0xd(%ebp)

	volatile struct i2c_dw_registers * const regs =
		(struct i2c_dw_registers *)dw->base_address;

	/* Why bother processing no messages */
	if (!msgs || !num_msgs) {
  10239f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
	struct i2c_msg *cur_msg = msgs;
	uint8_t msg_left = num_msgs;
	uint8_t pflags;
	int ret;

	volatile struct i2c_dw_registers * const regs =
  1023a3:	8b 33                	mov    (%ebx),%esi
		(struct i2c_dw_registers *)dw->base_address;

	/* Why bother processing no messages */
	if (!msgs || !num_msgs) {
  1023a5:	0f 84 e1 01 00 00    	je     10258c <i2c_dw_transfer+0x208>
  1023ab:	84 c0                	test   %al,%al
  1023ad:	0f 84 d9 01 00 00    	je     10258c <i2c_dw_transfer+0x208>
		return -ENOTSUP;
	}

	/* First step, check if there is current activity */
	if ((regs->ic_status.bits.activity) || (dw->state & I2C_DW_BUSY)) {
  1023b3:	8b 56 70             	mov    0x70(%esi),%edx
		return -EIO;
  1023b6:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	if (!msgs || !num_msgs) {
		return -ENOTSUP;
	}

	/* First step, check if there is current activity */
	if ((regs->ic_status.bits.activity) || (dw->state & I2C_DW_BUSY)) {
  1023bb:	80 e2 01             	and    $0x1,%dl
  1023be:	0f 85 cd 01 00 00    	jne    102591 <i2c_dw_transfer+0x20d>
  1023c4:	8a 53 28             	mov    0x28(%ebx),%dl
  1023c7:	80 e2 08             	and    $0x8,%dl
  1023ca:	0f 85 c1 01 00 00    	jne    102591 <i2c_dw_transfer+0x20d>
		return -EIO;
	}

	dw->state |= I2C_DW_BUSY;
  1023d0:	8a 43 28             	mov    0x28(%ebx),%al
	uint32_t value;
	union ic_con_register ic_con;
	volatile struct i2c_dw_registers * const regs =
		(struct i2c_dw_registers *)dw->base_address;

	ic_con.raw = 0;
  1023d3:	31 d2                	xor    %edx,%edx
	/* First step, check if there is current activity */
	if ((regs->ic_status.bits.activity) || (dw->state & I2C_DW_BUSY)) {
		return -EIO;
	}

	dw->state |= I2C_DW_BUSY;
  1023d5:	83 c8 08             	or     $0x8,%eax
  1023d8:	88 43 28             	mov    %al,0x28(%ebx)
}


static int _i2c_dw_setup(struct device *dev, uint16_t slave_address)
{
	struct i2c_dw_dev_config * const dw = dev->driver_data;
  1023db:	8b 7f 08             	mov    0x8(%edi),%edi
	uint32_t value;
	union ic_con_register ic_con;
	volatile struct i2c_dw_registers * const regs =
  1023de:	8b 07                	mov    (%edi),%eax
		(struct i2c_dw_registers *)dw->base_address;

	ic_con.raw = 0;

	/* Disable the device controller to be able set TAR */
	regs->ic_enable.bits.enable = 0;
  1023e0:	66 8b 48 6c          	mov    0x6c(%eax),%cx
  1023e4:	83 e1 fe             	and    $0xfffffffe,%ecx
  1023e7:	66 89 48 6c          	mov    %cx,0x6c(%eax)

	/* Disable interrupts */
	regs->ic_intr_mask.raw = 0;
  1023eb:	66 c7 40 30 00 00    	movw   $0x0,0x30(%eax)

	/* Clear interrupts */
	value = regs->ic_clr_intr;
  1023f1:	66 8b 48 40          	mov    0x40(%eax),%cx

	/* Set master or slave mode - (initialization = slave) */
	if (dw->app_config.bits.is_master_device) {
  1023f5:	8a 4f 14             	mov    0x14(%edi),%cl
  1023f8:	f6 c1 10             	test   $0x10,%cl
  1023fb:	74 05                	je     102402 <i2c_dw_transfer+0x7e>
		 * Make sure to set both the master_mode and slave_disable_bit
		 * to both 0 or both 1
		 */
		SYS_LOG_DBG("I2C: host configured as Master Device");
		ic_con.bits.master_mode = 1;
		ic_con.bits.slave_disable = 1;
  1023fd:	ba 41 00 00 00       	mov    $0x41,%edx
	}

	ic_con.bits.restart_en = 1;
  102402:	83 ca 20             	or     $0x20,%edx

	/* Set addressing mode - (initialization = 7 bit) */
	if (dw->app_config.bits.use_10_bit_addr) {
  102405:	f6 c1 01             	test   $0x1,%cl
  102408:	74 03                	je     10240d <i2c_dw_transfer+0x89>
		SYS_LOG_DBG("I2C: using 10-bit address");
		ic_con.bits.addr_master_10bit = 1;
		ic_con.bits.addr_slave_10bit = 1;
  10240a:	83 ca 18             	or     $0x18,%edx
	}

	/* Setup the clock frequency and speed mode */
	switch (dw->app_config.bits.speed) {
  10240d:	d0 e9                	shr    %cl
  10240f:	83 e1 07             	and    $0x7,%ecx
  102412:	80 f9 03             	cmp    $0x3,%cl
  102415:	77 24                	ja     10243b <i2c_dw_transfer+0xb7>
  102417:	80 f9 02             	cmp    $0x2,%cl
  10241a:	73 26                	jae    102442 <i2c_dw_transfer+0xbe>
  10241c:	fe c9                	dec    %cl
  10241e:	0f 85 92 00 00 00    	jne    1024b6 <i2c_dw_transfer+0x132>
	case I2C_SPEED_STANDARD:
		SYS_LOG_DBG("I2C: speed set to STANDARD");
		regs->ic_ss_scl_lcnt = dw->lcnt;
  102424:	66 8b 4f 26          	mov    0x26(%edi),%cx
		regs->ic_ss_scl_hcnt = dw->hcnt;
		ic_con.bits.speed = I2C_DW_SPEED_STANDARD;
  102428:	83 e2 f9             	and    $0xfffffff9,%edx

	/* Setup the clock frequency and speed mode */
	switch (dw->app_config.bits.speed) {
	case I2C_SPEED_STANDARD:
		SYS_LOG_DBG("I2C: speed set to STANDARD");
		regs->ic_ss_scl_lcnt = dw->lcnt;
  10242b:	66 89 48 18          	mov    %cx,0x18(%eax)
		regs->ic_ss_scl_hcnt = dw->hcnt;
  10242f:	8b 4f 24             	mov    0x24(%edi),%ecx
  102432:	66 89 48 14          	mov    %cx,0x14(%eax)
		ic_con.bits.speed = I2C_DW_SPEED_STANDARD;
  102436:	83 ca 02             	or     $0x2,%edx
  102439:	eb 36                	jmp    102471 <i2c_dw_transfer+0xed>
		ic_con.bits.addr_master_10bit = 1;
		ic_con.bits.addr_slave_10bit = 1;
	}

	/* Setup the clock frequency and speed mode */
	switch (dw->app_config.bits.speed) {
  10243b:	80 f9 04             	cmp    $0x4,%cl
  10243e:	74 19                	je     102459 <i2c_dw_transfer+0xd5>
  102440:	eb 74                	jmp    1024b6 <i2c_dw_transfer+0x132>
		break;
	case I2C_SPEED_FAST:
		/* fall through */
	case I2C_SPEED_FAST_PLUS:
		SYS_LOG_DBG("I2C: speed set to FAST or FAST_PLUS");
		regs->ic_fs_scl_lcnt = dw->lcnt;
  102442:	66 8b 4f 26          	mov    0x26(%edi),%cx
		regs->ic_fs_scl_hcnt = dw->hcnt;
		ic_con.bits.speed = I2C_DW_SPEED_FAST;
  102446:	83 e2 f9             	and    $0xfffffff9,%edx
		break;
	case I2C_SPEED_FAST:
		/* fall through */
	case I2C_SPEED_FAST_PLUS:
		SYS_LOG_DBG("I2C: speed set to FAST or FAST_PLUS");
		regs->ic_fs_scl_lcnt = dw->lcnt;
  102449:	66 89 48 20          	mov    %cx,0x20(%eax)
		regs->ic_fs_scl_hcnt = dw->hcnt;
  10244d:	8b 4f 24             	mov    0x24(%edi),%ecx
  102450:	66 89 48 1c          	mov    %cx,0x1c(%eax)
		ic_con.bits.speed = I2C_DW_SPEED_FAST;
  102454:	83 ca 04             	or     $0x4,%edx
  102457:	eb 18                	jmp    102471 <i2c_dw_transfer+0xed>

		break;
	case I2C_SPEED_HIGH:
		if (!dw->support_hs_mode) {
  102459:	80 7f 2b 00          	cmpb   $0x0,0x2b(%edi)
  10245d:	74 57                	je     1024b6 <i2c_dw_transfer+0x132>
			return -EINVAL;
		}

		SYS_LOG_DBG("I2C: speed set to HIGH");
		regs->ic_hs_scl_lcnt = dw->lcnt;
  10245f:	66 8b 4f 26          	mov    0x26(%edi),%cx
		regs->ic_hs_scl_hcnt = dw->hcnt;
		ic_con.bits.speed = I2C_DW_SPEED_HIGH;
  102463:	83 ca 06             	or     $0x6,%edx
		if (!dw->support_hs_mode) {
			return -EINVAL;
		}

		SYS_LOG_DBG("I2C: speed set to HIGH");
		regs->ic_hs_scl_lcnt = dw->lcnt;
  102466:	66 89 48 28          	mov    %cx,0x28(%eax)
		regs->ic_hs_scl_hcnt = dw->hcnt;
  10246a:	8b 4f 24             	mov    0x24(%edi),%ecx
  10246d:	66 89 48 24          	mov    %cx,0x24(%eax)

	SYS_LOG_DBG("I2C: lcnt = %d", dw->lcnt);
	SYS_LOG_DBG("I2C: hcnt = %d", dw->hcnt);

	/* Set the IC_CON register */
	regs->ic_con = ic_con;
  102471:	66 89 10             	mov    %dx,(%eax)
	 * Setting it to zero automatically triggers interrupt
	 * RX_FULL whenever there is data received.
	 *
	 * TODO: extend the threshold for multi-byte RX.
	 */
	regs->ic_rx_tl = 0;
  102474:	66 c7 40 38 00 00    	movw   $0x0,0x38(%eax)
	 * the controller do the transfers for longer period
	 * before we need to fill the FIFO again. This may
	 * cause some pauses during transfers, but this keeps
	 * the device from interrupting often.
	 */
	regs->ic_tx_tl = 0;
  10247a:	66 c7 40 3c 00 00    	movw   $0x0,0x3c(%eax)

	if (regs->ic_con.bits.master_mode) {
  102480:	8b 10                	mov    (%eax),%edx
  102482:	80 e2 01             	and    $0x1,%dl
		/* Set address of target slave */
		regs->ic_tar.bits.ic_tar = slave_address;
  102485:	8b 55 ec             	mov    -0x14(%ebp),%edx
	 * cause some pauses during transfers, but this keeps
	 * the device from interrupting often.
	 */
	regs->ic_tx_tl = 0;

	if (regs->ic_con.bits.master_mode) {
  102488:	74 16                	je     1024a0 <i2c_dw_transfer+0x11c>
		/* Set address of target slave */
		regs->ic_tar.bits.ic_tar = slave_address;
  10248a:	66 81 e2 ff 01       	and    $0x1ff,%dx
  10248f:	66 8b 48 04          	mov    0x4(%eax),%cx
  102493:	66 81 e1 00 fe       	and    $0xfe00,%cx
  102498:	09 ca                	or     %ecx,%edx
  10249a:	66 89 50 04          	mov    %dx,0x4(%eax)
  10249e:	eb 24                	jmp    1024c4 <i2c_dw_transfer+0x140>
	} else {
		/* Set slave address for device */
		regs->ic_sar.bits.ic_sar = slave_address;
  1024a0:	66 81 e2 ff 01       	and    $0x1ff,%dx
  1024a5:	66 8b 48 08          	mov    0x8(%eax),%cx
  1024a9:	66 81 e1 00 fe       	and    $0xfe00,%cx
  1024ae:	09 ca                	or     %ecx,%edx
  1024b0:	66 89 50 08          	mov    %dx,0x8(%eax)
  1024b4:	eb 0e                	jmp    1024c4 <i2c_dw_transfer+0x140>
		ic_con.bits.speed = I2C_DW_SPEED_FAST;

		break;
	case I2C_SPEED_HIGH:
		if (!dw->support_hs_mode) {
			return -EINVAL;
  1024b6:	b8 ea ff ff ff       	mov    $0xffffffea,%eax

	dw->state |= I2C_DW_BUSY;

	ret = _i2c_dw_setup(dev, slave_address);
	if (ret) {
		dw->state = I2C_DW_STATE_READY;
  1024bb:	c6 43 28 00          	movb   $0x0,0x28(%ebx)
		return ret;
  1024bf:	e9 cd 00 00 00       	jmp    102591 <i2c_dw_transfer+0x20d>
	}

	/* Enable controller */
	regs->ic_enable.bits.enable = 1;
  1024c4:	66 8b 46 6c          	mov    0x6c(%esi),%ax
  1024c8:	83 c8 01             	or     $0x1,%eax
  1024cb:	66 89 46 6c          	mov    %ax,0x6c(%esi)
	 * Note : This is just a sample to show a possible use of the API, it is
	 * upto the driver expert to see, if he actually needs it here, or
	 * somewhere else, or not needed as the driver's suspend()/resume()
	 * can handle everything
	 */
	device_busy_set(dev);
  1024cf:	ff 75 08             	pushl  0x8(%ebp)
  1024d2:	e8 4e 12 00 00       	call   103725 <device_busy_set>
  1024d7:	5f                   	pop    %edi
  1024d8:	8d 7b 04             	lea    0x4(%ebx),%edi

		/* Process all the messages */
	while (msg_left > 0) {
		pflags = dw->xfr_flags;

		dw->xfr_buf = cur_msg->buf;
  1024db:	8b 45 0c             	mov    0xc(%ebp),%eax
	 */
	device_busy_set(dev);

		/* Process all the messages */
	while (msg_left > 0) {
		pflags = dw->xfr_flags;
  1024de:	8a 53 2a             	mov    0x2a(%ebx),%dl

		dw->xfr_buf = cur_msg->buf;
  1024e1:	8b 00                	mov    (%eax),%eax
  1024e3:	89 43 18             	mov    %eax,0x18(%ebx)
		dw->xfr_len = cur_msg->len;
  1024e6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1024e9:	8b 48 04             	mov    0x4(%eax),%ecx
  1024ec:	89 4b 1c             	mov    %ecx,0x1c(%ebx)
		dw->xfr_flags = cur_msg->flags;
  1024ef:	8a 40 08             	mov    0x8(%eax),%al
		dw->rx_pending = 0;
  1024f2:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)

		/* Need to RESTART if changing transfer direction */
		if ((pflags & I2C_MSG_RW_MASK)
  1024f9:	31 c2                	xor    %eax,%edx
	while (msg_left > 0) {
		pflags = dw->xfr_flags;

		dw->xfr_buf = cur_msg->buf;
		dw->xfr_len = cur_msg->len;
		dw->xfr_flags = cur_msg->flags;
  1024fb:	88 43 2a             	mov    %al,0x2a(%ebx)
		dw->rx_pending = 0;

		/* Need to RESTART if changing transfer direction */
		if ((pflags & I2C_MSG_RW_MASK)
  1024fe:	80 e2 01             	and    $0x1,%dl
  102501:	74 06                	je     102509 <i2c_dw_transfer+0x185>
		    != (dw->xfr_flags & I2C_MSG_RW_MASK)) {
			dw->xfr_flags |= I2C_MSG_RESTART;
  102503:	83 c8 04             	or     $0x4,%eax
  102506:	88 43 2a             	mov    %al,0x2a(%ebx)
		}

		/* Send STOP if this is the last message */
		if (msg_left == 1) {
  102509:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
  10250d:	75 04                	jne    102513 <i2c_dw_transfer+0x18f>
			dw->xfr_flags |= I2C_MSG_STOP;
  10250f:	80 4b 2a 02          	orb    $0x2,0x2a(%ebx)
		}

		dw->state &= ~(I2C_DW_CMD_SEND | I2C_DW_CMD_RECV);
  102513:	8a 43 28             	mov    0x28(%ebx),%al
  102516:	83 e0 fc             	and    $0xfffffffc,%eax

		if ((dw->xfr_flags & I2C_MSG_RW_MASK) == I2C_MSG_WRITE) {
  102519:	f6 43 2a 01          	testb  $0x1,0x2a(%ebx)
		/* Send STOP if this is the last message */
		if (msg_left == 1) {
			dw->xfr_flags |= I2C_MSG_STOP;
		}

		dw->state &= ~(I2C_DW_CMD_SEND | I2C_DW_CMD_RECV);
  10251d:	88 43 28             	mov    %al,0x28(%ebx)

		if ((dw->xfr_flags & I2C_MSG_RW_MASK) == I2C_MSG_WRITE) {
			dw->state |= I2C_DW_CMD_SEND;
  102520:	8a 43 28             	mov    0x28(%ebx),%al
			dw->xfr_flags |= I2C_MSG_STOP;
		}

		dw->state &= ~(I2C_DW_CMD_SEND | I2C_DW_CMD_RECV);

		if ((dw->xfr_flags & I2C_MSG_RW_MASK) == I2C_MSG_WRITE) {
  102523:	75 0c                	jne    102531 <i2c_dw_transfer+0x1ad>
			dw->state |= I2C_DW_CMD_SEND;
  102525:	83 c8 01             	or     $0x1,%eax
			dw->request_bytes = 0;
  102528:	c6 43 29 00          	movb   $0x0,0x29(%ebx)
		}

		dw->state &= ~(I2C_DW_CMD_SEND | I2C_DW_CMD_RECV);

		if ((dw->xfr_flags & I2C_MSG_RW_MASK) == I2C_MSG_WRITE) {
			dw->state |= I2C_DW_CMD_SEND;
  10252c:	88 43 28             	mov    %al,0x28(%ebx)
  10252f:	eb 09                	jmp    10253a <i2c_dw_transfer+0x1b6>
			dw->request_bytes = 0;
		} else {
			dw->state |= I2C_DW_CMD_RECV;
  102531:	83 c8 02             	or     $0x2,%eax
			dw->request_bytes = dw->xfr_len;
  102534:	88 4b 29             	mov    %cl,0x29(%ebx)

		if ((dw->xfr_flags & I2C_MSG_RW_MASK) == I2C_MSG_WRITE) {
			dw->state |= I2C_DW_CMD_SEND;
			dw->request_bytes = 0;
		} else {
			dw->state |= I2C_DW_CMD_RECV;
  102537:	88 43 28             	mov    %al,0x28(%ebx)
			dw->request_bytes = dw->xfr_len;
		}

		/* Enable interrupts to trigger ISR */
		if (regs->ic_con.bits.master_mode) {
  10253a:	8b 06                	mov    (%esi),%eax
  10253c:	a8 01                	test   $0x1,%al
  10253e:	74 08                	je     102548 <i2c_dw_transfer+0x1c4>
			/* Enable necessary interrupts */
			regs->ic_intr_mask.raw = (DW_ENABLE_TX_INT_I2C_MASTER |
  102540:	66 c7 46 30 5f 02    	movw   $0x25f,0x30(%esi)
  102546:	eb 06                	jmp    10254e <i2c_dw_transfer+0x1ca>
						  DW_ENABLE_RX_INT_I2C_MASTER);
		} else {
			/* Enable necessary interrupts */
			regs->ic_intr_mask.raw = DW_ENABLE_TX_INT_I2C_SLAVE;
  102548:	66 c7 46 30 60 02    	movw   $0x260,0x30(%esi)
  10254e:	6a ff                	push   $0xffffffff
  102550:	57                   	push   %edi
  102551:	e8 6d 18 00 00       	call   103dc3 <k_sem_take>
		}

		/* Wait for transfer to be done */
		device_sync_call_wait(&dw->sync);

		if (dw->state & I2C_DW_CMD_ERROR) {
  102556:	8a 43 28             	mov    0x28(%ebx),%al
  102559:	5a                   	pop    %edx
  10255a:	a8 04                	test   $0x4,%al
  10255c:	59                   	pop    %ecx
  10255d:	75 17                	jne    102576 <i2c_dw_transfer+0x1f2>
			ret = -EIO;
			break;
		}

		/* Something wrong if there is something left to do */
		if (dw->xfr_len > 0) {
  10255f:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  102563:	75 11                	jne    102576 <i2c_dw_transfer+0x1f2>
			ret = -EIO;
			break;
		}

		cur_msg++;
  102565:	83 45 0c 0c          	addl   $0xc,0xc(%ebp)
	 * can handle everything
	 */
	device_busy_set(dev);

		/* Process all the messages */
	while (msg_left > 0) {
  102569:	fe 4d f3             	decb   -0xd(%ebp)
  10256c:	0f 85 69 ff ff ff    	jne    1024db <i2c_dw_transfer+0x157>
  102572:	31 f6                	xor    %esi,%esi
  102574:	eb 05                	jmp    10257b <i2c_dw_transfer+0x1f7>

		/* Wait for transfer to be done */
		device_sync_call_wait(&dw->sync);

		if (dw->state & I2C_DW_CMD_ERROR) {
			ret = -EIO;
  102576:	be fb ff ff ff       	mov    $0xfffffffb,%esi

		cur_msg++;
		msg_left--;
	}

	device_busy_clear(dev);
  10257b:	ff 75 08             	pushl  0x8(%ebp)
  10257e:	e8 a7 11 00 00       	call   10372a <device_busy_clear>
  102583:	58                   	pop    %eax

	dw->state = I2C_DW_STATE_READY;
  102584:	c6 43 28 00          	movb   $0x0,0x28(%ebx)

	return ret;
  102588:	89 f0                	mov    %esi,%eax
  10258a:	eb 05                	jmp    102591 <i2c_dw_transfer+0x20d>
	volatile struct i2c_dw_registers * const regs =
		(struct i2c_dw_registers *)dw->base_address;

	/* Why bother processing no messages */
	if (!msgs || !num_msgs) {
		return -ENOTSUP;
  10258c:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
	device_busy_clear(dev);

	dw->state = I2C_DW_STATE_READY;

	return ret;
}
  102591:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102594:	5b                   	pop    %ebx
  102595:	5e                   	pop    %esi
  102596:	5f                   	pop    %edi
  102597:	5d                   	pop    %ebp
  102598:	c3                   	ret    

00102599 <_i2c_dw_data_read.isra.1>:
		dw->request_bytes--;
		cnt--;
	}
}

static void _i2c_dw_data_read(struct device *dev)
  102599:	55                   	push   %ebp
{
	struct i2c_dw_dev_config * const dw = dev->driver_data;

	volatile struct i2c_dw_registers * const regs =
  10259a:	8b 08                	mov    (%eax),%ecx
		dw->request_bytes--;
		cnt--;
	}
}

static void _i2c_dw_data_read(struct device *dev)
  10259c:	89 e5                	mov    %esp,%ebp
  10259e:	53                   	push   %ebx
	struct i2c_dw_dev_config * const dw = dev->driver_data;

	volatile struct i2c_dw_registers * const regs =
		(struct i2c_dw_registers *)dw->base_address;

	while (regs->ic_status.bits.rfne && (dw->xfr_len > 0)) {
  10259f:	8b 51 70             	mov    0x70(%ecx),%edx
  1025a2:	80 e2 08             	and    $0x8,%dl
  1025a5:	75 11                	jne    1025b8 <_i2c_dw_data_read.isra.1+0x1f>
			break;
		}
	}

	/* Nothing to receive anymore */
	if (dw->xfr_len == 0) {
  1025a7:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
  1025ab:	75 2f                	jne    1025dc <_i2c_dw_data_read.isra.1+0x43>
		dw->state &= ~I2C_DW_CMD_RECV;
  1025ad:	8a 50 28             	mov    0x28(%eax),%dl
  1025b0:	83 e2 fd             	and    $0xfffffffd,%edx
  1025b3:	88 50 28             	mov    %dl,0x28(%eax)
  1025b6:	eb 24                	jmp    1025dc <_i2c_dw_data_read.isra.1+0x43>
	struct i2c_dw_dev_config * const dw = dev->driver_data;

	volatile struct i2c_dw_registers * const regs =
		(struct i2c_dw_registers *)dw->base_address;

	while (regs->ic_status.bits.rfne && (dw->xfr_len > 0)) {
  1025b8:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
  1025bc:	74 e9                	je     1025a7 <_i2c_dw_data_read.isra.1+0xe>
		dw->xfr_buf[0] = regs->ic_data_cmd.raw;
  1025be:	8b 50 18             	mov    0x18(%eax),%edx
  1025c1:	66 8b 59 10          	mov    0x10(%ecx),%bx
  1025c5:	88 1a                	mov    %bl,(%edx)

		dw->xfr_buf++;
		dw->xfr_len--;
  1025c7:	8b 58 1c             	mov    0x1c(%eax),%ebx
		(struct i2c_dw_registers *)dw->base_address;

	while (regs->ic_status.bits.rfne && (dw->xfr_len > 0)) {
		dw->xfr_buf[0] = regs->ic_data_cmd.raw;

		dw->xfr_buf++;
  1025ca:	ff 40 18             	incl   0x18(%eax)
		dw->xfr_len--;
  1025cd:	8d 53 ff             	lea    -0x1(%ebx),%edx
		dw->rx_pending--;
  1025d0:	ff 48 20             	decl   0x20(%eax)

	while (regs->ic_status.bits.rfne && (dw->xfr_len > 0)) {
		dw->xfr_buf[0] = regs->ic_data_cmd.raw;

		dw->xfr_buf++;
		dw->xfr_len--;
  1025d3:	89 50 1c             	mov    %edx,0x1c(%eax)
		dw->rx_pending--;

		if (dw->xfr_len == 0) {
  1025d6:	85 d2                	test   %edx,%edx
  1025d8:	75 c5                	jne    10259f <_i2c_dw_data_read.isra.1+0x6>
  1025da:	eb cb                	jmp    1025a7 <_i2c_dw_data_read.isra.1+0xe>
	/* Nothing to receive anymore */
	if (dw->xfr_len == 0) {
		dw->state &= ~I2C_DW_CMD_RECV;
		return;
	}
}
  1025dc:	5b                   	pop    %ebx
  1025dd:	5d                   	pop    %ebp
  1025de:	c3                   	ret    

001025df <_i2c_dw_data_send.isra.2>:
static int _i2c_dw_data_send(struct device *dev)
{
	struct i2c_dw_dev_config * const dw = dev->driver_data;
	uint32_t data = 0;

	volatile struct i2c_dw_registers * const regs =
  1025df:	8b 10                	mov    (%eax),%edx
		(struct i2c_dw_registers *)dw->base_address;

	/* Nothing to send anymore, mask the interrupt */
	if (dw->xfr_len == 0) {
  1025e1:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
  1025e5:	75 17                	jne    1025fe <_i2c_dw_data_send.isra.2+0x1f>
		regs->ic_intr_mask.bits.tx_empty = 0;
  1025e7:	66 8b 4a 30          	mov    0x30(%edx),%cx
  1025eb:	83 e1 ef             	and    $0xffffffef,%ecx
  1025ee:	66 89 4a 30          	mov    %cx,0x30(%edx)

		dw->state &= ~I2C_DW_CMD_SEND;
  1025f2:	8a 50 28             	mov    0x28(%eax),%dl
  1025f5:	83 e2 fe             	and    $0xfffffffe,%edx
  1025f8:	88 50 28             	mov    %dl,0x28(%eax)

		return 0;
  1025fb:	31 c0                	xor    %eax,%eax
			return -EIO;
		}
	}

	return 0;
}
  1025fd:	c3                   	ret    
		return;
	}
}


static int _i2c_dw_data_send(struct device *dev)
  1025fe:	55                   	push   %ebp
  1025ff:	89 e5                	mov    %esp,%ebp
  102601:	56                   	push   %esi
  102602:	53                   	push   %ebx
		dw->state &= ~I2C_DW_CMD_SEND;

		return 0;
	}

	while (regs->ic_status.bits.tfnf && (dw->xfr_len > 0)) {
  102603:	8b 4a 70             	mov    0x70(%edx),%ecx
  102606:	80 e1 02             	and    $0x2,%cl
  102609:	74 43                	je     10264e <_i2c_dw_data_send.isra.2+0x6f>
  10260b:	8b 70 1c             	mov    0x1c(%eax),%esi
  10260e:	85 f6                	test   %esi,%esi
  102610:	74 3c                	je     10264e <_i2c_dw_data_send.isra.2+0x6f>
		/* We have something to transmit to a specific host */
		data = dw->xfr_buf[0];
  102612:	8b 48 18             	mov    0x18(%eax),%ecx

		/* Send RESTART if needed */
		if (dw->xfr_flags & I2C_MSG_RESTART) {
  102615:	8a 58 2a             	mov    0x2a(%eax),%bl
  102618:	f6 c3 04             	test   $0x4,%bl
		return 0;
	}

	while (regs->ic_status.bits.tfnf && (dw->xfr_len > 0)) {
		/* We have something to transmit to a specific host */
		data = dw->xfr_buf[0];
  10261b:	0f b6 09             	movzbl (%ecx),%ecx

		/* Send RESTART if needed */
		if (dw->xfr_flags & I2C_MSG_RESTART) {
  10261e:	74 09                	je     102629 <_i2c_dw_data_send.isra.2+0x4a>
			data |= IC_DATA_CMD_RESTART;
			dw->xfr_flags &= ~(I2C_MSG_RESTART);
  102620:	83 e3 fb             	and    $0xfffffffb,%ebx
		/* We have something to transmit to a specific host */
		data = dw->xfr_buf[0];

		/* Send RESTART if needed */
		if (dw->xfr_flags & I2C_MSG_RESTART) {
			data |= IC_DATA_CMD_RESTART;
  102623:	80 cd 04             	or     $0x4,%ch
			dw->xfr_flags &= ~(I2C_MSG_RESTART);
  102626:	88 58 2a             	mov    %bl,0x2a(%eax)
		}

		/* Send STOP if needed */
		if ((dw->xfr_len == 1) && (dw->xfr_flags & I2C_MSG_STOP)) {
  102629:	4e                   	dec    %esi
  10262a:	75 09                	jne    102635 <_i2c_dw_data_send.isra.2+0x56>
  10262c:	f6 40 2a 02          	testb  $0x2,0x2a(%eax)
  102630:	74 03                	je     102635 <_i2c_dw_data_send.isra.2+0x56>
			data |= IC_DATA_CMD_STOP;
  102632:	80 cd 02             	or     $0x2,%ch
		}

		regs->ic_data_cmd.raw = data;
  102635:	66 89 4a 10          	mov    %cx,0x10(%edx)

		dw->xfr_len--;
  102639:	ff 48 1c             	decl   0x1c(%eax)
		dw->xfr_buf++;
  10263c:	ff 40 18             	incl   0x18(%eax)

		if (regs->ic_intr_stat.bits.tx_abrt) {
  10263f:	8b 4a 2c             	mov    0x2c(%edx),%ecx
  102642:	80 e1 40             	and    $0x40,%cl
  102645:	74 bc                	je     102603 <_i2c_dw_data_send.isra.2+0x24>
			return -EIO;
  102647:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  10264c:	eb 02                	jmp    102650 <_i2c_dw_data_send.isra.2+0x71>
		}
	}

	return 0;
  10264e:	31 c0                	xor    %eax,%eax
}
  102650:	5b                   	pop    %ebx
  102651:	5e                   	pop    %esi
  102652:	5d                   	pop    %ebp
  102653:	c3                   	ret    

00102654 <i2c_dw_isr>:

	device_sync_call_complete(&dw->sync);
}

static void i2c_dw_isr(void *arg)
{
  102654:	55                   	push   %ebp
  102655:	89 e5                	mov    %esp,%ebp
  102657:	57                   	push   %edi
  102658:	56                   	push   %esi
  102659:	53                   	push   %ebx
  10265a:	83 ec 08             	sub    $0x8,%esp
  10265d:	8b 7d 08             	mov    0x8(%ebp),%edi
	struct device *port = (struct device *)arg;
	struct i2c_dw_dev_config * const dw = port->driver_data;
  102660:	8b 5f 08             	mov    0x8(%edi),%ebx
	union ic_interrupt_register intr_stat;
	uint32_t value;
	int ret = 0;

	volatile struct i2c_dw_registers * const regs =
  102663:	8b 03                	mov    (%ebx),%eax
  102665:	89 45 ec             	mov    %eax,-0x14(%ebp)
		(struct i2c_dw_registers *)dw->base_address;

	/* Cache ic_intr_stat for processing, so there is no need to read
	 * the register multiple times.
	 */
	intr_stat.raw = regs->ic_intr_stat.raw;
  102668:	66 8b 40 2c          	mov    0x2c(%eax),%ax
#if CONFIG_SHARED_IRQ
	/* If using with shared IRQ, this function will be called
	 * by the shared IRQ driver. So check here if the interrupt
	 * is coming from the I2C controller (or somewhere else).
	 */
	if (!intr_stat.raw) {
  10266c:	66 85 c0             	test   %ax,%ax
		(struct i2c_dw_registers *)dw->base_address;

	/* Cache ic_intr_stat for processing, so there is no need to read
	 * the register multiple times.
	 */
	intr_stat.raw = regs->ic_intr_stat.raw;
  10266f:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
#if CONFIG_SHARED_IRQ
	/* If using with shared IRQ, this function will be called
	 * by the shared IRQ driver. So check here if the interrupt
	 * is coming from the I2C controller (or somewhere else).
	 */
	if (!intr_stat.raw) {
  102673:	0f 84 5a 01 00 00    	je     1027d3 <i2c_dw_isr+0x17f>
	 */

	SYS_LOG_DBG("I2C: interrupt received");

	/* Check if we are configured as a master device */
	if (regs->ic_con.bits.master_mode) {
  102679:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10267c:	8b 00                	mov    (%eax),%eax
  10267e:	a8 01                	test   $0x1,%al
  102680:	0f 84 e2 00 00 00    	je     102768 <i2c_dw_isr+0x114>
		/* Bail early if there is any error. */
		if ((DW_INTR_STAT_TX_ABRT | DW_INTR_STAT_TX_OVER |
  102686:	f6 45 f2 4b          	testb  $0x4b,-0xe(%ebp)
  10268a:	74 09                	je     102695 <i2c_dw_isr+0x41>
		     DW_INTR_STAT_RX_OVER | DW_INTR_STAT_RX_UNDER) &
		    intr_stat.raw) {
			dw->state = I2C_DW_CMD_ERROR;
  10268c:	c6 43 28 04          	movb   $0x4,0x28(%ebx)
			goto done;
  102690:	e9 1d 01 00 00       	jmp    1027b2 <i2c_dw_isr+0x15e>
		}

		/* Check if the RX FIFO reached threshold */
		if (intr_stat.bits.rx_full) {
  102695:	f6 45 f2 04          	testb  $0x4,-0xe(%ebp)
  102699:	74 07                	je     1026a2 <i2c_dw_isr+0x4e>
			_i2c_dw_data_read(port);
  10269b:	89 d8                	mov    %ebx,%eax
  10269d:	e8 f7 fe ff ff       	call   102599 <_i2c_dw_data_read.isra.1>

		/* Check if the TX FIFO is ready for commands.
		 * TX FIFO also serves as command queue where read requests
		 * are written to TX FIFO.
		 */
		if (intr_stat.bits.tx_empty) {
  1026a2:	f6 45 f2 10          	testb  $0x10,-0xe(%ebp)
  1026a6:	0f 84 f7 00 00 00    	je     1027a3 <i2c_dw_isr+0x14f>
			if ((dw->xfr_flags & I2C_MSG_RW_MASK)
  1026ac:	f6 43 2a 01          	testb  $0x1,0x2a(%ebx)
  1026b0:	8b 47 08             	mov    0x8(%edi),%eax
  1026b3:	75 0a                	jne    1026bf <i2c_dw_isr+0x6b>
			    == I2C_MSG_WRITE) {
				ret = _i2c_dw_data_send(port);
  1026b5:	e8 25 ff ff ff       	call   1025df <_i2c_dw_data_send.isra.2>
  1026ba:	e9 97 00 00 00       	jmp    102756 <i2c_dw_isr+0x102>

	volatile struct i2c_dw_registers * const regs =
		(struct i2c_dw_registers *)dw->base_address;

	/* No more bytes to request, so command queue is no longer needed */
	if (dw->request_bytes == 0) {
  1026bf:	8a 50 29             	mov    0x29(%eax),%dl
	uint32_t data;
	uint8_t tx_empty;
	int8_t rx_empty;
	uint8_t cnt;

	volatile struct i2c_dw_registers * const regs =
  1026c2:	8b 30                	mov    (%eax),%esi
		(struct i2c_dw_registers *)dw->base_address;

	/* No more bytes to request, so command queue is no longer needed */
	if (dw->request_bytes == 0) {
  1026c4:	88 55 f1             	mov    %dl,-0xf(%ebp)
  1026c7:	84 d2                	test   %dl,%dl
  1026c9:	75 0d                	jne    1026d8 <i2c_dw_isr+0x84>
		regs->ic_intr_mask.bits.tx_empty = 0;
  1026cb:	66 8b 46 30          	mov    0x30(%esi),%ax
  1026cf:	83 e0 ef             	and    $0xffffffef,%eax
  1026d2:	66 89 46 30          	mov    %ax,0x30(%esi)
  1026d6:	eb 0f                	jmp    1026e7 <i2c_dw_isr+0x93>
		return;
	}

	/* How many bytes we can actually ask */
	rx_empty = (I2C_DW_FIFO_DEPTH - regs->ic_rxflr) - dw->rx_pending;
  1026d8:	8b 4e 78             	mov    0x78(%esi),%ecx

	if (rx_empty < 0) {
  1026db:	b2 10                	mov    $0x10,%dl
		regs->ic_intr_mask.bits.tx_empty = 0;
		return;
	}

	/* How many bytes we can actually ask */
	rx_empty = (I2C_DW_FIFO_DEPTH - regs->ic_rxflr) - dw->rx_pending;
  1026dd:	03 48 20             	add    0x20(%eax),%ecx

	if (rx_empty < 0) {
  1026e0:	28 ca                	sub    %cl,%dl
  1026e2:	88 55 f0             	mov    %dl,-0x10(%ebp)
  1026e5:	79 04                	jns    1026eb <i2c_dw_isr+0x97>
{
	struct device *port = (struct device *)arg;
	struct i2c_dw_dev_config * const dw = port->driver_data;
	union ic_interrupt_register intr_stat;
	uint32_t value;
	int ret = 0;
  1026e7:	31 c0                	xor    %eax,%eax
  1026e9:	eb 6b                	jmp    102756 <i2c_dw_isr+0x102>
		 */
		return;
	}

	/* How many empty slots in TX FIFO (as command queue) */
	tx_empty = I2C_DW_FIFO_DEPTH - regs->ic_txflr;
  1026eb:	8b 4e 74             	mov    0x74(%esi),%ecx

	/* Figure out how many bytes we can request */
	cnt = min(I2C_DW_FIFO_DEPTH, dw->request_bytes);
	cnt = min(min(tx_empty, rx_empty), cnt);
  1026ee:	80 7d f1 10          	cmpb   $0x10,-0xf(%ebp)
  1026f2:	76 04                	jbe    1026f8 <i2c_dw_isr+0xa4>
  1026f4:	c6 45 f1 10          	movb   $0x10,-0xf(%ebp)
  1026f8:	b2 10                	mov    $0x10,%dl
  1026fa:	29 ca                	sub    %ecx,%edx
  1026fc:	0f b6 ca             	movzbl %dl,%ecx
  1026ff:	0f b6 55 f1          	movzbl -0xf(%ebp),%edx
  102703:	39 ca                	cmp    %ecx,%edx
  102705:	7e 02                	jle    102709 <i2c_dw_isr+0xb5>
  102707:	89 ca                	mov    %ecx,%edx
  102709:	0f be 4d f0          	movsbl -0x10(%ebp),%ecx
  10270d:	39 ca                	cmp    %ecx,%edx
  10270f:	7e 34                	jle    102745 <i2c_dw_isr+0xf1>
  102711:	89 ca                	mov    %ecx,%edx
  102713:	eb 30                	jmp    102745 <i2c_dw_isr+0xf1>
	while (cnt > 0) {
		/* Tell controller to get another byte */
		data = IC_DATA_CMD_CMD;

		/* Send RESTART if needed */
		if (dw->xfr_flags & I2C_MSG_RESTART) {
  102715:	8a 48 2a             	mov    0x2a(%eax),%cl
  102718:	88 4d f1             	mov    %cl,-0xf(%ebp)
	cnt = min(I2C_DW_FIFO_DEPTH, dw->request_bytes);
	cnt = min(min(tx_empty, rx_empty), cnt);

	while (cnt > 0) {
		/* Tell controller to get another byte */
		data = IC_DATA_CMD_CMD;
  10271b:	b9 00 01 00 00       	mov    $0x100,%ecx

		/* Send RESTART if needed */
		if (dw->xfr_flags & I2C_MSG_RESTART) {
  102720:	f6 45 f1 04          	testb  $0x4,-0xf(%ebp)
  102724:	74 0e                	je     102734 <i2c_dw_isr+0xe0>
			data |= IC_DATA_CMD_RESTART;
			dw->xfr_flags &= ~(I2C_MSG_RESTART);
  102726:	8a 4d f1             	mov    -0xf(%ebp),%cl
  102729:	83 e1 fb             	and    $0xfffffffb,%ecx
  10272c:	88 48 2a             	mov    %cl,0x2a(%eax)
		/* Tell controller to get another byte */
		data = IC_DATA_CMD_CMD;

		/* Send RESTART if needed */
		if (dw->xfr_flags & I2C_MSG_RESTART) {
			data |= IC_DATA_CMD_RESTART;
  10272f:	b9 00 05 00 00       	mov    $0x500,%ecx
			dw->xfr_flags &= ~(I2C_MSG_RESTART);
		}

		/* After receiving the last byte, send STOP if needed */
		if ((dw->xfr_flags & I2C_MSG_STOP)
  102734:	f6 40 2a 02          	testb  $0x2,0x2a(%eax)
  102738:	75 11                	jne    10274b <i2c_dw_isr+0xf7>
		    && (dw->request_bytes == 1)) {
			data |= IC_DATA_CMD_STOP;
		}

		regs->ic_data_cmd.raw = data;
  10273a:	66 89 4e 10          	mov    %cx,0x10(%esi)

		dw->rx_pending++;
		dw->request_bytes--;
		cnt--;
  10273e:	4a                   	dec    %edx
			data |= IC_DATA_CMD_STOP;
		}

		regs->ic_data_cmd.raw = data;

		dw->rx_pending++;
  10273f:	ff 40 20             	incl   0x20(%eax)
		dw->request_bytes--;
  102742:	fe 48 29             	decb   0x29(%eax)

	/* Figure out how many bytes we can request */
	cnt = min(I2C_DW_FIFO_DEPTH, dw->request_bytes);
	cnt = min(min(tx_empty, rx_empty), cnt);

	while (cnt > 0) {
  102745:	84 d2                	test   %dl,%dl
  102747:	75 cc                	jne    102715 <i2c_dw_isr+0xc1>
  102749:	eb 9c                	jmp    1026e7 <i2c_dw_isr+0x93>
			dw->xfr_flags &= ~(I2C_MSG_RESTART);
		}

		/* After receiving the last byte, send STOP if needed */
		if ((dw->xfr_flags & I2C_MSG_STOP)
		    && (dw->request_bytes == 1)) {
  10274b:	80 78 29 01          	cmpb   $0x1,0x29(%eax)
  10274f:	75 e9                	jne    10273a <i2c_dw_isr+0xe6>
			data |= IC_DATA_CMD_STOP;
  102751:	80 cd 02             	or     $0x2,%ch
  102754:	eb e4                	jmp    10273a <i2c_dw_isr+0xe6>
			}

			/* If STOP is not expected, finish processing this
			 * message if there is nothing left to do anymore.
			 */
			if (((dw->xfr_len == 0)
  102756:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  10275a:	75 06                	jne    102762 <i2c_dw_isr+0x10e>
			     && !(dw->xfr_flags & I2C_MSG_STOP))
  10275c:	f6 43 2a 02          	testb  $0x2,0x2a(%ebx)
  102760:	74 50                	je     1027b2 <i2c_dw_isr+0x15e>
			    || (ret != 0)) {
  102762:	85 c0                	test   %eax,%eax
  102764:	75 4c                	jne    1027b2 <i2c_dw_isr+0x15e>
  102766:	eb 3b                	jmp    1027a3 <i2c_dw_isr+0x14f>
			}
		}
	} else { /* we must be configured as a slave device */

		/* We have a read requested by the master device */
		if (intr_stat.bits.rd_req &&
  102768:	f6 45 f2 20          	testb  $0x20,-0xe(%ebp)
  10276c:	74 21                	je     10278f <i2c_dw_isr+0x13b>
  10276e:	f6 43 14 20          	testb  $0x20,0x14(%ebx)
  102772:	75 1b                	jne    10278f <i2c_dw_isr+0x13b>
		    (!dw->app_config.bits.is_slave_read)) {

			/* data is not ready to send */
			if (intr_stat.bits.tx_abrt) {
  102774:	f6 45 f2 40          	testb  $0x40,-0xe(%ebp)
  102778:	74 07                	je     102781 <i2c_dw_isr+0x12d>
				/* clear the TX_ABRT interrupt */
				value = regs->ic_clr_tx_abrt;
  10277a:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10277d:	66 8b 40 54          	mov    0x54(%eax),%ax
			}

			_i2c_dw_data_send(port);
  102781:	89 d8                	mov    %ebx,%eax
  102783:	e8 57 fe ff ff       	call   1025df <_i2c_dw_data_send.isra.2>
			value = regs->ic_clr_rd_req;
  102788:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10278b:	66 8b 40 50          	mov    0x50(%eax),%ax
		}

		/* The slave device is ready to receive */
		if (intr_stat.bits.rx_full &&
  10278f:	f6 45 f2 04          	testb  $0x4,-0xe(%ebp)
  102793:	74 0e                	je     1027a3 <i2c_dw_isr+0x14f>
  102795:	f6 43 14 20          	testb  $0x20,0x14(%ebx)
  102799:	74 08                	je     1027a3 <i2c_dw_isr+0x14f>
		    dw->app_config.bits.is_slave_read) {
			_i2c_dw_data_read(port);
  10279b:	8b 47 08             	mov    0x8(%edi),%eax
  10279e:	e8 f6 fd ff ff       	call   102599 <_i2c_dw_data_read.isra.1>
		}
	}

	/* STOP detected: finish processing this message */
	if (intr_stat.bits.stop_det) {
  1027a3:	66 f7 45 f2 00 02    	testw  $0x200,-0xe(%ebp)
  1027a9:	74 28                	je     1027d3 <i2c_dw_isr+0x17f>
		value = regs->ic_clr_stop_det;
  1027ab:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1027ae:	66 8b 40 60          	mov    0x60(%eax),%ax
  1027b2:	8b 47 08             	mov    0x8(%edi),%eax
 *
 * @param sync A pointer to a valid device_sync_call_t
 */
static inline void device_sync_call_complete(device_sync_call_t *sync)
{
	k_sem_give(&sync->f_sem);
  1027b5:	83 c0 04             	add    $0x4,%eax
static inline void _i2c_dw_transfer_complete(struct device *dev)
{
	struct i2c_dw_dev_config * const dw = dev->driver_data;
	uint32_t value;

	volatile struct i2c_dw_registers * const regs =
  1027b8:	8b 50 fc             	mov    -0x4(%eax),%edx
		(struct i2c_dw_registers *)dw->base_address;

	regs->ic_intr_mask.raw = DW_DISABLE_ALL_I2C_INT;
  1027bb:	66 c7 42 30 00 00    	movw   $0x0,0x30(%edx)
	value = regs->ic_clr_intr;
  1027c1:	66 8b 52 40          	mov    0x40(%edx),%dx
  1027c5:	89 45 08             	mov    %eax,0x8(%ebp)

	return;

done:
	_i2c_dw_transfer_complete(port);
}
  1027c8:	59                   	pop    %ecx
  1027c9:	5b                   	pop    %ebx
  1027ca:	5b                   	pop    %ebx
  1027cb:	5e                   	pop    %esi
  1027cc:	5f                   	pop    %edi
  1027cd:	5d                   	pop    %ebp
  1027ce:	e9 ca 15 00 00       	jmp    103d9d <k_sem_give>
  1027d3:	58                   	pop    %eax
  1027d4:	5a                   	pop    %edx
  1027d5:	5b                   	pop    %ebx
  1027d6:	5e                   	pop    %esi
  1027d7:	5f                   	pop    %edi
  1027d8:	5d                   	pop    %ebp
  1027d9:	c3                   	ret    

001027da <i2c_dw_initialize>:
#else
#define i2c_dw_pci_setup(_unused_) (1)
#endif /* CONFIG_PCI */

static int i2c_dw_initialize(struct device *port)
{
  1027da:	55                   	push   %ebp
  1027db:	89 e5                	mov    %esp,%ebp
  1027dd:	57                   	push   %edi
  1027de:	56                   	push   %esi
  1027df:	53                   	push   %ebx
  1027e0:	53                   	push   %ebx
  1027e1:	8b 75 08             	mov    0x8(%ebp),%esi
	const struct i2c_dw_rom_config * const rom = port->config->config_info;
  1027e4:	8b 06                	mov    (%esi),%eax
	struct i2c_dw_dev_config * const dev = port->driver_data;
  1027e6:	8b 5e 08             	mov    0x8(%esi),%ebx
#define i2c_dw_pci_setup(_unused_) (1)
#endif /* CONFIG_PCI */

static int i2c_dw_initialize(struct device *port)
{
	const struct i2c_dw_rom_config * const rom = port->config->config_info;
  1027e9:	8b 78 08             	mov    0x8(%eax),%edi
#ifdef CONFIG_PCI
static inline int i2c_dw_pci_setup(struct device *dev)
{
	struct i2c_dw_dev_config * const dw = dev->driver_data;

	pci_bus_scan_init();
  1027ec:	e8 b4 e1 ff ff       	call   1009a5 <pci_bus_scan_init>

	if (!pci_bus_scan(&dw->pci_dev)) {
  1027f1:	8d 53 2c             	lea    0x2c(%ebx),%edx
  1027f4:	52                   	push   %edx
  1027f5:	89 55 f0             	mov    %edx,-0x10(%ebp)
  1027f8:	e8 16 e2 ff ff       	call   100a13 <pci_bus_scan>
  1027fd:	5a                   	pop    %edx
  1027fe:	85 c0                	test   %eax,%eax
  102800:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102803:	74 30                	je     102835 <i2c_dw_initialize+0x5b>
		SYS_LOG_DBG("Could not find device");
		return 0;
	}

#ifdef CONFIG_PCI_ENUMERATION
	dw->base_address = dw->pci_dev.addr;
  102805:	8b 43 2c             	mov    0x2c(%ebx),%eax
  102808:	89 03                	mov    %eax,(%ebx)
#endif
	pci_enable_regs(&dw->pci_dev);
  10280a:	52                   	push   %edx
  10280b:	e8 d4 e7 ff ff       	call   100fe4 <pci_enable_regs>
 *
 * @param sync A pointer to a valid device_sync_call_t
 */
static inline void device_sync_call_init(device_sync_call_t *sync)
{
	k_sem_init(&sync->f_sem, 0, UINT_MAX);
  102810:	8d 43 04             	lea    0x4(%ebx),%eax
  102813:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  10281a:	6a 00                	push   $0x0
  10281c:	50                   	push   %eax
  10281d:	e8 62 15 00 00       	call   103d84 <k_sem_init>
		return -EPERM;
	}

	device_sync_call_init(&dev->sync);

	regs = (struct i2c_dw_registers *) dev->base_address;
  102822:	8b 03                	mov    (%ebx),%eax
  102824:	83 c4 0c             	add    $0xc,%esp

	/* verify that we have a valid DesignWare register first */
	if (regs->ic_comp_type != I2C_DW_MAGIC_KEY) {
  102827:	8b 90 fc 00 00 00    	mov    0xfc(%eax),%edx
  10282d:	81 fa 40 01 57 44    	cmp    $0x44570140,%edx
  102833:	74 09                	je     10283e <i2c_dw_initialize+0x64>
		port->driver_api = NULL;
  102835:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
  10283c:	eb 25                	jmp    102863 <i2c_dw_initialize+0x89>
	/*
	 * grab the default value on initialization.  This should be set to the
	 * IC_MAX_SPEED_MODE in the hardware.  If it does support high speed we
	 * can move provide support for it
	 */
	if (regs->ic_con.bits.speed == I2C_DW_SPEED_HIGH) {
  10283e:	8b 00                	mov    (%eax),%eax
  102840:	83 f0 06             	xor    $0x6,%eax
		SYS_LOG_DBG("I2C: high speed supported");
		dev->support_hs_mode = true;
  102843:	a8 06                	test   $0x6,%al
  102845:	0f 94 43 2b          	sete   0x2b(%ebx)
	} else {
		SYS_LOG_DBG("I2C: high speed NOT supported");
		dev->support_hs_mode = false;
	}

	rom->config_func(port);
  102849:	56                   	push   %esi
  10284a:	ff 57 08             	call   *0x8(%edi)
  10284d:	58                   	pop    %eax

	if (i2c_dw_runtime_configure(port, dev->app_config.raw) != 0) {
  10284e:	ff 73 14             	pushl  0x14(%ebx)
  102851:	56                   	push   %esi
  102852:	e8 2f fa ff ff       	call   102286 <i2c_dw_runtime_configure>
  102857:	5a                   	pop    %edx
  102858:	85 c0                	test   %eax,%eax
  10285a:	59                   	pop    %ecx
  10285b:	75 06                	jne    102863 <i2c_dw_initialize+0x89>
		SYS_LOG_DBG("I2C: Cannot set default configuration 0x%x",
		    dev->app_config.raw);
		return -EPERM;
	}

	dev->state = I2C_DW_STATE_READY;
  10285d:	c6 43 28 00          	movb   $0x0,0x28(%ebx)

	return 0;
  102861:	eb 03                	jmp    102866 <i2c_dw_initialize+0x8c>
	rom->config_func(port);

	if (i2c_dw_runtime_configure(port, dev->app_config.raw) != 0) {
		SYS_LOG_DBG("I2C: Cannot set default configuration 0x%x",
		    dev->app_config.raw);
		return -EPERM;
  102863:	83 c8 ff             	or     $0xffffffff,%eax
	}

	dev->state = I2C_DW_STATE_READY;

	return 0;
}
  102866:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102869:	5b                   	pop    %ebx
  10286a:	5e                   	pop    %esi
  10286b:	5f                   	pop    %edi
  10286c:	5d                   	pop    %ebp
  10286d:	c3                   	ret    

0010286e <i2c_config_0>:
		    &i2c_0_runtime, &i2c_config_dw_0,
		    POST_KERNEL, CONFIG_I2C_INIT_PRIORITY,
		    &funcs);

static void i2c_config_0(struct device *port)
{
  10286e:	55                   	push   %ebp
  10286f:	89 e5                	mov    %esp,%ebp
  102871:	56                   	push   %esi
  102872:	53                   	push   %ebx
  102873:	8b 75 08             	mov    0x8(%ebp),%esi

	IRQ_CONNECT(I2C_DW_0_IRQ, CONFIG_I2C_0_IRQ_PRI,
		    i2c_dw_isr, DEVICE_GET(i2c_0), I2C_DW_IRQ_FLAGS);
	irq_enable(rom->irq_num);
#elif defined(CONFIG_I2C_0_IRQ_SHARED)
	const struct i2c_dw_rom_config * const config =
  102876:	8b 06                	mov    (%esi),%eax
		port->config->config_info;
	struct device *shared_irq_dev;

	shared_irq_dev = device_get_binding(config->shared_irq_dev_name);
  102878:	8b 40 08             	mov    0x8(%eax),%eax
  10287b:	ff 70 0c             	pushl  0xc(%eax)
  10287e:	e8 69 0e 00 00       	call   1036ec <device_get_binding>
  102883:	89 c3                	mov    %eax,%ebx
static inline int shared_irq_isr_register(struct device *dev, isr_t isr_func,
				 struct device *isr_dev)
{
	const struct shared_irq_driver_api *api = dev->driver_api;

	return api->isr_register(dev, isr_func, isr_dev);
  102885:	8b 40 04             	mov    0x4(%eax),%eax
  102888:	89 34 24             	mov    %esi,(%esp)
  10288b:	68 54 26 10 00       	push   $0x102654
  102890:	53                   	push   %ebx
  102891:	ff 10                	call   *(%eax)
  102893:	83 c4 0c             	add    $0xc,%esp
 */
static inline int shared_irq_enable(struct device *dev, struct device *isr_dev)
{
	const struct shared_irq_driver_api *api = dev->driver_api;

	return api->enable(dev, isr_dev);
  102896:	8b 43 04             	mov    0x4(%ebx),%eax
  102899:	56                   	push   %esi
  10289a:	53                   	push   %ebx
  10289b:	ff 50 04             	call   *0x4(%eax)
  10289e:	58                   	pop    %eax
  10289f:	5a                   	pop    %edx
	shared_irq_isr_register(shared_irq_dev, (isr_t)i2c_dw_isr, port);
	shared_irq_enable(shared_irq_dev, port);
#endif
}
  1028a0:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1028a3:	5b                   	pop    %ebx
  1028a4:	5e                   	pop    %esi
  1028a5:	5d                   	pop    %ebp
  1028a6:	c3                   	ret    

001028a7 <pwm_pca9685_configure>:
		return 0;
}

static int pwm_pca9685_configure(struct device *dev, int access_op,
				 uint32_t pwm, int flags)
{
  1028a7:	55                   	push   %ebp
	ARG_UNUSED(access_op);
	ARG_UNUSED(pwm);
	ARG_UNUSED(flags);

	return 0;
}
  1028a8:	31 c0                	xor    %eax,%eax
		return 0;
}

static int pwm_pca9685_configure(struct device *dev, int access_op,
				 uint32_t pwm, int flags)
{
  1028aa:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(access_op);
	ARG_UNUSED(pwm);
	ARG_UNUSED(flags);

	return 0;
}
  1028ac:	5d                   	pop    %ebp
  1028ad:	c3                   	ret    

001028ae <pwm_pca9685_set_values>:

static int pwm_pca9685_set_values(struct device *dev, int access_op,
				  uint32_t pwm, uint32_t on, uint32_t off)
{
  1028ae:	55                   	push   %ebp
		dev->config->config_info;
	struct pwm_pca9685_drv_data * const drv_data =
		(struct pwm_pca9685_drv_data * const)dev->driver_data;
	struct device * const i2c_master = drv_data->i2c_master;
	uint16_t i2c_addr = config->i2c_slave_addr;
	uint8_t buf[] = { 0, 0, 0, 0, 0};
  1028af:	b9 05 00 00 00       	mov    $0x5,%ecx
	return 0;
}

static int pwm_pca9685_set_values(struct device *dev, int access_op,
				  uint32_t pwm, uint32_t on, uint32_t off)
{
  1028b4:	89 e5                	mov    %esp,%ebp
  1028b6:	57                   	push   %edi
  1028b7:	56                   	push   %esi
  1028b8:	53                   	push   %ebx
  1028b9:	83 ec 14             	sub    $0x14,%esp
		dev->config->config_info;
	struct pwm_pca9685_drv_data * const drv_data =
		(struct pwm_pca9685_drv_data * const)dev->driver_data;
	struct device * const i2c_master = drv_data->i2c_master;
	uint16_t i2c_addr = config->i2c_slave_addr;
	uint8_t buf[] = { 0, 0, 0, 0, 0};
  1028bc:	8d 7d e3             	lea    -0x1d(%ebp),%edi
	return 0;
}

static int pwm_pca9685_set_values(struct device *dev, int access_op,
				  uint32_t pwm, uint32_t on, uint32_t off)
{
  1028bf:	8b 45 08             	mov    0x8(%ebp),%eax
	const struct pwm_pca9685_config * const config =
		dev->config->config_info;
	struct pwm_pca9685_drv_data * const drv_data =
  1028c2:	8b 50 08             	mov    0x8(%eax),%edx
}

static int pwm_pca9685_set_values(struct device *dev, int access_op,
				  uint32_t pwm, uint32_t on, uint32_t off)
{
	const struct pwm_pca9685_config * const config =
  1028c5:	8b 00                	mov    (%eax),%eax
		dev->config->config_info;
	struct pwm_pca9685_drv_data * const drv_data =
		(struct pwm_pca9685_drv_data * const)dev->driver_data;
	struct device * const i2c_master = drv_data->i2c_master;
	uint16_t i2c_addr = config->i2c_slave_addr;
  1028c7:	8b 40 08             	mov    0x8(%eax),%eax
{
	const struct pwm_pca9685_config * const config =
		dev->config->config_info;
	struct pwm_pca9685_drv_data * const drv_data =
		(struct pwm_pca9685_drv_data * const)dev->driver_data;
	struct device * const i2c_master = drv_data->i2c_master;
  1028ca:	8b 1a                	mov    (%edx),%ebx
	uint16_t i2c_addr = config->i2c_slave_addr;
  1028cc:	0f b7 70 04          	movzwl 0x4(%eax),%esi
	uint8_t buf[] = { 0, 0, 0, 0, 0};
  1028d0:	31 c0                	xor    %eax,%eax
  1028d2:	f3 aa                	rep stos %al,%es:(%edi)

	if (!_has_i2c_master(dev)) {
		return -EINVAL;
  1028d4:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
{
	struct pwm_pca9685_drv_data * const drv_data =
		(struct pwm_pca9685_drv_data * const)dev->driver_data;
	struct device * const i2c_master = drv_data->i2c_master;

	if (i2c_master)
  1028d9:	83 3a 00             	cmpl   $0x0,(%edx)
  1028dc:	0f 84 99 00 00 00    	je     10297b <pwm_pca9685_set_values+0xcd>

	if (!_has_i2c_master(dev)) {
		return -EINVAL;
	}

	switch (access_op) {
  1028e2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  1028e6:	75 1e                	jne    102906 <pwm_pca9685_set_values+0x58>
	struct device * const i2c_master = drv_data->i2c_master;
	uint16_t i2c_addr = config->i2c_slave_addr;
	uint8_t buf[] = { 0, 0, 0, 0, 0};

	if (!_has_i2c_master(dev)) {
		return -EINVAL;
  1028e8:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	}

	switch (access_op) {
	case PWM_ACCESS_BY_PIN:
		if (pwm > MAX_PWM_OUT) {
  1028ed:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  1028f1:	0f 87 84 00 00 00    	ja     10297b <pwm_pca9685_set_values+0xcd>
			return -EINVAL;
		}
		buf[0] = REG_LED_ON_L(pwm);
  1028f7:	8a 45 10             	mov    0x10(%ebp),%al
  1028fa:	8d 04 85 06 00 00 00 	lea    0x6(,%eax,4),%eax
  102901:	88 45 e3             	mov    %al,-0x1d(%ebp)
		break;
  102904:	eb 0a                	jmp    102910 <pwm_pca9685_set_values+0x62>

	if (!_has_i2c_master(dev)) {
		return -EINVAL;
	}

	switch (access_op) {
  102906:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  10290a:	75 6a                	jne    102976 <pwm_pca9685_set_values+0xc8>
			return -EINVAL;
		}
		buf[0] = REG_LED_ON_L(pwm);
		break;
	case PWM_ACCESS_ALL:
		buf[0] = REG_ALL_LED_ON_L;
  10290c:	c6 45 e3 fa          	movb   $0xfa,-0x1d(%ebp)

	/* If either ON and/or OFF > max ticks, treat PWM as 100%.
	 * If OFF value == 0, treat it as 0%.
	 * Otherwise, populate registers accordingly.
	 */
	if ((on >= PWM_ONE_PERIOD_TICKS) || (off >= PWM_ONE_PERIOD_TICKS)) {
  102910:	81 7d 14 ff 0f 00 00 	cmpl   $0xfff,0x14(%ebp)
  102917:	77 09                	ja     102922 <pwm_pca9685_set_values+0x74>
  102919:	81 7d 18 ff 0f 00 00 	cmpl   $0xfff,0x18(%ebp)
  102920:	76 06                	jbe    102928 <pwm_pca9685_set_values+0x7a>
		buf[1] = 0x0;
		buf[2] = (1 << 4);
  102922:	c6 45 e5 10          	movb   $0x10,-0x1b(%ebp)
  102926:	eb 2a                	jmp    102952 <pwm_pca9685_set_values+0xa4>
		buf[3] = 0x0;
		buf[4] = 0x0;
	} else if (off == 0) {
  102928:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  10292c:	75 06                	jne    102934 <pwm_pca9685_set_values+0x86>
		buf[1] = 0x0;
		buf[2] = 0x0;
		buf[3] = 0x0;
		buf[4] = (1 << 4);
  10292e:	c6 45 e7 10          	movb   $0x10,-0x19(%ebp)
  102932:	eb 1e                	jmp    102952 <pwm_pca9685_set_values+0xa4>
	} else {
		buf[1] = (on & 0xFF);
  102934:	8a 45 14             	mov    0x14(%ebp),%al
  102937:	88 45 e4             	mov    %al,-0x1c(%ebp)
		buf[2] = ((on >> 8) & 0x0F);
  10293a:	8b 45 14             	mov    0x14(%ebp),%eax
  10293d:	c1 e8 08             	shr    $0x8,%eax
  102940:	88 45 e5             	mov    %al,-0x1b(%ebp)
		buf[3] = (off & 0xFF);
  102943:	8a 45 18             	mov    0x18(%ebp),%al
  102946:	88 45 e6             	mov    %al,-0x1a(%ebp)
		buf[4] = ((off >> 8) & 0x0F);
  102949:	8b 45 18             	mov    0x18(%ebp),%eax
  10294c:	c1 e8 08             	shr    $0x8,%eax
  10294f:	88 45 e7             	mov    %al,-0x19(%ebp)
			    uint32_t len, uint16_t addr)
{
	const struct i2c_driver_api *api = dev->driver_api;
	struct i2c_msg msg;

	msg.buf = buf;
  102952:	8d 55 e3             	lea    -0x1d(%ebp),%edx
 * @retval Negative errno code if failure.
 */
static inline int i2c_write(struct device *dev, uint8_t *buf,
			    uint32_t len, uint16_t addr)
{
	const struct i2c_driver_api *api = dev->driver_api;
  102955:	8b 43 04             	mov    0x4(%ebx),%eax
	struct i2c_msg msg;

	msg.buf = buf;
  102958:	89 55 e8             	mov    %edx,-0x18(%ebp)
	msg.len = len;
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;

	return api->transfer(dev, &msg, 1, addr);
  10295b:	8d 55 e8             	lea    -0x18(%ebp),%edx
  10295e:	56                   	push   %esi
{
	const struct i2c_driver_api *api = dev->driver_api;
	struct i2c_msg msg;

	msg.buf = buf;
	msg.len = len;
  10295f:	c7 45 ec 05 00 00 00 	movl   $0x5,-0x14(%ebp)
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;

	return api->transfer(dev, &msg, 1, addr);
  102966:	6a 01                	push   $0x1
	const struct i2c_driver_api *api = dev->driver_api;
	struct i2c_msg msg;

	msg.buf = buf;
	msg.len = len;
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
  102968:	c6 45 f0 02          	movb   $0x2,-0x10(%ebp)

	return api->transfer(dev, &msg, 1, addr);
  10296c:	52                   	push   %edx
  10296d:	53                   	push   %ebx
  10296e:	ff 50 04             	call   *0x4(%eax)
  102971:	83 c4 10             	add    $0x10,%esp
	}

	return i2c_write(i2c_master, buf, sizeof(buf), i2c_addr);
  102974:	eb 05                	jmp    10297b <pwm_pca9685_set_values+0xcd>
		break;
	case PWM_ACCESS_ALL:
		buf[0] = REG_ALL_LED_ON_L;
		break;
	default:
		return -ENOTSUP;
  102976:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
		buf[3] = (off & 0xFF);
		buf[4] = ((off >> 8) & 0x0F);
	}

	return i2c_write(i2c_master, buf, sizeof(buf), i2c_addr);
}
  10297b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10297e:	5b                   	pop    %ebx
  10297f:	5e                   	pop    %esi
  102980:	5f                   	pop    %edi
  102981:	5d                   	pop    %ebp
  102982:	c3                   	ret    

00102983 <pwm_pca9685_set_duty_cycle>:
 * Duty cycle describes the percentage of time a signal is turned
 * to the ON state.
 */
static int pwm_pca9685_set_duty_cycle(struct device *dev, int access_op,
				      uint32_t pwm, uint8_t duty)
{
  102983:	55                   	push   %ebp
  102984:	89 e5                	mov    %esp,%ebp
  102986:	8b 45 14             	mov    0x14(%ebp),%eax
	uint32_t on, off, phase;

	phase = 0;     /* Hard coded until API changes */

	if (duty == 0) {
  102989:	84 c0                	test   %al,%al
  10298b:	74 14                	je     1029a1 <pwm_pca9685_set_duty_cycle+0x1e>
		/* Turn off PWM */
		on = 0;
		off = 0;
	} else if (duty >= 100) {
  10298d:	3c 63                	cmp    $0x63,%al
  10298f:	77 16                	ja     1029a7 <pwm_pca9685_set_duty_cycle+0x24>
		/* Force PWM to be 100% */
		on = PWM_ONE_PERIOD_TICKS + 1;
		off = PWM_ONE_PERIOD_TICKS + 1;
	} else {
		off = PWM_ONE_PERIOD_TICKS * duty / 100;
  102991:	0f b6 c0             	movzbl %al,%eax
  102994:	c1 e0 0c             	shl    $0xc,%eax
  102997:	b9 64 00 00 00       	mov    $0x64,%ecx
  10299c:	99                   	cltd   
  10299d:	f7 f9                	idiv   %ecx
  10299f:	eb 02                	jmp    1029a3 <pwm_pca9685_set_duty_cycle+0x20>
	phase = 0;     /* Hard coded until API changes */

	if (duty == 0) {
		/* Turn off PWM */
		on = 0;
		off = 0;
  1029a1:	31 c0                	xor    %eax,%eax

	phase = 0;     /* Hard coded until API changes */

	if (duty == 0) {
		/* Turn off PWM */
		on = 0;
  1029a3:	31 d2                	xor    %edx,%edx
  1029a5:	eb 0a                	jmp    1029b1 <pwm_pca9685_set_duty_cycle+0x2e>
		off = 0;
	} else if (duty >= 100) {
		/* Force PWM to be 100% */
		on = PWM_ONE_PERIOD_TICKS + 1;
		off = PWM_ONE_PERIOD_TICKS + 1;
  1029a7:	b8 01 10 00 00       	mov    $0x1001,%eax
		/* Turn off PWM */
		on = 0;
		off = 0;
	} else if (duty >= 100) {
		/* Force PWM to be 100% */
		on = PWM_ONE_PERIOD_TICKS + 1;
  1029ac:	ba 01 10 00 00       	mov    $0x1001,%edx
	} else {
		off = PWM_ONE_PERIOD_TICKS * duty / 100;
		on = phase;
	}

	return pwm_pca9685_set_values(dev, access_op, pwm, on, off);
  1029b1:	50                   	push   %eax
  1029b2:	52                   	push   %edx
  1029b3:	ff 75 10             	pushl  0x10(%ebp)
  1029b6:	ff 75 0c             	pushl  0xc(%ebp)
  1029b9:	ff 75 08             	pushl  0x8(%ebp)
  1029bc:	e8 ed fe ff ff       	call   1028ae <pwm_pca9685_set_values>
  1029c1:	83 c4 14             	add    $0x14,%esp
}
  1029c4:	c9                   	leave  
  1029c5:	c3                   	ret    

001029c6 <pwm_pca9685_init>:
 *
 * @param dev Device struct
 * @return 0 if successful, failed otherwise.
 */
int pwm_pca9685_init(struct device *dev)
{
  1029c6:	55                   	push   %ebp
  1029c7:	89 e5                	mov    %esp,%ebp
  1029c9:	57                   	push   %edi
  1029ca:	56                   	push   %esi
  1029cb:	53                   	push   %ebx
  1029cc:	83 ec 10             	sub    $0x10,%esp
	const struct pwm_pca9685_config * const config =
		dev->config->config_info;
	struct pwm_pca9685_drv_data * const drv_data =
		(struct pwm_pca9685_drv_data * const)dev->driver_data;
	struct device *i2c_master;
	uint8_t buf[] = {0, 0};
  1029cf:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
 *
 * @param dev Device struct
 * @return 0 if successful, failed otherwise.
 */
int pwm_pca9685_init(struct device *dev)
{
  1029d3:	8b 5d 08             	mov    0x8(%ebp),%ebx
	const struct pwm_pca9685_config * const config =
		dev->config->config_info;
	struct pwm_pca9685_drv_data * const drv_data =
		(struct pwm_pca9685_drv_data * const)dev->driver_data;
	struct device *i2c_master;
	uint8_t buf[] = {0, 0};
  1029d6:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
 * @param dev Device struct
 * @return 0 if successful, failed otherwise.
 */
int pwm_pca9685_init(struct device *dev)
{
	const struct pwm_pca9685_config * const config =
  1029da:	8b 03                	mov    (%ebx),%eax
		dev->config->config_info;
	struct pwm_pca9685_drv_data * const drv_data =
  1029dc:	8b 7b 08             	mov    0x8(%ebx),%edi
 * @param dev Device struct
 * @return 0 if successful, failed otherwise.
 */
int pwm_pca9685_init(struct device *dev)
{
	const struct pwm_pca9685_config * const config =
  1029df:	8b 70 08             	mov    0x8(%eax),%esi
	struct device *i2c_master;
	uint8_t buf[] = {0, 0};
	int ret;

	/* Find out the device struct of the I2C master */
	i2c_master = device_get_binding((char *)config->i2c_master_dev_name);
  1029e2:	ff 36                	pushl  (%esi)
  1029e4:	e8 03 0d 00 00       	call   1036ec <device_get_binding>
  1029e9:	5a                   	pop    %edx
  1029ea:	89 c2                	mov    %eax,%edx
	if (!i2c_master) {
		return -EINVAL;
  1029ec:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	uint8_t buf[] = {0, 0};
	int ret;

	/* Find out the device struct of the I2C master */
	i2c_master = device_get_binding((char *)config->i2c_master_dev_name);
	if (!i2c_master) {
  1029f1:	85 d2                	test   %edx,%edx
  1029f3:	74 40                	je     102a35 <pwm_pca9685_init+0x6f>
	/* MODE1 register */

	buf[0] = REG_MODE1;
	buf[1] = (1 << 5); /* register addr auto increment */

	ret = i2c_write(i2c_master, buf, 2, config->i2c_slave_addr);
  1029f5:	0f b7 46 04          	movzwl 0x4(%esi),%eax
 * @retval Negative errno code if failure.
 */
static inline int i2c_write(struct device *dev, uint8_t *buf,
			    uint32_t len, uint16_t addr)
{
	const struct i2c_driver_api *api = dev->driver_api;
  1029f9:	8b 4a 04             	mov    0x4(%edx),%ecx
	struct i2c_msg msg;

	msg.buf = buf;
  1029fc:	8d 75 e6             	lea    -0x1a(%ebp),%esi
	/* Find out the device struct of the I2C master */
	i2c_master = device_get_binding((char *)config->i2c_master_dev_name);
	if (!i2c_master) {
		return -EINVAL;
	}
	drv_data->i2c_master = i2c_master;
  1029ff:	89 17                	mov    %edx,(%edi)
	msg.len = len;
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;

	return api->transfer(dev, &msg, 1, addr);
  102a01:	50                   	push   %eax

	/* MODE1 register */

	buf[0] = REG_MODE1;
  102a02:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  102a06:	8d 45 e8             	lea    -0x18(%ebp),%eax
	buf[1] = (1 << 5); /* register addr auto increment */
  102a09:	c6 45 e7 20          	movb   $0x20,-0x19(%ebp)
			    uint32_t len, uint16_t addr)
{
	const struct i2c_driver_api *api = dev->driver_api;
	struct i2c_msg msg;

	msg.buf = buf;
  102a0d:	89 75 e8             	mov    %esi,-0x18(%ebp)
	msg.len = len;
  102a10:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
  102a17:	c6 45 f0 02          	movb   $0x2,-0x10(%ebp)

	return api->transfer(dev, &msg, 1, addr);
  102a1b:	6a 01                	push   $0x1
  102a1d:	50                   	push   %eax
  102a1e:	52                   	push   %edx
  102a1f:	ff 51 04             	call   *0x4(%ecx)
  102a22:	83 c4 10             	add    $0x10,%esp

	ret = i2c_write(i2c_master, buf, 2, config->i2c_slave_addr);
	if (ret != 0) {
  102a25:	85 c0                	test   %eax,%eax
  102a27:	75 09                	jne    102a32 <pwm_pca9685_init+0x6c>
		return -EPERM;
	}

	dev->driver_api = &pwm_pca9685_drv_api_funcs;
  102a29:	c7 43 04 f0 48 10 00 	movl   $0x1048f0,0x4(%ebx)

	return 0;
  102a30:	eb 03                	jmp    102a35 <pwm_pca9685_init+0x6f>
	buf[0] = REG_MODE1;
	buf[1] = (1 << 5); /* register addr auto increment */

	ret = i2c_write(i2c_master, buf, 2, config->i2c_slave_addr);
	if (ret != 0) {
		return -EPERM;
  102a32:	83 c8 ff             	or     $0xffffffff,%eax
	}

	dev->driver_api = &pwm_pca9685_drv_api_funcs;

	return 0;
}
  102a35:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102a38:	5b                   	pop    %ebx
  102a39:	5e                   	pop    %esi
  102a3a:	5f                   	pop    %edi
  102a3b:	5d                   	pop    %ebp
  102a3c:	c3                   	ret    

00102a3d <ti_adc108s102_disable>:
	 * SPI will release CS)
	 */
}

static void ti_adc108s102_disable(struct device *dev)
{
  102a3d:	55                   	push   %ebp
  102a3e:	89 e5                	mov    %esp,%ebp
	/* Same issue as with ti_adc108s102_enable() */
}
  102a40:	5d                   	pop    %ebp
  102a41:	c3                   	ret    

00102a42 <ti_adc108s102_init>:
	.disable = ti_adc108s102_disable,
	.read = ti_adc108s102_read,
};

static int ti_adc108s102_init(struct device *dev)
{
  102a42:	55                   	push   %ebp
  102a43:	89 e5                	mov    %esp,%ebp
  102a45:	56                   	push   %esi
  102a46:	53                   	push   %ebx
  102a47:	8b 5d 08             	mov    0x8(%ebp),%ebx
	const struct ti_adc108s102_config *config = dev->config->config_info;
  102a4a:	8b 03                	mov    (%ebx),%eax
	struct ti_adc108s102_data *adc = dev->driver_data;
  102a4c:	8b 73 08             	mov    0x8(%ebx),%esi

	adc->spi = device_get_binding((char *)config->spi_port);
  102a4f:	8b 40 08             	mov    0x8(%eax),%eax
  102a52:	ff 30                	pushl  (%eax)
  102a54:	e8 93 0c 00 00       	call   1036ec <device_get_binding>
  102a59:	5a                   	pop    %edx
  102a5a:	83 ca ff             	or     $0xffffffff,%edx
  102a5d:	89 46 24             	mov    %eax,0x24(%esi)
	if (!adc->spi) {
  102a60:	85 c0                	test   %eax,%eax
  102a62:	74 09                	je     102a6d <ti_adc108s102_init+0x2b>
		return -EPERM;
	}

	SYS_LOG_DBG("ADC108s102 initialized\n");

	dev->driver_api = &ti_adc108s102_api;
  102a64:	c7 43 04 1c 49 10 00 	movl   $0x10491c,0x4(%ebx)

	return 0;
  102a6b:	31 d2                	xor    %edx,%edx
}
  102a6d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  102a70:	89 d0                	mov    %edx,%eax
  102a72:	5b                   	pop    %ebx
  102a73:	5e                   	pop    %esi
  102a74:	5d                   	pop    %ebp
  102a75:	c3                   	ret    

00102a76 <ti_adc108s102_read>:
	return chans_set;
}

static int ti_adc108s102_read(struct device *dev,
					struct adc_seq_table *seq_table)
{
  102a76:	55                   	push   %ebp
  102a77:	89 e5                	mov    %esp,%ebp
  102a79:	57                   	push   %edi
  102a7a:	56                   	push   %esi
  102a7b:	53                   	push   %ebx
  102a7c:	83 ec 4c             	sub    $0x4c,%esp
	const struct ti_adc108s102_config *config = dev->config->config_info;
	struct ti_adc108s102_data *adc = dev->driver_data;
	struct spi_config spi_conf;
	uint32_t data[2] = {0, 0};
  102a7f:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
}

static int ti_adc108s102_read(struct device *dev,
					struct adc_seq_table *seq_table)
{
	const struct ti_adc108s102_config *config = dev->config->config_info;
  102a86:	8b 45 08             	mov    0x8(%ebp),%eax
	return chans_set;
}

static int ti_adc108s102_read(struct device *dev,
					struct adc_seq_table *seq_table)
{
  102a89:	8b 7d 0c             	mov    0xc(%ebp),%edi
	const struct ti_adc108s102_config *config = dev->config->config_info;
  102a8c:	8b 00                	mov    (%eax),%eax
  102a8e:	8b 70 08             	mov    0x8(%eax),%esi
	struct ti_adc108s102_data *adc = dev->driver_data;
  102a91:	8b 45 08             	mov    0x8(%ebp),%eax
	struct spi_config spi_conf;
	uint32_t data[2] = {0, 0};
  102a94:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)

static int ti_adc108s102_read(struct device *dev,
					struct adc_seq_table *seq_table)
{
	const struct ti_adc108s102_config *config = dev->config->config_info;
	struct ti_adc108s102_data *adc = dev->driver_data;
  102a9b:	8b 58 08             	mov    0x8(%eax),%ebx
	uint32_t data[2] = {0, 0};
	struct nano_timer timer;
	int ret = 0;
	int32_t delay;

	spi_conf.config = config->spi_config_flags;
  102a9e:	8b 46 04             	mov    0x4(%esi),%eax
  102aa1:	89 45 b0             	mov    %eax,-0x50(%ebp)
	spi_conf.max_sys_freq = config->spi_freq;
  102aa4:	8b 46 08             	mov    0x8(%esi),%eax
  102aa7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  102aaa:	8d 45 c0             	lea    -0x40(%ebp),%eax
  102aad:	6a 00                	push   $0x0
  102aaf:	6a 00                	push   $0x0
  102ab1:	50                   	push   %eax
  102ab2:	e8 cb 19 00 00       	call   104482 <k_timer_init>
	timer->_legacy_data = data;
  102ab7:	8d 45 b8             	lea    -0x48(%ebp),%eax
 * @return N/A
 */
static inline __deprecated void
nano_timer_init(struct k_timer *timer, void *data)
{
	k_timer_init(timer, NULL, NULL);
  102aba:	83 c4 0c             	add    $0xc,%esp
	timer->_legacy_data = data;
  102abd:	89 45 f0             	mov    %eax,-0x10(%ebp)

	nano_timer_init(&timer, data);

	if (spi_configure(adc->spi, &spi_conf)) {
  102ac0:	8b 43 24             	mov    0x24(%ebx),%eax
static inline int spi_configure(struct device *dev,
				struct spi_config *config)
{
	const struct spi_driver_api *api = dev->driver_api;

	return api->configure(dev, config);
  102ac3:	8d 4d b0             	lea    -0x50(%ebp),%ecx
  102ac6:	8b 50 04             	mov    0x4(%eax),%edx
  102ac9:	51                   	push   %ecx
  102aca:	50                   	push   %eax
  102acb:	ff 12                	call   *(%edx)
  102acd:	5a                   	pop    %edx
  102ace:	89 45 ac             	mov    %eax,-0x54(%ebp)
  102ad1:	59                   	pop    %ecx
  102ad2:	85 c0                	test   %eax,%eax
  102ad4:	0f 85 90 01 00 00    	jne    102c6a <ti_adc108s102_read+0x1f4>
		return -EIO;
	}

	if (spi_slave_select(adc->spi, config->spi_slave)) {
  102ada:	8b 53 24             	mov    0x24(%ebx),%edx
 */
static inline int spi_slave_select(struct device *dev, uint32_t slave)
{
	const struct spi_driver_api *api = dev->driver_api;

	if (!api->slave_select) {
  102add:	8b 42 04             	mov    0x4(%edx),%eax
  102ae0:	8b 40 04             	mov    0x4(%eax),%eax
  102ae3:	85 c0                	test   %eax,%eax
  102ae5:	75 1a                	jne    102b01 <ti_adc108s102_read+0x8b>
		return -EIO;
	}

	/* Resetting all internal channel data */
	memset(adc->chans, 0, ADC108S102_CHANNELS_SIZE);
  102ae7:	8d 43 28             	lea    0x28(%ebx),%eax
  102aea:	6a 20                	push   $0x20
  102aec:	6a 00                	push   $0x0
  102aee:	50                   	push   %eax
  102aef:	e8 be 01 00 00       	call   102cb2 <memset>
  102af4:	83 c4 0c             	add    $0xc,%esp
{
	struct adc_seq_entry *entry;
	uint32_t chans_set = 0;
	int i;

	for (i = 0; i < seq_table->num_entries; i++) {
  102af7:	0f b6 77 04          	movzbl 0x4(%edi),%esi
  102afb:	31 d2                	xor    %edx,%edx
}

static inline int _verify_entries(struct adc_seq_table *seq_table)
{
	struct adc_seq_entry *entry;
	uint32_t chans_set = 0;
  102afd:	31 c9                	xor    %ecx,%ecx
  102aff:	eb 33                	jmp    102b34 <ti_adc108s102_read+0xbe>
		return 0;
	}

	return api->slave_select(dev, slave);
  102b01:	ff 76 0c             	pushl  0xc(%esi)
  102b04:	52                   	push   %edx
  102b05:	ff d0                	call   *%eax
  102b07:	59                   	pop    %ecx

	if (spi_configure(adc->spi, &spi_conf)) {
		return -EIO;
	}

	if (spi_slave_select(adc->spi, config->spi_slave)) {
  102b08:	85 c0                	test   %eax,%eax
  102b0a:	5e                   	pop    %esi
  102b0b:	74 da                	je     102ae7 <ti_adc108s102_read+0x71>
  102b0d:	e9 58 01 00 00       	jmp    102c6a <ti_adc108s102_read+0x1f4>
	struct adc_seq_entry *entry;
	uint32_t chans_set = 0;
	int i;

	for (i = 0; i < seq_table->num_entries; i++) {
		entry = &seq_table->entries[i];
  102b12:	89 d0                	mov    %edx,%eax
  102b14:	c1 e0 04             	shl    $0x4,%eax
  102b17:	03 07                	add    (%edi),%eax

		if (entry->sampling_delay <= 0 ||
  102b19:	83 38 00             	cmpl   $0x0,(%eax)
  102b1c:	0f 8e 51 01 00 00    	jle    102c73 <ti_adc108s102_read+0x1fd>
  102b22:	80 78 0c 08          	cmpb   $0x8,0xc(%eax)
  102b26:	0f 87 47 01 00 00    	ja     102c73 <ti_adc108s102_read+0x1fd>

		if (!entry->buffer_length) {
			continue;
		}

		chans_set++;
  102b2c:	83 78 08 01          	cmpl   $0x1,0x8(%eax)
  102b30:	83 d9 ff             	sbb    $0xffffffff,%ecx
{
	struct adc_seq_entry *entry;
	uint32_t chans_set = 0;
	int i;

	for (i = 0; i < seq_table->num_entries; i++) {
  102b33:	42                   	inc    %edx
  102b34:	39 f2                	cmp    %esi,%edx
  102b36:	7c da                	jl     102b12 <ti_adc108s102_read+0x9c>
	}

	/* Resetting all internal channel data */
	memset(adc->chans, 0, ADC108S102_CHANNELS_SIZE);

	if (_verify_entries(seq_table) == 0) {
  102b38:	85 c9                	test   %ecx,%ecx
  102b3a:	0f 84 33 01 00 00    	je     102c73 <ti_adc108s102_read+0x1fd>
		return -EINVAL;
	}

	adc->seq_table = seq_table;
  102b40:	89 7b 48             	mov    %edi,0x48(%ebx)
  102b43:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t i;

	adc->cmd_buf_len = 0;
	adc->sampling_buf_len = 1; /* Counting the dummy byte */

	for (i = 0; i < seq_table->num_entries; i++) {
  102b46:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
static inline int32_t _ti_adc108s102_prepare(struct device *dev)
{
	struct ti_adc108s102_data *adc = dev->driver_data;
	struct adc_seq_table *seq_table = adc->seq_table;
	struct ti_adc108s102_chan *chan;
	int32_t sampling_delay = 0;
  102b4d:	31 ff                	xor    %edi,%edi
  102b4f:	8b 50 08             	mov    0x8(%eax),%edx
}

static inline int32_t _ti_adc108s102_prepare(struct device *dev)
{
	struct ti_adc108s102_data *adc = dev->driver_data;
	struct adc_seq_table *seq_table = adc->seq_table;
  102b52:	8b 72 48             	mov    0x48(%edx),%esi
	struct ti_adc108s102_chan *chan;
	int32_t sampling_delay = 0;
	uint32_t i;

	adc->cmd_buf_len = 0;
  102b55:	c6 42 4c 00          	movb   $0x0,0x4c(%edx)
	adc->sampling_buf_len = 1; /* Counting the dummy byte */
  102b59:	c6 42 4d 01          	movb   $0x1,0x4d(%edx)

	for (i = 0; i < seq_table->num_entries; i++) {
  102b5d:	0f b6 46 04          	movzbl 0x4(%esi),%eax
  102b61:	39 45 a8             	cmp    %eax,-0x58(%ebp)
  102b64:	73 35                	jae    102b9b <ti_adc108s102_read+0x125>
		struct adc_seq_entry *entry = &seq_table->entries[i];
  102b66:	8b 5d a8             	mov    -0x58(%ebp),%ebx
  102b69:	c1 e3 04             	shl    $0x4,%ebx
  102b6c:	03 1e                	add    (%esi),%ebx

		/* No more space in the buffer? */
		chan = &adc->chans[entry->channel_id];
  102b6e:	0f b6 4b 0c          	movzbl 0xc(%ebx),%ecx
		if (entry->buffer_length - chan->buf_idx == 0) {
  102b72:	8b 44 8a 28          	mov    0x28(%edx,%ecx,4),%eax
  102b76:	39 43 08             	cmp    %eax,0x8(%ebx)
  102b79:	74 1b                	je     102b96 <ti_adc108s102_read+0x120>
			continue;
		}

		SYS_LOG_DBG("Requesting channel %d\n", entry->channel_id);
		adc->cmd_buffer[adc->cmd_buf_len] =
  102b7b:	0f b6 7a 4c          	movzbl 0x4c(%edx),%edi
  102b7f:	c1 e1 03             	shl    $0x3,%ecx
  102b82:	89 f8                	mov    %edi,%eax
  102b84:	66 81 e1 ff 00       	and    $0xff,%cx
				ADC108S102_CHANNEL_CMD(entry->channel_id);

		adc->cmd_buf_len++;
  102b89:	40                   	inc    %eax
		if (entry->buffer_length - chan->buf_idx == 0) {
			continue;
		}

		SYS_LOG_DBG("Requesting channel %d\n", entry->channel_id);
		adc->cmd_buffer[adc->cmd_buf_len] =
  102b8a:	66 89 0c 7a          	mov    %cx,(%edx,%edi,2)
				ADC108S102_CHANNEL_CMD(entry->channel_id);

		adc->cmd_buf_len++;
  102b8e:	88 42 4c             	mov    %al,0x4c(%edx)
		adc->sampling_buf_len++;
  102b91:	fe 42 4d             	incb   0x4d(%edx)

		sampling_delay = entry->sampling_delay;
  102b94:	8b 3b                	mov    (%ebx),%edi
	uint32_t i;

	adc->cmd_buf_len = 0;
	adc->sampling_buf_len = 1; /* Counting the dummy byte */

	for (i = 0; i < seq_table->num_entries; i++) {
  102b96:	ff 45 a8             	incl   -0x58(%ebp)
  102b99:	eb c2                	jmp    102b5d <ti_adc108s102_read+0xe7>
		adc->sampling_buf_len++;

		sampling_delay = entry->sampling_delay;
	}

	if (adc->cmd_buf_len == 0) {
  102b9b:	8a 42 4c             	mov    0x4c(%edx),%al
  102b9e:	84 c0                	test   %al,%al
  102ba0:	0f 84 d9 00 00 00    	je     102c7f <ti_adc108s102_read+0x209>
		return ADC108S102_DONE;
	}

	/* dummy cmd byte */
	adc->cmd_buffer[adc->cmd_buf_len] = 0;
  102ba6:	0f b6 c8             	movzbl %al,%ecx
	adc->cmd_buf_len++;
  102ba9:	40                   	inc    %eax
	adc->seq_table = seq_table;

	/* Sampling */
	while (1) {
		delay = _ti_adc108s102_prepare(dev);
		if (delay == ADC108S102_DONE) {
  102baa:	83 ff ff             	cmp    $0xffffffff,%edi
	if (adc->cmd_buf_len == 0) {
		return ADC108S102_DONE;
	}

	/* dummy cmd byte */
	adc->cmd_buffer[adc->cmd_buf_len] = 0;
  102bad:	66 c7 04 4a 00 00    	movw   $0x0,(%edx,%ecx,2)
	adc->cmd_buf_len++;
  102bb3:	88 42 4c             	mov    %al,0x4c(%edx)
	adc->seq_table = seq_table;

	/* Sampling */
	while (1) {
		delay = _ti_adc108s102_prepare(dev);
		if (delay == ADC108S102_DONE) {
  102bb6:	0f 84 c3 00 00 00    	je     102c7f <ti_adc108s102_read+0x209>
 * @return N/A
 */
static inline __deprecated void
nano_timer_start(struct nano_timer *timer, int ticks)
{
	k_timer_start(timer, _ticks_to_ms(ticks), 0);
  102bbc:	be e8 03 00 00       	mov    $0x3e8,%esi
  102bc1:	89 f8                	mov    %edi,%eax
  102bc3:	f7 ee                	imul   %esi
  102bc5:	6a 00                	push   $0x0
  102bc7:	6a 00                	push   $0x0
  102bc9:	6a 64                	push   $0x64
  102bcb:	52                   	push   %edx
  102bcc:	50                   	push   %eax
  102bcd:	e8 6e d6 ff ff       	call   100240 <__udivdi3>
  102bd2:	83 c4 10             	add    $0x10,%esp
  102bd5:	50                   	push   %eax
  102bd6:	8d 45 c0             	lea    -0x40(%ebp),%eax
  102bd9:	50                   	push   %eax
  102bda:	e8 ea 18 00 00       	call   1044c9 <k_timer_start>
  102bdf:	83 c4 0c             	add    $0xc,%esp
			break;
		}

		nano_timer_start(&timer, delay);
		nano_task_timer_test(&timer, TICKS_UNLIMITED);
  102be2:	8d 45 c0             	lea    -0x40(%ebp),%eax
  102be5:	6a ff                	push   $0xffffffff
  102be7:	50                   	push   %eax
  102be8:	e8 a1 0c 00 00       	call   10388e <nano_timer_test>
  102bed:	58                   	pop    %eax
  102bee:	8b 45 08             	mov    0x8(%ebp),%eax
  102bf1:	5a                   	pop    %edx
  102bf2:	8b 40 08             	mov    0x8(%eax),%eax
			  const void *tx_buf, uint32_t tx_buf_len,
			  void *rx_buf, uint32_t rx_buf_len)
{
	const struct spi_driver_api *api = dev->driver_api;

	return api->transceive(dev, tx_buf, tx_buf_len, rx_buf, rx_buf_len);
  102bf5:	0f b6 50 4d          	movzbl 0x4d(%eax),%edx
	struct ti_adc108s102_data *adc = dev->driver_data;

	SYS_LOG_DBG("Sampling!\n");

	/* SPI deals with uint8_t buffers so multiplying by 2 the length */
	return spi_transceive(adc->spi, adc->cmd_buffer,
  102bf9:	8b 48 24             	mov    0x24(%eax),%ecx
  102bfc:	01 d2                	add    %edx,%edx
  102bfe:	8b 59 04             	mov    0x4(%ecx),%ebx
  102c01:	52                   	push   %edx
			      adc->cmd_buf_len * 2,
			      adc->sampling_buffer,
  102c02:	8d 50 12             	lea    0x12(%eax),%edx
  102c05:	52                   	push   %edx
  102c06:	0f b6 50 4c          	movzbl 0x4c(%eax),%edx
  102c0a:	01 d2                	add    %edx,%edx
  102c0c:	52                   	push   %edx
  102c0d:	50                   	push   %eax
  102c0e:	51                   	push   %ecx
  102c0f:	ff 53 08             	call   *0x8(%ebx)
  102c12:	83 c4 14             	add    $0x14,%esp

		nano_timer_start(&timer, delay);
		nano_task_timer_test(&timer, TICKS_UNLIMITED);

		ret = _ti_adc108s102_sampling(dev);
		if (ret != 0) {
  102c15:	85 c0                	test   %eax,%eax
  102c17:	75 63                	jne    102c7c <ti_adc108s102_read+0x206>
  102c19:	8b 45 08             	mov    0x8(%ebp),%eax
  102c1c:	8b 58 08             	mov    0x8(%eax),%ebx
	struct adc_seq_entry *entry;
	uint32_t s_i, i;

	SYS_LOG_DBG("_ti_adc108s102_handle_result()");

	for (i = 0, s_i = 1; i < seq_table->num_entries; i++, s_i++) {
  102c1f:	31 c0                	xor    %eax,%eax
}

static inline void _ti_adc108s102_handle_result(struct device *dev)
{
	struct ti_adc108s102_data *adc = dev->driver_data;
	struct adc_seq_table *seq_table = adc->seq_table;
  102c21:	8b 7b 48             	mov    0x48(%ebx),%edi
	struct adc_seq_entry *entry;
	uint32_t s_i, i;

	SYS_LOG_DBG("_ti_adc108s102_handle_result()");

	for (i = 0, s_i = 1; i < seq_table->num_entries; i++, s_i++) {
  102c24:	0f b6 57 04          	movzbl 0x4(%edi),%edx
  102c28:	39 d0                	cmp    %edx,%eax
  102c2a:	0f 83 13 ff ff ff    	jae    102b43 <ti_adc108s102_read+0xcd>
		entry = &seq_table->entries[i];
  102c30:	89 c1                	mov    %eax,%ecx
  102c32:	c1 e1 04             	shl    $0x4,%ecx
  102c35:	03 0f                	add    (%edi),%ecx
  102c37:	0f b6 51 0c          	movzbl 0xc(%ecx),%edx
  102c3b:	8d 34 93             	lea    (%ebx,%edx,4),%esi
  102c3e:	89 75 a8             	mov    %esi,-0x58(%ebp)
		chan = &adc->chans[entry->channel_id];

		if (entry->buffer_length - chan->buf_idx == 0) {
  102c41:	8b 56 28             	mov    0x28(%esi),%edx
  102c44:	39 51 08             	cmp    %edx,0x8(%ecx)
  102c47:	74 1e                	je     102c67 <ti_adc108s102_read+0x1f1>
			continue;
		}

		*((uint16_t *)(entry->buffer+chan->buf_idx)) =
  102c49:	8b 49 04             	mov    0x4(%ecx),%ecx
  102c4c:	89 ce                	mov    %ecx,%esi
  102c4e:	66 8b 4c 43 14       	mov    0x14(%ebx,%eax,2),%cx
  102c53:	86 e9                	xchg   %ch,%cl
  102c55:	66 81 e1 ff 0f       	and    $0xfff,%cx
  102c5a:	66 89 0c 16          	mov    %cx,(%esi,%edx,1)
				ADC108S102_RESULT(adc->sampling_buffer[s_i]);

		chan->buf_idx += 2;
  102c5e:	8b 75 a8             	mov    -0x58(%ebp),%esi
  102c61:	83 c2 02             	add    $0x2,%edx
  102c64:	89 56 28             	mov    %edx,0x28(%esi)
	struct adc_seq_entry *entry;
	uint32_t s_i, i;

	SYS_LOG_DBG("_ti_adc108s102_handle_result()");

	for (i = 0, s_i = 1; i < seq_table->num_entries; i++, s_i++) {
  102c67:	40                   	inc    %eax
  102c68:	eb ba                	jmp    102c24 <ti_adc108s102_read+0x1ae>
	spi_conf.max_sys_freq = config->spi_freq;

	nano_timer_init(&timer, data);

	if (spi_configure(adc->spi, &spi_conf)) {
		return -EIO;
  102c6a:	c7 45 ac fb ff ff ff 	movl   $0xfffffffb,-0x54(%ebp)
  102c71:	eb 0c                	jmp    102c7f <ti_adc108s102_read+0x209>

	/* Resetting all internal channel data */
	memset(adc->chans, 0, ADC108S102_CHANNELS_SIZE);

	if (_verify_entries(seq_table) == 0) {
		return -EINVAL;
  102c73:	c7 45 ac ea ff ff ff 	movl   $0xffffffea,-0x54(%ebp)
  102c7a:	eb 03                	jmp    102c7f <ti_adc108s102_read+0x209>
  102c7c:	89 45 ac             	mov    %eax,-0x54(%ebp)

		_ti_adc108s102_handle_result(dev);
	}

	return ret;
}
  102c7f:	8b 45 ac             	mov    -0x54(%ebp),%eax
  102c82:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102c85:	5b                   	pop    %ebx
  102c86:	5e                   	pop    %esi
  102c87:	5f                   	pop    %edi
  102c88:	5d                   	pop    %ebp
  102c89:	c3                   	ret    

00102c8a <ti_adc108s102_enable>:
  102c8a:	55                   	push   %ebp
  102c8b:	89 e5                	mov    %esp,%ebp
  102c8d:	5d                   	pop    %ebp
  102c8e:	c3                   	ret    

00102c8f <strcmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
  102c8f:	55                   	push   %ebp
	while ((*s1 == *s2) && (*s1 != '\0')) {
  102c90:	31 c9                	xor    %ecx,%ecx
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
  102c92:	89 e5                	mov    %esp,%ebp
	while ((*s1 == *s2) && (*s1 != '\0')) {
  102c94:	8b 45 08             	mov    0x8(%ebp),%eax
  102c97:	8b 55 0c             	mov    0xc(%ebp),%edx
  102c9a:	0f be 04 08          	movsbl (%eax,%ecx,1),%eax
  102c9e:	0f be 14 0a          	movsbl (%edx,%ecx,1),%edx
  102ca2:	38 d0                	cmp    %dl,%al
  102ca4:	75 08                	jne    102cae <strcmp+0x1f>
  102ca6:	41                   	inc    %ecx
  102ca7:	84 c0                	test   %al,%al
  102ca9:	75 e9                	jne    102c94 <strcmp+0x5>
  102cab:	0f be d0             	movsbl %al,%edx
		s1++;
		s2++;
	}

	return *s1 - *s2;
  102cae:	29 d0                	sub    %edx,%eax
}
  102cb0:	5d                   	pop    %ebp
  102cb1:	c3                   	ret    

00102cb2 <memset>:
 *
 * @return pointer to start of buffer
 */

void *memset(void *buf, int c, size_t n)
{
  102cb2:	55                   	push   %ebp
  102cb3:	89 e5                	mov    %esp,%ebp
  102cb5:	57                   	push   %edi
  102cb6:	56                   	push   %esi
  102cb7:	53                   	push   %ebx
  102cb8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  102cbb:	8b 55 10             	mov    0x10(%ebp),%edx
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
  102cbe:	88 d8                	mov    %bl,%al

void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
  102cc0:	8b 4d 08             	mov    0x8(%ebp),%ecx
	unsigned char c_byte = (unsigned char)c;

	while (((unsigned int)d_byte) & 0x3) {
  102cc3:	f6 c1 03             	test   $0x3,%cl
  102cc6:	74 0b                	je     102cd3 <memset+0x21>
		if (n == 0) {
  102cc8:	85 d2                	test   %edx,%edx
  102cca:	74 42                	je     102d0e <memset+0x5c>
			return buf;
		}
		*(d_byte++) = c_byte;
  102ccc:	41                   	inc    %ecx
		n--;
  102ccd:	4a                   	dec    %edx

	while (((unsigned int)d_byte) & 0x3) {
		if (n == 0) {
			return buf;
		}
		*(d_byte++) = c_byte;
  102cce:	88 41 ff             	mov    %al,-0x1(%ecx)
  102cd1:	eb f0                	jmp    102cc3 <memset+0x11>
	};

	/* do word-sized initialization as long as possible */

	unsigned int *d_word = (unsigned int *)d_byte;
	unsigned int c_word = (unsigned int)(unsigned char)c;
  102cd3:	0f b6 db             	movzbl %bl,%ebx

	c_word |= c_word << 8;
  102cd6:	89 de                	mov    %ebx,%esi
  102cd8:	c1 e6 08             	shl    $0x8,%esi
  102cdb:	09 f3                	or     %esi,%ebx
	c_word |= c_word << 16;
  102cdd:	89 de                	mov    %ebx,%esi
  102cdf:	c1 e6 10             	shl    $0x10,%esi
  102ce2:	09 de                	or     %ebx,%esi

	while (n >= sizeof(unsigned int)) {
  102ce4:	31 db                	xor    %ebx,%ebx
  102ce6:	89 d7                	mov    %edx,%edi
  102ce8:	29 df                	sub    %ebx,%edi
  102cea:	83 ff 03             	cmp    $0x3,%edi
  102ced:	76 08                	jbe    102cf7 <memset+0x45>
		*(d_word++) = c_word;
  102cef:	89 34 19             	mov    %esi,(%ecx,%ebx,1)
  102cf2:	83 c3 04             	add    $0x4,%ebx
  102cf5:	eb ef                	jmp    102ce6 <memset+0x34>
  102cf7:	89 d3                	mov    %edx,%ebx
  102cf9:	83 e2 03             	and    $0x3,%edx
  102cfc:	c1 eb 02             	shr    $0x2,%ebx
  102cff:	8d 1c 99             	lea    (%ecx,%ebx,4),%ebx
	unsigned int c_word = (unsigned int)(unsigned char)c;

	c_word |= c_word << 8;
	c_word |= c_word << 16;

	while (n >= sizeof(unsigned int)) {
  102d02:	31 c9                	xor    %ecx,%ecx

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
  102d04:	39 ca                	cmp    %ecx,%edx
  102d06:	74 06                	je     102d0e <memset+0x5c>
		*(d_byte++) = c_byte;
  102d08:	88 04 0b             	mov    %al,(%ebx,%ecx,1)
  102d0b:	41                   	inc    %ecx
  102d0c:	eb f6                	jmp    102d04 <memset+0x52>
		n--;
	}

	return buf;
}
  102d0e:	5b                   	pop    %ebx
  102d0f:	8b 45 08             	mov    0x8(%ebp),%eax
  102d12:	5e                   	pop    %esi
  102d13:	5f                   	pop    %edi
  102d14:	5d                   	pop    %ebp
  102d15:	c3                   	ret    

00102d16 <_nop_char_out>:
 * @param c Character to swallow
 *
 * @return 0
 */
static int _nop_char_out(int c)
{
  102d16:	55                   	push   %ebp
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
  102d17:	31 c0                	xor    %eax,%eax
 * @param c Character to swallow
 *
 * @return 0
 */
static int _nop_char_out(int c)
{
  102d19:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
  102d1b:	5d                   	pop    %ebp
  102d1c:	c3                   	ret    

00102d1d <_printk_dec_ulong>:
 *
 * @return N/A
 */
static void _printk_dec_ulong(const unsigned long num, int pad_zero,
			      int min_width)
{
  102d1d:	55                   	push   %ebp
  102d1e:	89 e5                	mov    %esp,%ebp
  102d20:	57                   	push   %edi
  102d21:	56                   	push   %esi
  102d22:	53                   	push   %ebx
  102d23:	83 ec 0c             	sub    $0xc,%esp
  102d26:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	unsigned long remainder = num;
	int found_largest_digit = 0;
	int remaining = 10; /* 10 digits max */

	/* make sure we don't skip if value is zero */
	if (min_width <= 0) {
  102d29:	85 c9                	test   %ecx,%ecx
  102d2b:	7f 07                	jg     102d34 <_printk_dec_ulong+0x17>
		min_width = 1;
  102d2d:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
  102d34:	83 fa 01             	cmp    $0x1,%edx
  102d37:	89 45 f0             	mov    %eax,-0x10(%ebp)
  102d3a:	19 f6                	sbb    %esi,%esi
  102d3c:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
  102d43:	83 e6 f0             	and    $0xfffffff0,%esi
  102d46:	31 ff                	xor    %edi,%edi
  102d48:	83 c6 30             	add    $0x30,%esi
  102d4b:	bb ff c9 9a 3b       	mov    $0x3b9ac9ff,%ebx
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
  102d50:	3b 5d f0             	cmp    -0x10(%ebp),%ebx
  102d53:	72 04                	jb     102d59 <_printk_dec_ulong+0x3c>
  102d55:	85 ff                	test   %edi,%edi
  102d57:	74 1c                	je     102d75 <_printk_dec_ulong+0x58>
			found_largest_digit = 1;
			_char_out((int)((remainder / (pos + 1)) + 48));
  102d59:	8d 4b 01             	lea    0x1(%ebx),%ecx
  102d5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102d5f:	31 d2                	xor    %edx,%edx
		min_width = 1;
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
			found_largest_digit = 1;
  102d61:	bf 01 00 00 00       	mov    $0x1,%edi
			_char_out((int)((remainder / (pos + 1)) + 48));
  102d66:	f7 f1                	div    %ecx
  102d68:	83 c0 30             	add    $0x30,%eax
  102d6b:	50                   	push   %eax
  102d6c:	ff 15 a0 70 10 00    	call   *0x1070a0
  102d72:	59                   	pop    %ecx
  102d73:	eb 12                	jmp    102d87 <_printk_dec_ulong+0x6a>
		} else if (remaining <= min_width) {
  102d75:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102d78:	31 ff                	xor    %edi,%edi
  102d7a:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
  102d7d:	7c 08                	jl     102d87 <_printk_dec_ulong+0x6a>
			_char_out((int)(pad_zero ? '0' : ' '));
  102d7f:	56                   	push   %esi
  102d80:	ff 15 a0 70 10 00    	call   *0x1070a0
  102d86:	5a                   	pop    %edx
		}
		remaining--;
		remainder %= (pos + 1);
  102d87:	8d 4b 01             	lea    0x1(%ebx),%ecx
  102d8a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102d8d:	31 d2                	xor    %edx,%edx
			found_largest_digit = 1;
			_char_out((int)((remainder / (pos + 1)) + 48));
		} else if (remaining <= min_width) {
			_char_out((int)(pad_zero ? '0' : ' '));
		}
		remaining--;
  102d8f:	ff 4d ec             	decl   -0x14(%ebp)
		remainder %= (pos + 1);
  102d92:	f7 f1                	div    %ecx
  102d94:	89 55 f0             	mov    %edx,-0x10(%ebp)
		pos /= 10;
  102d97:	89 d8                	mov    %ebx,%eax
  102d99:	31 d2                	xor    %edx,%edx
  102d9b:	b9 0a 00 00 00       	mov    $0xa,%ecx
  102da0:	f7 f1                	div    %ecx
  102da2:	89 c3                	mov    %eax,%ebx
	/* make sure we don't skip if value is zero */
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 9) {
  102da4:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
  102da8:	75 a6                	jne    102d50 <_printk_dec_ulong+0x33>
		}
		remaining--;
		remainder %= (pos + 1);
		pos /= 10;
	}
	_char_out((int)(remainder + 48));
  102daa:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102dad:	83 c0 30             	add    $0x30,%eax
  102db0:	50                   	push   %eax
  102db1:	ff 15 a0 70 10 00    	call   *0x1070a0
  102db7:	58                   	pop    %eax
}
  102db8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102dbb:	5b                   	pop    %ebx
  102dbc:	5e                   	pop    %esi
  102dbd:	5f                   	pop    %edi
  102dbe:	5d                   	pop    %ebp
  102dbf:	c3                   	ret    

00102dc0 <__printk_hook_install>:
 * @param fn putc routine to install
 *
 * @return N/A
 */
void __printk_hook_install(int (*fn)(int))
{
  102dc0:	55                   	push   %ebp
  102dc1:	89 e5                	mov    %esp,%ebp
	_char_out = fn;
  102dc3:	8b 45 08             	mov    0x8(%ebp),%eax
}
  102dc6:	5d                   	pop    %ebp
 *
 * @return N/A
 */
void __printk_hook_install(int (*fn)(int))
{
	_char_out = fn;
  102dc7:	a3 a0 70 10 00       	mov    %eax,0x1070a0
}
  102dcc:	c3                   	ret    

00102dcd <printk>:
 * @param fmt formatted string to output
 *
 * @return N/A
 */
void printk(const char *fmt, ...)
{
  102dcd:	55                   	push   %ebp
  102dce:	89 e5                	mov    %esp,%ebp
  102dd0:	57                   	push   %edi
  102dd1:	56                   	push   %esi
  102dd2:	53                   	push   %ebx
  102dd3:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
  102dd6:	8d 5d 0c             	lea    0xc(%ebp),%ebx
 */
static inline void _vprintk(const char *fmt, va_list ap)
{
	int might_format = 0; /* 1 if encountered a '%' */
	int pad_zero = 0;
	int min_width = -1;
  102dd9:	83 ce ff             	or     $0xffffffff,%esi
 * @return N/A
 */
static inline void _vprintk(const char *fmt, va_list ap)
{
	int might_format = 0; /* 1 if encountered a '%' */
	int pad_zero = 0;
  102ddc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 *
 * @return N/A
 */
static inline void _vprintk(const char *fmt, va_list ap)
{
	int might_format = 0; /* 1 if encountered a '%' */
  102de3:	31 ff                	xor    %edi,%edi
	int pad_zero = 0;
	int min_width = -1;

	/* fmt has already been adjusted if needed */

	while (*fmt) {
  102de5:	8b 45 08             	mov    0x8(%ebp),%eax
  102de8:	0f be 00             	movsbl (%eax),%eax
  102deb:	84 c0                	test   %al,%al
  102ded:	0f 84 0b 02 00 00    	je     102ffe <printk+0x231>
		if (!might_format) {
  102df3:	85 ff                	test   %edi,%edi
  102df5:	75 15                	jne    102e0c <printk+0x3f>
			if (*fmt != '%') {
  102df7:	3c 25                	cmp    $0x25,%al
  102df9:	0f 84 df 01 00 00    	je     102fde <printk+0x211>
				_char_out((int)*fmt);
  102dff:	50                   	push   %eax
  102e00:	ff 15 a0 70 10 00    	call   *0x1070a0
  102e06:	58                   	pop    %eax
  102e07:	e9 ea 01 00 00       	jmp    102ff6 <printk+0x229>
				might_format = 1;
				min_width = -1;
				pad_zero = 0;
			}
		} else {
			switch (*fmt) {
  102e0c:	3c 68                	cmp    $0x68,%al
  102e0e:	0f 84 dd 01 00 00    	je     102ff1 <printk+0x224>
  102e14:	7f 32                	jg     102e48 <printk+0x7b>
  102e16:	3c 39                	cmp    $0x39,%al
  102e18:	7f 15                	jg     102e2f <printk+0x62>
  102e1a:	3c 31                	cmp    $0x31,%al
  102e1c:	7d 7f                	jge    102e9d <printk+0xd0>
  102e1e:	3c 25                	cmp    $0x25,%al
  102e20:	0f 84 98 01 00 00    	je     102fbe <printk+0x1f1>
  102e26:	3c 30                	cmp    $0x30,%al
  102e28:	74 62                	je     102e8c <printk+0xbf>
  102e2a:	e9 93 01 00 00       	jmp    102fc2 <printk+0x1f5>
  102e2f:	3c 63                	cmp    $0x63,%al
  102e31:	0f 84 77 01 00 00    	je     102fae <printk+0x1e1>
  102e37:	3c 64                	cmp    $0x64,%al
  102e39:	74 7a                	je     102eb5 <printk+0xe8>
  102e3b:	3c 58                	cmp    $0x58,%al
  102e3d:	0f 85 7f 01 00 00    	jne    102fc2 <printk+0x1f5>
  102e43:	e9 b5 00 00 00       	jmp    102efd <printk+0x130>
  102e48:	3c 73                	cmp    $0x73,%al
  102e4a:	0f 84 47 01 00 00    	je     102f97 <printk+0x1ca>
  102e50:	7f 16                	jg     102e68 <printk+0x9b>
  102e52:	3c 6c                	cmp    $0x6c,%al
  102e54:	0f 84 97 01 00 00    	je     102ff1 <printk+0x224>
  102e5a:	3c 70                	cmp    $0x70,%al
  102e5c:	74 7d                	je     102edb <printk+0x10e>
  102e5e:	3c 69                	cmp    $0x69,%al
  102e60:	0f 85 5c 01 00 00    	jne    102fc2 <printk+0x1f5>
  102e66:	eb 4d                	jmp    102eb5 <printk+0xe8>
  102e68:	3c 78                	cmp    $0x78,%al
  102e6a:	0f 84 8d 00 00 00    	je     102efd <printk+0x130>
  102e70:	3c 7a                	cmp    $0x7a,%al
  102e72:	0f 84 79 01 00 00    	je     102ff1 <printk+0x224>
  102e78:	3c 75                	cmp    $0x75,%al
  102e7a:	0f 85 42 01 00 00    	jne    102fc2 <printk+0x1f5>
				}
				_printk_dec_ulong(d, pad_zero, min_width);
				break;
			}
			case 'u': {
				unsigned long u = va_arg(
  102e80:	8d 7b 04             	lea    0x4(%ebx),%edi
					ap, unsigned long);
				_printk_dec_ulong(u, pad_zero, min_width);
  102e83:	89 f1                	mov    %esi,%ecx
  102e85:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102e88:	8b 03                	mov    (%ebx),%eax
  102e8a:	eb 45                	jmp    102ed1 <printk+0x104>
				pad_zero = 0;
			}
		} else {
			switch (*fmt) {
			case '0':
				if (min_width < 0 && pad_zero == 0) {
  102e8c:	89 f2                	mov    %esi,%edx
  102e8e:	c1 ea 1f             	shr    $0x1f,%edx
  102e91:	74 0a                	je     102e9d <printk+0xd0>
  102e93:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  102e97:	0f 84 4d 01 00 00    	je     102fea <printk+0x21d>
					pad_zero = 1;
					goto still_might_format;
				}
				/* Fall through */
			case '1' ... '9':
				if (min_width < 0) {
  102e9d:	85 f6                	test   %esi,%esi
  102e9f:	79 08                	jns    102ea9 <printk+0xdc>
					min_width = *fmt - '0';
  102ea1:	8d 70 d0             	lea    -0x30(%eax),%esi
  102ea4:	e9 48 01 00 00       	jmp    102ff1 <printk+0x224>
				} else {
					min_width = 10 * min_width + *fmt - '0';
  102ea9:	6b f6 0a             	imul   $0xa,%esi,%esi
  102eac:	8d 74 06 d0          	lea    -0x30(%esi,%eax,1),%esi
  102eb0:	e9 3c 01 00 00       	jmp    102ff1 <printk+0x224>
			case 'h':
				/* FIXME: do nothing for these modifiers */
				goto still_might_format;
			case 'd':
			case 'i': {
				long d = va_arg(ap, long);
  102eb5:	8d 7b 04             	lea    0x4(%ebx),%edi
  102eb8:	8b 1b                	mov    (%ebx),%ebx

				if (d < 0) {
  102eba:	85 db                	test   %ebx,%ebx
  102ebc:	79 0c                	jns    102eca <printk+0xfd>
					_char_out((int)'-');
  102ebe:	6a 2d                	push   $0x2d
					d = -d;
					min_width--;
  102ec0:	4e                   	dec    %esi
			case 'd':
			case 'i': {
				long d = va_arg(ap, long);

				if (d < 0) {
					_char_out((int)'-');
  102ec1:	ff 15 a0 70 10 00    	call   *0x1070a0
  102ec7:	58                   	pop    %eax
					d = -d;
  102ec8:	f7 db                	neg    %ebx
					min_width--;
				}
				_printk_dec_ulong(d, pad_zero, min_width);
  102eca:	89 f1                	mov    %esi,%ecx
  102ecc:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102ecf:	89 d8                	mov    %ebx,%eax
				break;
			}
			case 'u': {
				unsigned long u = va_arg(
					ap, unsigned long);
				_printk_dec_ulong(u, pad_zero, min_width);
  102ed1:	e8 47 fe ff ff       	call   102d1d <_printk_dec_ulong>
  102ed6:	e9 df 00 00 00       	jmp    102fba <printk+0x1ed>
				break;
			}
			case 'p':
				  _char_out('0');
  102edb:	6a 30                	push   $0x30
  102edd:	ff 15 a0 70 10 00    	call   *0x1070a0
				  _char_out('x');
  102ee3:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
				  /* left-pad pointers with zeros */
				  pad_zero = 1;
				  min_width = 8;
  102eea:	be 08 00 00 00       	mov    $0x8,%esi
				_printk_dec_ulong(u, pad_zero, min_width);
				break;
			}
			case 'p':
				  _char_out('0');
				  _char_out('x');
  102eef:	ff 15 a0 70 10 00    	call   *0x1070a0
  102ef5:	58                   	pop    %eax
				  /* left-pad pointers with zeros */
				  pad_zero = 1;
  102ef6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
  102efd:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
				  min_width = 8;
				  /* Fall through */
			case 'x':
			case 'X': {
				unsigned long x = va_arg(
  102f01:	8d 43 04             	lea    0x4(%ebx),%eax
 * @return N/A
 */
static void _printk_hex_ulong(const unsigned long num, int pad_zero,
			      int min_width)
{
	int size = sizeof(num) * 2;
  102f04:	ba 08 00 00 00       	mov    $0x8,%edx
				  pad_zero = 1;
				  min_width = 8;
				  /* Fall through */
			case 'x':
			case 'X': {
				unsigned long x = va_arg(
  102f09:	89 45 e8             	mov    %eax,-0x18(%ebp)
  102f0c:	8b 03                	mov    (%ebx),%eax
  102f0e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
static void _printk_hex_ulong(const unsigned long num, int pad_zero,
			      int min_width)
{
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
	int remaining = 8; /* 8 digits max */
  102f11:	bb 08 00 00 00       	mov    $0x8,%ebx
  102f16:	19 c0                	sbb    %eax,%eax
 */
static void _printk_hex_ulong(const unsigned long num, int pad_zero,
			      int min_width)
{
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
  102f18:	31 ff                	xor    %edi,%edi
  102f1a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  102f1d:	83 65 ec f0          	andl   $0xfffffff0,-0x14(%ebp)
  102f21:	83 45 ec 30          	addl   $0x30,-0x14(%ebp)
	int remaining = 8; /* 8 digits max */

	for (; size; size--) {
		char nibble = (num >> ((size - 1) << 2) & 0xf);
  102f25:	4a                   	dec    %edx
  102f26:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  102f29:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
  102f30:	d3 e8                	shr    %cl,%eax
  102f32:	89 c1                	mov    %eax,%ecx

		if (nibble || found_largest_digit || size == 1) {
  102f34:	80 e1 0f             	and    $0xf,%cl
  102f37:	75 0c                	jne    102f45 <printk+0x178>
  102f39:	85 ff                	test   %edi,%edi
  102f3b:	75 08                	jne    102f45 <printk+0x178>
  102f3d:	85 d2                	test   %edx,%edx
  102f3f:	75 2a                	jne    102f6b <printk+0x19e>
			found_largest_digit = 1;
			nibble += nibble > 9 ? 87 : 48;
  102f41:	b0 30                	mov    $0x30,%al
  102f43:	eb 0d                	jmp    102f52 <printk+0x185>
  102f45:	80 f9 09             	cmp    $0x9,%cl
  102f48:	0f 9f c0             	setg   %al
  102f4b:	48                   	dec    %eax
  102f4c:	83 e0 d9             	and    $0xffffffd9,%eax
  102f4f:	83 c0 57             	add    $0x57,%eax
			_char_out((int)nibble);
  102f52:	01 c8                	add    %ecx,%eax
  102f54:	89 55 e0             	mov    %edx,-0x20(%ebp)
  102f57:	0f b6 c0             	movzbl %al,%eax
  102f5a:	50                   	push   %eax
  102f5b:	ff 15 a0 70 10 00    	call   *0x1070a0
  102f61:	5f                   	pop    %edi
  102f62:	89 d9                	mov    %ebx,%ecx

	for (; size; size--) {
		char nibble = (num >> ((size - 1) << 2) & 0xf);

		if (nibble || found_largest_digit || size == 1) {
			found_largest_digit = 1;
  102f64:	bf 01 00 00 00       	mov    $0x1,%edi
  102f69:	eb 1c                	jmp    102f87 <printk+0x1ba>
			nibble += nibble > 9 ? 87 : 48;
			_char_out((int)nibble);
			continue;
		}

		if (remaining-- <= min_width) {
  102f6b:	31 ff                	xor    %edi,%edi
  102f6d:	8d 4b ff             	lea    -0x1(%ebx),%ecx
  102f70:	39 de                	cmp    %ebx,%esi
  102f72:	7c 16                	jl     102f8a <printk+0x1bd>
			_char_out((int)(pad_zero ? '0' : ' '));
  102f74:	ff 75 ec             	pushl  -0x14(%ebp)
  102f77:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  102f7a:	89 55 e0             	mov    %edx,-0x20(%ebp)
  102f7d:	ff 15 a0 70 10 00    	call   *0x1070a0
  102f83:	5b                   	pop    %ebx
  102f84:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  102f87:	8b 55 e0             	mov    -0x20(%ebp),%edx
{
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
	int remaining = 8; /* 8 digits max */

	for (; size; size--) {
  102f8a:	85 d2                	test   %edx,%edx
  102f8c:	74 04                	je     102f92 <printk+0x1c5>
  102f8e:	89 cb                	mov    %ecx,%ebx
  102f90:	eb 93                	jmp    102f25 <printk+0x158>
				  pad_zero = 1;
				  min_width = 8;
				  /* Fall through */
			case 'x':
			case 'X': {
				unsigned long x = va_arg(
  102f92:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  102f95:	eb 43                	jmp    102fda <printk+0x20d>
					ap, unsigned long);
				_printk_hex_ulong(x, pad_zero, min_width);
				break;
			}
			case 's': {
				char *s = va_arg(ap, char *);
  102f97:	8d 7b 04             	lea    0x4(%ebx),%edi
  102f9a:	8b 1b                	mov    (%ebx),%ebx

				while (*s)
  102f9c:	0f be 03             	movsbl (%ebx),%eax
  102f9f:	84 c0                	test   %al,%al
  102fa1:	74 17                	je     102fba <printk+0x1ed>
					_char_out((int)(*s++));
  102fa3:	50                   	push   %eax
  102fa4:	43                   	inc    %ebx
  102fa5:	ff 15 a0 70 10 00    	call   *0x1070a0
  102fab:	59                   	pop    %ecx
  102fac:	eb ee                	jmp    102f9c <printk+0x1cf>
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);

				_char_out(c);
  102fae:	ff 33                	pushl  (%ebx)
				while (*s)
					_char_out((int)(*s++));
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);
  102fb0:	8d 7b 04             	lea    0x4(%ebx),%edi

				_char_out(c);
  102fb3:	ff 15 a0 70 10 00    	call   *0x1070a0
  102fb9:	5a                   	pop    %edx
				while (*s)
					_char_out((int)(*s++));
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);
  102fba:	89 fb                	mov    %edi,%ebx
  102fbc:	eb 1c                	jmp    102fda <printk+0x20d>

				_char_out(c);
				break;
			}
			case '%': {
				_char_out((int)'%');
  102fbe:	6a 25                	push   $0x25
  102fc0:	eb 11                	jmp    102fd3 <printk+0x206>
				break;
			}
			default:
				_char_out((int)'%');
  102fc2:	6a 25                	push   $0x25
  102fc4:	ff 15 a0 70 10 00    	call   *0x1070a0
				_char_out((int)*fmt);
  102fca:	8b 45 08             	mov    0x8(%ebp),%eax
  102fcd:	0f be 00             	movsbl (%eax),%eax
  102fd0:	89 04 24             	mov    %eax,(%esp)
  102fd3:	ff 15 a0 70 10 00    	call   *0x1070a0
  102fd9:	58                   	pop    %eax
				break;
			}
			might_format = 0;
  102fda:	31 ff                	xor    %edi,%edi
  102fdc:	eb 18                	jmp    102ff6 <printk+0x229>
		if (!might_format) {
			if (*fmt != '%') {
				_char_out((int)*fmt);
			} else {
				might_format = 1;
				min_width = -1;
  102fde:	83 ce ff             	or     $0xffffffff,%esi
				pad_zero = 0;
  102fe1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  102fe8:	eb 07                	jmp    102ff1 <printk+0x224>
			}
		} else {
			switch (*fmt) {
			case '0':
				if (min_width < 0 && pad_zero == 0) {
					pad_zero = 1;
  102fea:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				pad_zero = 0;
			}
		} else {
			switch (*fmt) {
			case '0':
				if (min_width < 0 && pad_zero == 0) {
  102ff1:	bf 01 00 00 00       	mov    $0x1,%edi
				break;
			}
			might_format = 0;
		}
still_might_format:
		++fmt;
  102ff6:	ff 45 08             	incl   0x8(%ebp)
  102ff9:	e9 e7 fd ff ff       	jmp    102de5 <printk+0x18>
	va_list ap;

	va_start(ap, fmt);
	_vprintk(fmt, ap);
	va_end(ap);
}
  102ffe:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103001:	5b                   	pop    %ebx
  103002:	5e                   	pop    %esi
  103003:	5f                   	pop    %edi
  103004:	5d                   	pop    %ebp
  103005:	c3                   	ret    

00103006 <_ConfigAbsSyms>:
/* file is auto-generated, do not modify ! */

#include <toolchain.h>

GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
  103006:	55                   	push   %ebp
  103007:	89 e5                	mov    %esp,%ebp
GEN_ABSOLUTE_SYM(CONFIG_MICROKERNEL, 1);
GEN_ABSOLUTE_SYM(CONFIG_MEM_POOL_SPLIT_BEFORE_DEFRAG, 1);
GEN_ABSOLUTE_SYM(CONFIG_ISA_IA32, 1);
GEN_ABSOLUTE_SYM(CONFIG_PINMUX_GALILEO_EXP0_NAME, 1);

GEN_ABS_SYM_END
  103009:	5d                   	pop    %ebp
  10300a:	c3                   	ret    

0010300b <gpio_pin_configure>:
 * @param flags Flags for pin configuration. IN/OUT, interrupt ...
 * @return 0 if successful, negative errno code on failure.
 */
static inline int gpio_pin_configure(struct device *port, uint8_t pin,
				     int flags)
{
  10300b:	55                   	push   %ebp
  10300c:	89 e5                	mov    %esp,%ebp
  10300e:	53                   	push   %ebx
	const struct gpio_driver_api *api = port->driver_api;

	return api->config(port, GPIO_ACCESS_BY_PIN, pin, flags);
  10300f:	8b 58 04             	mov    0x4(%eax),%ebx
  103012:	51                   	push   %ecx
  103013:	0f b6 d2             	movzbl %dl,%edx
  103016:	52                   	push   %edx
  103017:	6a 00                	push   $0x0
  103019:	50                   	push   %eax
  10301a:	ff 13                	call   *(%ebx)
  10301c:	83 c4 10             	add    $0x10,%esp
}
  10301f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  103022:	c9                   	leave  
  103023:	c3                   	ret    

00103024 <gpio_pin_write>:
 * @param value Value set on the pin.
 * @return 0 if successful, negative errno code on failure.
 */
static inline int gpio_pin_write(struct device *port, uint32_t pin,
				 uint32_t value)
{
  103024:	55                   	push   %ebp
  103025:	89 e5                	mov    %esp,%ebp
  103027:	53                   	push   %ebx
	const struct gpio_driver_api *api = port->driver_api;

	return api->write(port, GPIO_ACCESS_BY_PIN, pin, value);
  103028:	8b 58 04             	mov    0x4(%eax),%ebx
  10302b:	51                   	push   %ecx
  10302c:	52                   	push   %edx
  10302d:	6a 00                	push   $0x0
  10302f:	50                   	push   %eax
  103030:	ff 53 04             	call   *0x4(%ebx)
  103033:	83 c4 10             	add    $0x10,%esp
}
  103036:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  103039:	c9                   	leave  
  10303a:	c3                   	ret    

0010303b <_galileo_pinmux_set_pin>:
			     { NONE,  0, DONT_CARE, (GPIO_DIR_IN)  },
			     { NONE,  0, DONT_CARE, (GPIO_DIR_IN)  } } },
};

int _galileo_pinmux_set_pin(struct device *port, uint8_t pin, uint32_t func)
{
  10303b:	55                   	push   %ebp
  10303c:	89 e5                	mov    %esp,%ebp
  10303e:	57                   	push   %edi
  10303f:	56                   	push   %esi
  103040:	53                   	push   %ebx
  103041:	50                   	push   %eax
	struct galileo_data * const drv_data = port->driver_data;
  103042:	8b 45 08             	mov    0x8(%ebp),%eax
			     { NONE,  0, DONT_CARE, (GPIO_DIR_IN)  },
			     { NONE,  0, DONT_CARE, (GPIO_DIR_IN)  } } },
};

int _galileo_pinmux_set_pin(struct device *port, uint8_t pin, uint32_t func)
{
  103045:	8b 55 0c             	mov    0xc(%ebp),%edx
  103048:	8b 5d 10             	mov    0x10(%ebp),%ebx
	uint8_t mux_index = 0;
	uint8_t i = 0;
	struct mux_path *enable = NULL;
	struct pin_config *mux_config = drv_data->mux_config;

	if (pin > PINMUX_NUM_PINS) {
  10304b:	80 fa 14             	cmp    $0x14,%dl
			     { NONE,  0, DONT_CARE, (GPIO_DIR_IN)  } } },
};

int _galileo_pinmux_set_pin(struct device *port, uint8_t pin, uint32_t func)
{
	struct galileo_data * const drv_data = port->driver_data;
  10304e:	8b 70 08             	mov    0x8(%eax),%esi
  103051:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax

	uint8_t mux_index = 0;
	uint8_t i = 0;
	struct mux_path *enable = NULL;
	struct pin_config *mux_config = drv_data->mux_config;
  103056:	8b 4e 1c             	mov    0x1c(%esi),%ecx

	if (pin > PINMUX_NUM_PINS) {
  103059:	0f 87 10 01 00 00    	ja     10316f <_galileo_pinmux_set_pin+0x134>
		return -ENOTSUP;
	}

	mux_config[pin].mode = func;
  10305f:	0f b6 c2             	movzbl %dl,%eax
	mux_index = NUM_PIN_FUNCS * pin;
	/*
	 * functions are in numeric order, we can just skip to the index
	 * needed
	 */
	mux_index += func;
  103062:	c6 45 f3 05          	movb   $0x5,-0xd(%ebp)

	if (pin > PINMUX_NUM_PINS) {
		return -ENOTSUP;
	}

	mux_config[pin].mode = func;
  103066:	89 5c c1 04          	mov    %ebx,0x4(%ecx,%eax,8)
  10306a:	8d 1c 93             	lea    (%ebx,%edx,4),%ebx
  10306d:	0f b6 db             	movzbl %bl,%ebx
  103070:	6b db 54             	imul   $0x54,%ebx,%ebx
  103073:	81 c3 60 49 10 00    	add    $0x104960,%ebx
	mux_index += func;

	enable = &_galileo_path[mux_index];

	for (i = 0; i < 5; i++) {
		switch (enable->path[i].mux) {
  103079:	8b 43 04             	mov    0x4(%ebx),%eax
  10307c:	48                   	dec    %eax
  10307d:	83 f8 06             	cmp    $0x6,%eax
  103080:	0f 87 db 00 00 00    	ja     103161 <_galileo_pinmux_set_pin+0x126>
  103086:	ff 24 85 28 49 10 00 	jmp    *0x104928(,%eax,4)
		case EXP0:
			gpio_pin_write(drv_data->exp0,
  10308d:	0f b6 7b 08          	movzbl 0x8(%ebx),%edi
  103091:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  103094:	89 fa                	mov    %edi,%edx
  103096:	8b 06                	mov    (%esi),%eax
  103098:	e8 87 ff ff ff       	call   103024 <gpio_pin_write>
					   enable->path[i].pin,
					   enable->path[i].level);
			gpio_pin_configure(drv_data->exp0,
  10309d:	8b 4b 10             	mov    0x10(%ebx),%ecx
  1030a0:	89 fa                	mov    %edi,%edx
  1030a2:	8b 06                	mov    (%esi),%eax
  1030a4:	e9 b3 00 00 00       	jmp    10315c <_galileo_pinmux_set_pin+0x121>
					   enable->path[i].pin,
					   enable->path[i].cfg);
			break;
		case EXP1:
			gpio_pin_write(drv_data->exp1,
  1030a9:	0f b6 7b 08          	movzbl 0x8(%ebx),%edi
  1030ad:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  1030b0:	8b 46 04             	mov    0x4(%esi),%eax
  1030b3:	89 fa                	mov    %edi,%edx
  1030b5:	e8 6a ff ff ff       	call   103024 <gpio_pin_write>
					   enable->path[i].pin,
					   enable->path[i].level);
			gpio_pin_configure(drv_data->exp1,
  1030ba:	8b 4b 10             	mov    0x10(%ebx),%ecx
  1030bd:	8b 46 04             	mov    0x4(%esi),%eax
  1030c0:	e9 95 00 00 00       	jmp    10315a <_galileo_pinmux_set_pin+0x11f>
					   enable->path[i].pin,
					   enable->path[i].cfg);
			break;
		case EXP2:
			gpio_pin_write(drv_data->exp2,
  1030c5:	0f b6 7b 08          	movzbl 0x8(%ebx),%edi
  1030c9:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  1030cc:	8b 46 08             	mov    0x8(%esi),%eax
  1030cf:	89 fa                	mov    %edi,%edx
  1030d1:	e8 4e ff ff ff       	call   103024 <gpio_pin_write>
					   enable->path[i].pin,
					   enable->path[i].level);
			gpio_pin_configure(drv_data->exp2,
  1030d6:	8b 4b 10             	mov    0x10(%ebx),%ecx
  1030d9:	8b 46 08             	mov    0x8(%esi),%eax
  1030dc:	eb 7c                	jmp    10315a <_galileo_pinmux_set_pin+0x11f>
					   enable->path[i].pin,
					   enable->path[i].cfg);
			break;
		case PWM0:
			pwm_pin_configure(drv_data->pwm0,
  1030de:	8b 46 0c             	mov    0xc(%esi),%eax
static inline int __deprecated pwm_pin_configure(struct device *dev,
						 uint8_t pwm, int flags)
{
	const struct pwm_driver_api *api = dev->driver_api;

	return api->config(dev, PWM_ACCESS_BY_PIN, pwm, flags);
  1030e1:	0f b6 7b 08          	movzbl 0x8(%ebx),%edi
  1030e5:	8b 50 04             	mov    0x4(%eax),%edx
  1030e8:	6a 00                	push   $0x0
  1030ea:	57                   	push   %edi
  1030eb:	6a 00                	push   $0x0
  1030ed:	50                   	push   %eax
  1030ee:	ff 12                	call   *(%edx)
  1030f0:	83 c4 10             	add    $0x10,%esp
				enable->path[i].pin, 0);
			pwm_pin_set_duty_cycle(drv_data->pwm0,
  1030f3:	8b 56 0c             	mov    0xc(%esi),%edx
  1030f6:	83 7b 0c 01          	cmpl   $0x1,0xc(%ebx)
  1030fa:	19 c0                	sbb    %eax,%eax
						      uint32_t pwm,
						      uint8_t duty)
{
	const struct pwm_driver_api *api = dev->driver_api;

	return api->set_duty_cycle(dev, PWM_ACCESS_BY_PIN, pwm, duty);
  1030fc:	8b 4a 04             	mov    0x4(%edx),%ecx
  1030ff:	f7 d0                	not    %eax
  103101:	83 e0 64             	and    $0x64,%eax
  103104:	50                   	push   %eax
  103105:	57                   	push   %edi
  103106:	6a 00                	push   $0x0
  103108:	52                   	push   %edx
  103109:	ff 51 0c             	call   *0xc(%ecx)
  10310c:	83 c4 10             	add    $0x10,%esp
  10310f:	eb 50                	jmp    103161 <_galileo_pinmux_set_pin+0x126>
				enable->path[i].pin,
				enable->path[i].level ? 100 : 0);
			break;
		case G_DW:
			gpio_pin_write(drv_data->gpio_dw,
  103111:	0f b6 7b 08          	movzbl 0x8(%ebx),%edi
  103115:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  103118:	8b 46 10             	mov    0x10(%esi),%eax
  10311b:	89 fa                	mov    %edi,%edx
  10311d:	e8 02 ff ff ff       	call   103024 <gpio_pin_write>
					   enable->path[i].pin,
					   enable->path[i].level);
			gpio_pin_configure(drv_data->gpio_dw,
  103122:	8b 4b 10             	mov    0x10(%ebx),%ecx
  103125:	8b 46 10             	mov    0x10(%esi),%eax
  103128:	eb 30                	jmp    10315a <_galileo_pinmux_set_pin+0x11f>
					   enable->path[i].pin,
					   enable->path[i].cfg);
			break;
		case G_CW:
			gpio_pin_write(drv_data->gpio_core,
  10312a:	0f b6 7b 08          	movzbl 0x8(%ebx),%edi
  10312e:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  103131:	8b 46 14             	mov    0x14(%esi),%eax
  103134:	89 fa                	mov    %edi,%edx
  103136:	e8 e9 fe ff ff       	call   103024 <gpio_pin_write>
					   enable->path[i].pin,
					   enable->path[i].level);
			gpio_pin_configure(drv_data->gpio_core,
  10313b:	8b 4b 10             	mov    0x10(%ebx),%ecx
  10313e:	8b 46 14             	mov    0x14(%esi),%eax
  103141:	eb 17                	jmp    10315a <_galileo_pinmux_set_pin+0x11f>
					   enable->path[i].pin,
					   enable->path[i].cfg);
			break;
		case G_RW:
			gpio_pin_write(drv_data->gpio_resume,
  103143:	0f b6 7b 08          	movzbl 0x8(%ebx),%edi
  103147:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  10314a:	8b 46 18             	mov    0x18(%esi),%eax
  10314d:	89 fa                	mov    %edi,%edx
  10314f:	e8 d0 fe ff ff       	call   103024 <gpio_pin_write>
					   enable->path[i].pin,
					   enable->path[i].level);
			gpio_pin_configure(drv_data->gpio_resume,
  103154:	8b 4b 10             	mov    0x10(%ebx),%ecx
  103157:	8b 46 18             	mov    0x18(%esi),%eax
  10315a:	89 fa                	mov    %edi,%edx
  10315c:	e8 aa fe ff ff       	call   10300b <gpio_pin_configure>
  103161:	83 c3 10             	add    $0x10,%ebx
	 */
	mux_index += func;

	enable = &_galileo_path[mux_index];

	for (i = 0; i < 5; i++) {
  103164:	fe 4d f3             	decb   -0xd(%ebp)
  103167:	0f 85 0c ff ff ff    	jne    103079 <_galileo_pinmux_set_pin+0x3e>
			/* no need to do anything */
			break;
		}
	}

	return 0;
  10316d:	31 c0                	xor    %eax,%eax
}
  10316f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103172:	5b                   	pop    %ebx
  103173:	5e                   	pop    %esi
  103174:	5f                   	pop    %edi
  103175:	5d                   	pop    %ebp
  103176:	c3                   	ret    

00103177 <pinmux_galileo_initialize>:
	.pwm0 = NULL,
	.mux_config = mux_config,
};

static int pinmux_galileo_initialize(struct device *port)
{
  103177:	55                   	push   %ebp
  103178:	89 e5                	mov    %esp,%ebp
  10317a:	56                   	push   %esi
  10317b:	53                   	push   %ebx
  10317c:	8b 75 08             	mov    0x8(%ebp),%esi
	struct galileo_data *dev = port->driver_data;
  10317f:	8b 5e 08             	mov    0x8(%esi),%ebx
	int i;

	/* Grab the EXP0, EXP1, EXP2, and PWM0 now by name */
	dev->exp0 = device_get_binding(PINMUX_GALILEO_EXP0_NAME);
  103182:	68 d5 47 10 00       	push   $0x1047d5
  103187:	e8 60 05 00 00       	call   1036ec <device_get_binding>
  10318c:	5a                   	pop    %edx
	if (!dev->exp0) {
  10318d:	85 c0                	test   %eax,%eax
{
	struct galileo_data *dev = port->driver_data;
	int i;

	/* Grab the EXP0, EXP1, EXP2, and PWM0 now by name */
	dev->exp0 = device_get_binding(PINMUX_GALILEO_EXP0_NAME);
  10318f:	89 03                	mov    %eax,(%ebx)
	if (!dev->exp0) {
  103191:	75 0a                	jne    10319d <pinmux_galileo_initialize+0x26>
		return -EINVAL;
  103193:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  103198:	e9 8e 00 00 00       	jmp    10322b <pinmux_galileo_initialize+0xb4>
	}
	dev->exp1 = device_get_binding(PINMUX_GALILEO_EXP1_NAME);
  10319d:	68 d0 47 10 00       	push   $0x1047d0
  1031a2:	e8 45 05 00 00       	call   1036ec <device_get_binding>
  1031a7:	59                   	pop    %ecx
	if (!dev->exp1) {
  1031a8:	85 c0                	test   %eax,%eax
	/* Grab the EXP0, EXP1, EXP2, and PWM0 now by name */
	dev->exp0 = device_get_binding(PINMUX_GALILEO_EXP0_NAME);
	if (!dev->exp0) {
		return -EINVAL;
	}
	dev->exp1 = device_get_binding(PINMUX_GALILEO_EXP1_NAME);
  1031aa:	89 43 04             	mov    %eax,0x4(%ebx)
	if (!dev->exp1) {
  1031ad:	74 e4                	je     103193 <pinmux_galileo_initialize+0x1c>
		return -EINVAL;
	}
	dev->exp2 = device_get_binding(PINMUX_GALILEO_EXP2_NAME);
  1031af:	68 c5 47 10 00       	push   $0x1047c5
  1031b4:	e8 33 05 00 00       	call   1036ec <device_get_binding>
  1031b9:	5a                   	pop    %edx
	if (!dev->exp2) {
  1031ba:	85 c0                	test   %eax,%eax
	}
	dev->exp1 = device_get_binding(PINMUX_GALILEO_EXP1_NAME);
	if (!dev->exp1) {
		return -EINVAL;
	}
	dev->exp2 = device_get_binding(PINMUX_GALILEO_EXP2_NAME);
  1031bc:	89 43 08             	mov    %eax,0x8(%ebx)
	if (!dev->exp2) {
  1031bf:	74 d2                	je     103193 <pinmux_galileo_initialize+0x1c>
		return -EINVAL;
	}
	dev->pwm0 = device_get_binding(PINMUX_GALILEO_PWM0_NAME);
  1031c1:	68 ea 47 10 00       	push   $0x1047ea
  1031c6:	e8 21 05 00 00       	call   1036ec <device_get_binding>
  1031cb:	59                   	pop    %ecx
	if (!dev->pwm0) {
  1031cc:	85 c0                	test   %eax,%eax
	}
	dev->exp2 = device_get_binding(PINMUX_GALILEO_EXP2_NAME);
	if (!dev->exp2) {
		return -EINVAL;
	}
	dev->pwm0 = device_get_binding(PINMUX_GALILEO_PWM0_NAME);
  1031ce:	89 43 0c             	mov    %eax,0xc(%ebx)
	if (!dev->pwm0) {
  1031d1:	74 c0                	je     103193 <pinmux_galileo_initialize+0x1c>
		return -EINVAL;
	}
	dev->gpio_dw = device_get_binding(PINMUX_GALILEO_GPIO_DW_NAME);
  1031d3:	68 be 47 10 00       	push   $0x1047be
  1031d8:	e8 0f 05 00 00       	call   1036ec <device_get_binding>
  1031dd:	5a                   	pop    %edx
	if (!dev->gpio_dw) {
  1031de:	85 c0                	test   %eax,%eax
	}
	dev->pwm0 = device_get_binding(PINMUX_GALILEO_PWM0_NAME);
	if (!dev->pwm0) {
		return -EINVAL;
	}
	dev->gpio_dw = device_get_binding(PINMUX_GALILEO_GPIO_DW_NAME);
  1031e0:	89 43 10             	mov    %eax,0x10(%ebx)
	if (!dev->gpio_dw) {
  1031e3:	74 ae                	je     103193 <pinmux_galileo_initialize+0x1c>
		return -EINVAL;
	}
	dev->gpio_core = device_get_binding(
  1031e5:	68 e2 47 10 00       	push   $0x1047e2
  1031ea:	e8 fd 04 00 00       	call   1036ec <device_get_binding>
  1031ef:	59                   	pop    %ecx
			    PINMUX_GALILEO_GPIO_INTEL_CW_NAME);
	if (!dev->gpio_core) {
  1031f0:	85 c0                	test   %eax,%eax
	}
	dev->gpio_dw = device_get_binding(PINMUX_GALILEO_GPIO_DW_NAME);
	if (!dev->gpio_dw) {
		return -EINVAL;
	}
	dev->gpio_core = device_get_binding(
  1031f2:	89 43 14             	mov    %eax,0x14(%ebx)
			    PINMUX_GALILEO_GPIO_INTEL_CW_NAME);
	if (!dev->gpio_core) {
  1031f5:	74 9c                	je     103193 <pinmux_galileo_initialize+0x1c>
		return -EINVAL;
	}
	dev->gpio_resume = device_get_binding(
  1031f7:	68 da 47 10 00       	push   $0x1047da
  1031fc:	e8 eb 04 00 00       	call   1036ec <device_get_binding>
  103201:	5a                   	pop    %edx
			    PINMUX_GALILEO_GPIO_INTEL_RW_NAME);
	if (!dev->gpio_resume) {
  103202:	85 c0                	test   %eax,%eax
	dev->gpio_core = device_get_binding(
			    PINMUX_GALILEO_GPIO_INTEL_CW_NAME);
	if (!dev->gpio_core) {
		return -EINVAL;
	}
	dev->gpio_resume = device_get_binding(
  103204:	89 43 18             	mov    %eax,0x18(%ebx)
			    PINMUX_GALILEO_GPIO_INTEL_RW_NAME);
	if (!dev->gpio_resume) {
  103207:	74 8a                	je     103193 <pinmux_galileo_initialize+0x1c>
  103209:	bb c0 70 10 00       	mov    $0x1070c0,%ebx
	/*
	 * Now that we have everything, let us start parsing everything
	 * from the above mapping as selected by the end user
	 */
	for (i = 0; i < PINMUX_NUM_PINS; i++) {
		_galileo_pinmux_set_pin(port,
  10320e:	ff 73 04             	pushl  0x4(%ebx)
  103211:	0f b6 03             	movzbl (%ebx),%eax
  103214:	83 c3 08             	add    $0x8,%ebx
  103217:	50                   	push   %eax
  103218:	56                   	push   %esi
  103219:	e8 1d fe ff ff       	call   10303b <_galileo_pinmux_set_pin>
  10321e:	83 c4 0c             	add    $0xc,%esp

	/*
	 * Now that we have everything, let us start parsing everything
	 * from the above mapping as selected by the end user
	 */
	for (i = 0; i < PINMUX_NUM_PINS; i++) {
  103221:	81 fb 60 71 10 00    	cmp    $0x107160,%ebx
  103227:	75 e5                	jne    10320e <pinmux_galileo_initialize+0x97>
		_galileo_pinmux_set_pin(port,
				 mux_config[i].pin_num,
				 mux_config[i].mode);
	}

	return 0;
  103229:	31 c0                	xor    %eax,%eax
}
  10322b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10322e:	5b                   	pop    %ebx
  10322f:	5e                   	pop    %esi
  103230:	5d                   	pop    %ebp
  103231:	c3                   	ret    

00103232 <pci_legacy_bridge_irq_config>:
 * - GPIO;
 * - UART0, UART1;
 * - SDIO/eMMC, USB, Ethernet.
 */
static int pci_legacy_bridge_irq_config(struct device *unused)
{
  103232:	55                   	push   %ebp
	ARG_UNUSED(unused);
	struct pci_dev_info info = {
  103233:	31 c0                	xor    %eax,%eax
 * - GPIO;
 * - UART0, UART1;
 * - SDIO/eMMC, USB, Ethernet.
 */
static int pci_legacy_bridge_irq_config(struct device *unused)
{
  103235:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(unused);
	struct pci_dev_info info = {
  103237:	b9 05 00 00 00       	mov    $0x5,%ecx
 * - GPIO;
 * - UART0, UART1;
 * - SDIO/eMMC, USB, Ethernet.
 */
static int pci_legacy_bridge_irq_config(struct device *unused)
{
  10323c:	57                   	push   %edi
  10323d:	53                   	push   %ebx
	ARG_UNUSED(unused);
	struct pci_dev_info info = {
  10323e:	8d 7d e4             	lea    -0x1c(%ebp),%edi
 * - GPIO;
 * - UART0, UART1;
 * - SDIO/eMMC, USB, Ethernet.
 */
static int pci_legacy_bridge_irq_config(struct device *unused)
{
  103241:	83 ec 14             	sub    $0x14,%esp
	ARG_UNUSED(unused);
	struct pci_dev_info info = {
  103244:	f3 ab                	rep stos %eax,%es:(%edi)
  103246:	c7 45 f0 00 00 01 00 	movl   $0x10000,-0x10(%ebp)
		.function = PCI_FUNCTION_ANY,
		.bar = PCI_BAR_ANY,
	};
	if (pci_legacy_bridge_detect(&info) == 0) {
  10324d:	8d 5d e4             	lea    -0x1c(%ebp),%ebx
 * - SDIO/eMMC, USB, Ethernet.
 */
static int pci_legacy_bridge_irq_config(struct device *unused)
{
	ARG_UNUSED(unused);
	struct pci_dev_info info = {
  103250:	8a 45 f3             	mov    -0xd(%ebp),%al
		.function = PCI_FUNCTION_ANY,
		.bar = PCI_BAR_ANY,
	};
	if (pci_legacy_bridge_detect(&info) == 0) {
  103253:	53                   	push   %ebx
 * - SDIO/eMMC, USB, Ethernet.
 */
static int pci_legacy_bridge_irq_config(struct device *unused)
{
	ARG_UNUSED(unused);
	struct pci_dev_info info = {
  103254:	83 e0 e3             	and    $0xffffffe3,%eax
  103257:	83 c8 18             	or     $0x18,%eax
  10325a:	88 45 f3             	mov    %al,-0xd(%ebp)
		.function = PCI_FUNCTION_ANY,
		.bar = PCI_BAR_ANY,
	};
	if (pci_legacy_bridge_detect(&info) == 0) {
  10325d:	e8 bb de ff ff       	call   10111d <pci_legacy_bridge_detect>
  103262:	5a                   	pop    %edx
  103263:	85 c0                	test   %eax,%eax
  103265:	75 78                	jne    1032df <pci_legacy_bridge_irq_config+0xad>
		pci_legacy_bridge_configure(&info, 1, PCI_INTA, 16);
  103267:	6a 10                	push   $0x10
  103269:	6a 01                	push   $0x1
  10326b:	6a 01                	push   $0x1
  10326d:	53                   	push   %ebx
  10326e:	e8 e1 df ff ff       	call   101254 <pci_legacy_bridge_configure>
  103273:	83 c4 10             	add    $0x10,%esp
		pci_legacy_bridge_configure(&info, 1, PCI_INTB, 17);
  103276:	6a 11                	push   $0x11
  103278:	6a 02                	push   $0x2
  10327a:	6a 01                	push   $0x1
  10327c:	53                   	push   %ebx
  10327d:	e8 d2 df ff ff       	call   101254 <pci_legacy_bridge_configure>
  103282:	83 c4 10             	add    $0x10,%esp
		pci_legacy_bridge_configure(&info, 1, PCI_INTC, 18);
  103285:	6a 12                	push   $0x12
  103287:	6a 03                	push   $0x3
  103289:	6a 01                	push   $0x1
  10328b:	53                   	push   %ebx
  10328c:	e8 c3 df ff ff       	call   101254 <pci_legacy_bridge_configure>
  103291:	83 c4 10             	add    $0x10,%esp
		pci_legacy_bridge_configure(&info, 1, PCI_INTD, 19);
  103294:	6a 13                	push   $0x13
  103296:	6a 04                	push   $0x4
  103298:	6a 01                	push   $0x1
  10329a:	53                   	push   %ebx
  10329b:	e8 b4 df ff ff       	call   101254 <pci_legacy_bridge_configure>
  1032a0:	83 c4 10             	add    $0x10,%esp
		pci_legacy_bridge_configure(&info, 0, PCI_INTA, 17);
  1032a3:	6a 11                	push   $0x11
  1032a5:	6a 01                	push   $0x1
  1032a7:	6a 00                	push   $0x0
  1032a9:	53                   	push   %ebx
  1032aa:	e8 a5 df ff ff       	call   101254 <pci_legacy_bridge_configure>
  1032af:	83 c4 10             	add    $0x10,%esp
		pci_legacy_bridge_configure(&info, 0, PCI_INTB, 18);
  1032b2:	6a 12                	push   $0x12
  1032b4:	6a 02                	push   $0x2
  1032b6:	6a 00                	push   $0x0
  1032b8:	53                   	push   %ebx
  1032b9:	e8 96 df ff ff       	call   101254 <pci_legacy_bridge_configure>
  1032be:	83 c4 10             	add    $0x10,%esp
		pci_legacy_bridge_configure(&info, 0, PCI_INTC, 19);
  1032c1:	6a 13                	push   $0x13
  1032c3:	6a 03                	push   $0x3
  1032c5:	6a 00                	push   $0x0
  1032c7:	53                   	push   %ebx
  1032c8:	e8 87 df ff ff       	call   101254 <pci_legacy_bridge_configure>
  1032cd:	83 c4 10             	add    $0x10,%esp
		pci_legacy_bridge_configure(&info, 0, PCI_INTD, 16);
  1032d0:	6a 10                	push   $0x10
  1032d2:	6a 04                	push   $0x4
  1032d4:	6a 00                	push   $0x0
  1032d6:	53                   	push   %ebx
  1032d7:	e8 78 df ff ff       	call   101254 <pci_legacy_bridge_configure>
  1032dc:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
}
  1032df:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1032e2:	31 c0                	xor    %eax,%eax
  1032e4:	5b                   	pop    %ebx
  1032e5:	5f                   	pop    %edi
  1032e6:	5d                   	pop    %ebp
  1032e7:	c3                   	ret    

001032e8 <nano_cpu_idle>:
 * will be issued causing a low-power consumption sleep mode.
 *
 * @return N/A
 */
void nano_cpu_idle(void)
{
  1032e8:	55                   	push   %ebp
  1032e9:	89 e5                	mov    %esp,%ebp
	_sys_k_event_logger_enter_sleep();
#if defined(CONFIG_BOOT_TIME_MEASUREMENT)
	__idle_tsc = _tsc_read();
#endif

	__asm__ volatile (
  1032eb:	fb                   	sti    
  1032ec:	f4                   	hlt    
	    "sti\n\t"
	    "hlt\n\t");
}
  1032ed:	5d                   	pop    %ebp
  1032ee:	c3                   	ret    

001032ef <_SysFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _SysFatalErrorHandler(unsigned int reason,
					 const NANO_ESF *pEsf)
{
  1032ef:	55                   	push   %ebp
  1032f0:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

	if (k_is_in_isr() || _is_thread_essential()) {
  1032f2:	e8 b6 0d 00 00       	call   1040ad <k_is_in_isr>
  1032f7:	85 c0                	test   %eax,%eax
  1032f9:	74 15                	je     103310 <_SysFatalErrorHandler+0x21>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
  1032fb:	e8 ad 0d 00 00       	call   1040ad <k_is_in_isr>
{
	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

	if (k_is_in_isr() || _is_thread_essential()) {
		printk("Fatal fault in %s! Spinning...\n",
  103300:	ba a0 63 10 00       	mov    $0x1063a0,%edx
  103305:	85 c0                	test   %eax,%eax
  103307:	75 2e                	jne    103337 <_SysFatalErrorHandler+0x48>
  103309:	ba a4 63 10 00       	mov    $0x1063a4,%edx
  10330e:	eb 27                	jmp    103337 <_SysFatalErrorHandler+0x48>
					 const NANO_ESF *pEsf)
{
	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

	if (k_is_in_isr() || _is_thread_essential()) {
  103310:	e8 a9 0d 00 00       	call   1040be <_is_thread_essential>
  103315:	85 c0                	test   %eax,%eax
  103317:	75 e2                	jne    1032fb <_SysFatalErrorHandler+0xc>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
		for (;;)
			; /* spin forever */
	}
	printk("Fatal fault in thread %p! Aborting.\n", _current);
  103319:	ff 35 c8 7d 10 00    	pushl  0x107dc8
  10331f:	68 d5 63 10 00       	push   $0x1063d5
  103324:	e8 a4 fa ff ff       	call   102dcd <printk>
  103329:	58                   	pop    %eax
  10332a:	5a                   	pop    %edx
	k_thread_abort(_current);
  10332b:	ff 35 c8 7d 10 00    	pushl  0x107dc8
  103331:	e8 aa 0f 00 00       	call   1042e0 <k_thread_abort>
  103336:	59                   	pop    %ecx
{
	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

	if (k_is_in_isr() || _is_thread_essential()) {
		printk("Fatal fault in %s! Spinning...\n",
  103337:	52                   	push   %edx
  103338:	68 b5 63 10 00       	push   $0x1063b5
  10333d:	e8 8b fa ff ff       	call   102dcd <printk>
  103342:	58                   	pop    %eax
  103343:	5a                   	pop    %edx
  103344:	eb fe                	jmp    103344 <_SysFatalErrorHandler+0x55>

00103346 <_cache_line_size_get>:
	#define CPUID_CACHE_LINE_MASK (0xff << 8)

	GTEXT(_cache_line_size_get)

SECTION_FUNC(TEXT, _cache_line_size_get)
	pushl %ebx
  103346:	53                   	push   %ebx
	movl $1, %eax
  103347:	b8 01 00 00 00       	mov    $0x1,%eax
	cpuid
  10334c:	0f a2                	cpuid  
	movl %ebx, %eax
  10334e:	89 d8                	mov    %ebx,%eax
	andl $CPUID_CACHE_LINE_MASK, %eax
  103350:	25 00 ff 00 00       	and    $0xff00,%eax
	shrl $5,%eax	/* shift right 8 to get value, then multiple by 8
  103355:	c1 e8 05             	shr    $0x5,%eax
					 * to get cache line size */
	popl %ebx
  103358:	5b                   	pop    %ebx
	ret
  103359:	c3                   	ret    

0010335a <init_cache>:
#else
#define init_cache_line_size() do { } while ((0))
#endif

static int init_cache(struct device *unused)
{
  10335a:	55                   	push   %ebp
  10335b:	89 e5                	mov    %esp,%ebp

#if defined(CONFIG_CACHE_LINE_SIZE_DETECT)
size_t sys_cache_line_size;
static void init_cache_line_size(void)
{
	sys_cache_line_size = _cache_line_size_get();
  10335d:	e8 e4 ff ff ff       	call   103346 <_cache_line_size_get>

	init_cache_flush();
	init_cache_line_size();

	return 0;
}
  103362:	5d                   	pop    %ebp

#if defined(CONFIG_CACHE_LINE_SIZE_DETECT)
size_t sys_cache_line_size;
static void init_cache_line_size(void)
{
	sys_cache_line_size = _cache_line_size_get();
  103363:	a3 44 7f 10 00       	mov    %eax,0x107f44

	init_cache_flush();
	init_cache_line_size();

	return 0;
}
  103368:	31 c0                	xor    %eax,%eax
  10336a:	c3                   	ret    

0010336b <_exception_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * exception exits.
	 */

	cld
  10336b:	fc                   	cld    


	/*
	 * Swap ecx and handler function on the current stack;
	 */
	xchgl	%ecx, (%esp)
  10336c:	87 0c 24             	xchg   %ecx,(%esp)

	/*
	 * Push the remaining volatile registers on the existing stack.
	 */

	pushl	%eax
  10336f:	50                   	push   %eax
	pushl	%edx
  103370:	52                   	push   %edx
	/*
	 * Push the cooperative registers on the existing stack as they are
	 * required by debug tools.
	 */

	pushl	%edi
  103371:	57                   	push   %edi
	pushl	%esi
  103372:	56                   	push   %esi
	pushl	%ebx
  103373:	53                   	push   %ebx
	pushl	%ebp
  103374:	55                   	push   %ebp

	leal	44(%esp), %eax   /* Calculate ESP before interrupt occurred */
  103375:	8d 44 24 2c          	lea    0x2c(%esp),%eax
	pushl	%eax             /* Save calculated ESP */
  103379:	50                   	push   %eax
	 * Test IF bit of saved EFLAGS and re-enable interrupts if IF=1.
	 */

	/* ESP is still pointing to the ESF at this point */

	testl	$0x200, __NANO_ESF_eflags_OFFSET(%esp)
  10337a:	f7 44 24 2c 00 02 00 	testl  $0x200,0x2c(%esp)
  103381:	00 
	je	allDone
  103382:	74 01                	je     103385 <allDone>
	sti
  103384:	fb                   	sti    

00103385 <allDone>:

allDone:
#if CONFIG_X86_IAMCU
	movl	%esp, %eax		/* NANO_ESF * parameter */
#else
	pushl	%esp			/* push NANO_ESF * parameter */
  103385:	54                   	push   %esp
#endif
	call	*%ecx			/* call exception handler */
  103386:	ff d1                	call   *%ecx

#ifndef CONFIG_X86_IAMCU
	addl	$0x4, %esp
  103388:	83 c4 04             	add    $0x4,%esp
	 * Pop the non-volatile registers from the stack.
	 * Note that debug tools may have altered the saved register values while
	 * the task was stopped, and we want to pick up the altered values.
	 */

	popl	%ebp		/* Discard saved ESP */
  10338b:	5d                   	pop    %ebp
	popl	%ebp
  10338c:	5d                   	pop    %ebp
	popl	%ebx
  10338d:	5b                   	pop    %ebx
	popl	%esi
  10338e:	5e                   	pop    %esi
	popl	%edi
  10338f:	5f                   	pop    %edi

	/* restore edx and ecx which are always saved on the stack */

	popl	%edx
  103390:	5a                   	pop    %edx
	popl	%eax
  103391:	58                   	pop    %eax
	popl	%ecx
  103392:	59                   	pop    %ecx

	addl	$4, %esp	/* "pop" error code */
  103393:	83 c4 04             	add    $0x4,%esp

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  103396:	cf                   	iret   

00103397 <_interrupt_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * interrupt exits via the IRET instruction.
	 */

	cld
  103397:	fc                   	cld    

	/*
	 * Swap EAX with isr_param and EDX with isr.
	 * Push ECX onto the stack
	 */
	xchgl	%eax, 4(%esp)
  103398:	87 44 24 04          	xchg   %eax,0x4(%esp)
	xchgl	%edx, (%esp)
  10339c:	87 14 24             	xchg   %edx,(%esp)
	pushl	%ecx
  10339f:	51                   	push   %ecx

	/* Push EDI as we will use it for scratch space.
	 * Rest of the callee-saved regs get saved by invocation of C
	 * functions (isr handler, _Swap(), etc)
	 */
	pushl	%edi
  1033a0:	57                   	push   %edi
	popl	%eax
#endif

	/* load %ecx with &_kernel */

	movl	$_kernel, %ecx
  1033a1:	b9 c0 7d 10 00       	mov    $0x107dc0,%ecx

	/* switch to the interrupt stack for the non-nested case */

	incl	_kernel_offset_to_nested(%ecx)
  1033a6:	ff 01                	incl   (%ecx)

	/* use interrupt stack if not nested */
	cmpl	$1, _kernel_offset_to_nested(%ecx)
  1033a8:	83 39 01             	cmpl   $0x1,(%ecx)
#ifdef CONFIG_DEBUG_INFO
	jne	nested_save_isf
#else
	jne	alreadyOnIntStack
  1033ab:	75 06                	jne    1033b3 <alreadyOnIntStack>
	/*
	 * switch to base of the interrupt stack: save esp in edi, then load
	 * irq_stack pointer
	 */

	movl	%esp, %edi
  1033ad:	89 e7                	mov    %esp,%edi
	movl	_kernel_offset_to_irq_stack(%ecx), %esp
  1033af:	8b 61 04             	mov    0x4(%ecx),%esp


	/* save thread's stack pointer onto base of interrupt stack */

	pushl	%edi			/* Save stack pointer */
  1033b2:	57                   	push   %edi

001033b3 <alreadyOnIntStack>:

#ifndef CONFIG_X86_IAMCU
	/* EAX has the interrupt handler argument, needs to go on
	 * stack for sys V calling convention
	 */
	push	%eax
  1033b3:	50                   	push   %eax
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	sti			/* re-enable interrupts */
  1033b4:	fb                   	sti    
#endif
	/* Now call the interrupt handler */
	call	*%edx
  1033b5:	ff d2                	call   *%edx
#ifndef CONFIG_X86_IAMCU
	/* Discard ISR argument */
	addl	$0x4, %esp
  1033b7:	83 c4 04             	add    $0x4,%esp
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	cli			/* disable interrupts again */
  1033ba:	fa                   	cli    
#endif

	/* irq_controller.h interface */
	_irq_controller_eoi
  1033bb:	31 c0                	xor    %eax,%eax
  1033bd:	a3 b0 00 e0 fe       	mov    %eax,0xfee000b0
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_start
#endif

	/* determine whether exiting from a nested interrupt */
	movl	$_kernel, %ecx
  1033c2:	b9 c0 7d 10 00       	mov    $0x107dc0,%ecx
#ifdef CONFIG_DEBUG_INFO
	popl	_kernel_offset_to_isf(%ecx)    /* Restore old ISF */
#endif
	decl	_kernel_offset_to_nested(%ecx)	/* dec interrupt nest count */
  1033c7:	ff 09                	decl   (%ecx)
	jne	nestedInterrupt                 /* 'iret' if nested case */
  1033c9:	75 28                	jne    1033f3 <nestedInterrupt>


	movl	_kernel_offset_to_current(%ecx), %edx
  1033cb:	8b 51 08             	mov    0x8(%ecx),%edx
	 * switch.  If the thread is preemptible, scheduler is not locked and
	 * a higher priority thread exists, a _Swap() needs to occur.
	 */

	/* do not reschedule coop threads (negative priority) */
	cmpl	$0, _thread_offset_to_prio(%edx)
  1033ce:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
	jl	noReschedule
  1033d2:	7c 1e                	jl     1033f2 <noReschedule>

	/* do not reschedule if scheduler is locked */
	cmpl	$0, _thread_offset_to_sched_locked(%edx)
  1033d4:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
	jg	noReschedule
  1033d8:	7f 18                	jg     1033f2 <noReschedule>


	/* reschedule only if the scheduler says that we must do so */
	call	_is_next_thread_current
  1033da:	e8 8d 07 00 00       	call   103b6c <_is_next_thread_current>
	testl   %eax, %eax
  1033df:	85 c0                	test   %eax,%eax
	jnz     noReschedule
  1033e1:	75 0f                	jne    1033f2 <noReschedule>
	 * the existing _Swap() primitive to save the remaining
	 * thread's registers (including floating point) and perform
	 * a switch to the new thread.
	 */

	popl	%esp	/* switch back to outgoing thread's stack */
  1033e3:	5c                   	pop    %esp
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif

	pushfl			/* push KERNEL_LOCK_KEY argument */
  1033e4:	9c                   	pushf  
#ifdef CONFIG_X86_IAMCU
	/* IAMCU first argument goes into a register, not the stack.
	 */
	popl	%eax
#endif
	call	_Swap
  1033e5:	e8 26 00 00 00       	call   103410 <_Swap>

#ifndef CONFIG_X86_IAMCU
	addl 	$4, %esp	/* pop KERNEL_LOCK_KEY argument */
  1033ea:	83 c4 04             	add    $0x4,%esp

	/* Restore volatile registers and return to the interrupted thread */
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_stop
#endif
	popl	%edi
  1033ed:	5f                   	pop    %edi
	popl	%ecx
  1033ee:	59                   	pop    %ecx
	popl	%edx
  1033ef:	5a                   	pop    %edx
	popl	%eax
  1033f0:	58                   	pop    %eax

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  1033f1:	cf                   	iret   

001033f2 <noReschedule>:
	/*
	 * A thread reschedule is not required; switch back to the
	 * interrupted thread's stack and restore volatile registers
	 */

	popl	%esp		/* pop thread stack pointer */
  1033f2:	5c                   	pop    %esp

001033f3 <nestedInterrupt>:
	popl	%ebp        /* Discard saved ESP */
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif
	popl	%edi
  1033f3:	5f                   	pop    %edi
	popl	%ecx		/* pop volatile registers in reverse order */
  1033f4:	59                   	pop    %ecx
	popl	%edx
  1033f5:	5a                   	pop    %edx
	popl	%eax
  1033f6:	58                   	pop    %eax
	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  1033f7:	cf                   	iret   

001033f8 <_SpuriousIntNoErrCodeHandler>:
 * thus _SpuriousIntNoErrCodeHandler()/_SpuriousIntHandler() shall be
 * invoked with interrupts disabled.
 */
SECTION_FUNC(TEXT, _SpuriousIntNoErrCodeHandler)

	pushl	$0			/* push dummy err code onto stk */
  1033f8:	6a 00                	push   $0x0

001033fa <_SpuriousIntHandler>:
	/* fall through to _SpuriousIntHandler */


SECTION_FUNC(TEXT, _SpuriousIntHandler)

	cld				/* Clear direction flag */
  1033fa:	fc                   	cld    

	/* Create the ESF */

	pushl %eax
  1033fb:	50                   	push   %eax
	pushl %ecx
  1033fc:	51                   	push   %ecx
	pushl %edx
  1033fd:	52                   	push   %edx
	pushl %edi
  1033fe:	57                   	push   %edi
	pushl %esi
  1033ff:	56                   	push   %esi
	pushl %ebx
  103400:	53                   	push   %ebx
	pushl %ebp
  103401:	55                   	push   %ebp

	leal	44(%esp), %ecx   /* Calculate ESP before exception occurred */
  103402:	8d 4c 24 2c          	lea    0x2c(%esp),%ecx
	pushl	%ecx             /* Save calculated ESP */
  103406:	51                   	push   %ecx

#ifndef CONFIG_X86_IAMCU
	pushl	%esp			/* push cur stack pointer: pEsf arg */
  103407:	54                   	push   %esp
#else
	mov	%esp, %edx
#endif

	/* re-enable interrupts */
	sti
  103408:	fb                   	sti    

	/* push the 'unsigned int reason' parameter */
#ifndef CONFIG_X86_IAMCU
	pushl	$_NANO_ERR_SPURIOUS_INT
  103409:	6a 00                	push   $0x0
#else
	movl	$_NANO_ERR_SPURIOUS_INT, %eax
#endif
	/* call the fatal error handler */
	call	_NanoFatalErrorHandler
  10340b:	e8 99 00 00 00       	call   1034a9 <_NanoFatalErrorHandler>

00103410 <_Swap>:
	 * any of these registers into the k_thread.  Only the 'esp' register
	 * after all the pushes have been performed) will be stored in the
	 * k_thread.
	 */

	pushl	%edi
  103410:	57                   	push   %edi

	movl	$_kernel, %edi
  103411:	bf c0 7d 10 00       	mov    $0x107dc0,%edi

	pushl	%esi
  103416:	56                   	push   %esi
	pushl	%ebx
  103417:	53                   	push   %ebx
	pushl	%ebp
  103418:	55                   	push   %ebp
	 * -EAGAIN eliminates the need for the timeout code to set it.
	 * If another value is ever needed, it can be modified with
	 * fiberRtnValueSet().
	 */

	pushl   _k_neg_eagain
  103419:	ff 35 e4 65 10 00    	pushl  0x1065e4


	/* save esp into k_thread structure */

	movl	_kernel_offset_to_current(%edi), %ecx
  10341f:	8b 4f 08             	mov    0x8(%edi),%ecx
	movl	%esp, _thread_offset_to_esp(%ecx)
  103422:	89 61 30             	mov    %esp,0x30(%ecx)

#ifdef CONFIG_KERNEL_EVENT_LOGGER_CONTEXT_SWITCH
	/* Register the context switch */
	call	_sys_k_event_logger_context_switch
#endif
	call	_get_next_ready_thread
  103425:	e8 bf 06 00 00       	call   103ae9 <_get_next_ready_thread>

#endif /* CONFIG_FP_SHARING */

	/* update _kernel.current to reflect incoming thread */

	movl    %eax, _kernel_offset_to_current(%edi)
  10342a:	89 47 08             	mov    %eax,0x8(%edi)

	/* recover task/fiber stack pointer from k_thread */

	movl	_thread_offset_to_esp(%eax), %esp
  10342d:	8b 60 30             	mov    0x30(%eax),%esp


	/* load return value from a possible fiberRtnValueSet() */

	popl	%eax
  103430:	58                   	pop    %eax

	/* pop the non-volatile registers from the stack */

	popl	%ebp
  103431:	5d                   	pop    %ebp
	popl	%ebx
  103432:	5b                   	pop    %ebx
	popl	%esi
  103433:	5e                   	pop    %esi
	popl	%edi
  103434:	5f                   	pop    %edi
	 * - in unified kernel, -EINVAL
	 */

	/* Utilize the 'eflags' parameter to _Swap() */

	pushl	4(%esp)
  103435:	ff 74 24 04          	pushl  0x4(%esp)
	/* restore _Swap's %eax */
	popl	%eax

skipIntLatencyStop:
#endif
	popfl
  103439:	9d                   	popf   
	 * will not do that for us.
	 */
	popl	%edx
	movl	%edx, (%esp)
#endif
	ret
  10343a:	c3                   	ret    

0010343b <_new_thread>:
 */
void _new_thread(char *pStackMem, size_t stackSize,
		 _thread_entry_t pEntry,
		 void *parameter1, void *parameter2, void *parameter3,
		 int priority, unsigned options)
{
  10343b:	55                   	push   %ebp
  10343c:	89 e5                	mov    %esp,%ebp
  10343e:	56                   	push   %esi
  10343f:	53                   	push   %ebx
  103440:	8b 75 08             	mov    0x8(%ebp),%esi
	memset(pStackMem, 0xaa, stackSize);
#endif

	/* carve the thread entry struct from the "base" of the stack */

	pInitialThread =
  103443:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  103446:	01 f3                	add    %esi,%ebx
	 * setup for both threads are equivalent.
	 */

	/* push arguments required by _thread_entry() */

	*--pInitialThread = (unsigned long)parameter3;
  103448:	8b 45 1c             	mov    0x1c(%ebp),%eax
	memset(pStackMem, 0xaa, stackSize);
#endif

	/* carve the thread entry struct from the "base" of the stack */

	pInitialThread =
  10344b:	83 e3 fc             	and    $0xfffffffc,%ebx
	 * setup for both threads are equivalent.
	 */

	/* push arguments required by _thread_entry() */

	*--pInitialThread = (unsigned long)parameter3;
  10344e:	89 43 fc             	mov    %eax,-0x4(%ebx)
	*--pInitialThread = (unsigned long)parameter2;
  103451:	8b 45 18             	mov    0x18(%ebp),%eax
  103454:	89 43 f8             	mov    %eax,-0x8(%ebx)
	*--pInitialThread = (unsigned long)parameter1;
  103457:	8b 45 14             	mov    0x14(%ebp),%eax
  10345a:	89 43 f4             	mov    %eax,-0xc(%ebx)
	*--pInitialThread = (unsigned long)pEntry;
  10345d:	8b 45 10             	mov    0x10(%ebp),%eax
  103460:	89 43 f0             	mov    %eax,-0x10(%ebx)
 */
static inline unsigned int EflagsGet(void)
{
	unsigned int eflags; /* EFLAGS register contents */

	__asm__ volatile(
  103463:	9c                   	pushf  
  103464:	58                   	pop    %eax

	/* push initial EFLAGS; only modify IF and IOPL bits */

	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
  103465:	80 e4 cd             	and    $0xcd,%ah

	*--pInitialThread = (unsigned long)_thread_entry_wrapper;

#else /* defined(CONFIG_GDB_INFO) || defined(CONFIG_DEBUG_INFO) */

	*--pInitialThread = (unsigned long)_thread_entry;
  103468:	c7 43 e8 d0 40 10 00 	movl   $0x1040d0,-0x18(%ebx)
	*--pInitialThread = (unsigned long)parameter1;
	*--pInitialThread = (unsigned long)pEntry;

	/* push initial EFLAGS; only modify IF and IOPL bits */

	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
  10346f:	80 cc 02             	or     $0x2,%ah
	 *  - eip (so that _Swap() "returns" to the entry point)
	 *  - edi, esi, ebx, ebp,  eax
	 */
	pInitialCtx -= 11;

	thread->callee_saved.esp = (unsigned long)pInitialCtx;
  103472:	83 eb 2c             	sub    $0x2c,%ebx
	*--pInitialThread = (unsigned long)parameter1;
	*--pInitialThread = (unsigned long)pEntry;

	/* push initial EFLAGS; only modify IF and IOPL bits */

	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
  103475:	89 43 18             	mov    %eax,0x18(%ebx)

#if (defined(CONFIG_FP_SHARING) || defined(CONFIG_GDB_INFO))
	thread->arch.excNestCount = 0;
#endif /* CONFIG_FP_SHARING || CONFIG_GDB_INFO */

	_init_thread_base(&thread->base, priority, K_PRESTART, options);
  103478:	ff 75 24             	pushl  0x24(%ebp)
  10347b:	68 00 40 00 00       	push   $0x4000
  103480:	ff 75 20             	pushl  0x20(%ebp)
  103483:	56                   	push   %esi
  103484:	e8 1d 0e 00 00       	call   1042a6 <_init_thread_base>

	/* static threads overwrite it afterwards with real value */
	thread->init_data = NULL;
  103489:	c7 46 34 00 00 00 00 	movl   $0x0,0x34(%esi)
	thread->fn_abort = NULL;
  103490:	c7 46 38 00 00 00 00 	movl   $0x0,0x38(%esi)
	 *  - eip (so that _Swap() "returns" to the entry point)
	 *  - edi, esi, ebx, ebp,  eax
	 */
	pInitialCtx -= 11;

	thread->callee_saved.esp = (unsigned long)pInitialCtx;
  103497:	89 5e 30             	mov    %ebx,0x30(%esi)

#if (defined(CONFIG_FP_SHARING) || defined(CONFIG_GDB_INFO))
	thread->arch.excNestCount = 0;
#endif /* CONFIG_FP_SHARING || CONFIG_GDB_INFO */

	_init_thread_base(&thread->base, priority, K_PRESTART, options);
  10349a:	83 c4 10             	add    $0x10,%esp
	 * The k_thread structure is located at the "low end" of memory set
	 * aside for the thread's stack.
	 */

	_new_thread_internal(pStackMem, stackSize, priority, options);
}
  10349d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1034a0:	5b                   	pop    %ebx
  1034a1:	5e                   	pop    %esi
  1034a2:	5d                   	pop    %ebp
  1034a3:	c3                   	ret    

001034a4 <_debug_fatal_hook>:
#include <misc/printk.h>
#include <arch/x86/irq_controller.h>
#include <arch/x86/segmentation.h>
#include <exception.h>

__weak void _debug_fatal_hook(const NANO_ESF *esf) { ARG_UNUSED(esf); }
  1034a4:	55                   	push   %ebp
  1034a5:	89 e5                	mov    %esp,%ebp
  1034a7:	5d                   	pop    %ebp
  1034a8:	c3                   	ret    

001034a9 <_NanoFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _NanoFatalErrorHandler(unsigned int reason,
					  const NANO_ESF *pEsf)
{
  1034a9:	55                   	push   %ebp
  1034aa:	89 e5                	mov    %esp,%ebp
  1034ac:	57                   	push   %edi
  1034ad:	56                   	push   %esi
  1034ae:	53                   	push   %ebx
  1034af:	83 ec 28             	sub    $0x28,%esp
  1034b2:	8b 75 08             	mov    0x8(%ebp),%esi
  1034b5:	8b 7d 0c             	mov    0xc(%ebp),%edi
	_debug_fatal_hook(pEsf);
  1034b8:	57                   	push   %edi
  1034b9:	e8 e6 ff ff ff       	call   1034a4 <_debug_fatal_hook>
  1034be:	58                   	pop    %eax

#ifdef CONFIG_PRINTK

	/* Display diagnostic information about the error */

	switch (reason) {
  1034bf:	83 fe 03             	cmp    $0x3,%esi
  1034c2:	74 3e                	je     103502 <_NanoFatalErrorHandler+0x59>
  1034c4:	77 06                	ja     1034cc <_NanoFatalErrorHandler+0x23>
  1034c6:	85 f6                	test   %esi,%esi
  1034c8:	74 0e                	je     1034d8 <_NanoFatalErrorHandler+0x2f>
  1034ca:	eb 4a                	jmp    103516 <_NanoFatalErrorHandler+0x6d>
  1034cc:	83 fe 05             	cmp    $0x5,%esi
  1034cf:	74 3e                	je     10350f <_NanoFatalErrorHandler+0x66>
  1034d1:	83 fe 06             	cmp    $0x6,%esi
  1034d4:	74 4d                	je     103523 <_NanoFatalErrorHandler+0x7a>
  1034d6:	eb 3e                	jmp    103516 <_NanoFatalErrorHandler+0x6d>
 * @return the vector of the interrupt that is currently being processed, or
 * -1 if this can't be determined
 */
static inline int _irq_controller_isr_vector_get(void)
{
	return __irq_controller_isr_vector_get();
  1034d8:	e8 17 d3 ff ff       	call   1007f4 <__irq_controller_isr_vector_get>
		break;

	case _NANO_ERR_SPURIOUS_INT: {
		int vector = _irq_controller_isr_vector_get();

		printk("***** Unhandled interrupt vector ");
  1034dd:	68 fa 63 10 00       	push   $0x1063fa
  1034e2:	89 c3                	mov    %eax,%ebx
  1034e4:	e8 e4 f8 ff ff       	call   102dcd <printk>
  1034e9:	58                   	pop    %eax
		if (vector >= 0) {
  1034ea:	85 db                	test   %ebx,%ebx
  1034ec:	78 0d                	js     1034fb <_NanoFatalErrorHandler+0x52>
			printk("%d ", vector);
  1034ee:	53                   	push   %ebx
  1034ef:	68 1c 64 10 00       	push   $0x10641c
  1034f4:	e8 d4 f8 ff ff       	call   102dcd <printk>
  1034f9:	5b                   	pop    %ebx
  1034fa:	58                   	pop    %eax
		}
		printk("*****\n");
  1034fb:	68 43 64 10 00       	push   $0x106443
  103500:	eb 05                	jmp    103507 <_NanoFatalErrorHandler+0x5e>
		break;
	}
	case _NANO_ERR_INVALID_TASK_EXIT:
		printk("***** Invalid Exit Software Error! *****\n");
  103502:	68 20 64 10 00       	push   $0x106420
  103507:	e8 c1 f8 ff ff       	call   102dcd <printk>
  10350c:	59                   	pop    %ecx
		break;
  10350d:	eb 14                	jmp    103523 <_NanoFatalErrorHandler+0x7a>
		break;
#endif /* CONFIG_STACK_CANARIES */


	case _NANO_ERR_ALLOCATION_FAIL:
		printk("**** Kernel Allocation Failure! ****\n");
  10350f:	68 4a 64 10 00       	push   $0x10644a
  103514:	eb f1                	jmp    103507 <_NanoFatalErrorHandler+0x5e>
		break;

	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
  103516:	56                   	push   %esi
  103517:	68 70 64 10 00       	push   $0x106470
  10351c:	e8 ac f8 ff ff       	call   102dcd <printk>
  103521:	58                   	pop    %eax
  103522:	5a                   	pop    %edx
		break;
	}

	printk("Current thread ID = %p\n"
  103523:	8b 47 04             	mov    0x4(%edi),%eax
  103526:	8b 4f 2c             	mov    0x2c(%edi),%ecx
  103529:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10352c:	8b 47 10             	mov    0x10(%edi),%eax
  10352f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  103532:	8b 47 0c             	mov    0xc(%edi),%eax
  103535:	89 45 e8             	mov    %eax,-0x18(%ebp)
  103538:	8b 47 14             	mov    0x14(%edi),%eax
  10353b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10353e:	8b 47 1c             	mov    0x1c(%edi),%eax
  103541:	89 45 e0             	mov    %eax,-0x20(%ebp)
  103544:	8b 47 08             	mov    0x8(%edi),%eax
  103547:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10354a:	8b 47 18             	mov    0x18(%edi),%eax
  10354d:	8b 17                	mov    (%edi),%edx
  10354f:	89 45 d8             	mov    %eax,-0x28(%ebp)
  103552:	8b 47 24             	mov    0x24(%edi),%eax
  103555:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  103558:	89 55 d0             	mov    %edx,-0x30(%ebp)
  10355b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  10355e:	0f b7 5f 28          	movzwl 0x28(%edi),%ebx
  103562:	e8 73 06 00 00       	call   103bda <k_current_get>
  103567:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  10356a:	8b 55 d0             	mov    -0x30(%ebp),%edx
  10356d:	51                   	push   %ecx
  10356e:	52                   	push   %edx
  10356f:	ff 75 f0             	pushl  -0x10(%ebp)
  103572:	ff 75 ec             	pushl  -0x14(%ebp)
  103575:	ff 75 e8             	pushl  -0x18(%ebp)
  103578:	ff 75 e4             	pushl  -0x1c(%ebp)
  10357b:	ff 75 e0             	pushl  -0x20(%ebp)
  10357e:	ff 75 dc             	pushl  -0x24(%ebp)
  103581:	ff 75 d8             	pushl  -0x28(%ebp)
  103584:	ff 75 d4             	pushl  -0x2c(%ebp)
  103587:	53                   	push   %ebx
  103588:	50                   	push   %eax
  103589:	68 93 64 10 00       	push   $0x106493
  10358e:	e8 3a f8 ff ff       	call   102dcd <printk>
  103593:	83 c4 34             	add    $0x34,%esp
	/*
	 * Error was fatal to a kernel task or a fiber; invoke the system
	 * fatal error handling policy defined for the platform.
	 */

	_SysFatalErrorHandler(reason, pEsf);
  103596:	57                   	push   %edi
  103597:	56                   	push   %esi
  103598:	e8 52 fd ff ff       	call   1032ef <_SysFatalErrorHandler>

0010359d <generic_exc_handle>:

#if CONFIG_EXCEPTION_DEBUG

static FUNC_NORETURN void generic_exc_handle(unsigned int vector,
					     const NANO_ESF *pEsf)
{
  10359d:	55                   	push   %ebp
  10359e:	89 e5                	mov    %esp,%ebp
  1035a0:	56                   	push   %esi
  1035a1:	89 c6                	mov    %eax,%esi
  1035a3:	53                   	push   %ebx
  1035a4:	89 d3                	mov    %edx,%ebx
	printk("***** CPU exception %d\n", vector);
  1035a6:	50                   	push   %eax
  1035a7:	68 32 65 10 00       	push   $0x106532
  1035ac:	e8 1c f8 ff ff       	call   102dcd <printk>
  1035b1:	59                   	pop    %ecx
  1035b2:	58                   	pop    %eax
	if ((1 << vector) & _EXC_ERROR_CODE_FAULTS) {
  1035b3:	b8 00 7d 02 00       	mov    $0x27d00,%eax
  1035b8:	0f a3 f0             	bt     %esi,%eax
  1035bb:	73 0f                	jae    1035cc <generic_exc_handle+0x2f>
		printk("***** Exception code: 0x%x\n", pEsf->errorCode);
  1035bd:	ff 73 20             	pushl  0x20(%ebx)
  1035c0:	68 4a 65 10 00       	push   $0x10654a
  1035c5:	e8 03 f8 ff ff       	call   102dcd <printk>
  1035ca:	58                   	pop    %eax
  1035cb:	5a                   	pop    %edx
	}
	_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, pEsf);
  1035cc:	53                   	push   %ebx
  1035cd:	6a 06                	push   $0x6
  1035cf:	e8 d5 fe ff ff       	call   1034a9 <_NanoFatalErrorHandler>

001035d4 <handle_exc_0>:
	_EXC_FUNC_NOCODE(vector)

#define EXC_FUNC_CODE(vector) \
	_EXC_FUNC_CODE(vector)

EXC_FUNC_NOCODE(IV_DIVIDE_ERROR);
  1035d4:	55                   	push   %ebp
  1035d5:	31 c0                	xor    %eax,%eax
  1035d7:	89 e5                	mov    %esp,%ebp
  1035d9:	8b 55 08             	mov    0x8(%ebp),%edx
  1035dc:	e8 bc ff ff ff       	call   10359d <generic_exc_handle>

001035e1 <handle_exc_2>:
EXC_FUNC_NOCODE(IV_NON_MASKABLE_INTERRUPT);
  1035e1:	55                   	push   %ebp
  1035e2:	b8 02 00 00 00       	mov    $0x2,%eax
  1035e7:	89 e5                	mov    %esp,%ebp
  1035e9:	8b 55 08             	mov    0x8(%ebp),%edx
  1035ec:	e8 ac ff ff ff       	call   10359d <generic_exc_handle>

001035f1 <handle_exc_4>:
EXC_FUNC_NOCODE(IV_OVERFLOW);
  1035f1:	55                   	push   %ebp
  1035f2:	b8 04 00 00 00       	mov    $0x4,%eax
  1035f7:	89 e5                	mov    %esp,%ebp
  1035f9:	8b 55 08             	mov    0x8(%ebp),%edx
  1035fc:	e8 9c ff ff ff       	call   10359d <generic_exc_handle>

00103601 <handle_exc_5>:
EXC_FUNC_NOCODE(IV_BOUND_RANGE);
  103601:	55                   	push   %ebp
  103602:	b8 05 00 00 00       	mov    $0x5,%eax
  103607:	89 e5                	mov    %esp,%ebp
  103609:	8b 55 08             	mov    0x8(%ebp),%edx
  10360c:	e8 8c ff ff ff       	call   10359d <generic_exc_handle>

00103611 <handle_exc_6>:
EXC_FUNC_NOCODE(IV_INVALID_OPCODE);
  103611:	55                   	push   %ebp
  103612:	b8 06 00 00 00       	mov    $0x6,%eax
  103617:	89 e5                	mov    %esp,%ebp
  103619:	8b 55 08             	mov    0x8(%ebp),%edx
  10361c:	e8 7c ff ff ff       	call   10359d <generic_exc_handle>

00103621 <handle_exc_7>:
EXC_FUNC_NOCODE(IV_DEVICE_NOT_AVAILABLE);
  103621:	55                   	push   %ebp
  103622:	b8 07 00 00 00       	mov    $0x7,%eax
  103627:	89 e5                	mov    %esp,%ebp
  103629:	8b 55 08             	mov    0x8(%ebp),%edx
  10362c:	e8 6c ff ff ff       	call   10359d <generic_exc_handle>

00103631 <handle_exc_8>:
EXC_FUNC_CODE(IV_DOUBLE_FAULT);
  103631:	55                   	push   %ebp
  103632:	b8 08 00 00 00       	mov    $0x8,%eax
  103637:	89 e5                	mov    %esp,%ebp
  103639:	8b 55 08             	mov    0x8(%ebp),%edx
  10363c:	e8 5c ff ff ff       	call   10359d <generic_exc_handle>

00103641 <handle_exc_10>:
EXC_FUNC_CODE(IV_INVALID_TSS);
  103641:	55                   	push   %ebp
  103642:	b8 0a 00 00 00       	mov    $0xa,%eax
  103647:	89 e5                	mov    %esp,%ebp
  103649:	8b 55 08             	mov    0x8(%ebp),%edx
  10364c:	e8 4c ff ff ff       	call   10359d <generic_exc_handle>

00103651 <handle_exc_11>:
EXC_FUNC_CODE(IV_SEGMENT_NOT_PRESENT);
  103651:	55                   	push   %ebp
  103652:	b8 0b 00 00 00       	mov    $0xb,%eax
  103657:	89 e5                	mov    %esp,%ebp
  103659:	8b 55 08             	mov    0x8(%ebp),%edx
  10365c:	e8 3c ff ff ff       	call   10359d <generic_exc_handle>

00103661 <handle_exc_12>:
EXC_FUNC_CODE(IV_STACK_FAULT);
  103661:	55                   	push   %ebp
  103662:	b8 0c 00 00 00       	mov    $0xc,%eax
  103667:	89 e5                	mov    %esp,%ebp
  103669:	8b 55 08             	mov    0x8(%ebp),%edx
  10366c:	e8 2c ff ff ff       	call   10359d <generic_exc_handle>

00103671 <handle_exc_13>:
EXC_FUNC_CODE(IV_GENERAL_PROTECTION);
  103671:	55                   	push   %ebp
  103672:	b8 0d 00 00 00       	mov    $0xd,%eax
  103677:	89 e5                	mov    %esp,%ebp
  103679:	8b 55 08             	mov    0x8(%ebp),%edx
  10367c:	e8 1c ff ff ff       	call   10359d <generic_exc_handle>

00103681 <handle_exc_14>:
EXC_FUNC_CODE(IV_PAGE_FAULT);
  103681:	55                   	push   %ebp
  103682:	b8 0e 00 00 00       	mov    $0xe,%eax
  103687:	89 e5                	mov    %esp,%ebp
  103689:	8b 55 08             	mov    0x8(%ebp),%edx
  10368c:	e8 0c ff ff ff       	call   10359d <generic_exc_handle>

00103691 <handle_exc_16>:
EXC_FUNC_NOCODE(IV_X87_FPU_FP_ERROR);
  103691:	55                   	push   %ebp
  103692:	b8 10 00 00 00       	mov    $0x10,%eax
  103697:	89 e5                	mov    %esp,%ebp
  103699:	8b 55 08             	mov    0x8(%ebp),%edx
  10369c:	e8 fc fe ff ff       	call   10359d <generic_exc_handle>

001036a1 <handle_exc_17>:
EXC_FUNC_CODE(IV_ALIGNMENT_CHECK);
  1036a1:	55                   	push   %ebp
  1036a2:	b8 11 00 00 00       	mov    $0x11,%eax
  1036a7:	89 e5                	mov    %esp,%ebp
  1036a9:	8b 55 08             	mov    0x8(%ebp),%edx
  1036ac:	e8 ec fe ff ff       	call   10359d <generic_exc_handle>

001036b1 <handle_exc_18>:
EXC_FUNC_NOCODE(IV_MACHINE_CHECK);
  1036b1:	55                   	push   %ebp
  1036b2:	b8 12 00 00 00       	mov    $0x12,%eax
  1036b7:	89 e5                	mov    %esp,%ebp
  1036b9:	8b 55 08             	mov    0x8(%ebp),%edx
  1036bc:	e8 dc fe ff ff       	call   10359d <generic_exc_handle>

001036c1 <_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void _sys_device_do_config_level(int level)
{
  1036c1:	55                   	push   %ebp
  1036c2:	89 e5                	mov    %esp,%ebp
  1036c4:	56                   	push   %esi
  1036c5:	53                   	push   %ebx
  1036c6:	8b 75 08             	mov    0x8(%ebp),%esi
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
  1036c9:	8b 1c b5 c0 65 10 00 	mov    0x1065c0(,%esi,4),%ebx
  1036d0:	3b 1c b5 c4 65 10 00 	cmp    0x1065c4(,%esi,4),%ebx
  1036d7:	73 0c                	jae    1036e5 <_sys_device_do_config_level+0x24>
		struct device_config *device = info->config;

		device->init(info);
  1036d9:	8b 03                	mov    (%ebx),%eax
  1036db:	53                   	push   %ebx
 */
void _sys_device_do_config_level(int level)
{
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
  1036dc:	83 c3 0c             	add    $0xc,%ebx
		struct device_config *device = info->config;

		device->init(info);
  1036df:	ff 50 04             	call   *0x4(%eax)
  1036e2:	58                   	pop    %eax
  1036e3:	eb eb                	jmp    1036d0 <_sys_device_do_config_level+0xf>
	}
}
  1036e5:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1036e8:	5b                   	pop    %ebx
  1036e9:	5e                   	pop    %esi
  1036ea:	5d                   	pop    %ebp
  1036eb:	c3                   	ret    

001036ec <device_get_binding>:

struct device *device_get_binding(const char *name)
{
  1036ec:	55                   	push   %ebp
  1036ed:	89 e5                	mov    %esp,%ebp
  1036ef:	53                   	push   %ebx
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
  1036f0:	bb 90 71 10 00       	mov    $0x107190,%ebx
  1036f5:	81 fb 80 72 10 00    	cmp    $0x107280,%ebx
  1036fb:	74 21                	je     10371e <device_get_binding+0x32>
		if (info->driver_api && !strcmp(name, info->config->name)) {
  1036fd:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  103701:	75 05                	jne    103708 <device_get_binding+0x1c>

struct device *device_get_binding(const char *name)
{
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
  103703:	83 c3 0c             	add    $0xc,%ebx
  103706:	eb ed                	jmp    1036f5 <device_get_binding+0x9>
		if (info->driver_api && !strcmp(name, info->config->name)) {
  103708:	8b 03                	mov    (%ebx),%eax
  10370a:	ff 30                	pushl  (%eax)
  10370c:	ff 75 08             	pushl  0x8(%ebp)
  10370f:	e8 7b f5 ff ff       	call   102c8f <strcmp>
  103714:	5a                   	pop    %edx
  103715:	85 c0                	test   %eax,%eax
  103717:	59                   	pop    %ecx
  103718:	75 e9                	jne    103703 <device_get_binding+0x17>
  10371a:	89 d8                	mov    %ebx,%eax
  10371c:	eb 02                	jmp    103720 <device_get_binding+0x34>
			return info;
		}
	}

	return NULL;
  10371e:	31 c0                	xor    %eax,%eax
}
  103720:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  103723:	c9                   	leave  
  103724:	c3                   	ret    

00103725 <device_busy_set>:
  103725:	55                   	push   %ebp
  103726:	89 e5                	mov    %esp,%ebp
  103728:	5d                   	pop    %ebp
  103729:	c3                   	ret    

0010372a <device_busy_clear>:
				 (busy_dev - __device_init_start));
#endif
}

void device_busy_clear(struct device *busy_dev)
{
  10372a:	55                   	push   %ebp
  10372b:	89 e5                	mov    %esp,%ebp
#ifdef CONFIG_DEVICE_POWER_MANAGEMENT
	atomic_clear_bit((atomic_t *) __device_busy_start,
				 (busy_dev - __device_init_start));
#endif
}
  10372d:	5d                   	pop    %ebp
  10372e:	c3                   	ret    

0010372f <_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void _main(void *unused1, void *unused2, void *unused3)
{
  10372f:	55                   	push   %ebp
  103730:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
  103732:	6a 02                	push   $0x2
  103734:	e8 88 ff ff ff       	call   1036c1 <_sys_device_do_config_level>

	/* These 3 are deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_SECONDARY);
  103739:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  103740:	e8 7c ff ff ff       	call   1036c1 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_NANOKERNEL);
  103745:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  10374c:	e8 70 ff ff ff       	call   1036c1 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_MICROKERNEL);
  103751:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  103758:	e8 64 ff ff ff       	call   1036c1 <_sys_device_do_config_level>

	/* Final init level before app starts */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
  10375d:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  103764:	e8 58 ff ff ff       	call   1036c1 <_sys_device_do_config_level>
  103769:	58                   	pop    %eax
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	_init_static_threads();
  10376a:	e8 a6 0a 00 00       	call   104215 <_init_static_threads>
	 */
#if defined(MDEF_MAIN_THREAD_PRIORITY) && \
		(MDEF_MAIN_THREAD_PRIORITY != CONFIG_MAIN_THREAD_PRIORITY)
	k_thread_priority_set(_main_thread, MDEF_MAIN_THREAD_PRIORITY);
#endif
	main();
  10376f:	e8 f5 cb ff ff       	call   100369 <main>

	/* Terminate thread normally since it has no more work to do */
	_main_thread->base.flags &= ~K_ESSENTIAL;
  103774:	81 25 80 88 10 00 ff 	andl   $0xfffffdff,0x108880
  10377b:	fd ff ff 
}
  10377e:	c9                   	leave  
  10377f:	c3                   	ret    

00103780 <_Cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void _Cstart(void)
{
  103780:	55                   	push   %ebp
  103781:	89 e5                	mov    %esp,%ebp
  103783:	83 ec 40             	sub    $0x40,%esp
	 * initialization.  However, don't waste effort initializing the
	 * fields of the dummy thread beyond those needed to identify it as a
	 * dummy thread.
	 */

	_current = dummy_thread;
  103786:	8d 45 c0             	lea    -0x40(%ebp),%eax

	/*
	 * Do not insert dummy execution context in the list of fibers, so
	 * that it does not get scheduled back in once context-switched out.
	 */
	dummy_thread->base.flags = K_ESSENTIAL;
  103789:	c7 45 c8 00 02 00 00 	movl   $0x200,-0x38(%ebp)
	 * initialization.  However, don't waste effort initializing the
	 * fields of the dummy thread beyond those needed to identify it as a
	 * dummy thread.
	 */

	_current = dummy_thread;
  103790:	a3 c8 7d 10 00       	mov    %eax,0x107dc8
	/*
	 * Do not insert dummy execution context in the list of fibers, so
	 * that it does not get scheduled back in once context-switched out.
	 */
	dummy_thread->base.flags = K_ESSENTIAL;
	dummy_thread->base.prio = K_PRIO_COOP(0);
  103795:	c7 45 cc f0 ff ff ff 	movl   $0xfffffff0,-0x34(%ebp)
  10379c:	b8 dc 7d 10 00       	mov    $0x107ddc,%eax
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  1037a1:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
  1037a3:	89 40 04             	mov    %eax,0x4(%eax)
  1037a6:	83 c0 08             	add    $0x8,%eax

	_IntLibInit();

	/* ready the init/main and idle threads */

	for (int ii = 0; ii < K_NUM_PRIORITIES; ii++) {
  1037a9:	3d dc 7e 10 00       	cmp    $0x107edc,%eax
  1037ae:	75 f1                	jne    1037a1 <_Cstart+0x21>
		sys_dlist_init(&_ready_q.q[ii]);
	}

	_new_thread(_main_stack, MAIN_STACK_SIZE,
  1037b0:	68 00 02 00 00       	push   $0x200
  1037b5:	6a 00                	push   $0x0
  1037b7:	6a 00                	push   $0x0
  1037b9:	6a 00                	push   $0x0
  1037bb:	6a 00                	push   $0x0
  1037bd:	68 2f 37 10 00       	push   $0x10372f
  1037c2:	68 00 04 00 00       	push   $0x400
  1037c7:	68 78 88 10 00       	push   $0x108878
  1037cc:	e8 6a fc ff ff       	call   10343b <_new_thread>
  1037d1:	83 c4 20             	add    $0x20,%esp
		    _main, NULL, NULL, NULL,
		    CONFIG_MAIN_THREAD_PRIORITY, K_ESSENTIAL);
	_mark_thread_as_started(_main_thread);
	_add_thread_to_ready_q(_main_thread);
  1037d4:	68 78 88 10 00       	push   $0x108878
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.flags &= ~K_PRESTART;
  1037d9:	81 25 80 88 10 00 ff 	andl   $0xffffbfff,0x108880
  1037e0:	bf ff ff 
  1037e3:	e8 7d 01 00 00       	call   103965 <_add_thread_to_ready_q>

	_new_thread(_idle_stack, IDLE_STACK_SIZE,
  1037e8:	c7 04 24 00 02 00 00 	movl   $0x200,(%esp)
  1037ef:	6a 0f                	push   $0xf
  1037f1:	6a 00                	push   $0x0
  1037f3:	6a 00                	push   $0x0
  1037f5:	6a 00                	push   $0x0
  1037f7:	68 89 45 10 00       	push   $0x104589
  1037fc:	68 00 01 00 00       	push   $0x100
  103801:	68 78 87 10 00       	push   $0x108778
  103806:	e8 30 fc ff ff       	call   10343b <_new_thread>
  10380b:	83 c4 20             	add    $0x20,%esp
  10380e:	81 25 80 87 10 00 ff 	andl   $0xffffbfff,0x108780
  103815:	bf ff ff 
		    idle, NULL, NULL, NULL,
		    K_LOWEST_THREAD_PRIO, K_ESSENTIAL);
	_mark_thread_as_started(_idle_thread);
	_add_thread_to_ready_q(_idle_thread);
  103818:	68 78 87 10 00       	push   $0x108778
  10381d:	e8 43 01 00 00       	call   103965 <_add_thread_to_ready_q>
	 */

	prepare_multithreading(dummy_thread);

	/* Deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRIMARY);
  103822:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  103829:	c7 05 cc 7d 10 00 cc 	movl   $0x107dcc,0x107dcc
  103830:	7d 10 00 
	list->tail = (sys_dnode_t *)list;
  103833:	c7 05 d0 7d 10 00 cc 	movl   $0x107dcc,0x107dd0
  10383a:	7d 10 00 
	extern void *_dummy_exception_vector_stub;
	extern char _interrupt_stack[CONFIG_ISR_STACK_SIZE];

	extern void _exception_enter(void);

	_kernel.nested = 0;
  10383d:	c7 05 c0 7d 10 00 00 	movl   $0x0,0x107dc0
  103844:	00 00 00 

	_kernel.irq_stack = _interrupt_stack + CONFIG_ISR_STACK_SIZE;
  103847:	c7 05 c4 7d 10 00 78 	movl   $0x108778,0x107dc4
  10384e:	87 10 00 
	 * Forces the inclusion of the spurious interrupt handlers. If a
	 * reference isn't made then intconnect.o is never pulled in by the
	 * linker.
	 */

	_dummy_spurious_interrupt = &__isr___SpuriousIntHandler;
  103851:	c7 05 48 7f 10 00 00 	movl   $0x800,0x107f48
  103858:	08 00 00 
	 * Forces the inclusion of the exception vector stub code. If a
	 * reference isn't made then excstubs.o is never pulled in by the
	 * linker.
	 */

	_dummy_exception_vector_stub = &_exception_enter;
  10385b:	c7 05 40 7f 10 00 6b 	movl   $0x10336b,0x107f40
  103862:	33 10 00 
  103865:	e8 57 fe ff ff       	call   1036c1 <_sys_device_do_config_level>

	/* perform basic hardware initialization */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
  10386a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  103871:	e8 4b fe ff ff       	call   1036c1 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
  103876:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10387d:	e8 3f fe ff ff       	call   1036c1 <_sys_device_do_config_level>

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  103882:	9c                   	pushf  
  103883:	fa                   	cli    
  103884:	58                   	pop    %eax
	 * Context switch to main task (entry function is _main()): the
	 * current fake thread is not on a wait queue or ready queue, so it
	 * will never be rescheduled in.
	 */

	_Swap(irq_lock());
  103885:	89 04 24             	mov    %eax,(%esp)
  103888:	e8 83 fb ff ff       	call   103410 <_Swap>
  10388d:	58                   	pop    %eax

0010388e <nano_timer_test>:
}

#endif /* (CONFIG_NUM_DYNAMIC_TIMERS > 0) */

void *nano_timer_test(struct nano_timer *timer, int32_t timeout_in_ticks)
{
  10388e:	55                   	push   %ebp
	uint32_t (*test_fn)(struct k_timer *timer);

	if (timeout_in_ticks == TICKS_NONE) {
		test_fn = k_timer_status_get;
	} else {
		test_fn = k_timer_status_sync;
  10388f:	b8 43 45 10 00       	mov    $0x104543,%eax
}

#endif /* (CONFIG_NUM_DYNAMIC_TIMERS > 0) */

void *nano_timer_test(struct nano_timer *timer, int32_t timeout_in_ticks)
{
  103894:	89 e5                	mov    %esp,%ebp
  103896:	53                   	push   %ebx
	uint32_t (*test_fn)(struct k_timer *timer);

	if (timeout_in_ticks == TICKS_NONE) {
  103897:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
}

#endif /* (CONFIG_NUM_DYNAMIC_TIMERS > 0) */

void *nano_timer_test(struct nano_timer *timer, int32_t timeout_in_ticks)
{
  10389b:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint32_t (*test_fn)(struct k_timer *timer);

	if (timeout_in_ticks == TICKS_NONE) {
  10389e:	75 05                	jne    1038a5 <nano_timer_test+0x17>
  1038a0:	b8 28 45 10 00       	mov    $0x104528,%eax
		test_fn = k_timer_status_get;
	} else {
		test_fn = k_timer_status_sync;
	}
	return test_fn(timer) ? timer->_legacy_data : NULL;
  1038a5:	53                   	push   %ebx
  1038a6:	ff d0                	call   *%eax
  1038a8:	5a                   	pop    %edx
  1038a9:	31 d2                	xor    %edx,%edx
  1038ab:	85 c0                	test   %eax,%eax
  1038ad:	74 03                	je     1038b2 <nano_timer_test+0x24>
  1038af:	8b 53 30             	mov    0x30(%ebx),%edx
}
  1038b2:	89 d0                	mov    %edx,%eax
  1038b4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1038b7:	c9                   	leave  
  1038b8:	c3                   	ret    

001038b9 <_get_highest_ready_prio>:
}

/* find out the currently highest priority where a thread is ready to run */
/* interrupts must be locked */
static inline int _get_highest_ready_prio(void)
{
  1038b9:	55                   	push   %ebp
  1038ba:	89 e5                	mov    %esp,%ebp

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
	unsigned int bitpos;

	__asm__ volatile (
  1038bc:	0f bc 05 d8 7d 10 00 	bsf    0x107dd8,%eax
  1038c3:	75 05                	jne    1038ca <_get_highest_ready_prio+0x11>
  1038c5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	int abs_prio = (find_lsb_set(ready_range) - 1) + (bitmap << 5);

	__ASSERT(abs_prio < K_NUM_PRIORITIES, "prio out-of-range\n");

	return abs_prio - CONFIG_NUM_COOP_PRIORITIES;
  1038ca:	83 e8 10             	sub    $0x10,%eax
}
  1038cd:	5d                   	pop    %ebp
  1038ce:	c3                   	ret    

001038cf <_is_timeout_insert_point>:
 * the timeout of the insert point to update its delta queue value, since the
 * current timeout will be inserted before it.
 */

static int _is_timeout_insert_point(sys_dnode_t *test, void *timeout)
{
  1038cf:	55                   	push   %ebp
  1038d0:	89 e5                	mov    %esp,%ebp
  1038d2:	53                   	push   %ebx
  1038d3:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1038d6:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct _timeout *t = (void *)test;
	int32_t *timeout_to_insert = timeout;

	if (*timeout_to_insert > t->delta_ticks_from_prev) {
  1038d9:	8b 41 10             	mov    0x10(%ecx),%eax
  1038dc:	8b 13                	mov    (%ebx),%edx
  1038de:	39 c2                	cmp    %eax,%edx
  1038e0:	7e 08                	jle    1038ea <_is_timeout_insert_point+0x1b>
		*timeout_to_insert -= t->delta_ticks_from_prev;
  1038e2:	29 c2                	sub    %eax,%edx
		return 0;
  1038e4:	31 c0                	xor    %eax,%eax
{
	struct _timeout *t = (void *)test;
	int32_t *timeout_to_insert = timeout;

	if (*timeout_to_insert > t->delta_ticks_from_prev) {
		*timeout_to_insert -= t->delta_ticks_from_prev;
  1038e6:	89 13                	mov    %edx,(%ebx)
		return 0;
  1038e8:	eb 0a                	jmp    1038f4 <_is_timeout_insert_point+0x25>
	}

	t->delta_ticks_from_prev -= *timeout_to_insert;
  1038ea:	29 d0                	sub    %edx,%eax
  1038ec:	89 41 10             	mov    %eax,0x10(%ecx)
	return 1;
  1038ef:	b8 01 00 00 00       	mov    $0x1,%eax
}
  1038f4:	5b                   	pop    %ebx
  1038f5:	5d                   	pop    %ebp
  1038f6:	c3                   	ret    

001038f7 <_is_wait_q_insert_point>:
/*
 * Callback for sys_dlist_insert_at() to find the correct insert point in a
 * wait queue (priority-based).
 */
static int _is_wait_q_insert_point(sys_dnode_t *node, void *insert_prio)
{
  1038f7:	55                   	push   %ebp
  1038f8:	89 e5                	mov    %esp,%ebp
		CONTAINER_OF(
			CONTAINER_OF(node, struct _thread_base, k_q_node),
			struct k_thread,
			base);

	return _is_prio_higher((int)insert_prio, waitq_node->base.prio);
  1038fa:	8b 45 08             	mov    0x8(%ebp),%eax
  1038fd:	8b 40 0c             	mov    0xc(%eax),%eax
  103900:	39 45 0c             	cmp    %eax,0xc(%ebp)
}
  103903:	5d                   	pop    %ebp
		CONTAINER_OF(
			CONTAINER_OF(node, struct _thread_base, k_q_node),
			struct k_thread,
			base);

	return _is_prio_higher((int)insert_prio, waitq_node->base.prio);
  103904:	0f 9c c0             	setl   %al
  103907:	0f b6 c0             	movzbl %al,%eax
}
  10390a:	c3                   	ret    

0010390b <sys_dlist_insert_at>:
 * @return N/A
 */

static inline void sys_dlist_insert_at(sys_dlist_t *list, sys_dnode_t *node,
	int (*cond)(sys_dnode_t *, void *), void *data)
{
  10390b:	55                   	push   %ebp
  10390c:	89 e5                	mov    %esp,%ebp
  10390e:	57                   	push   %edi
  10390f:	56                   	push   %esi
  103910:	53                   	push   %ebx
  103911:	53                   	push   %ebx
  103912:	89 c6                	mov    %eax,%esi
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  103914:	8b 38                	mov    (%eax),%edi
 * @return N/A
 */

static inline void sys_dlist_insert_at(sys_dlist_t *list, sys_dnode_t *node,
	int (*cond)(sys_dnode_t *, void *), void *data)
{
  103916:	89 d3                	mov    %edx,%ebx
	if (sys_dlist_is_empty(list)) {
  103918:	39 f8                	cmp    %edi,%eax
  10391a:	74 1f                	je     10393b <sys_dlist_insert_at+0x30>
		sys_dlist_append(list, node);
	} else {
		sys_dnode_t *pos = sys_dlist_peek_head(list);

		while (pos && !cond(pos, data)) {
  10391c:	85 ff                	test   %edi,%edi
  10391e:	74 1b                	je     10393b <sys_dlist_insert_at+0x30>
  103920:	ff 75 08             	pushl  0x8(%ebp)
  103923:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  103926:	57                   	push   %edi
  103927:	ff d1                	call   *%ecx
  103929:	5a                   	pop    %edx
  10392a:	85 c0                	test   %eax,%eax
  10392c:	59                   	pop    %ecx
  10392d:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103930:	75 1b                	jne    10394d <sys_dlist_insert_at+0x42>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (!node || node == list->tail) ? NULL : node->next;
  103932:	3b 7e 04             	cmp    0x4(%esi),%edi
  103935:	74 04                	je     10393b <sys_dlist_insert_at+0x30>
  103937:	8b 3f                	mov    (%edi),%edi
  103939:	eb e1                	jmp    10391c <sys_dlist_insert_at+0x11>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  10393b:	89 33                	mov    %esi,(%ebx)
	node->prev = list->tail;
  10393d:	8b 46 04             	mov    0x4(%esi),%eax
  103940:	89 43 04             	mov    %eax,0x4(%ebx)

	list->tail->next = node;
  103943:	8b 46 04             	mov    0x4(%esi),%eax
  103946:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
  103948:	89 5e 04             	mov    %ebx,0x4(%esi)
  10394b:	eb 10                	jmp    10395d <sys_dlist_insert_at+0x52>
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  10394d:	8b 47 04             	mov    0x4(%edi),%eax
		node->next = insert_point;
  103950:	89 3b                	mov    %edi,(%ebx)
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  103952:	89 43 04             	mov    %eax,0x4(%ebx)
		node->next = insert_point;
		insert_point->prev->next = node;
  103955:	8b 47 04             	mov    0x4(%edi),%eax
  103958:	89 18                	mov    %ebx,(%eax)
		insert_point->prev = node;
  10395a:	89 5f 04             	mov    %ebx,0x4(%edi)
		while (pos && !cond(pos, data)) {
			pos = sys_dlist_peek_next(list, pos);
		}
		sys_dlist_insert_before(list, pos, node);
	}
}
  10395d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103960:	5b                   	pop    %ebx
  103961:	5e                   	pop    %esi
  103962:	5f                   	pop    %edi
  103963:	5d                   	pop    %ebp
  103964:	c3                   	ret    

00103965 <_add_thread_to_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _add_thread_to_ready_q(struct k_thread *thread)
{
  103965:	55                   	push   %ebp
  103966:	89 e5                	mov    %esp,%ebp
  103968:	56                   	push   %esi
  103969:	53                   	push   %ebx
static void _set_ready_q_prio_bit(int prio)
{
	int bmap_index = _get_ready_q_prio_bmap_index(prio);
	uint32_t *bmap = &_ready_q.prio_bmap[bmap_index];

	*bmap |= _get_ready_q_prio_bit(prio);
  10396a:	bb 01 00 00 00       	mov    $0x1,%ebx
 *
 * Interrupts must be locked when calling this function.
 */

void _add_thread_to_ready_q(struct k_thread *thread)
{
  10396f:	8b 45 08             	mov    0x8(%ebp),%eax
}

/* find out the ready queue array index for a given prio */
static inline int _get_ready_q_q_index(int prio)
{
	return prio + CONFIG_NUM_COOP_PRIORITIES;
  103972:	8b 50 0c             	mov    0xc(%eax),%edx
  103975:	8d 4a 10             	lea    0x10(%edx),%ecx
	int q_index = _get_ready_q_q_index(thread->base.prio);
	sys_dlist_t *q = &_ready_q.q[q_index];
  103978:	83 c2 12             	add    $0x12,%edx
}

/* find out the prio bitmap index for a given prio */
static inline int _get_ready_q_prio_bmap_index(int prio)
{
	return (prio + CONFIG_NUM_COOP_PRIORITIES) >> 5;
  10397b:	89 ce                	mov    %ecx,%esi
  10397d:	c1 fe 05             	sar    $0x5,%esi
static void _set_ready_q_prio_bit(int prio)
{
	int bmap_index = _get_ready_q_prio_bmap_index(prio);
	uint32_t *bmap = &_ready_q.prio_bmap[bmap_index];

	*bmap |= _get_ready_q_prio_bit(prio);
  103980:	d3 e3                	shl    %cl,%ebx
 */

void _add_thread_to_ready_q(struct k_thread *thread)
{
	int q_index = _get_ready_q_q_index(thread->base.prio);
	sys_dlist_t *q = &_ready_q.q[q_index];
  103982:	8d 0c d5 cc 7d 10 00 	lea    0x107dcc(,%edx,8),%ecx
static void _set_ready_q_prio_bit(int prio)
{
	int bmap_index = _get_ready_q_prio_bmap_index(prio);
	uint32_t *bmap = &_ready_q.prio_bmap[bmap_index];

	*bmap |= _get_ready_q_prio_bit(prio);
  103989:	09 1c b5 d8 7d 10 00 	or     %ebx,0x107dd8(,%esi,4)
 */

void _add_thread_to_ready_q(struct k_thread *thread)
{
	int q_index = _get_ready_q_q_index(thread->base.prio);
	sys_dlist_t *q = &_ready_q.q[q_index];
  103990:	89 08                	mov    %ecx,(%eax)
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
	node->prev = list->tail;
  103992:	8b 0c d5 d0 7d 10 00 	mov    0x107dd0(,%edx,8),%ecx
  103999:	89 48 04             	mov    %ecx,0x4(%eax)

	list->tail->next = node;
  10399c:	8b 0c d5 d0 7d 10 00 	mov    0x107dd0(,%edx,8),%ecx
  1039a3:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
  1039a5:	89 04 d5 d0 7d 10 00 	mov    %eax,0x107dd0(,%edx,8)
	_set_ready_q_prio_bit(thread->base.prio);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache && _is_prio_higher(thread->base.prio,
  1039ac:	8b 15 d4 7d 10 00    	mov    0x107dd4,%edx
					   (*cache)->base.prio) ?
		 thread : *cache;
  1039b2:	85 d2                	test   %edx,%edx
  1039b4:	74 0a                	je     1039c0 <_add_thread_to_ready_q+0x5b>
	_set_ready_q_prio_bit(thread->base.prio);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache && _is_prio_higher(thread->base.prio,
  1039b6:	8b 58 0c             	mov    0xc(%eax),%ebx
  1039b9:	39 5a 0c             	cmp    %ebx,0xc(%edx)
  1039bc:	7e 02                	jle    1039c0 <_add_thread_to_ready_q+0x5b>
  1039be:	89 c2                	mov    %eax,%edx
					   (*cache)->base.prio) ?
		 thread : *cache;
}
  1039c0:	5b                   	pop    %ebx
	_set_ready_q_prio_bit(thread->base.prio);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache && _is_prio_higher(thread->base.prio,
  1039c1:	89 15 d4 7d 10 00    	mov    %edx,0x107dd4
					   (*cache)->base.prio) ?
		 thread : *cache;
}
  1039c7:	5e                   	pop    %esi
  1039c8:	5d                   	pop    %ebp
  1039c9:	c3                   	ret    

001039ca <_remove_thread_from_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _remove_thread_from_ready_q(struct k_thread *thread)
{
  1039ca:	55                   	push   %ebp
  1039cb:	89 e5                	mov    %esp,%ebp
  1039cd:	53                   	push   %ebx
  1039ce:	8b 45 08             	mov    0x8(%ebp),%eax
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  1039d1:	8b 48 04             	mov    0x4(%eax),%ecx
  1039d4:	8b 18                	mov    (%eax),%ebx
}

/* find out the ready queue array index for a given prio */
static inline int _get_ready_q_q_index(int prio)
{
	return prio + CONFIG_NUM_COOP_PRIORITIES;
  1039d6:	8b 50 0c             	mov    0xc(%eax),%edx
  1039d9:	89 19                	mov    %ebx,(%ecx)
	node->next->prev = node->prev;
  1039db:	8b 18                	mov    (%eax),%ebx
  1039dd:	89 4b 04             	mov    %ecx,0x4(%ebx)
	int q_index = _get_ready_q_q_index(thread->base.prio);
	sys_dlist_t *q = &_ready_q.q[q_index];
  1039e0:	8d 0c d5 5c 7e 10 00 	lea    0x107e5c(,%edx,8),%ecx

	sys_dlist_remove(&thread->base.k_q_node);
	if (sys_dlist_is_empty(q)) {
  1039e7:	3b 0c d5 5c 7e 10 00 	cmp    0x107e5c(,%edx,8),%ecx
  1039ee:	75 1b                	jne    103a0b <_remove_thread_from_ready_q+0x41>
}

/* find out the prio bitmap index for a given prio */
static inline int _get_ready_q_prio_bmap_index(int prio)
{
	return (prio + CONFIG_NUM_COOP_PRIORITIES) >> 5;
  1039f0:	8b 48 0c             	mov    0xc(%eax),%ecx
static void _clear_ready_q_prio_bit(int prio)
{
	int bmap_index = _get_ready_q_prio_bmap_index(prio);
	uint32_t *bmap = &_ready_q.prio_bmap[bmap_index];

	*bmap &= ~_get_ready_q_prio_bit(prio);
  1039f3:	ba 01 00 00 00       	mov    $0x1,%edx
  1039f8:	83 c1 10             	add    $0x10,%ecx
  1039fb:	89 cb                	mov    %ecx,%ebx
  1039fd:	c1 fb 05             	sar    $0x5,%ebx
  103a00:	d3 e2                	shl    %cl,%edx
  103a02:	f7 d2                	not    %edx
  103a04:	21 14 9d d8 7d 10 00 	and    %edx,0x107dd8(,%ebx,4)
		_clear_ready_q_prio_bit(thread->base.prio);
	}

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? NULL : *cache;
  103a0b:	8b 15 d4 7d 10 00    	mov    0x107dd4,%edx
  103a11:	39 d0                	cmp    %edx,%eax
  103a13:	75 02                	jne    103a17 <_remove_thread_from_ready_q+0x4d>
  103a15:	31 d2                	xor    %edx,%edx
}
  103a17:	5b                   	pop    %ebx
		_clear_ready_q_prio_bit(thread->base.prio);
	}

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? NULL : *cache;
  103a18:	89 15 d4 7d 10 00    	mov    %edx,0x107dd4
}
  103a1e:	5d                   	pop    %ebp
  103a1f:	c3                   	ret    

00103a20 <_ms_to_ticks>:

#define ceiling(numerator, divider) \
	(((numerator) + ((divider) - 1)) / (divider))

int32_t _ms_to_ticks(int32_t ms)
{
  103a20:	55                   	push   %ebp
	int64_t ms_ticks_per_sec = (int64_t)ms * sys_clock_ticks_per_sec;

	return (int32_t)ceiling(ms_ticks_per_sec, MSEC_PER_SEC);
  103a21:	b8 64 00 00 00       	mov    $0x64,%eax

#define ceiling(numerator, divider) \
	(((numerator) + ((divider) - 1)) / (divider))

int32_t _ms_to_ticks(int32_t ms)
{
  103a26:	89 e5                	mov    %esp,%ebp
	int64_t ms_ticks_per_sec = (int64_t)ms * sys_clock_ticks_per_sec;

	return (int32_t)ceiling(ms_ticks_per_sec, MSEC_PER_SEC);
  103a28:	6a 00                	push   $0x0
  103a2a:	68 e8 03 00 00       	push   $0x3e8
  103a2f:	f7 6d 08             	imull  0x8(%ebp)
  103a32:	05 e7 03 00 00       	add    $0x3e7,%eax
  103a37:	83 d2 00             	adc    $0x0,%edx
  103a3a:	52                   	push   %edx
  103a3b:	50                   	push   %eax
  103a3c:	e8 4f c6 ff ff       	call   100090 <__divdi3>
  103a41:	83 c4 10             	add    $0x10,%esp
}
  103a44:	c9                   	leave  
  103a45:	c3                   	ret    

00103a46 <_pend_thread>:

/* pend the specified thread: it must *not* be in the ready queue */
/* must be called with interrupts locked */
void _pend_thread(struct k_thread *thread, _wait_q_t *wait_q, int32_t timeout)
{
  103a46:	55                   	push   %ebp
	sys_dlist_t *dlist = (sys_dlist_t *)wait_q;

	sys_dlist_insert_at(dlist, &thread->base.k_q_node,
  103a47:	b9 f7 38 10 00       	mov    $0x1038f7,%ecx
}

/* pend the specified thread: it must *not* be in the ready queue */
/* must be called with interrupts locked */
void _pend_thread(struct k_thread *thread, _wait_q_t *wait_q, int32_t timeout)
{
  103a4c:	89 e5                	mov    %esp,%ebp
  103a4e:	57                   	push   %edi
  103a4f:	56                   	push   %esi
  103a50:	53                   	push   %ebx
  103a51:	8b 5d 08             	mov    0x8(%ebp),%ebx
  103a54:	8b 75 0c             	mov    0xc(%ebp),%esi
  103a57:	8b 7d 10             	mov    0x10(%ebp),%edi
	sys_dlist_t *dlist = (sys_dlist_t *)wait_q;

	sys_dlist_insert_at(dlist, &thread->base.k_q_node,
  103a5a:	89 f0                	mov    %esi,%eax
  103a5c:	ff 73 0c             	pushl  0xc(%ebx)
  103a5f:	89 da                	mov    %ebx,%edx
  103a61:	e8 a5 fe ff ff       	call   10390b <sys_dlist_insert_at>
  103a66:	58                   	pop    %eax
}

/* mark a thread as pending in its TCS */
static inline void _mark_thread_as_pending(struct k_thread *thread)
{
	thread->base.flags |= K_PENDING;
  103a67:	81 4b 08 00 20 00 00 	orl    $0x2000,0x8(%ebx)
			    _is_wait_q_insert_point,
			    (void *)thread->base.prio);

	_mark_thread_as_pending(thread);

	if (timeout != K_FOREVER) {
  103a6e:	83 ff ff             	cmp    $0xffffffff,%edi
  103a71:	74 49                	je     103abc <_pend_thread+0x76>

	K_DEBUG("timeout   %p before: next: %p, prev: %p\n",
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
	timeout_obj->delta_ticks_from_prev = timeout;
  103a73:	b8 64 00 00 00       	mov    $0x64,%eax
		_timeout_q.tail);

	K_DEBUG("timeout   %p before: next: %p, prev: %p\n",
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
  103a78:	89 5b 20             	mov    %ebx,0x20(%ebx)
	timeout_obj->delta_ticks_from_prev = timeout;
  103a7b:	f7 ef                	imul   %edi
  103a7d:	05 e7 03 00 00       	add    $0x3e7,%eax
  103a82:	6a 00                	push   $0x0
  103a84:	83 d2 00             	adc    $0x0,%edx
  103a87:	68 e8 03 00 00       	push   $0x3e8
  103a8c:	52                   	push   %edx
  103a8d:	50                   	push   %eax
  103a8e:	e8 fd c5 ff ff       	call   100090 <__divdi3>
	timeout_obj->wait_q = (sys_dlist_t *)wait_q;
  103a93:	89 73 24             	mov    %esi,0x24(%ebx)

	K_DEBUG("timeout   %p before: next: %p, prev: %p\n",
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
	timeout_obj->delta_ticks_from_prev = timeout;
  103a96:	40                   	inc    %eax
 */

static inline void _add_thread_timeout(struct k_thread *thread,
				       _wait_q_t *wait_q, int32_t timeout)
{
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout);
  103a97:	8d 53 18             	lea    0x18(%ebx),%edx

	K_DEBUG("timeout   %p before: next: %p, prev: %p\n",
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
	timeout_obj->delta_ticks_from_prev = timeout;
  103a9a:	89 43 28             	mov    %eax,0x28(%ebx)
	timeout_obj->wait_q = (sys_dlist_t *)wait_q;
	sys_dlist_insert_at(timeout_q, (void *)timeout_obj,
			    _is_timeout_insert_point,
			    &timeout_obj->delta_ticks_from_prev);
  103a9d:	83 c3 28             	add    $0x28,%ebx
  103aa0:	89 5d 08             	mov    %ebx,0x8(%ebp)

	K_DEBUG("timeout   %p before: next: %p, prev: %p\n",
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
	timeout_obj->delta_ticks_from_prev = timeout;
  103aa3:	83 c4 10             	add    $0x10,%esp
		int32_t ticks = _TICK_ALIGN + _ms_to_ticks(timeout);

		_add_thread_timeout(thread, wait_q, ticks);
	}
}
  103aa6:	8d 65 f4             	lea    -0xc(%ebp),%esp
	timeout_obj->wait_q = (sys_dlist_t *)wait_q;
	sys_dlist_insert_at(timeout_q, (void *)timeout_obj,
  103aa9:	b9 cf 38 10 00       	mov    $0x1038cf,%ecx
  103aae:	b8 cc 7d 10 00       	mov    $0x107dcc,%eax
  103ab3:	5b                   	pop    %ebx
  103ab4:	5e                   	pop    %esi
  103ab5:	5f                   	pop    %edi
  103ab6:	5d                   	pop    %ebp
  103ab7:	e9 4f fe ff ff       	jmp    10390b <sys_dlist_insert_at>
  103abc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103abf:	5b                   	pop    %ebx
  103ac0:	5e                   	pop    %esi
  103ac1:	5f                   	pop    %edi
  103ac2:	5d                   	pop    %ebp
  103ac3:	c3                   	ret    

00103ac4 <_pend_current_thread>:

/* pend the current thread */
/* must be called with interrupts locked */
void _pend_current_thread(_wait_q_t *wait_q, int32_t timeout)
{
  103ac4:	55                   	push   %ebp
  103ac5:	89 e5                	mov    %esp,%ebp
	_remove_thread_from_ready_q(_current);
  103ac7:	ff 35 c8 7d 10 00    	pushl  0x107dc8
  103acd:	e8 f8 fe ff ff       	call   1039ca <_remove_thread_from_ready_q>
  103ad2:	58                   	pop    %eax
	_pend_thread(_current, wait_q, timeout);
  103ad3:	ff 75 0c             	pushl  0xc(%ebp)
  103ad6:	ff 75 08             	pushl  0x8(%ebp)
  103ad9:	ff 35 c8 7d 10 00    	pushl  0x107dc8
  103adf:	e8 62 ff ff ff       	call   103a46 <_pend_thread>
  103ae4:	83 c4 0c             	add    $0xc,%esp
}
  103ae7:	c9                   	leave  
  103ae8:	c3                   	ret    

00103ae9 <_get_next_ready_thread>:

/* find which one is the next thread to run */
/* must be called with interrupts locked */
struct k_thread *_get_next_ready_thread(void)
{
	struct k_thread *cache = _ready_q.cache;
  103ae9:	a1 d4 7d 10 00       	mov    0x107dd4,%eax

	return cache ? cache : __get_next_ready_thread();
  103aee:	85 c0                	test   %eax,%eax
  103af0:	75 15                	jne    103b07 <_get_next_ready_thread+0x1e>
}

/* find which one is the next thread to run */
/* must be called with interrupts locked */
struct k_thread *_get_next_ready_thread(void)
{
  103af2:	55                   	push   %ebp
  103af3:	89 e5                	mov    %esp,%ebp
 * Find the next thread to run when there is no thread in the cache and update
 * the cache.
 */
static struct k_thread *__get_next_ready_thread(void)
{
	int prio = _get_highest_ready_prio();
  103af5:	e8 bf fd ff ff       	call   1038b9 <_get_highest_ready_prio>
struct k_thread *_get_next_ready_thread(void)
{
	struct k_thread *cache = _ready_q.cache;

	return cache ? cache : __get_next_ready_thread();
}
  103afa:	5d                   	pop    %ebp
  103afb:	8b 04 c5 5c 7e 10 00 	mov    0x107e5c(,%eax,8),%eax
		 prio, q_index);

	struct k_thread *thread =
		(struct k_thread *)sys_dlist_peek_head_not_empty(list);

	_ready_q.cache = thread;
  103b02:	a3 d4 7d 10 00       	mov    %eax,0x107dd4
struct k_thread *_get_next_ready_thread(void)
{
	struct k_thread *cache = _ready_q.cache;

	return cache ? cache : __get_next_ready_thread();
}
  103b07:	c3                   	ret    

00103b08 <__must_switch_threads>:
/*
 * Check if there is a thread of higher prio than the current one. Should only
 * be called if we already know that the current thread is preemptible.
 */
int __must_switch_threads(void)
{
  103b08:	55                   	push   %ebp
		_current->base.prio, _get_highest_ready_prio());

	extern void _dump_ready_q(void);
	_dump_ready_q();

	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
  103b09:	a1 c8 7d 10 00       	mov    0x107dc8,%eax
/*
 * Check if there is a thread of higher prio than the current one. Should only
 * be called if we already know that the current thread is preemptible.
 */
int __must_switch_threads(void)
{
  103b0e:	89 e5                	mov    %esp,%ebp
		_current->base.prio, _get_highest_ready_prio());

	extern void _dump_ready_q(void);
	_dump_ready_q();

	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
  103b10:	8b 50 0c             	mov    0xc(%eax),%edx
  103b13:	e8 a1 fd ff ff       	call   1038b9 <_get_highest_ready_prio>
  103b18:	39 c2                	cmp    %eax,%edx
}
  103b1a:	5d                   	pop    %ebp
		_current->base.prio, _get_highest_ready_prio());

	extern void _dump_ready_q(void);
	_dump_ready_q();

	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
  103b1b:	0f 9f c0             	setg   %al
  103b1e:	0f b6 c0             	movzbl %al,%eax
}
  103b21:	c3                   	ret    

00103b22 <_reschedule_threads>:

/* reschedule threads if the scheduler is not locked */
/* not callable from ISR */
/* must be called with interrupts locked */
void _reschedule_threads(int key)
{
  103b22:	55                   	push   %ebp
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
  103b23:	a1 c8 7d 10 00       	mov    0x107dc8,%eax
  103b28:	89 e5                	mov    %esp,%ebp
}

/* is thread currently preemptible ? */
static inline int _is_preempt(struct k_thread *thread)
{
	return !_is_coop(thread) && !atomic_get(&thread->base.sched_locked);
  103b2a:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
  103b2e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103b31:	78 19                	js     103b4c <_reschedule_threads+0x2a>
 * @return Value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_get(const atomic_t *target)
{
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
  103b33:	8b 40 10             	mov    0x10(%eax),%eax
  103b36:	85 c0                	test   %eax,%eax
  103b38:	75 12                	jne    103b4c <_reschedule_threads+0x2a>
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
  103b3a:	e8 c9 ff ff ff       	call   103b08 <__must_switch_threads>
  103b3f:	85 c0                	test   %eax,%eax
  103b41:	74 09                	je     103b4c <_reschedule_threads+0x2a>
	K_DEBUG("rescheduling threads\n");

	if (_must_switch_threads()) {
		K_DEBUG("context-switching out %p\n", _current);
		_Swap(key);
  103b43:	89 4d 08             	mov    %ecx,0x8(%ebp)
	} else {
		irq_unlock(key);
	}
}
  103b46:	5d                   	pop    %ebp
{
	K_DEBUG("rescheduling threads\n");

	if (_must_switch_threads()) {
		K_DEBUG("context-switching out %p\n", _current);
		_Swap(key);
  103b47:	e9 c4 f8 ff ff       	jmp    103410 <_Swap>
  103b4c:	80 e5 02             	and    $0x2,%ch
  103b4f:	74 01                	je     103b52 <_reschedule_threads+0x30>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  103b51:	fb                   	sti    
	} else {
		irq_unlock(key);
	}
}
  103b52:	5d                   	pop    %ebp
  103b53:	c3                   	ret    

00103b54 <k_sched_unlock>:
	K_DEBUG("scheduler locked (%p:%d)\n",
		_current, _current->base.sched_locked);
}

void k_sched_unlock(void)
{
  103b54:	55                   	push   %ebp
  103b55:	89 e5                	mov    %esp,%ebp

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  103b57:	9c                   	pushf  
  103b58:	fa                   	cli    
  103b59:	5a                   	pop    %edx
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
  103b5a:	a1 c8 7d 10 00       	mov    0x107dc8,%eax
  103b5f:	f0 ff 48 10          	lock decl 0x10(%eax)
	atomic_dec(&_current->base.sched_locked);

	K_DEBUG("scheduler unlocked (%p:%d)\n",
		_current, _current->base.sched_locked);

	_reschedule_threads(key);
  103b63:	52                   	push   %edx
  103b64:	e8 b9 ff ff ff       	call   103b22 <_reschedule_threads>
  103b69:	58                   	pop    %eax
}
  103b6a:	c9                   	leave  
  103b6b:	c3                   	ret    

00103b6c <_is_next_thread_current>:

	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
}

int _is_next_thread_current(void)
{
  103b6c:	55                   	push   %ebp
  103b6d:	89 e5                	mov    %esp,%ebp
	return _get_next_ready_thread() == _current;
  103b6f:	e8 75 ff ff ff       	call   103ae9 <_get_next_ready_thread>
}
  103b74:	5d                   	pop    %ebp
	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
}

int _is_next_thread_current(void)
{
	return _get_next_ready_thread() == _current;
  103b75:	39 05 c8 7d 10 00    	cmp    %eax,0x107dc8
  103b7b:	0f 94 c0             	sete   %al
  103b7e:	0f b6 c0             	movzbl %al,%eax
}
  103b81:	c3                   	ret    

00103b82 <_move_thread_to_end_of_prio_q>:
 * This function, along with _add_thread_to_ready_q() and
 * _remove_thread_from_ready_q(), are the _only_ places where a thread is
 * taken off or put on the ready queue.
 */
void _move_thread_to_end_of_prio_q(struct k_thread *thread)
{
  103b82:	55                   	push   %ebp
  103b83:	89 e5                	mov    %esp,%ebp
  103b85:	56                   	push   %esi
  103b86:	53                   	push   %ebx
  103b87:	8b 45 08             	mov    0x8(%ebp),%eax
	int q_index = _get_ready_q_q_index(thread->base.prio);
	sys_dlist_t *q = &_ready_q.q[q_index];
  103b8a:	8b 58 0c             	mov    0xc(%eax),%ebx
  103b8d:	8d 53 12             	lea    0x12(%ebx),%edx
  103b90:	8d 0c d5 cc 7d 10 00 	lea    0x107dcc(,%edx,8),%ecx

	if (sys_dlist_is_tail(q, &thread->base.k_q_node)) {
  103b97:	3b 41 04             	cmp    0x4(%ecx),%eax
  103b9a:	74 3a                	je     103bd6 <_move_thread_to_end_of_prio_q+0x54>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  103b9c:	8b 58 04             	mov    0x4(%eax),%ebx
  103b9f:	8b 30                	mov    (%eax),%esi
  103ba1:	89 33                	mov    %esi,(%ebx)
	node->next->prev = node->prev;
  103ba3:	8b 30                	mov    (%eax),%esi
  103ba5:	89 5e 04             	mov    %ebx,0x4(%esi)
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  103ba8:	89 08                	mov    %ecx,(%eax)
	node->prev = list->tail;
  103baa:	8b 0c d5 d0 7d 10 00 	mov    0x107dd0(,%edx,8),%ecx
  103bb1:	89 48 04             	mov    %ecx,0x4(%eax)

	list->tail->next = node;
  103bb4:	8b 0c d5 d0 7d 10 00 	mov    0x107dd0(,%edx,8),%ecx
  103bbb:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
  103bbd:	89 04 d5 d0 7d 10 00 	mov    %eax,0x107dd0(,%edx,8)
	sys_dlist_remove(&thread->base.k_q_node);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? NULL : *cache;
  103bc4:	8b 15 d4 7d 10 00    	mov    0x107dd4,%edx
  103bca:	39 d0                	cmp    %edx,%eax
  103bcc:	75 02                	jne    103bd0 <_move_thread_to_end_of_prio_q+0x4e>
  103bce:	31 d2                	xor    %edx,%edx
  103bd0:	89 15 d4 7d 10 00    	mov    %edx,0x107dd4
}
  103bd6:	5b                   	pop    %ebx
  103bd7:	5e                   	pop    %esi
  103bd8:	5d                   	pop    %ebp
  103bd9:	c3                   	ret    

00103bda <k_current_get>:
		_reschedule_threads(key);
	}
}

k_tid_t k_current_get(void)
{
  103bda:	55                   	push   %ebp
	return _current;
}
  103bdb:	a1 c8 7d 10 00       	mov    0x107dc8,%eax
		_reschedule_threads(key);
	}
}

k_tid_t k_current_get(void)
{
  103be0:	89 e5                	mov    %esp,%ebp
	return _current;
}
  103be2:	5d                   	pop    %ebp
  103be3:	c3                   	ret    

00103be4 <_abort_timeout>:
}

/* returns 0 in success and -1 if the timer has expired */

static inline int _abort_timeout(struct _timeout *t)
{
  103be4:	55                   	push   %ebp
  103be5:	89 c2                	mov    %eax,%edx
	sys_dlist_t *timeout_q = &_timeout_q;

	if (-1 == t->delta_ticks_from_prev) {
  103be7:	8b 40 10             	mov    0x10(%eax),%eax
}

/* returns 0 in success and -1 if the timer has expired */

static inline int _abort_timeout(struct _timeout *t)
{
  103bea:	89 e5                	mov    %esp,%ebp
	sys_dlist_t *timeout_q = &_timeout_q;

	if (-1 == t->delta_ticks_from_prev) {
  103bec:	83 f8 ff             	cmp    $0xffffffff,%eax
  103bef:	74 22                	je     103c13 <_abort_timeout+0x2f>
		return -1;
	}

	if (!sys_dlist_is_tail(timeout_q, &t->node)) {
  103bf1:	3b 15 d0 7d 10 00    	cmp    0x107dd0,%edx
  103bf7:	74 05                	je     103bfe <_abort_timeout+0x1a>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (!node || node == list->tail) ? NULL : node->next;
  103bf9:	8b 0a                	mov    (%edx),%ecx
		struct _timeout *next =
			(struct _timeout *)sys_dlist_peek_next(timeout_q,
								    &t->node);
		next->delta_ticks_from_prev += t->delta_ticks_from_prev;
  103bfb:	01 41 10             	add    %eax,0x10(%ecx)
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  103bfe:	8b 42 04             	mov    0x4(%edx),%eax
  103c01:	8b 0a                	mov    (%edx),%ecx
  103c03:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
  103c05:	8b 0a                	mov    (%edx),%ecx
  103c07:	89 41 04             	mov    %eax,0x4(%ecx)
	}
	sys_dlist_remove(&t->node);
	t->delta_ticks_from_prev = -1;
  103c0a:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edx)

	return 0;
  103c11:	31 c0                	xor    %eax,%eax
}
  103c13:	5d                   	pop    %ebp
  103c14:	c3                   	ret    

00103c15 <_unpend_first_thread>:
	return (struct k_thread *)sys_dlist_peek_head(wait_q);
}

/* unpend the first thread from a wait queue */
static inline struct k_thread *_unpend_first_thread(_wait_q_t *wait_q)
{
  103c15:	55                   	push   %ebp
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  103c16:	8b 10                	mov    (%eax),%edx
  103c18:	89 e5                	mov    %esp,%ebp

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node;

	if (sys_dlist_is_empty(list)) {
  103c1a:	39 d0                	cmp    %edx,%eax
  103c1c:	74 15                	je     103c33 <_unpend_first_thread+0x1e>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  103c1e:	8b 42 04             	mov    0x4(%edx),%eax
  103c21:	8b 0a                	mov    (%edx),%ecx
  103c23:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
  103c25:	8b 0a                	mov    (%edx),%ecx
  103c27:	89 41 04             	mov    %eax,0x4(%ecx)
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.flags &= ~K_PENDING;
  103c2a:	81 62 08 ff df ff ff 	andl   $0xffffdfff,0x8(%edx)
  103c31:	eb 02                	jmp    103c35 <_unpend_first_thread+0x20>
static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node;

	if (sys_dlist_is_empty(list)) {
		return NULL;
  103c33:	31 d2                	xor    %edx,%edx
	if (thread) {
		_mark_thread_as_not_pending(thread);
	}

	return thread;
}
  103c35:	89 d0                	mov    %edx,%eax
  103c37:	5d                   	pop    %ebp
  103c38:	c3                   	ret    

00103c39 <_ready_thread>:
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.flags &= ~K_PRESTART;
  103c39:	8b 50 08             	mov    0x8(%eax),%edx
  103c3c:	89 d1                	mov    %edx,%ecx
  103c3e:	80 e5 bf             	and    $0xbf,%ch
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  103c41:	81 e2 00 a0 03 00    	and    $0x3a000,%edx
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.flags &= ~K_PRESTART;
  103c47:	89 48 08             	mov    %ecx,0x8(%eax)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  103c4a:	75 11                	jne    103c5d <_ready_thread+0x24>
  103c4c:	83 78 28 ff          	cmpl   $0xffffffff,0x28(%eax)
  103c50:	75 0b                	jne    103c5d <_ready_thread+0x24>
 * blocked for another reason (eg. suspended).
 *
 * Must be called with interrupts locked.
 */
static inline void _ready_thread(struct k_thread *thread)
{
  103c52:	55                   	push   %ebp
  103c53:	89 e5                	mov    %esp,%ebp

	/* needed to handle the start-with-delay case */
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
		_add_thread_to_ready_q(thread);
  103c55:	50                   	push   %eax
  103c56:	e8 0a fd ff ff       	call   103965 <_add_thread_to_ready_q>
  103c5b:	58                   	pop    %eax
	}
}
  103c5c:	c9                   	leave  
  103c5d:	c3                   	ret    

00103c5e <sem_give_common>:
 * @brief Common semaphore give code
 *
 * @return true if _Swap() will need to be invoked; false if not
 */
static bool sem_give_common(struct k_sem *sem)
{
  103c5e:	55                   	push   %ebp
  103c5f:	89 e5                	mov    %esp,%ebp
  103c61:	57                   	push   %edi
  103c62:	56                   	push   %esi
  103c63:	89 c6                	mov    %eax,%esi
  103c65:	53                   	push   %ebx
  103c66:	52                   	push   %edx
	struct k_thread *thread;

	thread = _unpend_first_thread(&sem->wait_q);
  103c67:	e8 a9 ff ff ff       	call   103c15 <_unpend_first_thread>
	if (!thread) {
  103c6c:	85 c0                	test   %eax,%eax
  103c6e:	75 17                	jne    103c87 <sem_give_common+0x29>
		/*
		 * No thread is waiting on the semaphore.
		 * Increment the semaphore's count unless
		 * its limit has already been reached.
		 */
		sem->count += (sem->count != sem->limit);
  103c70:	8b 46 08             	mov    0x8(%esi),%eax
  103c73:	31 d2                	xor    %edx,%edx
  103c75:	39 46 0c             	cmp    %eax,0xc(%esi)
  103c78:	0f 95 c2             	setne  %dl
  103c7b:	01 d0                	add    %edx,%eax
  103c7d:	89 46 08             	mov    %eax,0x8(%esi)
  103c80:	31 c0                	xor    %eax,%eax
  103c82:	e9 f5 00 00 00       	jmp    103d7c <sem_give_common+0x11e>
  103c87:	89 c3                	mov    %eax,%ebx

static inline int _abort_thread_timeout(struct k_thread *thread)
{
	return _abort_timeout(&thread->base.timeout);
  103c89:	8d 40 18             	lea    0x18(%eax),%eax
  103c8c:	e8 53 ff ff ff       	call   103be4 <_abort_timeout>
	struct _sem_desc *desc = NULL;
	sys_dlist_t  *list;
	sys_dnode_t  *node;
	sys_dnode_t  *next;

	if (!(thread->base.flags & K_DUMMY)) {
  103c91:	f6 43 0a 02          	testb  $0x2,0xa(%ebx)
  103c95:	0f 84 d1 00 00 00    	je     103d6c <sem_give_common+0x10e>
	/*
	 * The awakened thread is a dummy thread and thus was involved
	 * in a semaphore group operation.
	 */

	list = (sys_dlist_t *)dummy->desc.thread->base.swap_data;
  103c9b:	8b 43 38             	mov    0x38(%ebx),%eax
  103c9e:	8b 50 14             	mov    0x14(%eax),%edx
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  103ca1:	8b 1a                	mov    (%edx),%ebx
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  103ca3:	39 da                	cmp    %ebx,%edx
  103ca5:	75 45                	jne    103cec <sem_give_common+0x8e>
  103ca7:	31 db                	xor    %ebx,%ebx
  103ca9:	eb 41                	jmp    103cec <sem_give_common+0x8e>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (!node || node == list->tail) ? NULL : node->next;
  103cab:	39 5a 04             	cmp    %ebx,0x4(%edx)
  103cae:	74 02                	je     103cb2 <sem_give_common+0x54>
  103cb0:	8b 3b                	mov    (%ebx),%edi
	do {
		next = sys_dlist_peek_next(list, node);

		desc = (struct _sem_desc *)node;

		if (desc->sem != sem) {
  103cb2:	3b 73 0c             	cmp    0xc(%ebx),%esi
  103cb5:	74 2f                	je     103ce6 <sem_give_common+0x88>
  103cb7:	8d 43 e8             	lea    -0x18(%ebx),%eax
  103cba:	89 55 f0             	mov    %edx,-0x10(%ebp)
  103cbd:	e8 22 ff ff ff       	call   103be4 <_abort_timeout>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  103cc2:	8b 43 d4             	mov    -0x2c(%ebx),%eax
  103cc5:	8b 4b d0             	mov    -0x30(%ebx),%ecx
	node->next->prev = node->prev;
  103cc8:	8b 55 f0             	mov    -0x10(%ebp),%edx
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  103ccb:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
  103ccd:	8b 4b d0             	mov    -0x30(%ebx),%ecx
  103cd0:	89 41 04             	mov    %eax,0x4(%ecx)
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  103cd3:	8b 43 04             	mov    0x4(%ebx),%eax
  103cd6:	8b 0b                	mov    (%ebx),%ecx
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.flags &= ~K_PENDING;
  103cd8:	81 63 d8 ff df ff ff 	andl   $0xffffdfff,-0x28(%ebx)
  103cdf:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
  103ce1:	8b 0b                	mov    (%ebx),%ecx
  103ce3:	89 41 04             	mov    %eax,0x4(%ecx)
			_unpend_thread(dummy_thread);

			sys_dlist_remove(node);
		}
		node = next;
	} while (node != NULL);
  103ce6:	85 ff                	test   %edi,%edi
  103ce8:	74 0a                	je     103cf4 <sem_give_common+0x96>
  103cea:	89 fb                	mov    %edi,%ebx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (!node || node == list->tail) ? NULL : node->next;
  103cec:	31 ff                	xor    %edi,%edi
  103cee:	85 db                	test   %ebx,%ebx
  103cf0:	75 b9                	jne    103cab <sem_give_common+0x4d>
  103cf2:	eb be                	jmp    103cb2 <sem_give_common+0x54>
	 * As this code may be executed several times by a semaphore group give
	 * operation, it is important to ensure that the attempt to ready the
	 * master thread is done only once.
	 */

	if (!_is_thread_ready(desc->thread)) {
  103cf4:	8b 43 08             	mov    0x8(%ebx),%eax
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  103cf7:	f7 40 08 00 e0 03 00 	testl  $0x3e000,0x8(%eax)
  103cfe:	75 06                	jne    103d06 <sem_give_common+0xa8>
  103d00:	83 78 28 ff          	cmpl   $0xffffffff,0x28(%eax)
  103d04:	74 1e                	je     103d24 <sem_give_common+0xc6>
  103d06:	83 c0 18             	add    $0x18,%eax
  103d09:	e8 d6 fe ff ff       	call   103be4 <_abort_timeout>
		_abort_thread_timeout(desc->thread);
		_mark_thread_as_not_pending(desc->thread);
  103d0e:	8b 43 08             	mov    0x8(%ebx),%eax
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.flags &= ~K_PENDING;
  103d11:	8b 50 08             	mov    0x8(%eax),%edx
  103d14:	89 d1                	mov    %edx,%ecx
  103d16:	80 e5 df             	and    $0xdf,%ch
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  103d19:	81 e2 00 c0 03 00    	and    $0x3c000,%edx
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.flags &= ~K_PENDING;
  103d1f:	89 48 08             	mov    %ecx,0x8(%eax)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  103d22:	74 39                	je     103d5d <sem_give_common+0xff>
static ALWAYS_INLINE void
_set_thread_return_value(struct k_thread *thread, unsigned int value)
{
	/* write into 'eax' slot created in _Swap() entry */

	*(unsigned int *)(thread->callee_saved.esp) = value;
  103d24:	8b 43 08             	mov    0x8(%ebx),%eax
  103d27:	8b 40 30             	mov    0x30(%eax),%eax
  103d2a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		/* Handle the non-group case */
		_ready_thread(thread);
		_set_thread_return_value(thread, 0);
	}

	return !_is_in_isr() && _must_switch_threads();
  103d30:	83 3d c0 7d 10 00 00 	cmpl   $0x0,0x107dc0
  103d37:	75 3f                	jne    103d78 <sem_give_common+0x11a>
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
  103d39:	a1 c8 7d 10 00       	mov    0x107dc8,%eax
}

/* is thread currently preemptible ? */
static inline int _is_preempt(struct k_thread *thread)
{
	return !_is_coop(thread) && !atomic_get(&thread->base.sched_locked);
  103d3e:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
  103d42:	78 34                	js     103d78 <sem_give_common+0x11a>
 * @return Value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_get(const atomic_t *target)
{
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
  103d44:	8b 40 10             	mov    0x10(%eax),%eax
  103d47:	85 c0                	test   %eax,%eax
  103d49:	75 2d                	jne    103d78 <sem_give_common+0x11a>
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
  103d4b:	e8 b8 fd ff ff       	call   103b08 <__must_switch_threads>
  103d50:	85 c0                	test   %eax,%eax
  103d52:	0f 95 c0             	setne  %al
  103d55:	0f b6 c0             	movzbl %al,%eax
  103d58:	83 e0 01             	and    $0x1,%eax
  103d5b:	eb 1f                	jmp    103d7c <sem_give_common+0x11e>
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  103d5d:	83 78 28 ff          	cmpl   $0xffffffff,0x28(%eax)
  103d61:	75 c1                	jne    103d24 <sem_give_common+0xc6>

	if (!_is_thread_ready(desc->thread)) {
		_abort_thread_timeout(desc->thread);
		_mark_thread_as_not_pending(desc->thread);
		if (_is_thread_ready(desc->thread)) {
			_add_thread_to_ready_q(desc->thread);
  103d63:	50                   	push   %eax
  103d64:	e8 fc fb ff ff       	call   103965 <_add_thread_to_ready_q>
  103d69:	58                   	pop    %eax
  103d6a:	eb b8                	jmp    103d24 <sem_give_common+0xc6>

	_abort_thread_timeout(thread);

	if (!handle_sem_group(sem, thread)) {
		/* Handle the non-group case */
		_ready_thread(thread);
  103d6c:	89 d8                	mov    %ebx,%eax
  103d6e:	e8 c6 fe ff ff       	call   103c39 <_ready_thread>
  103d73:	8b 43 30             	mov    0x30(%ebx),%eax
  103d76:	eb b2                	jmp    103d2a <sem_give_common+0xcc>
		_set_thread_return_value(thread, 0);
	}

	return !_is_in_isr() && _must_switch_threads();
  103d78:	31 c0                	xor    %eax,%eax
  103d7a:	eb dc                	jmp    103d58 <sem_give_common+0xfa>
}
  103d7c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103d7f:	5b                   	pop    %ebx
  103d80:	5e                   	pop    %esi
  103d81:	5f                   	pop    %edi
  103d82:	5d                   	pop    %ebp
  103d83:	c3                   	ret    

00103d84 <k_sem_init>:

#endif /* CONFIG_DEBUG_TRACING_KERNEL_OBJECTS */

void k_sem_init(struct k_sem *sem, unsigned int initial_count,
		unsigned int limit)
{
  103d84:	55                   	push   %ebp
  103d85:	89 e5                	mov    %esp,%ebp
  103d87:	8b 45 08             	mov    0x8(%ebp),%eax
	__ASSERT(limit != 0, "limit cannot be zero");

	sem->count = initial_count;
  103d8a:	8b 55 0c             	mov    0xc(%ebp),%edx
  103d8d:	89 50 08             	mov    %edx,0x8(%eax)
	sem->limit = limit;
  103d90:	8b 55 10             	mov    0x10(%ebp),%edx
  103d93:	89 50 0c             	mov    %edx,0xc(%eax)
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  103d96:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
  103d98:	89 40 04             	mov    %eax,0x4(%eax)
	sys_dlist_init(&sem->wait_q);
	SYS_TRACING_OBJ_INIT(k_sem, sem);
}
  103d9b:	5d                   	pop    %ebp
  103d9c:	c3                   	ret    

00103d9d <k_sem_give>:
	irq_unlock(key);
}
#endif

void k_sem_give(struct k_sem *sem)
{
  103d9d:	55                   	push   %ebp
  103d9e:	89 e5                	mov    %esp,%ebp
  103da0:	53                   	push   %ebx
  103da1:	8b 45 08             	mov    0x8(%ebp),%eax
  103da4:	9c                   	pushf  
  103da5:	fa                   	cli    
  103da6:	5b                   	pop    %ebx
	unsigned int   key;

	key = irq_lock();

	if (sem_give_common(sem)) {
  103da7:	e8 b2 fe ff ff       	call   103c5e <sem_give_common>
  103dac:	84 c0                	test   %al,%al
  103dae:	74 0a                	je     103dba <k_sem_give+0x1d>
		_Swap(key);
  103db0:	89 5d 08             	mov    %ebx,0x8(%ebp)
	} else {
		irq_unlock(key);
	}
}
  103db3:	5b                   	pop    %ebx
  103db4:	5d                   	pop    %ebp
	unsigned int   key;

	key = irq_lock();

	if (sem_give_common(sem)) {
		_Swap(key);
  103db5:	e9 56 f6 ff ff       	jmp    103410 <_Swap>
  103dba:	80 e7 02             	and    $0x2,%bh
  103dbd:	74 01                	je     103dc0 <k_sem_give+0x23>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  103dbf:	fb                   	sti    
	} else {
		irq_unlock(key);
	}
}
  103dc0:	5b                   	pop    %ebx
  103dc1:	5d                   	pop    %ebp
  103dc2:	c3                   	ret    

00103dc3 <k_sem_take>:

int k_sem_take(struct k_sem *sem, int32_t timeout)
{
  103dc3:	55                   	push   %ebp
  103dc4:	89 e5                	mov    %esp,%ebp
  103dc6:	53                   	push   %ebx
  103dc7:	8b 55 08             	mov    0x8(%ebp),%edx
  103dca:	8b 4d 0c             	mov    0xc(%ebp),%ecx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  103dcd:	9c                   	pushf  
  103dce:	fa                   	cli    
  103dcf:	5b                   	pop    %ebx
	__ASSERT(!_is_in_isr() || timeout == K_NO_WAIT, "");

	unsigned int key = irq_lock();

	if (likely(sem->count > 0)) {
  103dd0:	8b 42 08             	mov    0x8(%edx),%eax
  103dd3:	85 c0                	test   %eax,%eax
  103dd5:	74 08                	je     103ddf <k_sem_take+0x1c>
		sem->count--;
  103dd7:	48                   	dec    %eax
  103dd8:	89 42 08             	mov    %eax,0x8(%edx)
		irq_unlock(key);
		return 0;
  103ddb:	31 c0                	xor    %eax,%eax
  103ddd:	eb 09                	jmp    103de8 <k_sem_take+0x25>
	}

	if (timeout == K_NO_WAIT) {
  103ddf:	85 c9                	test   %ecx,%ecx
  103de1:	75 0d                	jne    103df0 <k_sem_take+0x2d>
		irq_unlock(key);
		return -EBUSY;
  103de3:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  103de8:	80 e7 02             	and    $0x2,%bh
  103deb:	74 18                	je     103e05 <k_sem_take+0x42>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  103ded:	fb                   	sti    
  103dee:	eb 15                	jmp    103e05 <k_sem_take+0x42>
	}

	_pend_current_thread(&sem->wait_q, timeout);
  103df0:	51                   	push   %ecx
  103df1:	52                   	push   %edx
  103df2:	e8 cd fc ff ff       	call   103ac4 <_pend_current_thread>

	return _Swap(key);
  103df7:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
  103dfa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	if (timeout == K_NO_WAIT) {
		irq_unlock(key);
		return -EBUSY;
	}

	_pend_current_thread(&sem->wait_q, timeout);
  103dfd:	58                   	pop    %eax
  103dfe:	5a                   	pop    %edx

	return _Swap(key);
}
  103dff:	c9                   	leave  
		return -EBUSY;
	}

	_pend_current_thread(&sem->wait_q, timeout);

	return _Swap(key);
  103e00:	e9 0b f6 ff ff       	jmp    103410 <_Swap>
}
  103e05:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  103e08:	c9                   	leave  
  103e09:	c3                   	ret    

00103e0a <_nano_sys_clock_tick_announce>:
 * timers that have expired and wake up the fibers pending on them.
 *
 * @return N/A
 */
void _nano_sys_clock_tick_announce(int32_t ticks)
{
  103e0a:	55                   	push   %ebp
  103e0b:	89 e5                	mov    %esp,%ebp
  103e0d:	57                   	push   %edi
  103e0e:	56                   	push   %esi
  103e0f:	53                   	push   %ebx
  103e10:	51                   	push   %ecx
  103e11:	8b 5d 08             	mov    0x8(%ebp),%ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  103e14:	9c                   	pushf  
  103e15:	fa                   	cli    
  103e16:	8f 45 f0             	popl   -0x10(%ebp)
	unsigned int  key;

	K_DEBUG("ticks: %d\n", ticks);

	key = irq_lock();
	_sys_clock_tick_count += ticks;
  103e19:	89 d8                	mov    %ebx,%eax
  103e1b:	99                   	cltd   
  103e1c:	01 1d 58 7f 10 00    	add    %ebx,0x107f58
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  103e22:	a1 cc 7d 10 00       	mov    0x107dcc,%eax
  103e27:	11 15 5c 7f 10 00    	adc    %edx,0x107f5c
		(struct _timeout *)sys_dlist_peek_head(&_timeout_q);

	K_DEBUG("head: %p, delta: %d\n",
		head, head ? head->delta_ticks_from_prev : -2112);

	if (head) {
  103e2d:	3d cc 7d 10 00       	cmp    $0x107dcc,%eax
  103e32:	74 04                	je     103e38 <_nano_sys_clock_tick_announce+0x2e>
  103e34:	85 c0                	test   %eax,%eax
  103e36:	75 13                	jne    103e4b <_nano_sys_clock_tick_announce+0x41>
int32_t _time_slice_duration = CONFIG_TIMESLICE_SIZE;
int  _time_slice_prio_ceiling = CONFIG_TIMESLICE_PRIORITY;

static void handle_time_slicing(int32_t ticks)
{
	if (_time_slice_duration == 0) {
  103e38:	8b 35 e0 7e 10 00    	mov    0x107ee0,%esi
  103e3e:	85 f6                	test   %esi,%esi
  103e40:	0f 85 a0 00 00 00    	jne    103ee6 <_nano_sys_clock_tick_announce+0xdc>
  103e46:	e9 eb 00 00 00       	jmp    103f36 <_nano_sys_clock_tick_announce+0x12c>

	K_DEBUG("head: %p, delta: %d\n",
		head, head ? head->delta_ticks_from_prev : -2112);

	if (head) {
		head->delta_ticks_from_prev -= ticks;
  103e4b:	29 58 10             	sub    %ebx,0x10(%eax)
{
	sys_dlist_t *timeout_q = &_timeout_q;
	struct _timeout *next;

	next = (struct _timeout *)sys_dlist_peek_head(timeout_q);
	while (next && next->delta_ticks_from_prev == 0) {
  103e4e:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  103e52:	75 e4                	jne    103e38 <_nano_sys_clock_tick_announce+0x2e>
  103e54:	8b 15 cc 7d 10 00    	mov    0x107dcc,%edx

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node;

	if (sys_dlist_is_empty(list)) {
  103e5a:	81 fa cc 7d 10 00    	cmp    $0x107dcc,%edx
  103e60:	0f 84 e7 00 00 00    	je     103f4d <_nano_sys_clock_tick_announce+0x143>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  103e66:	8b 42 04             	mov    0x4(%edx),%eax
  103e69:	8b 0a                	mov    (%edx),%ecx
  103e6b:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
  103e6d:	8b 0a                	mov    (%edx),%ecx
  103e6f:	89 41 04             	mov    %eax,0x4(%ecx)
	sys_dlist_t *timeout_q)
{
	struct _timeout *t = (void *)sys_dlist_get(timeout_q);
	struct k_thread *thread = t->thread;

	t->delta_ticks_from_prev = -1;
  103e72:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edx)

static inline struct _timeout *_handle_one_timeout(
	sys_dlist_t *timeout_q)
{
	struct _timeout *t = (void *)sys_dlist_get(timeout_q);
	struct k_thread *thread = t->thread;
  103e79:	8b 42 08             	mov    0x8(%edx),%eax

	t->delta_ticks_from_prev = -1;

	K_DEBUG("timeout %p\n", t);
	if (thread != NULL) {
  103e7c:	85 c0                	test   %eax,%eax
  103e7e:	74 3e                	je     103ebe <_nano_sys_clock_tick_announce+0xb4>
/* remove a thread timing out from kernel object's wait queue */

static inline void _unpend_thread_timing_out(struct k_thread *thread,
					     struct _timeout *timeout_obj)
{
	if (timeout_obj->wait_q) {
  103e80:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
  103e84:	74 1a                	je     103ea0 <_nano_sys_clock_tick_announce+0x96>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  103e86:	8b 50 04             	mov    0x4(%eax),%edx
  103e89:	8b 08                	mov    (%eax),%ecx
  103e8b:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  103e8d:	8b 08                	mov    (%eax),%ecx
  103e8f:	89 51 04             	mov    %edx,0x4(%ecx)
		_unpend_thread(thread);
		thread->base.timeout.wait_q = NULL;
  103e92:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.flags &= ~K_PENDING;
  103e99:	81 60 08 ff df ff ff 	andl   $0xffffdfff,0x8(%eax)
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.flags &= ~K_PRESTART;
  103ea0:	8b 50 08             	mov    0x8(%eax),%edx
  103ea3:	89 d1                	mov    %edx,%ecx
  103ea5:	80 e5 bf             	and    $0xbf,%ch
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  103ea8:	81 e2 00 a0 03 00    	and    $0x3a000,%edx
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.flags &= ~K_PRESTART;
  103eae:	89 48 08             	mov    %ecx,0x8(%eax)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  103eb1:	75 16                	jne    103ec9 <_nano_sys_clock_tick_announce+0xbf>
  103eb3:	83 78 28 ff          	cmpl   $0xffffffff,0x28(%eax)
  103eb7:	75 10                	jne    103ec9 <_nano_sys_clock_tick_announce+0xbf>
  103eb9:	e9 84 00 00 00       	jmp    103f42 <_nano_sys_clock_tick_announce+0x138>

	K_DEBUG("timeout %p\n", t);
	if (thread != NULL) {
		_unpend_thread_timing_out(thread, t);
		_ready_thread(thread);
	} else if (t->func) {
  103ebe:	8b 42 14             	mov    0x14(%edx),%eax
  103ec1:	85 c0                	test   %eax,%eax
  103ec3:	74 04                	je     103ec9 <_nano_sys_clock_tick_announce+0xbf>
		t->func(t);
  103ec5:	52                   	push   %edx
  103ec6:	ff d0                	call   *%eax
  103ec8:	5a                   	pop    %edx
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  103ec9:	a1 cc 7d 10 00       	mov    0x107dcc,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  103ece:	3d cc 7d 10 00       	cmp    $0x107dcc,%eax
  103ed3:	0f 84 5f ff ff ff    	je     103e38 <_nano_sys_clock_tick_announce+0x2e>
{
	sys_dlist_t *timeout_q = &_timeout_q;
	struct _timeout *next;

	next = (struct _timeout *)sys_dlist_peek_head(timeout_q);
	while (next && next->delta_ticks_from_prev == 0) {
  103ed9:	85 c0                	test   %eax,%eax
  103edb:	0f 85 6d ff ff ff    	jne    103e4e <_nano_sys_clock_tick_announce+0x44>
  103ee1:	e9 52 ff ff ff       	jmp    103e38 <_nano_sys_clock_tick_announce+0x2e>
{
	if (_time_slice_duration == 0) {
		return;
	}

	if (_is_prio_higher(_current->base.prio, _time_slice_prio_ceiling)) {
  103ee6:	8b 3d c8 7d 10 00    	mov    0x107dc8,%edi
  103eec:	8b 47 0c             	mov    0xc(%edi),%eax
  103eef:	39 05 dc 7e 10 00    	cmp    %eax,0x107edc
  103ef5:	7f 3f                	jg     103f36 <_nano_sys_clock_tick_announce+0x12c>

#define kpriority_t uint32_t

static inline int32_t _ticks_to_ms(int32_t ticks)
{
	return (ticks == TICKS_UNLIMITED) ? K_FOREVER : __ticks_to_ms(ticks);
  103ef7:	83 c8 ff             	or     $0xffffffff,%eax
  103efa:	83 fb ff             	cmp    $0xffffffff,%ebx
  103efd:	74 15                	je     103f14 <_nano_sys_clock_tick_announce+0x10a>
  103eff:	b8 e8 03 00 00       	mov    $0x3e8,%eax
  103f04:	6a 00                	push   $0x0
  103f06:	f7 eb                	imul   %ebx
  103f08:	6a 64                	push   $0x64
  103f0a:	52                   	push   %edx
  103f0b:	50                   	push   %eax
  103f0c:	e8 2f c3 ff ff       	call   100240 <__udivdi3>
  103f11:	83 c4 10             	add    $0x10,%esp
		return;
	}

	_time_slice_elapsed += _ticks_to_ms(ticks);
  103f14:	03 05 50 7f 10 00    	add    0x107f50,%eax
	if (_time_slice_elapsed >= _time_slice_duration) {
  103f1a:	39 c6                	cmp    %eax,%esi
  103f1c:	7e 07                	jle    103f25 <_nano_sys_clock_tick_announce+0x11b>

	if (_is_prio_higher(_current->base.prio, _time_slice_prio_ceiling)) {
		return;
	}

	_time_slice_elapsed += _ticks_to_ms(ticks);
  103f1e:	a3 50 7f 10 00       	mov    %eax,0x107f50
  103f23:	eb 11                	jmp    103f36 <_nano_sys_clock_tick_announce+0x12c>
	if (_time_slice_elapsed >= _time_slice_duration) {
		_time_slice_elapsed = 0;
		_move_thread_to_end_of_prio_q(_current);
  103f25:	57                   	push   %edi
		return;
	}

	_time_slice_elapsed += _ticks_to_ms(ticks);
	if (_time_slice_elapsed >= _time_slice_duration) {
		_time_slice_elapsed = 0;
  103f26:	c7 05 50 7f 10 00 00 	movl   $0x0,0x107f50
  103f2d:	00 00 00 
		_move_thread_to_end_of_prio_q(_current);
  103f30:	e8 4d fc ff ff       	call   103b82 <_move_thread_to_end_of_prio_q>
  103f35:	58                   	pop    %eax
  103f36:	f7 45 f0 00 02 00 00 	testl  $0x200,-0x10(%ebp)
  103f3d:	74 15                	je     103f54 <_nano_sys_clock_tick_announce+0x14a>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  103f3f:	fb                   	sti    
	handle_expired_timeouts(ticks);

	handle_time_slicing(ticks);

	irq_unlock(key);
}
  103f40:	eb 12                	jmp    103f54 <_nano_sys_clock_tick_announce+0x14a>

	/* needed to handle the start-with-delay case */
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
		_add_thread_to_ready_q(thread);
  103f42:	50                   	push   %eax
  103f43:	e8 1d fa ff ff       	call   103965 <_add_thread_to_ready_q>
  103f48:	e9 7b ff ff ff       	jmp    103ec8 <_nano_sys_clock_tick_announce+0xbe>

static inline struct _timeout *_handle_one_timeout(
	sys_dlist_t *timeout_q)
{
	struct _timeout *t = (void *)sys_dlist_get(timeout_q);
	struct k_thread *thread = t->thread;
  103f4d:	a1 08 00 00 00       	mov    0x8,%eax
  103f52:	0f 0b                	ud2    
  103f54:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103f57:	5b                   	pop    %ebx
  103f58:	5e                   	pop    %esi
  103f59:	5f                   	pop    %edi
  103f5a:	5d                   	pop    %ebp
  103f5b:	c3                   	ret    

00103f5c <_is_thread_ready>:

}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
  103f5c:	55                   	push   %ebp
  103f5d:	89 e5                	mov    %esp,%ebp
	return !(_is_thread_prevented_from_running(thread) ||
  103f5f:	f7 40 08 00 e0 03 00 	testl  $0x3e000,0x8(%eax)
  103f66:	75 0c                	jne    103f74 <_is_thread_ready+0x18>
  103f68:	83 78 28 ff          	cmpl   $0xffffffff,0x28(%eax)
  103f6c:	0f 94 c0             	sete   %al
  103f6f:	0f b6 c0             	movzbl %al,%eax
  103f72:	eb 02                	jmp    103f76 <_is_thread_ready+0x1a>
  103f74:	31 c0                	xor    %eax,%eax
		 _is_thread_timeout_active(thread));
}
  103f76:	5d                   	pop    %ebp
  103f77:	c3                   	ret    

00103f78 <_k_thread_single_start>:
	_sched_unlock_no_reschedule();
	_Swap(key);
}

void _k_thread_single_start(struct k_thread *thread)
{
  103f78:	55                   	push   %ebp
  103f79:	89 e5                	mov    %esp,%ebp
  103f7b:	8b 55 08             	mov    0x8(%ebp),%edx
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
  103f7e:	89 d0                	mov    %edx,%eax
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.flags &= ~K_PRESTART;
  103f80:	81 62 08 ff bf ff ff 	andl   $0xffffbfff,0x8(%edx)
  103f87:	e8 d0 ff ff ff       	call   103f5c <_is_thread_ready>
  103f8c:	85 c0                	test   %eax,%eax
  103f8e:	74 09                	je     103f99 <_k_thread_single_start+0x21>
		_add_thread_to_ready_q(thread);
  103f90:	89 55 08             	mov    %edx,0x8(%ebp)
	}
}
  103f93:	5d                   	pop    %ebp
void _k_thread_single_start(struct k_thread *thread)
{
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
		_add_thread_to_ready_q(thread);
  103f94:	e9 cc f9 ff ff       	jmp    103965 <_add_thread_to_ready_q>
	}
}
  103f99:	5d                   	pop    %ebp
  103f9a:	c3                   	ret    

00103f9b <start_thread>:

	CODE_UNREACHABLE;
}

static void start_thread(struct k_thread *thread)
{
  103f9b:	55                   	push   %ebp
  103f9c:	89 c2                	mov    %eax,%edx
  103f9e:	89 e5                	mov    %esp,%ebp
  103fa0:	53                   	push   %ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  103fa1:	9c                   	pushf  
  103fa2:	fa                   	cli    
  103fa3:	5b                   	pop    %ebx
  103fa4:	81 60 08 ff bf ff ff 	andl   $0xffffbfff,0x8(%eax)
	int key = irq_lock(); /* protect kernel queues */

	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
  103fab:	e8 ac ff ff ff       	call   103f5c <_is_thread_ready>
  103fb0:	85 c0                	test   %eax,%eax
  103fb2:	74 2b                	je     103fdf <start_thread+0x44>
		_add_thread_to_ready_q(thread);
  103fb4:	52                   	push   %edx
  103fb5:	e8 ab f9 ff ff       	call   103965 <_add_thread_to_ready_q>
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
  103fba:	a1 c8 7d 10 00       	mov    0x107dc8,%eax
  103fbf:	5a                   	pop    %edx
}

/* is thread currently preemptible ? */
static inline int _is_preempt(struct k_thread *thread)
{
	return !_is_coop(thread) && !atomic_get(&thread->base.sched_locked);
  103fc0:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
  103fc4:	78 19                	js     103fdf <start_thread+0x44>
  103fc6:	8b 40 10             	mov    0x10(%eax),%eax
  103fc9:	85 c0                	test   %eax,%eax
  103fcb:	75 12                	jne    103fdf <start_thread+0x44>
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
  103fcd:	e8 36 fb ff ff       	call   103b08 <__must_switch_threads>
  103fd2:	85 c0                	test   %eax,%eax
  103fd4:	74 09                	je     103fdf <start_thread+0x44>
		if (_must_switch_threads()) {
			_Swap(key);
  103fd6:	53                   	push   %ebx
  103fd7:	e8 34 f4 ff ff       	call   103410 <_Swap>
  103fdc:	58                   	pop    %eax
			return;
  103fdd:	eb 06                	jmp    103fe5 <start_thread+0x4a>
  103fdf:	80 e7 02             	and    $0x2,%bh
  103fe2:	74 01                	je     103fe5 <start_thread+0x4a>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  103fe4:	fb                   	sti    
		}
	}

	irq_unlock(key);
}
  103fe5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  103fe8:	c9                   	leave  
  103fe9:	c3                   	ret    

00103fea <_abort_timeout>:
}

/* returns 0 in success and -1 if the timer has expired */

static inline int _abort_timeout(struct _timeout *t)
{
  103fea:	55                   	push   %ebp
  103feb:	89 c2                	mov    %eax,%edx
	sys_dlist_t *timeout_q = &_timeout_q;

	if (-1 == t->delta_ticks_from_prev) {
  103fed:	8b 40 10             	mov    0x10(%eax),%eax
}

/* returns 0 in success and -1 if the timer has expired */

static inline int _abort_timeout(struct _timeout *t)
{
  103ff0:	89 e5                	mov    %esp,%ebp
	sys_dlist_t *timeout_q = &_timeout_q;

	if (-1 == t->delta_ticks_from_prev) {
  103ff2:	83 f8 ff             	cmp    $0xffffffff,%eax
  103ff5:	74 22                	je     104019 <_abort_timeout+0x2f>
		return -1;
	}

	if (!sys_dlist_is_tail(timeout_q, &t->node)) {
  103ff7:	3b 15 d0 7d 10 00    	cmp    0x107dd0,%edx
  103ffd:	74 05                	je     104004 <_abort_timeout+0x1a>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (!node || node == list->tail) ? NULL : node->next;
  103fff:	8b 0a                	mov    (%edx),%ecx
		struct _timeout *next =
			(struct _timeout *)sys_dlist_peek_next(timeout_q,
								    &t->node);
		next->delta_ticks_from_prev += t->delta_ticks_from_prev;
  104001:	01 41 10             	add    %eax,0x10(%ecx)
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  104004:	8b 42 04             	mov    0x4(%edx),%eax
  104007:	8b 0a                	mov    (%edx),%ecx
  104009:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
  10400b:	8b 0a                	mov    (%edx),%ecx
  10400d:	89 41 04             	mov    %eax,0x4(%ecx)
	}
	sys_dlist_remove(&t->node);
	t->delta_ticks_from_prev = -1;
  104010:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edx)

	return 0;
  104017:	31 c0                	xor    %eax,%eax
}
  104019:	5d                   	pop    %ebp
  10401a:	c3                   	ret    

0010401b <_sched_lock>:
 * Must be kept in sync until the header files are cleaned-up and the
 * applications have access to the kernel internal deta structures (through
 * APIs of course).
 */
static inline void _sched_lock(void)
{
  10401b:	55                   	push   %ebp
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  10401c:	a1 c8 7d 10 00       	mov    0x107dc8,%eax
  104021:	89 e5                	mov    %esp,%ebp
  104023:	f0 ff 40 10          	lock incl 0x10(%eax)

	atomic_inc(&_current->base.sched_locked);

	K_DEBUG("scheduler locked (%p:%d)\n",
		_current, _current->base.sched_locked);
}
  104027:	5d                   	pop    %ebp
  104028:	c3                   	ret    

00104029 <schedule_new_thread.part.13>:

static void schedule_new_thread(struct k_thread *thread, int32_t delay)
  104029:	55                   	push   %ebp
  10402a:	89 e5                	mov    %esp,%ebp
  10402c:	57                   	push   %edi
  10402d:	56                   	push   %esi
  10402e:	53                   	push   %ebx
  10402f:	89 c3                	mov    %eax,%ebx
{
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (delay == 0) {
		start_thread(thread);
	} else {
		int32_t ticks = _TICK_ALIGN + _ms_to_ticks(delay);
  104031:	52                   	push   %edx
  104032:	e8 e9 f9 ff ff       	call   103a20 <_ms_to_ticks>
  104037:	5a                   	pop    %edx

	K_DEBUG("timeout   %p before: next: %p, prev: %p\n",
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
	timeout_obj->delta_ticks_from_prev = timeout;
  104038:	40                   	inc    %eax
 */

static inline void _add_thread_timeout(struct k_thread *thread,
				       _wait_q_t *wait_q, int32_t timeout)
{
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout);
  104039:	8d 53 18             	lea    0x18(%ebx),%edx

	K_DEBUG("timeout   %p before: next: %p, prev: %p\n",
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
	timeout_obj->delta_ticks_from_prev = timeout;
  10403c:	89 43 28             	mov    %eax,0x28(%ebx)
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  10403f:	a1 cc 7d 10 00       	mov    0x107dcc,%eax
		_timeout_q.tail);

	K_DEBUG("timeout   %p before: next: %p, prev: %p\n",
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
  104044:	89 5b 20             	mov    %ebx,0x20(%ebx)
	timeout_obj->delta_ticks_from_prev = timeout;
	timeout_obj->wait_q = (sys_dlist_t *)wait_q;
  104047:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (!node || node == list->tail) ? NULL : node->next;
  10404e:	8b 3d d0 7d 10 00    	mov    0x107dd0,%edi
 */

static inline void sys_dlist_insert_at(sys_dlist_t *list, sys_dnode_t *node,
	int (*cond)(sys_dnode_t *, void *), void *data)
{
	if (sys_dlist_is_empty(list)) {
  104054:	3d cc 7d 10 00       	cmp    $0x107dcc,%eax
  104059:	74 33                	je     10408e <schedule_new_thread.part.13+0x65>
		sys_dlist_append(list, node);
	} else {
		sys_dnode_t *pos = sys_dlist_peek_head(list);

		while (pos && !cond(pos, data)) {
  10405b:	85 c0                	test   %eax,%eax
  10405d:	74 2f                	je     10408e <schedule_new_thread.part.13+0x65>
static int _is_timeout_insert_point(sys_dnode_t *test, void *timeout)
{
	struct _timeout *t = (void *)test;
	int32_t *timeout_to_insert = timeout;

	if (*timeout_to_insert > t->delta_ticks_from_prev) {
  10405f:	8b 73 28             	mov    0x28(%ebx),%esi
  104062:	8b 48 10             	mov    0x10(%eax),%ecx
  104065:	39 ce                	cmp    %ecx,%esi
  104067:	7e 0d                	jle    104076 <schedule_new_thread.part.13+0x4d>
		*timeout_to_insert -= t->delta_ticks_from_prev;
  104069:	29 ce                	sub    %ecx,%esi
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (!node || node == list->tail) ? NULL : node->next;
  10406b:	39 f8                	cmp    %edi,%eax
  10406d:	89 73 28             	mov    %esi,0x28(%ebx)
  104070:	74 1c                	je     10408e <schedule_new_thread.part.13+0x65>
  104072:	8b 00                	mov    (%eax),%eax
  104074:	eb e5                	jmp    10405b <schedule_new_thread.part.13+0x32>
		return 0;
	}

	t->delta_ticks_from_prev -= *timeout_to_insert;
  104076:	29 f1                	sub    %esi,%ecx
  104078:	89 48 10             	mov    %ecx,0x10(%eax)
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  10407b:	8b 48 04             	mov    0x4(%eax),%ecx
  10407e:	89 4b 1c             	mov    %ecx,0x1c(%ebx)
		node->next = insert_point;
  104081:	89 43 18             	mov    %eax,0x18(%ebx)
		insert_point->prev->next = node;
  104084:	8b 48 04             	mov    0x4(%eax),%ecx
  104087:	89 11                	mov    %edx,(%ecx)
		insert_point->prev = node;
  104089:	89 50 04             	mov    %edx,0x4(%eax)
  10408c:	eb 17                	jmp    1040a5 <schedule_new_thread.part.13+0x7c>
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
	node->prev = list->tail;
  10408e:	a1 d0 7d 10 00       	mov    0x107dd0,%eax
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  104093:	c7 43 18 cc 7d 10 00 	movl   $0x107dcc,0x18(%ebx)
	node->prev = list->tail;
  10409a:	89 43 1c             	mov    %eax,0x1c(%ebx)

	list->tail->next = node;
  10409d:	89 10                	mov    %edx,(%eax)
	list->tail = node;
  10409f:	89 15 d0 7d 10 00    	mov    %edx,0x107dd0
	}
#else
	ARG_UNUSED(delay);
	start_thread(thread);
#endif
}
  1040a5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1040a8:	5b                   	pop    %ebx
  1040a9:	5e                   	pop    %esi
  1040aa:	5f                   	pop    %edi
  1040ab:	5d                   	pop    %ebp
  1040ac:	c3                   	ret    

001040ad <k_is_in_isr>:

	return NANO_CTX_TASK;
}

int k_is_in_isr(void)
{
  1040ad:	55                   	push   %ebp
	return _is_in_isr();
  1040ae:	31 c0                	xor    %eax,%eax

	return NANO_CTX_TASK;
}

int k_is_in_isr(void)
{
  1040b0:	89 e5                	mov    %esp,%ebp
	return _is_in_isr();
}
  1040b2:	5d                   	pop    %ebp
	return NANO_CTX_TASK;
}

int k_is_in_isr(void)
{
	return _is_in_isr();
  1040b3:	83 3d c0 7d 10 00 00 	cmpl   $0x0,0x107dc0
  1040ba:	0f 95 c0             	setne  %al
}
  1040bd:	c3                   	ret    

001040be <_is_thread_essential>:
 *
 * Returns non-zero if current thread is essential, zero if it is not.
 */
int _is_thread_essential(void)
{
	return _current->base.flags & K_ESSENTIAL;
  1040be:	a1 c8 7d 10 00       	mov    0x107dc8,%eax
 * This routine indicates if the current thread is an essential system thread.
 *
 * Returns non-zero if current thread is essential, zero if it is not.
 */
int _is_thread_essential(void)
{
  1040c3:	55                   	push   %ebp
  1040c4:	89 e5                	mov    %esp,%ebp
	return _current->base.flags & K_ESSENTIAL;
}
  1040c6:	5d                   	pop    %ebp
 *
 * Returns non-zero if current thread is essential, zero if it is not.
 */
int _is_thread_essential(void)
{
	return _current->base.flags & K_ESSENTIAL;
  1040c7:	8b 40 08             	mov    0x8(%eax),%eax
  1040ca:	25 00 02 00 00       	and    $0x200,%eax
}
  1040cf:	c3                   	ret    

001040d0 <_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void _thread_entry(void (*entry)(void *, void *, void *),
				 void *p1, void *p2, void *p3)
{
  1040d0:	55                   	push   %ebp
  1040d1:	89 e5                	mov    %esp,%ebp
	entry(p1, p2, p3);
  1040d3:	ff 75 14             	pushl  0x14(%ebp)
  1040d6:	ff 75 10             	pushl  0x10(%ebp)
  1040d9:	ff 75 0c             	pushl  0xc(%ebp)
  1040dc:	ff 55 08             	call   *0x8(%ebp)
  1040df:	83 c4 0c             	add    $0xc,%esp

	if (_is_thread_essential()) {
  1040e2:	e8 d7 ff ff ff       	call   1040be <_is_thread_essential>
  1040e7:	85 c0                	test   %eax,%eax
  1040e9:	74 0c                	je     1040f7 <_thread_entry+0x27>
		_NanoFatalErrorHandler(_NANO_ERR_INVALID_TASK_EXIT,
  1040eb:	68 80 65 10 00       	push   $0x106580
  1040f0:	6a 03                	push   $0x3
  1040f2:	e8 b2 f3 ff ff       	call   1034a9 <_NanoFatalErrorHandler>
				       &_default_esf);
	}

	k_thread_abort(_current);
  1040f7:	ff 35 c8 7d 10 00    	pushl  0x107dc8
  1040fd:	e8 de 01 00 00       	call   1042e0 <k_thread_abort>
  104102:	58                   	pop    %eax

00104103 <k_thread_spawn>:

k_tid_t k_thread_spawn(char *stack, size_t stack_size,
			void (*entry)(void *, void *, void*),
			void *p1, void *p2, void *p3,
			int prio, uint32_t options, int32_t delay)
{
  104103:	55                   	push   %ebp
  104104:	89 e5                	mov    %esp,%ebp
  104106:	56                   	push   %esi
  104107:	53                   	push   %ebx
	__ASSERT(!_is_in_isr(), "");

	struct k_thread *new_thread = (struct k_thread *)stack;

	_new_thread(stack, stack_size, entry, p1, p2, p3, prio, options);
  104108:	ff 75 24             	pushl  0x24(%ebp)
  10410b:	ff 75 20             	pushl  0x20(%ebp)
  10410e:	ff 75 1c             	pushl  0x1c(%ebp)
  104111:	ff 75 18             	pushl  0x18(%ebp)
  104114:	ff 75 14             	pushl  0x14(%ebp)
  104117:	ff 75 10             	pushl  0x10(%ebp)
  10411a:	ff 75 0c             	pushl  0xc(%ebp)

k_tid_t k_thread_spawn(char *stack, size_t stack_size,
			void (*entry)(void *, void *, void*),
			void *p1, void *p2, void *p3,
			int prio, uint32_t options, int32_t delay)
{
  10411d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  104120:	8b 75 28             	mov    0x28(%ebp),%esi
	__ASSERT(!_is_in_isr(), "");

	struct k_thread *new_thread = (struct k_thread *)stack;

	_new_thread(stack, stack_size, entry, p1, p2, p3, prio, options);
  104123:	53                   	push   %ebx
  104124:	e8 12 f3 ff ff       	call   10343b <_new_thread>
  104129:	83 c4 20             	add    $0x20,%esp
}

static void schedule_new_thread(struct k_thread *thread, int32_t delay)
{
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (delay == 0) {
  10412c:	85 f6                	test   %esi,%esi
  10412e:	75 09                	jne    104139 <k_thread_spawn+0x36>
		start_thread(thread);
  104130:	89 d8                	mov    %ebx,%eax
  104132:	e8 64 fe ff ff       	call   103f9b <start_thread>
  104137:	eb 09                	jmp    104142 <k_thread_spawn+0x3f>
  104139:	89 f2                	mov    %esi,%edx
  10413b:	89 d8                	mov    %ebx,%eax
  10413d:	e8 e7 fe ff ff       	call   104029 <schedule_new_thread.part.13>
	_new_thread(stack, stack_size, entry, p1, p2, p3, prio, options);

	schedule_new_thread(new_thread, delay);

	return new_thread;
}
  104142:	8d 65 f8             	lea    -0x8(%ebp),%esp
  104145:	89 d8                	mov    %ebx,%eax
  104147:	5b                   	pop    %ebx
  104148:	5e                   	pop    %esi
  104149:	5d                   	pop    %ebp
  10414a:	c3                   	ret    

0010414b <_k_thread_group_op>:
{
	return !!(thread_data->init_groups & groups);
}

void _k_thread_group_op(uint32_t groups, void (*func)(struct k_thread *))
{
  10414b:	55                   	push   %ebp
  10414c:	89 e5                	mov    %esp,%ebp
  10414e:	57                   	push   %edi
  10414f:	56                   	push   %esi
  104150:	53                   	push   %ebx
  104151:	52                   	push   %edx

	_sched_lock();

	/* Invoke func() on each static thread in the specified group set. */

	_FOREACH_STATIC_THREAD(thread_data) {
  104152:	bf 80 72 10 00       	mov    $0x107280,%edi
{
	return !!(thread_data->init_groups & groups);
}

void _k_thread_group_op(uint32_t groups, void (*func)(struct k_thread *))
{
  104157:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10415a:	8b 75 0c             	mov    0xc(%ebp),%esi
	unsigned int  key;

	__ASSERT(!_is_in_isr(), "");

	_sched_lock();
  10415d:	e8 b9 fe ff ff       	call   10401b <_sched_lock>

	/* Invoke func() on each static thread in the specified group set. */

	_FOREACH_STATIC_THREAD(thread_data) {
  104162:	81 ff 80 72 10 00    	cmp    $0x107280,%edi
  104168:	73 1e                	jae    104188 <_k_thread_group_op+0x3d>
		if (is_in_any_group(thread_data, groups)) {
  10416a:	85 5f 28             	test   %ebx,0x28(%edi)
  10416d:	74 14                	je     104183 <_k_thread_group_op+0x38>

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  10416f:	9c                   	pushf  
  104170:	fa                   	cli    
  104171:	8f 45 f0             	popl   -0x10(%ebp)
			key = irq_lock();
			func(thread_data->thread);
  104174:	ff 37                	pushl  (%edi)
  104176:	ff d6                	call   *%esi
  104178:	58                   	pop    %eax
  104179:	f7 45 f0 00 02 00 00 	testl  $0x200,-0x10(%ebp)
  104180:	74 01                	je     104183 <_k_thread_group_op+0x38>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  104182:	fb                   	sti    

	_sched_lock();

	/* Invoke func() on each static thread in the specified group set. */

	_FOREACH_STATIC_THREAD(thread_data) {
  104183:	83 c7 2c             	add    $0x2c,%edi
  104186:	eb da                	jmp    104162 <_k_thread_group_op+0x17>

	/*
	 * If the current thread is still in a ready state, then let the
	 * "unlock scheduler" code determine if any rescheduling is needed.
	 */
	if (_is_thread_ready(_current)) {
  104188:	a1 c8 7d 10 00       	mov    0x107dc8,%eax
  10418d:	e8 ca fd ff ff       	call   103f5c <_is_thread_ready>
  104192:	85 c0                	test   %eax,%eax
  104194:	74 0c                	je     1041a2 <_k_thread_group_op+0x57>

	/* The current thread is no longer in a ready state--reschedule. */
	key = irq_lock();
	_sched_unlock_no_reschedule();
	_Swap(key);
}
  104196:	8d 65 f4             	lea    -0xc(%ebp),%esp
  104199:	5b                   	pop    %ebx
  10419a:	5e                   	pop    %esi
  10419b:	5f                   	pop    %edi
  10419c:	5d                   	pop    %ebp
	/*
	 * If the current thread is still in a ready state, then let the
	 * "unlock scheduler" code determine if any rescheduling is needed.
	 */
	if (_is_thread_ready(_current)) {
		k_sched_unlock();
  10419d:	e9 b2 f9 ff ff       	jmp    103b54 <k_sched_unlock>

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1041a2:	9c                   	pushf  
  1041a3:	fa                   	cli    
  1041a4:	5a                   	pop    %edx
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
  1041a5:	a1 c8 7d 10 00       	mov    0x107dc8,%eax
  1041aa:	f0 ff 48 10          	lock decl 0x10(%eax)
	}

	/* The current thread is no longer in a ready state--reschedule. */
	key = irq_lock();
	_sched_unlock_no_reschedule();
	_Swap(key);
  1041ae:	89 55 08             	mov    %edx,0x8(%ebp)
}
  1041b1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1041b4:	5b                   	pop    %ebx
  1041b5:	5e                   	pop    %esi
  1041b6:	5f                   	pop    %edi
  1041b7:	5d                   	pop    %ebp
	}

	/* The current thread is no longer in a ready state--reschedule. */
	key = irq_lock();
	_sched_unlock_no_reschedule();
	_Swap(key);
  1041b8:	e9 53 f2 ff ff       	jmp    103410 <_Swap>

001041bd <_k_thread_single_abort>:

	_reschedule_threads(key);
}

void _k_thread_single_abort(struct k_thread *thread)
{
  1041bd:	55                   	push   %ebp
  1041be:	89 e5                	mov    %esp,%ebp
  1041c0:	53                   	push   %ebx
  1041c1:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (thread->fn_abort != NULL) {
  1041c4:	8b 43 38             	mov    0x38(%ebx),%eax
  1041c7:	85 c0                	test   %eax,%eax
  1041c9:	74 02                	je     1041cd <_k_thread_single_abort+0x10>
		thread->fn_abort();
  1041cb:	ff d0                	call   *%eax
	}

	if (_is_thread_ready(thread)) {
  1041cd:	89 d8                	mov    %ebx,%eax
  1041cf:	e8 88 fd ff ff       	call   103f5c <_is_thread_ready>
  1041d4:	85 c0                	test   %eax,%eax
  1041d6:	74 09                	je     1041e1 <_k_thread_single_abort+0x24>
		_remove_thread_from_ready_q(thread);
  1041d8:	53                   	push   %ebx
  1041d9:	e8 ec f7 ff ff       	call   1039ca <_remove_thread_from_ready_q>
  1041de:	58                   	pop    %eax
  1041df:	eb 28                	jmp    104209 <_k_thread_single_abort+0x4c>
  1041e1:	8b 43 08             	mov    0x8(%ebx),%eax
	} else {
		if (_is_thread_pending(thread)) {
  1041e4:	f6 c4 20             	test   $0x20,%ah
  1041e7:	74 12                	je     1041fb <_k_thread_single_abort+0x3e>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  1041e9:	8b 53 04             	mov    0x4(%ebx),%edx
  1041ec:	8b 0b                	mov    (%ebx),%ecx
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.flags &= ~K_PENDING;
  1041ee:	80 e4 df             	and    $0xdf,%ah
  1041f1:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  1041f3:	8b 0b                	mov    (%ebx),%ecx
  1041f5:	89 51 04             	mov    %edx,0x4(%ecx)
  1041f8:	89 43 08             	mov    %eax,0x8(%ebx)
			_unpend_thread(thread);
		}
		if (_is_thread_timeout_active(thread)) {
  1041fb:	83 7b 28 ff          	cmpl   $0xffffffff,0x28(%ebx)
  1041ff:	74 08                	je     104209 <_k_thread_single_abort+0x4c>
	return 0;
}

static inline int _abort_thread_timeout(struct k_thread *thread)
{
	return _abort_timeout(&thread->base.timeout);
  104201:	8d 43 18             	lea    0x18(%ebx),%eax
  104204:	e8 e1 fd ff ff       	call   103fea <_abort_timeout>
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_dead(struct k_thread *thread)
{
	thread->base.flags |= K_DEAD;
  104209:	81 4b 08 00 80 00 00 	orl    $0x8000,0x8(%ebx)
			_abort_thread_timeout(thread);
		}
	}
	_mark_thread_as_dead(thread);
}
  104210:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  104213:	c9                   	leave  
  104214:	c3                   	ret    

00104215 <_init_static_threads>:

void _init_static_threads(void)
{
  104215:	55                   	push   %ebp
  104216:	89 e5                	mov    %esp,%ebp
  104218:	56                   	push   %esi
  104219:	53                   	push   %ebx
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
  10421a:	bb 80 72 10 00       	mov    $0x107280,%ebx
  10421f:	81 fb 80 72 10 00    	cmp    $0x107280,%ebx
  104225:	73 29                	jae    104250 <_init_static_threads+0x3b>
		_task_group_adjust(thread_data);
		_new_thread(
  104227:	ff 73 1c             	pushl  0x1c(%ebx)
  10422a:	ff 73 18             	pushl  0x18(%ebx)
  10422d:	ff 73 14             	pushl  0x14(%ebx)
  104230:	ff 73 10             	pushl  0x10(%ebx)
  104233:	ff 73 0c             	pushl  0xc(%ebx)
  104236:	ff 73 08             	pushl  0x8(%ebx)
  104239:	ff 73 04             	pushl  0x4(%ebx)
  10423c:	ff 33                	pushl  (%ebx)
  10423e:	e8 f8 f1 ff ff       	call   10343b <_new_thread>
			thread_data->init_p2,
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options);

		thread_data->thread->init_data = thread_data;
  104243:	8b 03                	mov    (%ebx),%eax
{
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
		_task_group_adjust(thread_data);
		_new_thread(
  104245:	83 c4 20             	add    $0x20,%esp
			thread_data->init_p2,
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options);

		thread_data->thread->init_data = thread_data;
  104248:	89 58 34             	mov    %ebx,0x34(%eax)

void _init_static_threads(void)
{
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
  10424b:	83 c3 2c             	add    $0x2c,%ebx
  10424e:	eb cf                	jmp    10421f <_init_static_threads+0xa>
			thread_data->init_options);

		thread_data->thread->init_data = thread_data;
	}

	_sched_lock();
  104250:	e8 c6 fd ff ff       	call   10401b <_sched_lock>
	/* Start all (legacy) threads that are part of the EXE task group */
	_k_thread_group_op(K_TASK_GROUP_EXE, _k_thread_single_start);
  104255:	68 78 3f 10 00       	push   $0x103f78
  10425a:	6a 01                	push   $0x1
  10425c:	e8 ea fe ff ff       	call   10414b <_k_thread_group_op>
  104261:	58                   	pop    %eax
  104262:	5a                   	pop    %edx
  104263:	9c                   	pushf  
  104264:	fa                   	cli    
  104265:	5e                   	pop    %esi
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
  104266:	bb 80 72 10 00       	mov    $0x107280,%ebx
  10426b:	81 fb 80 72 10 00    	cmp    $0x107280,%ebx
  104271:	73 1f                	jae    104292 <_init_static_threads+0x7d>
		if (thread_data->init_delay != K_FOREVER) {
  104273:	8b 53 20             	mov    0x20(%ebx),%edx
  104276:	83 fa ff             	cmp    $0xffffffff,%edx
  104279:	74 12                	je     10428d <_init_static_threads+0x78>
			schedule_new_thread(thread_data->thread,
  10427b:	8b 03                	mov    (%ebx),%eax
}

static void schedule_new_thread(struct k_thread *thread, int32_t delay)
{
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (delay == 0) {
  10427d:	85 d2                	test   %edx,%edx
  10427f:	75 07                	jne    104288 <_init_static_threads+0x73>
		start_thread(thread);
  104281:	e8 15 fd ff ff       	call   103f9b <start_thread>
  104286:	eb 05                	jmp    10428d <_init_static_threads+0x78>
  104288:	e8 9c fd ff ff       	call   104029 <schedule_new_thread.part.13>
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
  10428d:	83 c3 2c             	add    $0x2c,%ebx
  104290:	eb d9                	jmp    10426b <_init_static_threads+0x56>
  104292:	81 e6 00 02 00 00    	and    $0x200,%esi
  104298:	74 01                	je     10429b <_init_static_threads+0x86>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  10429a:	fb                   	sti    
					    thread_data->init_delay);
		}
	}
	irq_unlock(key);
	k_sched_unlock();
}
  10429b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10429e:	5b                   	pop    %ebx
  10429f:	5e                   	pop    %esi
  1042a0:	5d                   	pop    %ebp
			schedule_new_thread(thread_data->thread,
					    thread_data->init_delay);
		}
	}
	irq_unlock(key);
	k_sched_unlock();
  1042a1:	e9 ae f8 ff ff       	jmp    103b54 <k_sched_unlock>

001042a6 <_init_thread_base>:
}

void _init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
  1042a6:	55                   	push   %ebp
  1042a7:	89 e5                	mov    %esp,%ebp
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->flags = options | initial_state;
  1042a9:	8b 55 14             	mov    0x14(%ebp),%edx
	k_sched_unlock();
}

void _init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
  1042ac:	8b 45 08             	mov    0x8(%ebp),%eax
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->flags = options | initial_state;
  1042af:	0b 55 10             	or     0x10(%ebp),%edx
  1042b2:	89 50 08             	mov    %edx,0x8(%eax)

	thread_base->prio = priority;
  1042b5:	8b 55 0c             	mov    0xc(%ebp),%edx
  1042b8:	89 50 0c             	mov    %edx,0xc(%eax)

	thread_base->sched_locked = 0;
  1042bb:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	/*
	 * Must be initialized here and when dequeueing a timeout so that code
	 * not dealing with timeouts does not have to handle this, such as when
	 * waiting forever on a semaphore.
	 */
	t->delta_ticks_from_prev = -1;
  1042c2:	c7 40 28 ff ff ff ff 	movl   $0xffffffff,0x28(%eax)

	/*
	 * Must be initialized here so that the _fiber_wakeup family of APIs can
	 * verify the fiber is not on a wait queue before aborting a timeout.
	 */
	t->wait_q = NULL;
  1042c9:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)

	/*
	 * Must be initialized here, so the _handle_one_timeout()
	 * routine can check if there is a fiber waiting on this timeout
	 */
	t->thread = NULL;
  1042d0:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)

	/*
	 * Function must be initialized before being potentially called.
	 */
	t->func = func;
  1042d7:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)

	/* swap_data does not need to be initialized */

	_init_thread_timeout(thread_base);
}
  1042de:	5d                   	pop    %ebp
  1042df:	c3                   	ret    

001042e0 <k_thread_abort>:

extern void _k_thread_single_abort(struct k_thread *thread);

#if !defined(CONFIG_ARCH_HAS_NANO_FIBER_ABORT)
void k_thread_abort(k_tid_t thread)
{
  1042e0:	55                   	push   %ebp
  1042e1:	89 e5                	mov    %esp,%ebp
  1042e3:	56                   	push   %esi
  1042e4:	53                   	push   %ebx
  1042e5:	8b 75 08             	mov    0x8(%ebp),%esi

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1042e8:	9c                   	pushf  
  1042e9:	fa                   	cli    
  1042ea:	5b                   	pop    %ebx
	unsigned int key;

	key = irq_lock();

	_k_thread_single_abort(thread);
  1042eb:	56                   	push   %esi
  1042ec:	e8 cc fe ff ff       	call   1041bd <_k_thread_single_abort>
  1042f1:	5a                   	pop    %edx
	_thread_monitor_exit(thread);

	if (_current == thread) {
  1042f2:	3b 35 c8 7d 10 00    	cmp    0x107dc8,%esi
  1042f8:	75 07                	jne    104301 <k_thread_abort+0x21>
		_Swap(key);
  1042fa:	53                   	push   %ebx
  1042fb:	e8 10 f1 ff ff       	call   103410 <_Swap>
  104300:	58                   	pop    %eax
		CODE_UNREACHABLE;
	}

	/* The abort handler might have altered the ready queue. */
	_reschedule_threads(key);
  104301:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
  104304:	8d 65 f8             	lea    -0x8(%ebp),%esp
  104307:	5b                   	pop    %ebx
  104308:	5e                   	pop    %esi
  104309:	5d                   	pop    %ebp
		_Swap(key);
		CODE_UNREACHABLE;
	}

	/* The abort handler might have altered the ready queue. */
	_reschedule_threads(key);
  10430a:	e9 13 f8 ff ff       	jmp    103b22 <_reschedule_threads>

0010430f <_is_timeout_insert_point>:
 * the timeout of the insert point to update its delta queue value, since the
 * current timeout will be inserted before it.
 */

static int _is_timeout_insert_point(sys_dnode_t *test, void *timeout)
{
  10430f:	55                   	push   %ebp
  104310:	89 e5                	mov    %esp,%ebp
  104312:	53                   	push   %ebx
  104313:	8b 4d 08             	mov    0x8(%ebp),%ecx
  104316:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct _timeout *t = (void *)test;
	int32_t *timeout_to_insert = timeout;

	if (*timeout_to_insert > t->delta_ticks_from_prev) {
  104319:	8b 41 10             	mov    0x10(%ecx),%eax
  10431c:	8b 13                	mov    (%ebx),%edx
  10431e:	39 c2                	cmp    %eax,%edx
  104320:	7e 08                	jle    10432a <_is_timeout_insert_point+0x1b>
		*timeout_to_insert -= t->delta_ticks_from_prev;
  104322:	29 c2                	sub    %eax,%edx
		return 0;
  104324:	31 c0                	xor    %eax,%eax
{
	struct _timeout *t = (void *)test;
	int32_t *timeout_to_insert = timeout;

	if (*timeout_to_insert > t->delta_ticks_from_prev) {
		*timeout_to_insert -= t->delta_ticks_from_prev;
  104326:	89 13                	mov    %edx,(%ebx)
		return 0;
  104328:	eb 0a                	jmp    104334 <_is_timeout_insert_point+0x25>
	}

	t->delta_ticks_from_prev -= *timeout_to_insert;
  10432a:	29 d0                	sub    %edx,%eax
  10432c:	89 41 10             	mov    %eax,0x10(%ecx)
	return 1;
  10432f:	b8 01 00 00 00       	mov    $0x1,%eax
}
  104334:	5b                   	pop    %ebx
  104335:	5d                   	pop    %ebp
  104336:	c3                   	ret    

00104337 <_ready_thread>:
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.flags &= ~K_PRESTART;
  104337:	8b 50 08             	mov    0x8(%eax),%edx
  10433a:	89 d1                	mov    %edx,%ecx
  10433c:	80 e5 bf             	and    $0xbf,%ch
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  10433f:	81 e2 00 a0 03 00    	and    $0x3a000,%edx
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.flags &= ~K_PRESTART;
  104345:	89 48 08             	mov    %ecx,0x8(%eax)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  104348:	75 11                	jne    10435b <_ready_thread+0x24>
  10434a:	83 78 28 ff          	cmpl   $0xffffffff,0x28(%eax)
  10434e:	75 0b                	jne    10435b <_ready_thread+0x24>
 * blocked for another reason (eg. suspended).
 *
 * Must be called with interrupts locked.
 */
static inline void _ready_thread(struct k_thread *thread)
{
  104350:	55                   	push   %ebp
  104351:	89 e5                	mov    %esp,%ebp

	/* needed to handle the start-with-delay case */
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
		_add_thread_to_ready_q(thread);
  104353:	50                   	push   %eax
  104354:	e8 0c f6 ff ff       	call   103965 <_add_thread_to_ready_q>
  104359:	58                   	pop    %eax
	}
}
  10435a:	c9                   	leave  
  10435b:	c3                   	ret    

0010435c <_abort_timeout>:
}

/* returns 0 in success and -1 if the timer has expired */

static inline int _abort_timeout(struct _timeout *t)
{
  10435c:	55                   	push   %ebp
  10435d:	89 c2                	mov    %eax,%edx
	sys_dlist_t *timeout_q = &_timeout_q;

	if (-1 == t->delta_ticks_from_prev) {
  10435f:	8b 40 10             	mov    0x10(%eax),%eax
}

/* returns 0 in success and -1 if the timer has expired */

static inline int _abort_timeout(struct _timeout *t)
{
  104362:	89 e5                	mov    %esp,%ebp
	sys_dlist_t *timeout_q = &_timeout_q;

	if (-1 == t->delta_ticks_from_prev) {
  104364:	83 f8 ff             	cmp    $0xffffffff,%eax
  104367:	74 22                	je     10438b <_abort_timeout+0x2f>
		return -1;
	}

	if (!sys_dlist_is_tail(timeout_q, &t->node)) {
  104369:	3b 15 d0 7d 10 00    	cmp    0x107dd0,%edx
  10436f:	74 05                	je     104376 <_abort_timeout+0x1a>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (!node || node == list->tail) ? NULL : node->next;
  104371:	8b 0a                	mov    (%edx),%ecx
		struct _timeout *next =
			(struct _timeout *)sys_dlist_peek_next(timeout_q,
								    &t->node);
		next->delta_ticks_from_prev += t->delta_ticks_from_prev;
  104373:	01 41 10             	add    %eax,0x10(%ecx)
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  104376:	8b 42 04             	mov    0x4(%edx),%eax
  104379:	8b 0a                	mov    (%edx),%ecx
  10437b:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
  10437d:	8b 0a                	mov    (%edx),%ecx
  10437f:	89 41 04             	mov    %eax,0x4(%ecx)
	}
	sys_dlist_remove(&t->node);
	t->delta_ticks_from_prev = -1;
  104382:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edx)

	return 0;
  104389:	31 c0                	xor    %eax,%eax
}
  10438b:	5d                   	pop    %ebp
  10438c:	c3                   	ret    

0010438d <_unpend_first_thread>:
	return (struct k_thread *)sys_dlist_peek_head(wait_q);
}

/* unpend the first thread from a wait queue */
static inline struct k_thread *_unpend_first_thread(_wait_q_t *wait_q)
{
  10438d:	55                   	push   %ebp
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  10438e:	8b 10                	mov    (%eax),%edx
  104390:	89 e5                	mov    %esp,%ebp

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node;

	if (sys_dlist_is_empty(list)) {
  104392:	39 d0                	cmp    %edx,%eax
  104394:	74 15                	je     1043ab <_unpend_first_thread+0x1e>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  104396:	8b 42 04             	mov    0x4(%edx),%eax
  104399:	8b 0a                	mov    (%edx),%ecx
  10439b:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
  10439d:	8b 0a                	mov    (%edx),%ecx
  10439f:	89 41 04             	mov    %eax,0x4(%ecx)
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.flags &= ~K_PENDING;
  1043a2:	81 62 08 ff df ff ff 	andl   $0xffffdfff,0x8(%edx)
  1043a9:	eb 02                	jmp    1043ad <_unpend_first_thread+0x20>
static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node;

	if (sys_dlist_is_empty(list)) {
		return NULL;
  1043ab:	31 d2                	xor    %edx,%edx
	if (thread) {
		_mark_thread_as_not_pending(thread);
	}

	return thread;
}
  1043ad:	89 d0                	mov    %edx,%eax
  1043af:	5d                   	pop    %ebp
  1043b0:	c3                   	ret    

001043b1 <sys_dlist_insert_at.constprop.7>:
 * @param data parameter to cond()
 *
 * @return N/A
 */

static inline void sys_dlist_insert_at(sys_dlist_t *list, sys_dnode_t *node,
  1043b1:	55                   	push   %ebp
  1043b2:	89 e5                	mov    %esp,%ebp
  1043b4:	57                   	push   %edi
  1043b5:	56                   	push   %esi
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  1043b6:	8b 35 cc 7d 10 00    	mov    0x107dcc,%esi
 * @param data parameter to cond()
 *
 * @return N/A
 */

static inline void sys_dlist_insert_at(sys_dlist_t *list, sys_dnode_t *node,
  1043bc:	53                   	push   %ebx
  1043bd:	89 d7                	mov    %edx,%edi
  1043bf:	89 c3                	mov    %eax,%ebx
	int (*cond)(sys_dnode_t *, void *), void *data)
{
	if (sys_dlist_is_empty(list)) {
  1043c1:	81 fe cc 7d 10 00    	cmp    $0x107dcc,%esi
  1043c7:	74 1d                	je     1043e6 <sys_dlist_insert_at.constprop.7+0x35>
		sys_dlist_append(list, node);
	} else {
		sys_dnode_t *pos = sys_dlist_peek_head(list);

		while (pos && !cond(pos, data)) {
  1043c9:	85 f6                	test   %esi,%esi
  1043cb:	74 19                	je     1043e6 <sys_dlist_insert_at.constprop.7+0x35>
  1043cd:	57                   	push   %edi
  1043ce:	56                   	push   %esi
  1043cf:	e8 3b ff ff ff       	call   10430f <_is_timeout_insert_point>
  1043d4:	5a                   	pop    %edx
  1043d5:	85 c0                	test   %eax,%eax
  1043d7:	59                   	pop    %ecx
  1043d8:	75 29                	jne    104403 <sys_dlist_insert_at.constprop.7+0x52>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (!node || node == list->tail) ? NULL : node->next;
  1043da:	3b 35 d0 7d 10 00    	cmp    0x107dd0,%esi
  1043e0:	74 04                	je     1043e6 <sys_dlist_insert_at.constprop.7+0x35>
  1043e2:	8b 36                	mov    (%esi),%esi
  1043e4:	eb e3                	jmp    1043c9 <sys_dlist_insert_at.constprop.7+0x18>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  1043e6:	c7 03 cc 7d 10 00    	movl   $0x107dcc,(%ebx)
	node->prev = list->tail;
  1043ec:	a1 d0 7d 10 00       	mov    0x107dd0,%eax
  1043f1:	89 43 04             	mov    %eax,0x4(%ebx)

	list->tail->next = node;
  1043f4:	a1 d0 7d 10 00       	mov    0x107dd0,%eax
  1043f9:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
  1043fb:	89 1d d0 7d 10 00    	mov    %ebx,0x107dd0
  104401:	eb 10                	jmp    104413 <sys_dlist_insert_at.constprop.7+0x62>
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  104403:	8b 46 04             	mov    0x4(%esi),%eax
		node->next = insert_point;
  104406:	89 33                	mov    %esi,(%ebx)
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  104408:	89 43 04             	mov    %eax,0x4(%ebx)
		node->next = insert_point;
		insert_point->prev->next = node;
  10440b:	8b 46 04             	mov    0x4(%esi),%eax
  10440e:	89 18                	mov    %ebx,(%eax)
		insert_point->prev = node;
  104410:	89 5e 04             	mov    %ebx,0x4(%esi)
		while (pos && !cond(pos, data)) {
			pos = sys_dlist_peek_next(list, pos);
		}
		sys_dlist_insert_before(list, pos, node);
	}
}
  104413:	8d 65 f4             	lea    -0xc(%ebp),%esp
  104416:	5b                   	pop    %ebx
  104417:	5e                   	pop    %esi
  104418:	5f                   	pop    %edi
  104419:	5d                   	pop    %ebp
  10441a:	c3                   	ret    

0010441b <_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void _timer_expiration_handler(struct _timeout *t)
{
  10441b:	55                   	push   %ebp
  10441c:	89 e5                	mov    %esp,%ebp
  10441e:	57                   	push   %edi
  10441f:	56                   	push   %esi
  104420:	53                   	push   %ebx
  104421:	8b 5d 08             	mov    0x8(%ebp),%ebx
  104424:	9c                   	pushf  
  104425:	fa                   	cli    
  104426:	5e                   	pop    %esi

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (timer->period > 0) {
  104427:	8b 43 28             	mov    0x28(%ebx),%eax
  10442a:	8d 7b 18             	lea    0x18(%ebx),%edi
  10442d:	85 c0                	test   %eax,%eax
  10442f:	7e 17                	jle    104448 <_timer_expiration_handler+0x2d>

	K_DEBUG("timeout   %p before: next: %p, prev: %p\n",
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
	timeout_obj->delta_ticks_from_prev = timeout;
  104431:	89 43 10             	mov    %eax,0x10(%ebx)
		_timeout_q.tail);

	K_DEBUG("timeout   %p before: next: %p, prev: %p\n",
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
  104434:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		_add_timeout(NULL, &timer->timeout, &timer->wait_q,
  10443b:	89 7b 0c             	mov    %edi,0xc(%ebx)
	timeout_obj->delta_ticks_from_prev = timeout;
	timeout_obj->wait_q = (sys_dlist_t *)wait_q;
	sys_dlist_insert_at(timeout_q, (void *)timeout_obj,
			    _is_timeout_insert_point,
			    &timeout_obj->delta_ticks_from_prev);
  10443e:	8d 53 10             	lea    0x10(%ebx),%edx
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
	timeout_obj->delta_ticks_from_prev = timeout;
	timeout_obj->wait_q = (sys_dlist_t *)wait_q;
	sys_dlist_insert_at(timeout_q, (void *)timeout_obj,
  104441:	89 d8                	mov    %ebx,%eax
  104443:	e8 69 ff ff ff       	call   1043b1 <sys_dlist_insert_at.constprop.7>

	/* update timer's status */
	timer->status += 1;

	/* invoke timer expiry function */
	if (timer->expiry_fn) {
  104448:	8b 43 20             	mov    0x20(%ebx),%eax
		_add_timeout(NULL, &timer->timeout, &timer->wait_q,
				timer->period);
	}

	/* update timer's status */
	timer->status += 1;
  10444b:	ff 43 2c             	incl   0x2c(%ebx)

	/* invoke timer expiry function */
	if (timer->expiry_fn) {
  10444e:	85 c0                	test   %eax,%eax
  104450:	74 04                	je     104456 <_timer_expiration_handler+0x3b>
		timer->expiry_fn(timer);
  104452:	53                   	push   %ebx
  104453:	ff d0                	call   *%eax
  104455:	58                   	pop    %eax
	}
	/*
	 * wake up the (only) thread waiting on the timer, if there is one;
	 * don't invoke _Swap() since the timeout ISR called us, not a thread
	 */
	pending_thread = _unpend_first_thread(&timer->wait_q);
  104456:	89 f8                	mov    %edi,%eax
  104458:	e8 30 ff ff ff       	call   10438d <_unpend_first_thread>
  10445d:	89 c3                	mov    %eax,%ebx
	if (pending_thread) {
  10445f:	85 c0                	test   %eax,%eax
  104461:	74 0e                	je     104471 <_timer_expiration_handler+0x56>
		_ready_thread(pending_thread);
  104463:	e8 cf fe ff ff       	call   104337 <_ready_thread>
  104468:	8b 43 30             	mov    0x30(%ebx),%eax
  10446b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  104471:	81 e6 00 02 00 00    	and    $0x200,%esi
  104477:	74 01                	je     10447a <_timer_expiration_handler+0x5f>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  104479:	fb                   	sti    
		_set_thread_return_value(pending_thread, 0);
	}

	irq_unlock(key);
}
  10447a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10447d:	5b                   	pop    %ebx
  10447e:	5e                   	pop    %esi
  10447f:	5f                   	pop    %edi
  104480:	5d                   	pop    %ebp
  104481:	c3                   	ret    

00104482 <k_timer_init>:


void k_timer_init(struct k_timer *timer,
		  void (*expiry_fn)(struct k_timer *),
		  void (*stop_fn)(struct k_timer *))
{
  104482:	55                   	push   %ebp
  104483:	89 e5                	mov    %esp,%ebp
  104485:	8b 45 08             	mov    0x8(%ebp),%eax
	timer->expiry_fn = expiry_fn;
  104488:	8b 55 0c             	mov    0xc(%ebp),%edx
  10448b:	89 50 20             	mov    %edx,0x20(%eax)
	timer->stop_fn = stop_fn;
  10448e:	8b 55 10             	mov    0x10(%ebp),%edx
  104491:	89 50 24             	mov    %edx,0x24(%eax)
	timer->status = 0;

	sys_dlist_init(&timer->wait_q);
  104494:	8d 50 18             	lea    0x18(%eax),%edx
		  void (*expiry_fn)(struct k_timer *),
		  void (*stop_fn)(struct k_timer *))
{
	timer->expiry_fn = expiry_fn;
	timer->stop_fn = stop_fn;
	timer->status = 0;
  104497:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  10449e:	89 50 18             	mov    %edx,0x18(%eax)
	list->tail = (sys_dnode_t *)list;
  1044a1:	89 50 1c             	mov    %edx,0x1c(%eax)
	/*
	 * Must be initialized here and when dequeueing a timeout so that code
	 * not dealing with timeouts does not have to handle this, such as when
	 * waiting forever on a semaphore.
	 */
	t->delta_ticks_from_prev = -1;
  1044a4:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)

	/*
	 * Must be initialized here so that the _fiber_wakeup family of APIs can
	 * verify the fiber is not on a wait queue before aborting a timeout.
	 */
	t->wait_q = NULL;
  1044ab:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

	/*
	 * Must be initialized here, so the _handle_one_timeout()
	 * routine can check if there is a fiber waiting on this timeout
	 */
	t->thread = NULL;
  1044b2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

	/*
	 * Function must be initialized before being potentially called.
	 */
	t->func = func;
  1044b9:	c7 40 14 1b 44 10 00 	movl   $0x10441b,0x14(%eax)

	sys_dlist_init(&timer->wait_q);
	_init_timeout(&timer->timeout, _timer_expiration_handler);
	SYS_TRACING_OBJ_INIT(k_timer, timer);

	timer->_legacy_data = NULL;
  1044c0:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
}
  1044c7:	5d                   	pop    %ebp
  1044c8:	c3                   	ret    

001044c9 <k_timer_start>:


void k_timer_start(struct k_timer *timer, int32_t duration, int32_t period)
{
  1044c9:	55                   	push   %ebp
  1044ca:	89 e5                	mov    %esp,%ebp
  1044cc:	56                   	push   %esi
  1044cd:	53                   	push   %ebx
  1044ce:	8b 5d 08             	mov    0x8(%ebp),%ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1044d1:	9c                   	pushf  
  1044d2:	fa                   	cli    
  1044d3:	5e                   	pop    %esi
	__ASSERT(duration >= 0 && period >= 0 &&
		 (duration != 0 || period != 0), "invalid parameters\n");

	unsigned int key = irq_lock();

	if (timer->timeout.delta_ticks_from_prev != -1) {
  1044d4:	83 7b 10 ff          	cmpl   $0xffffffff,0x10(%ebx)
  1044d8:	74 07                	je     1044e1 <k_timer_start+0x18>
		_abort_timeout(&timer->timeout);
  1044da:	89 d8                	mov    %ebx,%eax
  1044dc:	e8 7b fe ff ff       	call   10435c <_abort_timeout>
	}

	timer->period = _ms_to_ticks(period);
  1044e1:	ff 75 10             	pushl  0x10(%ebp)
  1044e4:	e8 37 f5 ff ff       	call   103a20 <_ms_to_ticks>
  1044e9:	5a                   	pop    %edx
  1044ea:	89 43 28             	mov    %eax,0x28(%ebx)
	_add_timeout(NULL, &timer->timeout, &timer->wait_q,
			_TICK_ALIGN + _ms_to_ticks(duration));
  1044ed:	ff 75 0c             	pushl  0xc(%ebp)
  1044f0:	e8 2b f5 ff ff       	call   103a20 <_ms_to_ticks>
  1044f5:	59                   	pop    %ecx

	K_DEBUG("timeout   %p before: next: %p, prev: %p\n",
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
	timeout_obj->delta_ticks_from_prev = timeout;
  1044f6:	40                   	inc    %eax
		_timeout_q.tail);

	K_DEBUG("timeout   %p before: next: %p, prev: %p\n",
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
  1044f7:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	timeout_obj->delta_ticks_from_prev = timeout;
  1044fe:	89 43 10             	mov    %eax,0x10(%ebx)
	if (timer->timeout.delta_ticks_from_prev != -1) {
		_abort_timeout(&timer->timeout);
	}

	timer->period = _ms_to_ticks(period);
	_add_timeout(NULL, &timer->timeout, &timer->wait_q,
  104501:	8d 43 18             	lea    0x18(%ebx),%eax
  104504:	89 43 0c             	mov    %eax,0xc(%ebx)
	timeout_obj->wait_q = (sys_dlist_t *)wait_q;
	sys_dlist_insert_at(timeout_q, (void *)timeout_obj,
			    _is_timeout_insert_point,
			    &timeout_obj->delta_ticks_from_prev);
  104507:	8d 53 10             	lea    0x10(%ebx),%edx
		timeout_obj, timeout_obj->node.next, timeout_obj->node.prev);

	timeout_obj->thread = thread;
	timeout_obj->delta_ticks_from_prev = timeout;
	timeout_obj->wait_q = (sys_dlist_t *)wait_q;
	sys_dlist_insert_at(timeout_q, (void *)timeout_obj,
  10450a:	89 d8                	mov    %ebx,%eax
  10450c:	e8 a0 fe ff ff       	call   1043b1 <sys_dlist_insert_at.constprop.7>
			_TICK_ALIGN + _ms_to_ticks(duration));
	timer->status = 0;
  104511:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  104518:	81 e6 00 02 00 00    	and    $0x200,%esi
  10451e:	74 01                	je     104521 <k_timer_start+0x58>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  104520:	fb                   	sti    
	irq_unlock(key);
}
  104521:	8d 65 f8             	lea    -0x8(%ebp),%esp
  104524:	5b                   	pop    %ebx
  104525:	5e                   	pop    %esi
  104526:	5d                   	pop    %ebp
  104527:	c3                   	ret    

00104528 <k_timer_status_get>:
	}
}


uint32_t k_timer_status_get(struct k_timer *timer)
{
  104528:	55                   	push   %ebp
  104529:	89 e5                	mov    %esp,%ebp
  10452b:	8b 55 08             	mov    0x8(%ebp),%edx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  10452e:	9c                   	pushf  
  10452f:	fa                   	cli    
  104530:	59                   	pop    %ecx
  104531:	80 e5 02             	and    $0x2,%ch
	unsigned int key = irq_lock();
	uint32_t result = timer->status;
  104534:	8b 42 2c             	mov    0x2c(%edx),%eax

	timer->status = 0;
  104537:	c7 42 2c 00 00 00 00 	movl   $0x0,0x2c(%edx)
  10453e:	74 01                	je     104541 <k_timer_status_get+0x19>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  104540:	fb                   	sti    
	irq_unlock(key);

	return result;
}
  104541:	5d                   	pop    %ebp
  104542:	c3                   	ret    

00104543 <k_timer_status_sync>:


uint32_t k_timer_status_sync(struct k_timer *timer)
{
  104543:	55                   	push   %ebp
  104544:	89 e5                	mov    %esp,%ebp
  104546:	56                   	push   %esi
  104547:	53                   	push   %ebx
  104548:	8b 75 08             	mov    0x8(%ebp),%esi

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  10454b:	9c                   	pushf  
  10454c:	fa                   	cli    
  10454d:	5b                   	pop    %ebx
	__ASSERT(!_is_in_isr(), "");

	unsigned int key = irq_lock();
	uint32_t result = timer->status;
  10454e:	8b 46 2c             	mov    0x2c(%esi),%eax

	if (result == 0) {
  104551:	85 c0                	test   %eax,%eax
  104553:	75 20                	jne    104575 <k_timer_status_sync+0x32>
		if (timer->timeout.delta_ticks_from_prev != -1) {
  104555:	83 7e 10 ff          	cmpl   $0xffffffff,0x10(%esi)
  104559:	74 1a                	je     104575 <k_timer_status_sync+0x32>
			/* wait for timer to expire or stop */
			_pend_current_thread(&timer->wait_q, K_FOREVER);
  10455b:	8d 46 18             	lea    0x18(%esi),%eax
  10455e:	6a ff                	push   $0xffffffff
  104560:	50                   	push   %eax
  104561:	e8 5e f5 ff ff       	call   103ac4 <_pend_current_thread>
  104566:	58                   	pop    %eax
  104567:	5a                   	pop    %edx
			_Swap(key);
  104568:	53                   	push   %ebx
  104569:	e8 a2 ee ff ff       	call   103410 <_Swap>
  10456e:	59                   	pop    %ecx
  10456f:	9c                   	pushf  
  104570:	fa                   	cli    
  104571:	5b                   	pop    %ebx

			/* get updated timer status */
			key = irq_lock();
			result = timer->status;
  104572:	8b 46 2c             	mov    0x2c(%esi),%eax
  104575:	80 e7 02             	and    $0x2,%bh
		}
	} else {
		/* timer has already expired at least once */
	}

	timer->status = 0;
  104578:	c7 46 2c 00 00 00 00 	movl   $0x0,0x2c(%esi)
  10457f:	74 01                	je     104582 <k_timer_status_sync+0x3f>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  104581:	fb                   	sti    
	irq_unlock(key);

	return result;
}
  104582:	8d 65 f8             	lea    -0x8(%ebp),%esp
  104585:	5b                   	pop    %ebx
  104586:	5e                   	pop    %esi
  104587:	5d                   	pop    %ebp
  104588:	c3                   	ret    

00104589 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while ((0))
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
  104589:	55                   	push   %ebp
  10458a:	89 e5                	mov    %esp,%ebp

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  10458c:	9c                   	pushf  
  10458d:	fa                   	cli    
  10458e:	58                   	pop    %eax
	if (_sys_soc_suspend(ticks) == SYS_PM_NOT_HANDLED) {
		_sys_pm_idle_exit_notify = 0;
		nano_cpu_idle();
	}
#else
	nano_cpu_idle();
  10458f:	e8 54 ed ff ff       	call   1032e8 <nano_cpu_idle>
  104594:	eb f6                	jmp    10458c <idle+0x3>

00104596 <_OffsetAbsSyms>:
/*
 * The final link step uses the symbol _OffsetAbsSyms to force the linkage of
 * offsets.o into the ELF image.
 */

GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
  104596:	55                   	push   %ebp
  104597:	89 e5                	mov    %esp,%ebp
/* size of the ISR_LIST structure. Used by linker scripts */

GEN_ABSOLUTE_SYM(__ISR_LIST_SIZEOF, sizeof(ISR_LIST));


GEN_ABS_SYM_END
  104599:	5d                   	pop    %ebp
  10459a:	c3                   	ret    

0010459b <_handle_exc_0_vector_0_stub>:
  10459b:	6a 00                	push   $0x0
  10459d:	68 d4 35 10 00       	push   $0x1035d4
  1045a2:	e9 c4 ed ff ff       	jmp    10336b <_exception_enter>

001045a7 <_handle_exc_2_vector_2_stub>:
  1045a7:	6a 00                	push   $0x0
  1045a9:	68 e1 35 10 00       	push   $0x1035e1
  1045ae:	e9 b8 ed ff ff       	jmp    10336b <_exception_enter>

001045b3 <_handle_exc_4_vector_4_stub>:
  1045b3:	6a 00                	push   $0x0
  1045b5:	68 f1 35 10 00       	push   $0x1035f1
  1045ba:	e9 ac ed ff ff       	jmp    10336b <_exception_enter>

001045bf <_handle_exc_5_vector_5_stub>:
  1045bf:	6a 00                	push   $0x0
  1045c1:	68 01 36 10 00       	push   $0x103601
  1045c6:	e9 a0 ed ff ff       	jmp    10336b <_exception_enter>

001045cb <_handle_exc_6_vector_6_stub>:
  1045cb:	6a 00                	push   $0x0
  1045cd:	68 11 36 10 00       	push   $0x103611
  1045d2:	e9 94 ed ff ff       	jmp    10336b <_exception_enter>

001045d7 <_handle_exc_7_vector_7_stub>:
  1045d7:	6a 00                	push   $0x0
  1045d9:	68 21 36 10 00       	push   $0x103621
  1045de:	e9 88 ed ff ff       	jmp    10336b <_exception_enter>

001045e3 <_handle_exc_8_vector_8_stub>:
  1045e3:	68 31 36 10 00       	push   $0x103631
  1045e8:	e9 7e ed ff ff       	jmp    10336b <_exception_enter>

001045ed <_handle_exc_10_vector_10_stub>:
  1045ed:	68 41 36 10 00       	push   $0x103641
  1045f2:	e9 74 ed ff ff       	jmp    10336b <_exception_enter>

001045f7 <_handle_exc_11_vector_11_stub>:
  1045f7:	68 51 36 10 00       	push   $0x103651
  1045fc:	e9 6a ed ff ff       	jmp    10336b <_exception_enter>

00104601 <_handle_exc_12_vector_12_stub>:
  104601:	68 61 36 10 00       	push   $0x103661
  104606:	e9 60 ed ff ff       	jmp    10336b <_exception_enter>

0010460b <_handle_exc_13_vector_13_stub>:
  10460b:	68 71 36 10 00       	push   $0x103671
  104610:	e9 56 ed ff ff       	jmp    10336b <_exception_enter>

00104615 <_handle_exc_14_vector_14_stub>:
  104615:	68 81 36 10 00       	push   $0x103681
  10461a:	e9 4c ed ff ff       	jmp    10336b <_exception_enter>

0010461f <_handle_exc_16_vector_16_stub>:
  10461f:	6a 00                	push   $0x0
  104621:	68 91 36 10 00       	push   $0x103691
  104626:	e9 40 ed ff ff       	jmp    10336b <_exception_enter>

0010462b <_handle_exc_17_vector_17_stub>:
  10462b:	68 a1 36 10 00       	push   $0x1036a1
  104630:	e9 36 ed ff ff       	jmp    10336b <_exception_enter>

00104635 <_handle_exc_18_vector_18_stub>:
  104635:	6a 00                	push   $0x0
  104637:	68 b1 36 10 00       	push   $0x1036b1
  10463c:	e9 2a ed ff ff       	jmp    10336b <_exception_enter>
